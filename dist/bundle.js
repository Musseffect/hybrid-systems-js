/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "hot/hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "hot/hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "e6cda078f39939019812";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./src/index.ts")(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/antlr4/BufferedTokenStream.js":
/*!****************************************************!*\
  !*** ./node_modules/antlr4/BufferedTokenStream.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// This implementation of {@link TokenStream} loads tokens from a
// {@link TokenSource} on-demand, and places the tokens in a buffer to provide
// access to any previous token by index.
//
// <p>
// This token stream ignores the value of {@link Token//getChannel}. If your
// parser requires the token stream filter tokens to only those on a particular
// channel, such as {@link Token//DEFAULT_CHANNEL} or
// {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
// {@link CommonTokenStream}.</p>

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var Lexer = __webpack_require__(/*! ./Lexer */ "./node_modules/antlr4/Lexer.js").Lexer;
var Interval = __webpack_require__(/*! ./IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;

// this is just to keep meaningful parameter types to Parser
function TokenStream() {
	return this;
}

function BufferedTokenStream(tokenSource) {

	TokenStream.call(this);
	// The {@link TokenSource} from which tokens for this stream are fetched.
	this.tokenSource = tokenSource;

	// A collection of all tokens fetched from the token source. The list is
	// considered a complete view of the input once {@link //fetchedEOF} is set
	// to {@code true}.
	this.tokens = [];

	// The index into {@link //tokens} of the current token (next token to
	// {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
	// be
	// {@link //LT LT(1)}.
	//
	// <p>This field is set to -1 when the stream is first constructed or when
	// {@link //setTokenSource} is called, indicating that the first token has
	// not yet been fetched from the token source. For additional information,
	// see the documentation of {@link IntStream} for a description of
	// Initializing Methods.</p>
	this.index = -1;

	// Indicates whether the {@link Token//EOF} token has been fetched from
	// {@link //tokenSource} and added to {@link //tokens}. This field improves
	// performance for the following cases:
	//
	// <ul>
	// <li>{@link //consume}: The lookahead check in {@link //consume} to
	// prevent
	// consuming the EOF symbol is optimized by checking the values of
	// {@link //fetchedEOF} and {@link //p} instead of calling {@link
	// //LA}.</li>
	// <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
	// into
	// {@link //tokens} is trivial with this field.</li>
	// <ul>
	this.fetchedEOF = false;
	return this;
}

BufferedTokenStream.prototype = Object.create(TokenStream.prototype);
BufferedTokenStream.prototype.constructor = BufferedTokenStream;

BufferedTokenStream.prototype.mark = function() {
	return 0;
};

BufferedTokenStream.prototype.release = function(marker) {
	// no resources to release
};

BufferedTokenStream.prototype.reset = function() {
	this.seek(0);
};

BufferedTokenStream.prototype.seek = function(index) {
	this.lazyInit();
	this.index = this.adjustSeekIndex(index);
};

BufferedTokenStream.prototype.get = function(index) {
	this.lazyInit();
	return this.tokens[index];
};

BufferedTokenStream.prototype.consume = function() {
	var skipEofCheck = false;
	if (this.index >= 0) {
		if (this.fetchedEOF) {
			// the last token in tokens is EOF. skip check if p indexes any
			// fetched token except the last.
			skipEofCheck = this.index < this.tokens.length - 1;
		} else {
			// no EOF token in tokens. skip check if p indexes a fetched token.
			skipEofCheck = this.index < this.tokens.length;
		}
	} else {
		// not yet initialized
		skipEofCheck = false;
	}
	if (!skipEofCheck && this.LA(1) === Token.EOF) {
		throw "cannot consume EOF";
	}
	if (this.sync(this.index + 1)) {
		this.index = this.adjustSeekIndex(this.index + 1);
	}
};

// Make sure index {@code i} in tokens has a token.
//
// @return {@code true} if a token is located at index {@code i}, otherwise
// {@code false}.
// @see //get(int i)
// /
BufferedTokenStream.prototype.sync = function(i) {
	var n = i - this.tokens.length + 1; // how many more elements we need?
	if (n > 0) {
		var fetched = this.fetch(n);
		return fetched >= n;
	}
	return true;
};

// Add {@code n} elements to buffer.
//
// @return The actual number of elements added to the buffer.
// /
BufferedTokenStream.prototype.fetch = function(n) {
	if (this.fetchedEOF) {
		return 0;
	}
	for (var i = 0; i < n; i++) {
		var t = this.tokenSource.nextToken();
		t.tokenIndex = this.tokens.length;
		this.tokens.push(t);
		if (t.type === Token.EOF) {
			this.fetchedEOF = true;
			return i + 1;
		}
	}
	return n;
};

// Get all tokens from start..stop inclusively///
BufferedTokenStream.prototype.getTokens = function(start, stop, types) {
	if (types === undefined) {
		types = null;
	}
	if (start < 0 || stop < 0) {
		return null;
	}
	this.lazyInit();
	var subset = [];
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	for (var i = start; i < stop; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		if (types === null || types.contains(t.type)) {
			subset.push(t);
		}
	}
	return subset;
};

BufferedTokenStream.prototype.LA = function(i) {
	return this.LT(i).type;
};

BufferedTokenStream.prototype.LB = function(k) {
	if (this.index - k < 0) {
		return null;
	}
	return this.tokens[this.index - k];
};

BufferedTokenStream.prototype.LT = function(k) {
	this.lazyInit();
	if (k === 0) {
		return null;
	}
	if (k < 0) {
		return this.LB(-k);
	}
	var i = this.index + k - 1;
	this.sync(i);
	if (i >= this.tokens.length) { // return EOF token
		// EOF must be last token
		return this.tokens[this.tokens.length - 1];
	}
	return this.tokens[i];
};

// Allowed derived classes to modify the behavior of operations which change
// the current stream position by adjusting the target token index of a seek
// operation. The default implementation simply returns {@code i}. If an
// exception is thrown in this method, the current stream index should not be
// changed.
//
// <p>For example, {@link CommonTokenStream} overrides this method to ensure
// that
// the seek target is always an on-channel token.</p>
//
// @param i The target token index.
// @return The adjusted target token index.

BufferedTokenStream.prototype.adjustSeekIndex = function(i) {
	return i;
};

BufferedTokenStream.prototype.lazyInit = function() {
	if (this.index === -1) {
		this.setup();
	}
};

BufferedTokenStream.prototype.setup = function() {
	this.sync(0);
	this.index = this.adjustSeekIndex(0);
};

// Reset this token stream by setting its token source.///
BufferedTokenStream.prototype.setTokenSource = function(tokenSource) {
	this.tokenSource = tokenSource;
	this.tokens = [];
	this.index = -1;
	this.fetchedEOF = false;
};


// Given a starting index, return the index of the next token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and EOF.
// /
BufferedTokenStream.prototype.nextTokenOnChannel = function(i, channel) {
	this.sync(i);
	if (i >= this.tokens.length) {
		return -1;
	}
	var token = this.tokens[i];
	while (token.channel !== this.channel) {
		if (token.type === Token.EOF) {
			return -1;
		}
		i += 1;
		this.sync(i);
		token = this.tokens[i];
	}
	return i;
};

// Given a starting index, return the index of the previous token on channel.
// Return i if tokens[i] is on channel. Return -1 if there are no tokens
// on channel between i and 0.
BufferedTokenStream.prototype.previousTokenOnChannel = function(i, channel) {
	while (i >= 0 && this.tokens[i].channel !== channel) {
		i -= 1;
	}
	return i;
};

// Collect all tokens on specified channel to the right of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
// EOF. If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToRight = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	var from_ = tokenIndex + 1;
	// if none onchannel to right, nextOnChannel=-1 so set to = last token
	var to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
	return this.filterForChannel(from_, to, channel);
};

// Collect all tokens on specified channel to the left of
// the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
// If channel is -1, find any non default channel token.
BufferedTokenStream.prototype.getHiddenTokensToLeft = function(tokenIndex,
		channel) {
	if (channel === undefined) {
		channel = -1;
	}
	this.lazyInit();
	if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
		throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
	}
	var prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);
	if (prevOnChannel === tokenIndex - 1) {
		return null;
	}
	// if none on channel to left, prevOnChannel=-1 then from=0
	var from_ = prevOnChannel + 1;
	var to = tokenIndex - 1;
	return this.filterForChannel(from_, to, channel);
};

BufferedTokenStream.prototype.filterForChannel = function(left, right, channel) {
	var hidden = [];
	for (var i = left; i < right + 1; i++) {
		var t = this.tokens[i];
		if (channel === -1) {
			if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
				hidden.push(t);
			}
		} else if (t.channel === channel) {
			hidden.push(t);
		}
	}
	if (hidden.length === 0) {
		return null;
	}
	return hidden;
};

BufferedTokenStream.prototype.getSourceName = function() {
	return this.tokenSource.getSourceName();
};

// Get the text of all tokens in this buffer.///
BufferedTokenStream.prototype.getText = function(interval) {
	this.lazyInit();
	this.fill();
	if (interval === undefined || interval === null) {
		interval = new Interval(0, this.tokens.length - 1);
	}
	var start = interval.start;
	if (start instanceof Token) {
		start = start.tokenIndex;
	}
	var stop = interval.stop;
	if (stop instanceof Token) {
		stop = stop.tokenIndex;
	}
	if (start === null || stop === null || start < 0 || stop < 0) {
		return "";
	}
	if (stop >= this.tokens.length) {
		stop = this.tokens.length - 1;
	}
	var s = "";
	for (var i = start; i < stop + 1; i++) {
		var t = this.tokens[i];
		if (t.type === Token.EOF) {
			break;
		}
		s = s + t.text;
	}
	return s;
};

// Get all tokens from lexer until EOF///
BufferedTokenStream.prototype.fill = function() {
	this.lazyInit();
	while (this.fetch(1000) === 1000) {
		continue;
	}
};

exports.BufferedTokenStream = BufferedTokenStream;


/***/ }),

/***/ "./node_modules/antlr4/CharStreams.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/CharStreams.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/antlr4/InputStream.js").InputStream;

var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js") : null;

// Utility functions to create InputStreams from various sources.
//
// All returned InputStreams support the full range of Unicode
// up to U+10FFFF (the default behavior of InputStream only supports
// code points up to U+FFFF).
var CharStreams = {
  // Creates an InputStream from a string.
  fromString: function(str) {
    return new InputStream(str, true);
  },

  // Asynchronously creates an InputStream from a blob given the
  // encoding of the bytes in that blob (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes onLoad(result) on success, onError(error) on
  // failure.
  fromBlob: function(blob, encoding, onLoad, onError) {
    var reader = FileReader();
    reader.onload = function(e) {
      var is = new InputStream(e.target.result, true);
      onLoad(is);
    };
    reader.onerror = onError;
    reader.readAsText(blob, encoding);
  },

  // Creates an InputStream from a Buffer given the
  // encoding of the bytes in that buffer (defaults to 'utf8' if
  // encoding is null).
  fromBuffer: function(buffer, encoding) {
    return new InputStream(buffer.toString(encoding), true);
  },

  // Asynchronously creates an InputStream from a file on disk given
  // the encoding of the bytes in that file (defaults to 'utf8' if
  // encoding is null).
  //
  // Invokes callback(error, result) on completion.
  fromPath: function(path, encoding, callback) {
    fs.readFile(path, encoding, function(err, data) {
      var is = null;
      if (data !== null) {
        is = new InputStream(data, true);
      }
      callback(err, is);
    });
  },

  // Synchronously creates an InputStream given a path to a file
  // on disk and the encoding of the bytes in that file (defaults to
  // 'utf8' if encoding is null).
  fromPathSync: function(path, encoding) {
    var data = fs.readFileSync(path, encoding);
    return new InputStream(data, true);
  }
};

exports.CharStreams = CharStreams;


/***/ }),

/***/ "./node_modules/antlr4/CommonTokenFactory.js":
/*!***************************************************!*\
  !*** ./node_modules/antlr4/CommonTokenFactory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This default implementation of {@link TokenFactory} creates
// {@link CommonToken} objects.
//

var CommonToken = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").CommonToken;

function TokenFactory() {
	return this;
}

function CommonTokenFactory(copyText) {
	TokenFactory.call(this);
    // Indicates whether {@link CommonToken//setText} should be called after
    // constructing tokens to explicitly set the text. This is useful for cases
    // where the input stream might not be able to provide arbitrary substrings
    // of text from the input after the lexer creates a token (e.g. the
    // implementation of {@link CharStream//getText} in
    // {@link UnbufferedCharStream} throws an
    // {@link UnsupportedOperationException}). Explicitly setting the token text
    // allows {@link Token//getText} to be called at any time regardless of the
    // input stream implementation.
    //
    // <p>
    // The default value is {@code false} to avoid the performance and memory
    // overhead of copying text for every token unless explicitly requested.</p>
    //
    this.copyText = copyText===undefined ? false : copyText;
	return this;
}

CommonTokenFactory.prototype = Object.create(TokenFactory.prototype);
CommonTokenFactory.prototype.constructor = CommonTokenFactory;

//
// The default {@link CommonTokenFactory} instance.
//
// <p>
// This token factory does not explicitly copy token text when constructing
// tokens.</p>
//
CommonTokenFactory.DEFAULT = new CommonTokenFactory();

CommonTokenFactory.prototype.create = function(source, type, text, channel, start, stop, line, column) {
    var t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;
    if (text !==null) {
        t.text = text;
    } else if (this.copyText && source[1] !==null) {
        t.text = source[1].getText(start,stop);
    }
    return t;
};

CommonTokenFactory.prototype.createThin = function(type, text) {
    var t = new CommonToken(null, type);
    t.text = text;
    return t;
};

exports.CommonTokenFactory = CommonTokenFactory;


/***/ }),

/***/ "./node_modules/antlr4/CommonTokenStream.js":
/*!**************************************************!*\
  !*** ./node_modules/antlr4/CommonTokenStream.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//
// This class extends {@link BufferedTokenStream} with functionality to filter
// token streams to tokens on a particular channel (tokens where
// {@link Token//getChannel} returns a particular value).
//
// <p>
// This token stream provides access to all tokens by index or when calling
// methods like {@link //getText}. The channel filtering is only used for code
// accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
// {@link //LB}.</p>
//
// <p>
// By default, tokens are placed on the default channel
// ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
// {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
// call {@link Lexer//setChannel}.
// </p>
//
// <p>
// Note: lexer rules which use the {@code ->skip} lexer command or call
// {@link Lexer//skip} do not produce tokens at all, so input text matched by
// such a rule will not be available as part of the token stream, regardless of
// channel.</p>
///

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var BufferedTokenStream = __webpack_require__(/*! ./BufferedTokenStream */ "./node_modules/antlr4/BufferedTokenStream.js").BufferedTokenStream;

function CommonTokenStream(lexer, channel) {
	BufferedTokenStream.call(this, lexer);
    this.channel = channel===undefined ? Token.DEFAULT_CHANNEL : channel;
    return this;
}

CommonTokenStream.prototype = Object.create(BufferedTokenStream.prototype);
CommonTokenStream.prototype.constructor = CommonTokenStream;

CommonTokenStream.prototype.adjustSeekIndex = function(i) {
    return this.nextTokenOnChannel(i, this.channel);
};

CommonTokenStream.prototype.LB = function(k) {
    if (k===0 || this.index-k<0) {
        return null;
    }
    var i = this.index;
    var n = 1;
    // find k good tokens looking backwards
    while (n <= k) {
        // skip off-channel tokens
        i = this.previousTokenOnChannel(i - 1, this.channel);
        n += 1;
    }
    if (i < 0) {
        return null;
    }
    return this.tokens[i];
};

CommonTokenStream.prototype.LT = function(k) {
    this.lazyInit();
    if (k === 0) {
        return null;
    }
    if (k < 0) {
        return this.LB(-k);
    }
    var i = this.index;
    var n = 1; // we know tokens[pos] is a good one
    // find k good tokens
    while (n < k) {
        // skip off-channel tokens, but make sure to not look past EOF
        if (this.sync(i + 1)) {
            i = this.nextTokenOnChannel(i + 1, this.channel);
        }
        n += 1;
    }
    return this.tokens[i];
};

// Count EOF just once.///
CommonTokenStream.prototype.getNumberOfOnChannelTokens = function() {
    var n = 0;
    this.fill();
    for (var i =0; i< this.tokens.length;i++) {
        var t = this.tokens[i];
        if( t.channel===this.channel) {
            n += 1;
        }
        if( t.type===Token.EOF) {
            break;
        }
    }
    return n;
};

exports.CommonTokenStream = CommonTokenStream;

/***/ }),

/***/ "./node_modules/antlr4/FileStream.js":
/*!*******************************************!*\
  !*** ./node_modules/antlr4/FileStream.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
//  This is an InputStream that is loaded from a file all at once
//  when you construct the object.
//
var InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/antlr4/InputStream.js").InputStream;
var isNodeJs = typeof window === 'undefined' && typeof importScripts === 'undefined';
var fs = isNodeJs ? __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js") : null;

function FileStream(fileName, decodeToUnicodeCodePoints) {
	var data = fs.readFileSync(fileName, "utf8");
	InputStream.call(this, data, decodeToUnicodeCodePoints);
	this.fileName = fileName;
	return this;
}

FileStream.prototype = Object.create(InputStream.prototype);
FileStream.prototype.constructor = FileStream;

exports.FileStream = FileStream;


/***/ }),

/***/ "./node_modules/antlr4/InputStream.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/InputStream.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
__webpack_require__(/*! ./polyfills/codepointat */ "./node_modules/antlr4/polyfills/codepointat.js");
__webpack_require__(/*! ./polyfills/fromcodepoint */ "./node_modules/antlr4/polyfills/fromcodepoint.js");

// Vacuum all input from a string and then treat it like a buffer.

function _loadString(stream) {
	stream._index = 0;
	stream.data = [];
	if (stream.decodeToUnicodeCodePoints) {
		for (var i = 0; i < stream.strdata.length; ) {
			var codePoint = stream.strdata.codePointAt(i);
			stream.data.push(codePoint);
			i += codePoint <= 0xFFFF ? 1 : 2;
		}
	} else {
		for (var i = 0; i < stream.strdata.length; i++) {
			var codeUnit = stream.strdata.charCodeAt(i);
			stream.data.push(codeUnit);
		}
	}
	stream._size = stream.data.length;
}

// If decodeToUnicodeCodePoints is true, the input is treated
// as a series of Unicode code points.
//
// Otherwise, the input is treated as a series of 16-bit UTF-16 code
// units.
function InputStream(data, decodeToUnicodeCodePoints) {
	this.name = "<empty>";
	this.strdata = data;
	this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
	_loadString(this);
	return this;
}

Object.defineProperty(InputStream.prototype, "index", {
	get : function() {
		return this._index;
	}
});

Object.defineProperty(InputStream.prototype, "size", {
	get : function() {
		return this._size;
	}
});

// Reset the stream so that it's in the same state it was
// when the object was created *except* the data array is not
// touched.
//
InputStream.prototype.reset = function() {
	this._index = 0;
};

InputStream.prototype.consume = function() {
	if (this._index >= this._size) {
		// assert this.LA(1) == Token.EOF
		throw ("cannot consume EOF");
	}
	this._index += 1;
};

InputStream.prototype.LA = function(offset) {
	if (offset === 0) {
		return 0; // undefined
	}
	if (offset < 0) {
		offset += 1; // e.g., translate LA(-1) to use offset=0
	}
	var pos = this._index + offset - 1;
	if (pos < 0 || pos >= this._size) { // invalid
		return Token.EOF;
	}
	return this.data[pos];
};

InputStream.prototype.LT = function(offset) {
	return this.LA(offset);
};

// mark/release do nothing; we have entire buffer
InputStream.prototype.mark = function() {
	return -1;
};

InputStream.prototype.release = function(marker) {
};

// consume() ahead until p==_index; can't just set p=_index as we must
// update line and column. If we seek backwards, just set p
//
InputStream.prototype.seek = function(_index) {
	if (_index <= this._index) {
		this._index = _index; // just jump; don't update stream state (line,
								// ...)
		return;
	}
	// seek forward
	this._index = Math.min(_index, this._size);
};

InputStream.prototype.getText = function(start, stop) {
	if (stop >= this._size) {
		stop = this._size - 1;
	}
	if (start >= this._size) {
		return "";
	} else {
		if (this.decodeToUnicodeCodePoints) {
			var result = "";
			for (var i = start; i <= stop; i++) {
				result += String.fromCodePoint(this.data[i]);
			}
			return result;
		} else {
			return this.strdata.slice(start, stop + 1);
		}
	}
};

InputStream.prototype.toString = function() {
	return this.strdata;
};

exports.InputStream = InputStream;


/***/ }),

/***/ "./node_modules/antlr4/IntervalSet.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/IntervalSet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/*jslint smarttabs:true */

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;

/* stop is not included! */
function Interval(start, stop) {
	this.start = start;
	this.stop = stop;
	return this;
}

Interval.prototype.contains = function(item) {
	return item >= this.start && item < this.stop;
};

Interval.prototype.toString = function() {
	if(this.start===this.stop-1) {
		return this.start.toString();
	} else {
		return this.start.toString() + ".." + (this.stop-1).toString();
	}
};


Object.defineProperty(Interval.prototype, "length", {
	get : function() {
		return this.stop - this.start;
	}
});

function IntervalSet() {
	this.intervals = null;
	this.readOnly = false;
}

IntervalSet.prototype.first = function(v) {
	if (this.intervals === null || this.intervals.length===0) {
		return Token.INVALID_TYPE;
	} else {
		return this.intervals[0].start;
	}
};

IntervalSet.prototype.addOne = function(v) {
	this.addInterval(new Interval(v, v + 1));
};

IntervalSet.prototype.addRange = function(l, h) {
	this.addInterval(new Interval(l, h + 1));
};

IntervalSet.prototype.addInterval = function(v) {
	if (this.intervals === null) {
		this.intervals = [];
		this.intervals.push(v);
	} else {
		// find insert pos
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// distinct range -> insert
			if (v.stop < i.start) {
				this.intervals.splice(k, 0, v);
				return;
			}
			// contiguous range -> adjust
			else if (v.stop === i.start) {
				this.intervals[k].start = v.start;
				return;
			}
			// overlapping range -> adjust and reduce
			else if (v.start <= i.stop) {
				this.intervals[k] = new Interval(Math.min(i.start, v.start), Math.max(i.stop, v.stop));
				this.reduce(k);
				return;
			}
		}
		// greater than any existing
		this.intervals.push(v);
	}
};

IntervalSet.prototype.addSet = function(other) {
	if (other.intervals !== null) {
		for (var k = 0; k < other.intervals.length; k++) {
			var i = other.intervals[k];
			this.addInterval(new Interval(i.start, i.stop));
		}
	}
	return this;
};

IntervalSet.prototype.reduce = function(k) {
	// only need to reduce if k is not the last
	if (k < this.intervalslength - 1) {
		var l = this.intervals[k];
		var r = this.intervals[k + 1];
		// if r contained in l
		if (l.stop >= r.stop) {
			this.intervals.pop(k + 1);
			this.reduce(k);
		} else if (l.stop >= r.start) {
			this.intervals[k] = new Interval(l.start, r.stop);
			this.intervals.pop(k + 1);
		}
	}
};

IntervalSet.prototype.complement = function(start, stop) {
    var result = new IntervalSet();
    result.addInterval(new Interval(start,stop+1));
    for(var i=0; i<this.intervals.length; i++) {
        result.removeRange(this.intervals[i]);
    }
    return result;
};

IntervalSet.prototype.contains = function(item) {
	if (this.intervals === null) {
		return false;
	} else {
		for (var k = 0; k < this.intervals.length; k++) {
			if(this.intervals[k].contains(item)) {
				return true;
			}
		}
		return false;
	}
};

Object.defineProperty(IntervalSet.prototype, "length", {
	get : function() {
		var len = 0;
		this.intervals.map(function(i) {len += i.length;});
		return len;
	}
});

IntervalSet.prototype.removeRange = function(v) {
    if(v.start===v.stop-1) {
        this.removeOne(v.start);
    } else if (this.intervals!==null) {
        var k = 0;
        for(var n=0; n<this.intervals.length; n++) {
            var i = this.intervals[k];
            // intervals are ordered
            if (v.stop<=i.start) {
                return;
            }
            // check for including range, split it
            else if(v.start>i.start && v.stop<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
                var x = new Interval(v.stop, i.stop);
                this.intervals.splice(k, 0, x);
                return;
            }
            // check for included range, remove it
            else if(v.start<=i.start && v.stop>=i.stop) {
                this.intervals.splice(k, 1);
                k = k - 1; // need another pass
            }
            // check for lower boundary
            else if(v.start<i.stop) {
                this.intervals[k] = new Interval(i.start, v.start);
            }
            // check for upper boundary
            else if(v.stop<i.stop) {
                this.intervals[k] = new Interval(v.stop, i.stop);
            }
            k += 1;
        }
    }
};

IntervalSet.prototype.removeOne = function(v) {
	if (this.intervals !== null) {
		for (var k = 0; k < this.intervals.length; k++) {
			var i = this.intervals[k];
			// intervals is ordered
			if (v < i.start) {
				return;
			}
			// check for single value range
			else if (v === i.start && v === i.stop - 1) {
				this.intervals.splice(k, 1);
				return;
			}
			// check for lower boundary
			else if (v === i.start) {
				this.intervals[k] = new Interval(i.start + 1, i.stop);
				return;
			}
			// check for upper boundary
			else if (v === i.stop - 1) {
				this.intervals[k] = new Interval(i.start, i.stop - 1);
				return;
			}
			// split existing range
			else if (v < i.stop - 1) {
				var x = new Interval(i.start, v);
				i.start = v + 1;
				this.intervals.splice(k, 0, x);
				return;
			}
		}
	}
};

IntervalSet.prototype.toString = function(literalNames, symbolicNames, elemsAreChar) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	elemsAreChar = elemsAreChar || false;
	if (this.intervals === null) {
		return "{}";
	} else if(literalNames!==null || symbolicNames!==null) {
		return this.toTokenString(literalNames, symbolicNames);
	} else if(elemsAreChar) {
		return this.toCharString();
	} else {
		return this.toIndexString();
	}
};

IntervalSet.prototype.toCharString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push("'" + String.fromCharCode(v.start) + "'");
			}
		} else {
			names.push("'" + String.fromCharCode(v.start) + "'..'" + String.fromCharCode(v.stop-1) + "'");
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toIndexString = function() {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		if(v.stop===v.start+1) {
			if ( v.start===Token.EOF ) {
				names.push("<EOF>");
			} else {
				names.push(v.start.toString());
			}
		} else {
			names.push(v.start.toString() + ".." + (v.stop-1).toString());
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};


IntervalSet.prototype.toTokenString = function(literalNames, symbolicNames) {
	var names = [];
	for (var i = 0; i < this.intervals.length; i++) {
		var v = this.intervals[i];
		for (var j = v.start; j < v.stop; j++) {
			names.push(this.elementName(literalNames, symbolicNames, j));
		}
	}
	if (names.length > 1) {
		return "{" + names.join(", ") + "}";
	} else {
		return names[0];
	}
};

IntervalSet.prototype.elementName = function(literalNames, symbolicNames, a) {
	if (a === Token.EOF) {
		return "<EOF>";
	} else if (a === Token.EPSILON) {
		return "<EPSILON>";
	} else {
		return literalNames[a] || symbolicNames[a];
	}
};

exports.Interval = Interval;
exports.IntervalSet = IntervalSet;


/***/ }),

/***/ "./node_modules/antlr4/LL1Analyzer.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/LL1Analyzer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var Set = __webpack_require__(/*! ./Utils */ "./node_modules/antlr4/Utils.js").Set;
var BitSet = __webpack_require__(/*! ./Utils */ "./node_modules/antlr4/Utils.js").BitSet;
var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var ATNConfig = __webpack_require__(/*! ./atn/ATNConfig */ "./node_modules/antlr4/atn/ATNConfig.js").ATNConfig;
var Interval = __webpack_require__(/*! ./IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var IntervalSet = __webpack_require__(/*! ./IntervalSet */ "./node_modules/antlr4/IntervalSet.js").IntervalSet;
var RuleStopState = __webpack_require__(/*! ./atn/ATNState */ "./node_modules/antlr4/atn/ATNState.js").RuleStopState;
var RuleTransition = __webpack_require__(/*! ./atn/Transition */ "./node_modules/antlr4/atn/Transition.js").RuleTransition;
var NotSetTransition = __webpack_require__(/*! ./atn/Transition */ "./node_modules/antlr4/atn/Transition.js").NotSetTransition;
var WildcardTransition = __webpack_require__(/*! ./atn/Transition */ "./node_modules/antlr4/atn/Transition.js").WildcardTransition;
var AbstractPredicateTransition = __webpack_require__(/*! ./atn/Transition */ "./node_modules/antlr4/atn/Transition.js").AbstractPredicateTransition;

var pc = __webpack_require__(/*! ./PredictionContext */ "./node_modules/antlr4/PredictionContext.js");
var predictionContextFromRuleContext = pc.predictionContextFromRuleContext;
var PredictionContext = pc.PredictionContext;
var SingletonPredictionContext = pc.SingletonPredictionContext;

function LL1Analyzer (atn) {
    this.atn = atn;
}

//* Special value added to the lookahead sets to indicate that we hit
//  a predicate during analysis if {@code seeThruPreds==false}.
///
LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;


//*
// Calculates the SLL(1) expected lookahead set for each outgoing transition
// of an {@link ATNState}. The returned array has one element for each
// outgoing transition in {@code s}. If the closure from transition
// <em>i</em> leads to a semantic predicate before matching a symbol, the
// element at index <em>i</em> of the result will be {@code null}.
//
// @param s the ATN state
// @return the expected symbols for each outgoing transition of {@code s}.
///
LL1Analyzer.prototype.getDecisionLookahead = function(s) {
    if (s === null) {
        return null;
    }
    var count = s.transitions.length;
    var look = [];
    for(var alt=0; alt< count; alt++) {
        look[alt] = new IntervalSet();
        var lookBusy = new Set();
        var seeThruPreds = false; // fail to get lookahead upon pred
        this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY,
              look[alt], lookBusy, new BitSet(), seeThruPreds, false);
        // Wipe out lookahead for this alternative if we found nothing
        // or we had a predicate when we !seeThruPreds
        if (look[alt].length===0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
            look[alt] = null;
        }
    }
    return look;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and the end of the rule containing
// {@code s} is reached, {@link Token//EPSILON} is added to the result set.
// If {@code ctx} is not {@code null} and the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx the complete parser context, or {@code null} if the context
// should be ignored
//
// @return The set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
///
LL1Analyzer.prototype.LOOK = function(s, stopState, ctx) {
    var r = new IntervalSet();
    var seeThruPreds = true; // ignore preds; get all lookahead
	ctx = ctx || null;
    var lookContext = ctx!==null ? predictionContextFromRuleContext(s.atn, ctx) : null;
    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);
    return r;
};

//*
// Compute set of tokens that can follow {@code s} in the ATN in the
// specified {@code ctx}.
//
// <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
// rule containing {@code s} is reached, {@link Token//EPSILON} is added to
// the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
// {@code true} and {@code stopState} or the end of the outermost rule is
// reached, {@link Token//EOF} is added to the result set.</p>
//
// @param s the ATN state.
// @param stopState the ATN state to stop at. This can be a
// {@link BlockEndState} to detect epsilon paths through a closure.
// @param ctx The outer context, or {@code null} if the outer context should
// not be used.
// @param look The result lookahead set.
// @param lookBusy A set used for preventing epsilon closures in the ATN
// from causing a stack overflow. Outside code should pass
// {@code new Set<ATNConfig>} for this argument.
// @param calledRuleStack A set used for preventing left recursion in the
// ATN from causing a stack overflow. Outside code should pass
// {@code new BitSet()} for this argument.
// @param seeThruPreds {@code true} to true semantic predicates as
// implicitly {@code true} and "see through them", otherwise {@code false}
// to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
// result if one is encountered.
// @param addEOF Add {@link Token//EOF} to the result if the end of the
// outermost context is reached. This parameter has no effect if {@code ctx}
// is {@code null}.
///
LL1Analyzer.prototype._LOOK = function(s, stopState , ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    var c = new ATNConfig({state:s, alt:0, context: ctx}, null);
    if (lookBusy.contains(c)) {
        return;
    }
    lookBusy.add(c);
    if (s === stopState) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
    }
    if (s instanceof RuleStopState ) {
        if (ctx ===null) {
            look.addOne(Token.EPSILON);
            return;
        } else if (ctx.isEmpty() && addEOF) {
            look.addOne(Token.EOF);
            return;
        }
        if (ctx !== PredictionContext.EMPTY) {
            // run thru all possible stack tops in ctx
            for(var i=0; i<ctx.length; i++) {
                var returnState = this.atn.states[ctx.getReturnState(i)];
                var removed = calledRuleStack.contains(returnState.ruleIndex);
                try {
                    calledRuleStack.remove(returnState.ruleIndex);
                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                } finally {
                    if (removed) {
                        calledRuleStack.add(returnState.ruleIndex);
                    }
                }
            }
            return;
        }
    }
    for(var j=0; j<s.transitions.length; j++) {
        var t = s.transitions[j];
        if (t.constructor === RuleTransition) {
            if (calledRuleStack.contains(t.target.ruleIndex)) {
                continue;
            }
            var newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);
            try {
                calledRuleStack.add(t.target.ruleIndex);
                this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } finally {
                calledRuleStack.remove(t.target.ruleIndex);
            }
        } else if (t instanceof AbstractPredicateTransition ) {
            if (seeThruPreds) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            } else {
                look.addOne(LL1Analyzer.HIT_PRED);
            }
        } else if( t.isEpsilon) {
            this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else if (t.constructor === WildcardTransition) {
            look.addRange( Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType );
        } else {
            var set = t.label;
            if (set !== null) {
                if (t instanceof NotSetTransition) {
                    set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                }
                look.addSet(set);
            }
        }
    }
};

exports.LL1Analyzer = LL1Analyzer;



/***/ }),

/***/ "./node_modules/antlr4/Lexer.js":
/*!**************************************!*\
  !*** ./node_modules/antlr4/Lexer.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A lexer is recognizer that draws input symbols from a character stream.
//  lexer grammars result in a subclass of this object. A Lexer object
//  uses simplified match() and error recovery mechanisms in the interest of speed.

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var Recognizer = __webpack_require__(/*! ./Recognizer */ "./node_modules/antlr4/Recognizer.js").Recognizer;
var CommonTokenFactory = __webpack_require__(/*! ./CommonTokenFactory */ "./node_modules/antlr4/CommonTokenFactory.js").CommonTokenFactory;
var RecognitionException  = __webpack_require__(/*! ./error/Errors */ "./node_modules/antlr4/error/Errors.js").RecognitionException;
var LexerNoViableAltException = __webpack_require__(/*! ./error/Errors */ "./node_modules/antlr4/error/Errors.js").LexerNoViableAltException;

function TokenSource() {
	return this;
}

function Lexer(input) {
	Recognizer.call(this);
	this._input = input;
	this._factory = CommonTokenFactory.DEFAULT;
	this._tokenFactorySourcePair = [ this, input ];

	this._interp = null; // child classes must populate this

	// The goal of all lexer rules/methods is to create a token object.
	// this is an instance variable as multiple rules may collaborate to
	// create a single token. nextToken will return this object after
	// matching lexer rule(s). If you subclass to allow multiple token
	// emissions, then set this to the last token to be matched or
	// something nonnull so that the auto token emit mechanism will not
	// emit another token.
	this._token = null;

	// What character index in the stream did the current token start at?
	// Needed, for example, to get the text for current token. Set at
	// the start of nextToken.
	this._tokenStartCharIndex = -1;

	// The line on which the first character of the token resides///
	this._tokenStartLine = -1;

	// The character position of first character within the line///
	this._tokenStartColumn = -1;

	// Once we see EOF on char stream, next token will be EOF.
	// If you have DONE : EOF ; then you see DONE EOF.
	this._hitEOF = false;

	// The channel number for the current token///
	this._channel = Token.DEFAULT_CHANNEL;

	// The token type for the current token///
	this._type = Token.INVALID_TYPE;

	this._modeStack = [];
	this._mode = Lexer.DEFAULT_MODE;

	// You can set the text for the current token to override what is in
	// the input char buffer. Use setText() or can set this instance var.
	// /
	this._text = null;

	return this;
}

Lexer.prototype = Object.create(Recognizer.prototype);
Lexer.prototype.constructor = Lexer;

Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;

Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;

Lexer.prototype.reset = function() {
	// wack Lexer state variables
	if (this._input !== null) {
		this._input.seek(0); // rewind the input
	}
	this._token = null;
	this._type = Token.INVALID_TYPE;
	this._channel = Token.DEFAULT_CHANNEL;
	this._tokenStartCharIndex = -1;
	this._tokenStartColumn = -1;
	this._tokenStartLine = -1;
	this._text = null;

	this._hitEOF = false;
	this._mode = Lexer.DEFAULT_MODE;
	this._modeStack = [];

	this._interp.reset();
};

// Return a token from this source; i.e., match a token on the char stream.
Lexer.prototype.nextToken = function() {
	if (this._input === null) {
		throw "nextToken requires a non-null input stream.";
	}

	// Mark start location in char stream so unbuffered streams are
	// guaranteed at least have text of current token
	var tokenStartMarker = this._input.mark();
	try {
		while (true) {
			if (this._hitEOF) {
				this.emitEOF();
				return this._token;
			}
			this._token = null;
			this._channel = Token.DEFAULT_CHANNEL;
			this._tokenStartCharIndex = this._input.index;
			this._tokenStartColumn = this._interp.column;
			this._tokenStartLine = this._interp.line;
			this._text = null;
			var continueOuter = false;
			while (true) {
				this._type = Token.INVALID_TYPE;
				var ttype = Lexer.SKIP;
				try {
					ttype = this._interp.match(this._input, this._mode);
				} catch (e) {
				    if(e instanceof RecognitionException) {
                        this.notifyListeners(e); // report error
                        this.recover(e);
                    } else {
                        console.log(e.stack);
                        throw e;
                    }
				}
				if (this._input.LA(1) === Token.EOF) {
					this._hitEOF = true;
				}
				if (this._type === Token.INVALID_TYPE) {
					this._type = ttype;
				}
				if (this._type === Lexer.SKIP) {
					continueOuter = true;
					break;
				}
				if (this._type !== Lexer.MORE) {
					break;
				}
			}
			if (continueOuter) {
				continue;
			}
			if (this._token === null) {
				this.emit();
			}
			return this._token;
		}
	} finally {
		// make sure we release marker after match or
		// unbuffered char stream will keep buffering
		this._input.release(tokenStartMarker);
	}
};

// Instruct the lexer to skip creating a token for current lexer rule
// and look for another token. nextToken() knows to keep looking when
// a lexer rule finishes with token set to SKIP_TOKEN. Recall that
// if token==null at end of any token rule, it creates one for you
// and emits it.
// /
Lexer.prototype.skip = function() {
	this._type = Lexer.SKIP;
};

Lexer.prototype.more = function() {
	this._type = Lexer.MORE;
};

Lexer.prototype.mode = function(m) {
	this._mode = m;
};

Lexer.prototype.pushMode = function(m) {
	if (this._interp.debug) {
		console.log("pushMode " + m);
	}
	this._modeStack.push(this._mode);
	this.mode(m);
};

Lexer.prototype.popMode = function() {
	if (this._modeStack.length === 0) {
		throw "Empty Stack";
	}
	if (this._interp.debug) {
		console.log("popMode back to " + this._modeStack.slice(0, -1));
	}
	this.mode(this._modeStack.pop());
	return this._mode;
};

// Set the char stream and reset the lexer
Object.defineProperty(Lexer.prototype, "inputStream", {
	get : function() {
		return this._input;
	},
	set : function(input) {
		this._input = null;
		this._tokenFactorySourcePair = [ this, this._input ];
		this.reset();
		this._input = input;
		this._tokenFactorySourcePair = [ this, this._input ];
	}
});

Object.defineProperty(Lexer.prototype, "sourceName", {
	get : function sourceName() {
		return this._input.sourceName;
	}
});

// By default does not support multiple emits per nextToken invocation
// for efficiency reasons. Subclass and override this method, nextToken,
// and getToken (to push tokens into a list and pull from that list
// rather than a single variable as this implementation does).
// /
Lexer.prototype.emitToken = function(token) {
	this._token = token;
};

// The standard method called to automatically emit a token at the
// outermost lexical rule. The token object should point into the
// char buffer start..stop. If there is a text override in 'text',
// use that to set the token's text. Override this method to emit
// custom Token objects or provide a new factory.
// /
Lexer.prototype.emit = function() {
	var t = this._factory.create(this._tokenFactorySourcePair, this._type,
			this._text, this._channel, this._tokenStartCharIndex, this
					.getCharIndex() - 1, this._tokenStartLine,
			this._tokenStartColumn);
	this.emitToken(t);
	return t;
};

Lexer.prototype.emitEOF = function() {
	var cpos = this.column;
	var lpos = this.line;
	var eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF,
			null, Token.DEFAULT_CHANNEL, this._input.index,
			this._input.index - 1, lpos, cpos);
	this.emitToken(eof);
	return eof;
};

Object.defineProperty(Lexer.prototype, "type", {
	get : function() {
		return this.type;
	},
	set : function(type) {
		this._type = type;
	}
});

Object.defineProperty(Lexer.prototype, "line", {
	get : function() {
		return this._interp.line;
	},
	set : function(line) {
		this._interp.line = line;
	}
});

Object.defineProperty(Lexer.prototype, "column", {
	get : function() {
		return this._interp.column;
	},
	set : function(column) {
		this._interp.column = column;
	}
});


// What is the index of the current character of lookahead?///
Lexer.prototype.getCharIndex = function() {
	return this._input.index;
};

// Return the text matched so far for the current token or any text override.
//Set the complete text of this token; it wipes any previous changes to the text.
Object.defineProperty(Lexer.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		} else {
			return this._interp.getText(this._input);
		}
	},
	set : function(text) {
		this._text = text;
	}
});
// Return a list of all Token objects in input char stream.
// Forces load of all tokens. Does not include EOF token.
// /
Lexer.prototype.getAllTokens = function() {
	var tokens = [];
	var t = this.nextToken();
	while (t.type !== Token.EOF) {
		tokens.push(t);
		t = this.nextToken();
	}
	return tokens;
};

Lexer.prototype.notifyListeners = function(e) {
	var start = this._tokenStartCharIndex;
	var stop = this._input.index;
	var text = this._input.getText(start, stop);
	var msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, null, this._tokenStartLine,
			this._tokenStartColumn, msg, e);
};

Lexer.prototype.getErrorDisplay = function(s) {
	var d = [];
	for (var i = 0; i < s.length; i++) {
		d.push(s[i]);
	}
	return d.join('');
};

Lexer.prototype.getErrorDisplayForChar = function(c) {
	if (c.charCodeAt(0) === Token.EOF) {
		return "<EOF>";
	} else if (c === '\n') {
		return "\\n";
	} else if (c === '\t') {
		return "\\t";
	} else if (c === '\r') {
		return "\\r";
	} else {
		return c;
	}
};

Lexer.prototype.getCharErrorDisplay = function(c) {
	return "'" + this.getErrorDisplayForChar(c) + "'";
};

// Lexers can normally match any char in it's vocabulary after matching
// a token, so do the easy thing and just kill a character and hope
// it all works out. You can instead use the rule invocation stack
// to do sophisticated error recovery if you are in a fragment rule.
// /
Lexer.prototype.recover = function(re) {
	if (this._input.LA(1) !== Token.EOF) {
		if (re instanceof LexerNoViableAltException) {
			// skip a char and try again
			this._interp.consume(this._input);
		} else {
			// TODO: Do we lose character or line position information?
			this._input.consume();
		}
	}
};

exports.Lexer = Lexer;


/***/ }),

/***/ "./node_modules/antlr4/Parser.js":
/*!***************************************!*\
  !*** ./node_modules/antlr4/Parser.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var ParseTreeListener = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js").ParseTreeListener;
var Recognizer = __webpack_require__(/*! ./Recognizer */ "./node_modules/antlr4/Recognizer.js").Recognizer;
var DefaultErrorStrategy = __webpack_require__(/*! ./error/ErrorStrategy */ "./node_modules/antlr4/error/ErrorStrategy.js").DefaultErrorStrategy;
var ATNDeserializer = __webpack_require__(/*! ./atn/ATNDeserializer */ "./node_modules/antlr4/atn/ATNDeserializer.js").ATNDeserializer;
var ATNDeserializationOptions = __webpack_require__(/*! ./atn/ATNDeserializationOptions */ "./node_modules/antlr4/atn/ATNDeserializationOptions.js").ATNDeserializationOptions;
var TerminalNode = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js").TerminalNode;
var ErrorNode = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js").ErrorNode;

function TraceListener(parser) {
	ParseTreeListener.call(this);
    this.parser = parser;
	return this;
}

TraceListener.prototype = Object.create(ParseTreeListener.prototype);
TraceListener.prototype.constructor = TraceListener;

TraceListener.prototype.enterEveryRule = function(ctx) {
	console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

TraceListener.prototype.visitTerminal = function( node) {
	console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
};

TraceListener.prototype.exitEveryRule = function(ctx) {
	console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
};

// this is all the parsing support code essentially; most of it is error
// recovery stuff.//
function Parser(input) {
	Recognizer.call(this);
	// The input stream.
	this._input = null;
	// The error handling strategy for the parser. The default value is a new
	// instance of {@link DefaultErrorStrategy}.
	this._errHandler = new DefaultErrorStrategy();
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	// The {@link ParserRuleContext} object for the currently executing rule.
	// this is always non-null during the parsing process.
	this._ctx = null;
	// Specifies whether or not the parser should construct a parse tree during
	// the parsing process. The default value is {@code true}.
	this.buildParseTrees = true;
	// When {@link //setTrace}{@code (true)} is called, a reference to the
	// {@link TraceListener} is stored here so it can be easily removed in a
	// later call to {@link //setTrace}{@code (false)}. The listener itself is
	// implemented as a parser listener so this field is not directly used by
	// other parser methods.
	this._tracer = null;
	// The list of {@link ParseTreeListener} listeners registered to receive
	// events during the parse.
	this._parseListeners = null;
	// The number of syntax errors reported during parsing. this value is
	// incremented each time {@link //notifyErrorListeners} is called.
	this._syntaxErrors = 0;
	this.setInputStream(input);
	return this;
}

Parser.prototype = Object.create(Recognizer.prototype);
Parser.prototype.contructor = Parser;

// this field maps from the serialized ATN string to the deserialized {@link
// ATN} with
// bypass alternatives.
//
// @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
//
Parser.bypassAltsAtnCache = {};

// reset the parser's state//
Parser.prototype.reset = function() {
	if (this._input !== null) {
		this._input.seek(0);
	}
	this._errHandler.reset(this);
	this._ctx = null;
	this._syntaxErrors = 0;
	this.setTrace(false);
	this._precedenceStack = [];
	this._precedenceStack.push(0);
	if (this._interp !== null) {
		this._interp.reset();
	}
};

// Match current input symbol against {@code ttype}. If the symbol type
// matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
// called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @param ttype the token type to match
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// {@code ttype} and the error strategy could not recover from the
// mismatched symbol

Parser.prototype.match = function(ttype) {
	var t = this.getCurrentToken();
	if (t.type === ttype) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this.buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};
// Match current input symbol as a wildcard. If the symbol type matches
// (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
// and {@link //consume} are called to complete the match process.
//
// <p>If the symbol type does not match,
// {@link ANTLRErrorStrategy//recoverInline} is called on the current error
// strategy to attempt recovery. If {@link //getBuildParseTree} is
// {@code true} and the token index of the symbol returned by
// {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
// the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
//
// @return the matched symbol
// @throws RecognitionException if the current input symbol did not match
// a wildcard and the error strategy could not recover from the mismatched
// symbol

Parser.prototype.matchWildcard = function() {
	var t = this.getCurrentToken();
	if (t.type > 0) {
		this._errHandler.reportMatch(this);
		this.consume();
	} else {
		t = this._errHandler.recoverInline(this);
		if (this._buildParseTrees && t.tokenIndex === -1) {
			// we must have conjured up a new token during single token
			// insertion
			// if it's not the current symbol
			this._ctx.addErrorNode(t);
		}
	}
	return t;
};

Parser.prototype.getParseListeners = function() {
	return this._parseListeners || [];
};

// Registers {@code listener} to receive events during the parsing process.
//
// <p>To support output-preserving grammar transformations (including but not
// limited to left-recursion removal, automated left-factoring, and
// optimized code generation), calls to listener methods during the parse
// may differ substantially from calls made by
// {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
// particular, rule entry and exit events may occur in a different order
// during the parse than after the parser. In addition, calls to certain
// rule entry methods may be omitted.</p>
//
// <p>With the following specific exceptions, calls to listener events are
// <em>deterministic</em>, i.e. for identical input the calls to listener
// methods will be the same.</p>
//
// <ul>
// <li>Alterations to the grammar used to generate code may change the
// behavior of the listener calls.</li>
// <li>Alterations to the command line options passed to ANTLR 4 when
// generating the parser may change the behavior of the listener calls.</li>
// <li>Changing the version of the ANTLR Tool used to generate the parser
// may change the behavior of the listener calls.</li>
// </ul>
//
// @param listener the listener to add
//
// @throws NullPointerException if {@code} listener is {@code null}
//
Parser.prototype.addParseListener = function(listener) {
	if (listener === null) {
		throw "listener";
	}
	if (this._parseListeners === null) {
		this._parseListeners = [];
	}
	this._parseListeners.push(listener);
};

//
// Remove {@code listener} from the list of parse listeners.
//
// <p>If {@code listener} is {@code null} or has not been added as a parse
// listener, this method does nothing.</p>
// @param listener the listener to remove
//
Parser.prototype.removeParseListener = function(listener) {
	if (this._parseListeners !== null) {
		var idx = this._parseListeners.indexOf(listener);
		if (idx >= 0) {
			this._parseListeners.splice(idx, 1);
		}
		if (this._parseListeners.length === 0) {
			this._parseListeners = null;
		}
	}
};

// Remove all parse listeners.
Parser.prototype.removeParseListeners = function() {
	this._parseListeners = null;
};

// Notify any parse listeners of an enter rule event.
Parser.prototype.triggerEnterRuleEvent = function() {
	if (this._parseListeners !== null) {
        var ctx = this._ctx;
		this._parseListeners.map(function(listener) {
			listener.enterEveryRule(ctx);
			ctx.enterRule(listener);
		});
	}
};

//
// Notify any parse listeners of an exit rule event.
//
// @see //addParseListener
//
Parser.prototype.triggerExitRuleEvent = function() {
	if (this._parseListeners !== null) {
		// reverse order walk of listeners
        var ctx = this._ctx;
		this._parseListeners.slice(0).reverse().map(function(listener) {
			ctx.exitRule(listener);
			listener.exitEveryRule(ctx);
		});
	}
};

Parser.prototype.getTokenFactory = function() {
	return this._input.tokenSource._factory;
};

// Tell our token source and error strategy about a new way to create tokens.//
Parser.prototype.setTokenFactory = function(factory) {
	this._input.tokenSource._factory = factory;
};

// The ATN with bypass alternatives is expensive to create so we create it
// lazily.
//
// @throws UnsupportedOperationException if the current parser does not
// implement the {@link //getSerializedATN()} method.
//
Parser.prototype.getATNWithBypassAlts = function() {
	var serializedAtn = this.getSerializedATN();
	if (serializedAtn === null) {
		throw "The current parser does not support an ATN with bypass alternatives.";
	}
	var result = this.bypassAltsAtnCache[serializedAtn];
	if (result === null) {
		var deserializationOptions = new ATNDeserializationOptions();
		deserializationOptions.generateRuleBypassTransitions = true;
		result = new ATNDeserializer(deserializationOptions)
				.deserialize(serializedAtn);
		this.bypassAltsAtnCache[serializedAtn] = result;
	}
	return result;
};

// The preferred method of getting a tree pattern. For example, here's a
// sample use:
//
// <pre>
// ParseTree t = parser.expr();
// ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
// MyParser.RULE_expr);
// ParseTreeMatch m = p.match(t);
// String id = m.get("ID");
// </pre>

var Lexer = __webpack_require__(/*! ./Lexer */ "./node_modules/antlr4/Lexer.js").Lexer;

Parser.prototype.compileParseTreePattern = function(pattern, patternRuleIndex, lexer) {
	lexer = lexer || null;
	if (lexer === null) {
		if (this.getTokenStream() !== null) {
			var tokenSource = this.getTokenStream().tokenSource;
			if (tokenSource instanceof Lexer) {
				lexer = tokenSource;
			}
		}
	}
	if (lexer === null) {
		throw "Parser can't discover a lexer to use";
	}
	var m = new ParseTreePatternMatcher(lexer, this);
	return m.compile(pattern, patternRuleIndex);
};

Parser.prototype.getInputStream = function() {
	return this.getTokenStream();
};

Parser.prototype.setInputStream = function(input) {
	this.setTokenStream(input);
};

Parser.prototype.getTokenStream = function() {
	return this._input;
};

// Set the token stream and reset the parser.//
Parser.prototype.setTokenStream = function(input) {
	this._input = null;
	this.reset();
	this._input = input;
};

// Match needs to return the current input symbol, which gets put
// into the label for the associated token ref; e.g., x=ID.
//
Parser.prototype.getCurrentToken = function() {
	return this._input.LT(1);
};

Parser.prototype.notifyErrorListeners = function(msg, offendingToken, err) {
	offendingToken = offendingToken || null;
	err = err || null;
	if (offendingToken === null) {
		offendingToken = this.getCurrentToken();
	}
	this._syntaxErrors += 1;
	var line = offendingToken.line;
	var column = offendingToken.column;
	var listener = this.getErrorListenerDispatch();
	listener.syntaxError(this, offendingToken, line, column, msg, err);
};

//
// Consume and return the {@linkplain //getCurrentToken current symbol}.
//
// <p>E.g., given the following input with {@code A} being the current
// lookahead symbol, this function moves the cursor to {@code B} and returns
// {@code A}.</p>
//
// <pre>
// A B
// ^
// </pre>
//
// If the parser is not in error recovery mode, the consumed symbol is added
// to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
// {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
// If the parser <em>is</em> in error recovery mode, the consumed symbol is
// added to the parse tree using
// {@link ParserRuleContext//addErrorNode(Token)}, and
// {@link ParseTreeListener//visitErrorNode} is called on any parse
// listeners.
//
Parser.prototype.consume = function() {
	var o = this.getCurrentToken();
	if (o.type !== Token.EOF) {
		this.getInputStream().consume();
	}
	var hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
	if (this.buildParseTrees || hasListener) {
		var node;
		if (this._errHandler.inErrorRecoveryMode(this)) {
			node = this._ctx.addErrorNode(o);
		} else {
			node = this._ctx.addTokenNode(o);
		}
        node.invokingState = this.state;
		if (hasListener) {
			this._parseListeners.map(function(listener) {
				if (node instanceof ErrorNode || (node.isErrorNode !== undefined && node.isErrorNode())) {
					listener.visitErrorNode(node);
				} else if (node instanceof TerminalNode) {
					listener.visitTerminal(node);
				}
			});
		}
	}
	return o;
};

Parser.prototype.addContextToParseTree = function() {
	// add current context to parent if we have a parent
	if (this._ctx.parentCtx !== null) {
		this._ctx.parentCtx.addChild(this._ctx);
	}
};

// Always called by generated parsers upon entry to a rule. Access field
// {@link //_ctx} get the current context.

Parser.prototype.enterRule = function(localctx, state, ruleIndex) {
	this.state = state;
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this.buildParseTrees) {
		this.addContextToParseTree();
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent();
	}
};

Parser.prototype.exitRule = function() {
	this._ctx.stop = this._input.LT(-1);
	// trigger event on _ctx, before it reverts to parent
	if (this._parseListeners !== null) {
		this.triggerExitRuleEvent();
	}
	this.state = this._ctx.invokingState;
	this._ctx = this._ctx.parentCtx;
};

Parser.prototype.enterOuterAlt = function(localctx, altNum) {
   	localctx.setAltNumber(altNum);
	// if we have new localctx, make sure we replace existing ctx
	// that is previous child of parse tree
	if (this.buildParseTrees && this._ctx !== localctx) {
		if (this._ctx.parentCtx !== null) {
			this._ctx.parentCtx.removeLastChild();
			this._ctx.parentCtx.addChild(localctx);
		}
	}
	this._ctx = localctx;
};

// Get the precedence level for the top-most precedence rule.
//
// @return The precedence level for the top-most precedence rule, or -1 if
// the parser context is not nested within a precedence rule.

Parser.prototype.getPrecedence = function() {
	if (this._precedenceStack.length === 0) {
		return -1;
	} else {
		return this._precedenceStack[this._precedenceStack.length-1];
	}
};

Parser.prototype.enterRecursionRule = function(localctx, state, ruleIndex,
		precedence) {
	this.state = state;
	this._precedenceStack.push(precedence);
	this._ctx = localctx;
	this._ctx.start = this._input.LT(1);
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

//
// Like {@link //enterRule} but for recursive rules.

Parser.prototype.pushNewRecursionContext = function(localctx, state, ruleIndex) {
	var previous = this._ctx;
	previous.parentCtx = localctx;
	previous.invokingState = state;
	previous.stop = this._input.LT(-1);

	this._ctx = localctx;
	this._ctx.start = previous.start;
	if (this.buildParseTrees) {
		this._ctx.addChild(previous);
	}
	if (this._parseListeners !== null) {
		this.triggerEnterRuleEvent(); // simulates rule entry for
										// left-recursive rules
	}
};

Parser.prototype.unrollRecursionContexts = function(parentCtx) {
	this._precedenceStack.pop();
	this._ctx.stop = this._input.LT(-1);
	var retCtx = this._ctx; // save current ctx (return value)
	// unroll so _ctx is as it was before call to recursive method
	if (this._parseListeners !== null) {
		while (this._ctx !== parentCtx) {
			this.triggerExitRuleEvent();
			this._ctx = this._ctx.parentCtx;
		}
	} else {
		this._ctx = parentCtx;
	}
	// hook into tree
	retCtx.parentCtx = parentCtx;
	if (this.buildParseTrees && parentCtx !== null) {
		// add return ctx into invoking rule's tree
		parentCtx.addChild(retCtx);
	}
};

Parser.prototype.getInvokingContext = function(ruleIndex) {
	var ctx = this._ctx;
	while (ctx !== null) {
		if (ctx.ruleIndex === ruleIndex) {
			return ctx;
		}
		ctx = ctx.parentCtx;
	}
	return null;
};

Parser.prototype.precpred = function(localctx, precedence) {
	return precedence >= this._precedenceStack[this._precedenceStack.length-1];
};

Parser.prototype.inContext = function(context) {
	// TODO: useful in parser?
	return false;
};

//
// Checks whether or not {@code symbol} can follow the current state in the
// ATN. The behavior of this method is equivalent to the following, but is
// implemented such that the complete context-sensitive follow set does not
// need to be explicitly constructed.
//
// <pre>
// return getExpectedTokens().contains(symbol);
// </pre>
//
// @param symbol the symbol type to check
// @return {@code true} if {@code symbol} can follow the current state in
// the ATN, otherwise {@code false}.

Parser.prototype.isExpectedToken = function(symbol) {
	var atn = this._interp.atn;
	var ctx = this._ctx;
	var s = atn.states[this.state];
	var following = atn.nextTokens(s);
	if (following.contains(symbol)) {
		return true;
	}
	if (!following.contains(Token.EPSILON)) {
		return false;
	}
	while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
		var invokingState = atn.states[ctx.invokingState];
		var rt = invokingState.transitions[0];
		following = atn.nextTokens(rt.followState);
		if (following.contains(symbol)) {
			return true;
		}
		ctx = ctx.parentCtx;
	}
	if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
		return true;
	} else {
		return false;
	}
};

// Computes the set of input symbols which could follow the current parser
// state and context, as given by {@link //getState} and {@link //getContext},
// respectively.
//
// @see ATN//getExpectedTokens(int, RuleContext)
//
Parser.prototype.getExpectedTokens = function() {
	return this._interp.atn.getExpectedTokens(this.state, this._ctx);
};

Parser.prototype.getExpectedTokensWithinCurrentRule = function() {
	var atn = this._interp.atn;
	var s = atn.states[this.state];
	return atn.nextTokens(s);
};

// Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.//
Parser.prototype.getRuleIndex = function(ruleName) {
	var ruleIndex = this.getRuleIndexMap()[ruleName];
	if (ruleIndex !== null) {
		return ruleIndex;
	} else {
		return -1;
	}
};

// Return List&lt;String&gt; of the rule names in your parser instance
// leading up to a call to the current rule. You could override if
// you want more details such as the file/line info of where
// in the ATN a rule is invoked.
//
// this is very useful for error messages.
//
Parser.prototype.getRuleInvocationStack = function(p) {
	p = p || null;
	if (p === null) {
		p = this._ctx;
	}
	var stack = [];
	while (p !== null) {
		// compute what follows who invoked us
		var ruleIndex = p.ruleIndex;
		if (ruleIndex < 0) {
			stack.push("n/a");
		} else {
			stack.push(this.ruleNames[ruleIndex]);
		}
		p = p.parentCtx;
	}
	return stack;
};

// For debugging and other purposes.//
Parser.prototype.getDFAStrings = function() {
	return this._interp.decisionToDFA.toString();
};
// For debugging and other purposes.//
Parser.prototype.dumpDFA = function() {
	var seenOne = false;
	for (var i = 0; i < this._interp.decisionToDFA.length; i++) {
		var dfa = this._interp.decisionToDFA[i];
		if (dfa.states.length > 0) {
			if (seenOne) {
				console.log();
			}
			this.printer.println("Decision " + dfa.decision + ":");
			this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
			seenOne = true;
		}
	}
};

/*
"			printer = function() {\r\n" +
"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
"			};\r\n" +
*/

Parser.prototype.getSourceName = function() {
	return this._input.sourceName;
};

// During a parse is sometimes useful to listen in on the rule entry and exit
// events as well as token matches. this is for quick and dirty debugging.
//
Parser.prototype.setTrace = function(trace) {
	if (!trace) {
		this.removeParseListener(this._tracer);
		this._tracer = null;
	} else {
		if (this._tracer !== null) {
			this.removeParseListener(this._tracer);
		}
		this._tracer = new TraceListener(this);
		this.addParseListener(this._tracer);
	}
};

exports.Parser = Parser;

/***/ }),

/***/ "./node_modules/antlr4/ParserRuleContext.js":
/*!**************************************************!*\
  !*** ./node_modules/antlr4/ParserRuleContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//* A rule invocation record for parsing.
//
//  Contains all of the information about the current rule not stored in the
//  RuleContext. It handles parse tree children list, Any ATN state
//  tracing, and the default values available for rule indications:
//  start, stop, rule index, current alt number, current
//  ATN state.
//
//  Subclasses made for each rule and grammar track the parameters,
//  return values, locals, and labels specific to that rule. These
//  are the objects that are returned from rules.
//
//  Note text is not an actual field of a rule return value; it is computed
//  from start and stop using the input stream's toString() method.  I
//  could add a ctor to this so that we can pass in and store the input
//  stream, but I'm not sure we want to do that.  It would seem to be undefined
//  to get the .text property anyway if the rule matches tokens from multiple
//  input streams.
//
//  I do not use getters for fields of objects that are used simply to
//  group values such as this aggregate.  The getters/setters are there to
//  satisfy the superclass interface.

var RuleContext = __webpack_require__(/*! ./RuleContext */ "./node_modules/antlr4/RuleContext.js").RuleContext;
var Tree = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js");
var INVALID_INTERVAL = Tree.INVALID_INTERVAL;
var TerminalNode = Tree.TerminalNode;
var TerminalNodeImpl = Tree.TerminalNodeImpl;
var ErrorNodeImpl = Tree.ErrorNodeImpl;
var Interval = __webpack_require__(/*! ./IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;

function ParserRuleContext(parent, invokingStateNumber) {
	parent = parent || null;
	invokingStateNumber = invokingStateNumber || null;
	RuleContext.call(this, parent, invokingStateNumber);
	this.ruleIndex = -1;
    // * If we are debugging or building a parse tree for a visitor,
    // we need to track all of the tokens and rule invocations associated
    // with this rule's context. This is empty for parsing w/o tree constr.
    // operation because we don't the need to track the details about
    // how we parse this rule.
    // /
    this.children = null;
    this.start = null;
    this.stop = null;
    // The exception that forced this rule to return. If the rule successfully
    // completed, this is {@code null}.
    this.exception = null;
}

ParserRuleContext.prototype = Object.create(RuleContext.prototype);
ParserRuleContext.prototype.constructor = ParserRuleContext;

// * COPY a ctx (I'm deliberately not using copy constructor)///
ParserRuleContext.prototype.copyFrom = function(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop;
    // copy any error nodes to alt label node
    if(ctx.children) {
        this.children = [];
        // reset parent pointer for any error nodes
    	ctx.children.map(function(child) {
    		if (child instanceof ErrorNodeImpl) {
                this.children.push(child);
                child.parentCtx = this;
            }
		}, this);
	}
};

// Double dispatch methods for listeners
ParserRuleContext.prototype.enterRule = function(listener) {
};

ParserRuleContext.prototype.exitRule = function(listener) {
};

// * Does not set parent link; other add methods do that///
ParserRuleContext.prototype.addChild = function(child) {
    if (this.children === null) {
        this.children = [];
    }
    this.children.push(child);
    return child;
};

// * Used by enterOuterAlt to toss out a RuleContext previously added as
// we entered a rule. If we have // label, we will need to remove
// generic ruleContext object.
// /
ParserRuleContext.prototype.removeLastChild = function() {
    if (this.children !== null) {
        this.children.pop();
    }
};

ParserRuleContext.prototype.addTokenNode = function(token) {
    var node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.addErrorNode = function(badToken) {
    var node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
};

ParserRuleContext.prototype.getChild = function(i, type) {
	type = type || null;
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	if (type === null) {
		return this.children[i];
	} else {
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if(child instanceof type) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
		}
		return null;
    }
};


ParserRuleContext.prototype.getToken = function(ttype, i) {
	if (this.children === null || i < 0 || i >= this.children.length) {
		return null;
	}
	for(var j=0; j<this.children.length; j++) {
		var child = this.children[j];
		if (child instanceof TerminalNode) {
			if (child.symbol.type === ttype) {
				if(i===0) {
					return child;
				} else {
					i -= 1;
				}
			}
        }
	}
    return null;
};

ParserRuleContext.prototype.getTokens = function(ttype ) {
    if (this.children=== null) {
        return [];
    } else {
		var tokens = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof TerminalNode) {
				if (child.symbol.type === ttype) {
					tokens.push(child);
				}
			}
		}
		return tokens;
    }
};

ParserRuleContext.prototype.getTypedRuleContext = function(ctxType, i) {
    return this.getChild(i, ctxType);
};

ParserRuleContext.prototype.getTypedRuleContexts = function(ctxType) {
    if (this.children=== null) {
        return [];
    } else {
		var contexts = [];
		for(var j=0; j<this.children.length; j++) {
			var child = this.children[j];
			if (child instanceof ctxType) {
				contexts.push(child);
			}
		}
		return contexts;
	}
};

ParserRuleContext.prototype.getChildCount = function() {
	if (this.children=== null) {
		return 0;
	} else {
		return this.children.length;
	}
};

ParserRuleContext.prototype.getSourceInterval = function() {
    if( this.start === null || this.stop === null) {
        return INVALID_INTERVAL;
    } else {
        return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
};

RuleContext.EMPTY = new ParserRuleContext();

function InterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {
	ParserRuleContext.call(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
    return this;
}

InterpreterRuleContext.prototype = Object.create(ParserRuleContext.prototype);
InterpreterRuleContext.prototype.constructor = InterpreterRuleContext;

exports.ParserRuleContext = ParserRuleContext;

/***/ }),

/***/ "./node_modules/antlr4/PredictionContext.js":
/*!**************************************************!*\
  !*** ./node_modules/antlr4/PredictionContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var RuleContext = __webpack_require__(/*! ./RuleContext */ "./node_modules/antlr4/RuleContext.js").RuleContext;
var Hash = __webpack_require__(/*! ./Utils */ "./node_modules/antlr4/Utils.js").Hash;
var Map = __webpack_require__(/*! ./Utils */ "./node_modules/antlr4/Utils.js").Map;

function PredictionContext(cachedHashCode) {
	this.cachedHashCode = cachedHashCode;
}

// Represents {@code $} in local context prediction, which means wildcard.
// {@code//+x =//}.
// /
PredictionContext.EMPTY = null;

// Represents {@code $} in an array in full context mode, when {@code $}
// doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
// {@code $} = {@link //EMPTY_RETURN_STATE}.
// /
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;

PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;

// Stores the computed hash code of this {@link PredictionContext}. The hash
// code is computed in parts to match the following reference algorithm.
//
// <pre>
// private int referenceHashCode() {
// int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
// //INITIAL_HASH});
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
// getParent}(i));
// }
//
// for (int i = 0; i &lt; {@link //size()}; i++) {
// hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
// //getReturnState getReturnState}(i));
// }
//
// hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
// //size()});
// return hash;
// }
// </pre>
// /

// This means only the {@link //EMPTY} context is in set.
PredictionContext.prototype.isEmpty = function() {
	return this === PredictionContext.EMPTY;
};

PredictionContext.prototype.hasEmptyPath = function() {
	return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
};

PredictionContext.prototype.hashCode = function() {
	return this.cachedHashCode;
};


PredictionContext.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};
/*
function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}
*/

// Used to cache {@link PredictionContext} objects. Its used for the shared
// context cash associated with contexts in DFA states. This cache
// can be used for both lexers and parsers.

function PredictionContextCache() {
	this.cache = new Map();
	return this;
}

// Add a context to the cache and return it. If the context already exists,
// return that one instead and do not add a new context to the cache.
// Protect shared cache from unsafe thread access.
//
PredictionContextCache.prototype.add = function(ctx) {
	if (ctx === PredictionContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	var existing = this.cache.get(ctx) || null;
	if (existing !== null) {
		return existing;
	}
	this.cache.put(ctx, ctx);
	return ctx;
};

PredictionContextCache.prototype.get = function(ctx) {
	return this.cache.get(ctx) || null;
};

Object.defineProperty(PredictionContextCache.prototype, "length", {
	get : function() {
		return this.cache.length;
	}
});

function SingletonPredictionContext(parent, returnState) {
	var hashCode = 0;
	var hash = new Hash();
	if(parent !== null) {
		hash.update(parent, returnState);
	} else {
		hash.update(1);
	}
	hashCode = hash.finish();
	PredictionContext.call(this, hashCode);
	this.parentCtx = parent;
	this.returnState = returnState;
}

SingletonPredictionContext.prototype = Object.create(PredictionContext.prototype);
SingletonPredictionContext.prototype.contructor = SingletonPredictionContext;

SingletonPredictionContext.create = function(parent, returnState) {
	if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
		// someone can pass in the bits of an array ctx that mean $
		return PredictionContext.EMPTY;
	} else {
		return new SingletonPredictionContext(parent, returnState);
	}
};

Object.defineProperty(SingletonPredictionContext.prototype, "length", {
	get : function() {
		return 1;
	}
});

SingletonPredictionContext.prototype.getParent = function(index) {
	return this.parentCtx;
};

SingletonPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

SingletonPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof SingletonPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		if(this.returnState !== other.returnState)
            return false;
        else if(this.parentCtx==null)
            return other.parentCtx==null
		else
            return this.parentCtx.equals(other.parentCtx);
	}
};

SingletonPredictionContext.prototype.toString = function() {
	var up = this.parentCtx === null ? "" : this.parentCtx.toString();
	if (up.length === 0) {
		if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
			return "$";
		} else {
			return "" + this.returnState;
		}
	} else {
		return "" + this.returnState + " " + up;
	}
};

function EmptyPredictionContext() {
	SingletonPredictionContext.call(this, null, PredictionContext.EMPTY_RETURN_STATE);
	return this;
}

EmptyPredictionContext.prototype = Object.create(SingletonPredictionContext.prototype);
EmptyPredictionContext.prototype.constructor = EmptyPredictionContext;

EmptyPredictionContext.prototype.isEmpty = function() {
	return true;
};

EmptyPredictionContext.prototype.getParent = function(index) {
	return null;
};

EmptyPredictionContext.prototype.getReturnState = function(index) {
	return this.returnState;
};

EmptyPredictionContext.prototype.equals = function(other) {
	return this === other;
};

EmptyPredictionContext.prototype.toString = function() {
	return "$";
};

PredictionContext.EMPTY = new EmptyPredictionContext();

function ArrayPredictionContext(parents, returnStates) {
	// Parent can be null only if full ctx mode and we make an array
	// from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
	// null parent and
	// returnState == {@link //EMPTY_RETURN_STATE}.
	var h = new Hash();
	h.update(parents, returnStates);
	var hashCode = h.finish();
	PredictionContext.call(this, hashCode);
	this.parents = parents;
	this.returnStates = returnStates;
	return this;
}

ArrayPredictionContext.prototype = Object.create(PredictionContext.prototype);
ArrayPredictionContext.prototype.constructor = ArrayPredictionContext;

ArrayPredictionContext.prototype.isEmpty = function() {
	// since EMPTY_RETURN_STATE can only appear in the last position, we
	// don't need to verify that size==1
	return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
};

Object.defineProperty(ArrayPredictionContext.prototype, "length", {
	get : function() {
		return this.returnStates.length;
	}
});

ArrayPredictionContext.prototype.getParent = function(index) {
	return this.parents[index];
};

ArrayPredictionContext.prototype.getReturnState = function(index) {
	return this.returnStates[index];
};

ArrayPredictionContext.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof ArrayPredictionContext)) {
		return false;
	} else if (this.hashCode() !== other.hashCode()) {
		return false; // can't be same if hash is different
	} else {
		return this.returnStates === other.returnStates &&
				this.parents === other.parents;
	}
};

ArrayPredictionContext.prototype.toString = function() {
	if (this.isEmpty()) {
		return "[]";
	} else {
		var s = "[";
		for (var i = 0; i < this.returnStates.length; i++) {
			if (i > 0) {
				s = s + ", ";
			}
			if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
				s = s + "$";
				continue;
			}
			s = s + this.returnStates[i];
			if (this.parents[i] !== null) {
				s = s + " " + this.parents[i];
			} else {
				s = s + "null";
			}
		}
		return s + "]";
	}
};

// Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
// Return {@link //EMPTY} if {@code outerContext} is empty or null.
// /
function predictionContextFromRuleContext(atn, outerContext) {
	if (outerContext === undefined || outerContext === null) {
		outerContext = RuleContext.EMPTY;
	}
	// if we are in RuleContext of start rule, s, then PredictionContext
	// is EMPTY. Nobody called us. (if we are empty, return empty)
	if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
		return PredictionContext.EMPTY;
	}
	// If we have a parent, convert it to a PredictionContext graph
	var parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
	var state = atn.states[outerContext.invokingState];
	var transition = state.transitions[0];
	return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
/*
function calculateListsHashString(parents, returnStates) {
	var s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}
*/
function merge(a, b, rootIsWildcard, mergeCache) {
	// share same graph if both same
	if (a === b) {
		return a;
	}
	if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
		return mergeSingletons(a, b, rootIsWildcard, mergeCache);
	}
	// At least one of a or b is array
	// If one is $ and rootIsWildcard, return $ as// wildcard
	if (rootIsWildcard) {
		if (a instanceof EmptyPredictionContext) {
			return a;
		}
		if (b instanceof EmptyPredictionContext) {
			return b;
		}
	}
	// convert singleton so both are arrays to normalize
	if (a instanceof SingletonPredictionContext) {
		a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
	}
	if (b instanceof SingletonPredictionContext) {
		b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
	}
	return mergeArrays(a, b, rootIsWildcard, mergeCache);
}

//
// Merge two {@link SingletonPredictionContext} instances.
//
// <p>Stack tops equal, parents merge is same; return left graph.<br>
// <embed src="images/SingletonMerge_SameRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Same stack top, parents differ; merge parents giving array node, then
// remainders of those graphs. A new root node is created to point to the
// merged parents.<br>
// <embed src="images/SingletonMerge_SameRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to same parent. Make array node for the
// root where both element in the root point to the same (original)
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootSamePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Different stack tops pointing to different parents. Make array node for
// the root where each element points to the corresponding original
// parent.<br>
// <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
// type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// @param mergeCache
// /
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}

	var rootMerge = mergeRoot(a, b, rootIsWildcard);
	if (rootMerge !== null) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, rootMerge);
		}
		return rootMerge;
	}
	if (a.returnState === b.returnState) {
		var parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
		// if parent is same as existing a or b parent or reduced to a parent,
		// return it
		if (parent === a.parentCtx) {
			return a; // ax + bx = ax, if a=b
		}
		if (parent === b.parentCtx) {
			return b; // ax + bx = bx, if a=b
		}
		// else: ax + ay = a'[x,y]
		// merge parents x and y, giving array node with x,y then remainders
		// of those graphs. dup a, a' points at merged array
		// new joined parent so create new singleton pointing to it, a'
		var spc = SingletonPredictionContext.create(parent, a.returnState);
		if (mergeCache !== null) {
			mergeCache.set(a, b, spc);
		}
		return spc;
	} else { // a != b payloads differ
		// see if we can collapse parents due to $+x parents if local ctx
		var singleParent = null;
		if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
																				// bx =
																				// [a,b]x
			singleParent = a.parentCtx;
		}
		if (singleParent !== null) { // parents are same
			// sort payloads and use same parent
			var payloads = [ a.returnState, b.returnState ];
			if (a.returnState > b.returnState) {
				payloads[0] = b.returnState;
				payloads[1] = a.returnState;
			}
			var parents = [ singleParent, singleParent ];
			var apc = new ArrayPredictionContext(parents, payloads);
			if (mergeCache !== null) {
				mergeCache.set(a, b, apc);
			}
			return apc;
		}
		// parents differ and can't merge them. Just pack together
		// into array; can't merge.
		// ax + by = [ax,by]
		var payloads = [ a.returnState, b.returnState ];
		var parents = [ a.parentCtx, b.parentCtx ];
		if (a.returnState > b.returnState) { // sort by payload
			payloads[0] = b.returnState;
			payloads[1] = a.returnState;
			parents = [ b.parentCtx, a.parentCtx ];
		}
		var a_ = new ArrayPredictionContext(parents, payloads);
		if (mergeCache !== null) {
			mergeCache.set(a, b, a_);
		}
		return a_;
	}
}

//
// Handle case where at least one of {@code a} or {@code b} is
// {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
// to represent {@link //EMPTY}.
//
// <h2>Local-Context Merges</h2>
//
// <p>These local-context merge operations are used when {@code rootIsWildcard}
// is true.</p>
//
// <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
// <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
// {@code //EMPTY}; return left graph.<br>
// <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
//
// <p>Special case of last merge if local context.<br>
// <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
//
// <h2>Full-Context Merges</h2>
//
// <p>These full-context merge operations are used when {@code rootIsWildcard}
// is false.</p>
//
// <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
//
// <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
// null parent).<br>
// <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
//
// <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
//
// @param a the first {@link SingletonPredictionContext}
// @param b the second {@link SingletonPredictionContext}
// @param rootIsWildcard {@code true} if this is a local-context merge,
// otherwise false to indicate a full-context merge
// /
function mergeRoot(a, b, rootIsWildcard) {
	if (rootIsWildcard) {
		if (a === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // // + b =//
		}
		if (b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // a +// =//
		}
	} else {
		if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
			return PredictionContext.EMPTY; // $ + $ = $
		} else if (a === PredictionContext.EMPTY) { // $ + x = [$,x]
			var payloads = [ b.returnState,
					PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ b.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		} else if (b === PredictionContext.EMPTY) { // x + $ = [$,x] ($ is always first if present)
			var payloads = [ a.returnState, PredictionContext.EMPTY_RETURN_STATE ];
			var parents = [ a.parentCtx, null ];
			return new ArrayPredictionContext(parents, payloads);
		}
	}
	return null;
}

//
// Merge two {@link ArrayPredictionContext} instances.
//
// <p>Different tops, different parents.<br>
// <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, same parents.<br>
// <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, different parents.<br>
// <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
//
// <p>Shared top, all shared parents.<br>
// <embed src="images/ArrayMerge_ShareTopSharePar.svg"
// type="image/svg+xml"/></p>
//
// <p>Equal tops, merge parents and reduce top to
// {@link SingletonPredictionContext}.<br>
// <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
// /
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
	if (mergeCache !== null) {
		var previous = mergeCache.get(a, b);
		if (previous !== null) {
			return previous;
		}
		previous = mergeCache.get(b, a);
		if (previous !== null) {
			return previous;
		}
	}
	// merge sorted payloads a + b => M
	var i = 0; // walks a
	var j = 0; // walks b
	var k = 0; // walks target M array

	var mergedReturnStates = [];
	var mergedParents = [];
	// walk and merge to yield mergedParents, mergedReturnStates
	while (i < a.returnStates.length && j < b.returnStates.length) {
		var a_parent = a.parents[i];
		var b_parent = b.parents[j];
		if (a.returnStates[i] === b.returnStates[j]) {
			// same payload (stack tops are equal), must yield merged singleton
			var payload = a.returnStates[i];
			// $+$ = $
			var bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE &&
					a_parent === null && b_parent === null;
			var ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
																							// ->
																							// ax
			if (bothDollars || ax_ax) {
				mergedParents[k] = a_parent; // choose left
				mergedReturnStates[k] = payload;
			} else { // ax+ay -> a'[x,y]
				var mergedParent = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
				mergedParents[k] = mergedParent;
				mergedReturnStates[k] = payload;
			}
			i += 1; // hop over left one as usual
			j += 1; // but also skip one in right side since we merge
		} else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
			mergedParents[k] = a_parent;
			mergedReturnStates[k] = a.returnStates[i];
			i += 1;
		} else { // b > a, copy b[j] to M
			mergedParents[k] = b_parent;
			mergedReturnStates[k] = b.returnStates[j];
			j += 1;
		}
		k += 1;
	}
	// copy over any payloads remaining in either array
	if (i < a.returnStates.length) {
		for (var p = i; p < a.returnStates.length; p++) {
			mergedParents[k] = a.parents[p];
			mergedReturnStates[k] = a.returnStates[p];
			k += 1;
		}
	} else {
		for (var p = j; p < b.returnStates.length; p++) {
			mergedParents[k] = b.parents[p];
			mergedReturnStates[k] = b.returnStates[p];
			k += 1;
		}
	}
	// trim merged if we combined a few that had same stack tops
	if (k < mergedParents.length) { // write index < last position; trim
		if (k === 1) { // for just one merged element, return singleton top
			var a_ = SingletonPredictionContext.create(mergedParents[0],
					mergedReturnStates[0]);
			if (mergeCache !== null) {
				mergeCache.set(a, b, a_);
			}
			return a_;
		}
		mergedParents = mergedParents.slice(0, k);
		mergedReturnStates = mergedReturnStates.slice(0, k);
	}

	var M = new ArrayPredictionContext(mergedParents, mergedReturnStates);

	// if we created same array as a or b, return that instead
	// TODO: track whether this is possible above during merge sort for speed
	if (M === a) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, a);
		}
		return a;
	}
	if (M === b) {
		if (mergeCache !== null) {
			mergeCache.set(a, b, b);
		}
		return b;
	}
	combineCommonParents(mergedParents);

	if (mergeCache !== null) {
		mergeCache.set(a, b, M);
	}
	return M;
}

//
// Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
// ones.
// /
function combineCommonParents(parents) {
	var uniqueParents = new Map();

	for (var p = 0; p < parents.length; p++) {
		var parent = parents[p];
		if (!(uniqueParents.containsKey(parent))) {
			uniqueParents.put(parent, parent);
		}
	}
	for (var q = 0; q < parents.length; q++) {
		parents[q] = uniqueParents.get(parents[q]);
	}
}

function getCachedPredictionContext(context, contextCache, visited) {
	if (context.isEmpty()) {
		return context;
	}
	var existing = visited.get(context) || null;
	if (existing !== null) {
		return existing;
	}
	existing = contextCache.get(context);
	if (existing !== null) {
		visited.put(context, existing);
		return existing;
	}
	var changed = false;
	var parents = [];
	for (var i = 0; i < parents.length; i++) {
		var parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
		if (changed || parent !== context.getParent(i)) {
			if (!changed) {
				parents = [];
				for (var j = 0; j < context.length; j++) {
					parents[j] = context.getParent(j);
				}
				changed = true;
			}
			parents[i] = parent;
		}
	}
	if (!changed) {
		contextCache.add(context);
		visited.put(context, context);
		return context;
	}
	var updated = null;
	if (parents.length === 0) {
		updated = PredictionContext.EMPTY;
	} else if (parents.length === 1) {
		updated = SingletonPredictionContext.create(parents[0], context
				.getReturnState(0));
	} else {
		updated = new ArrayPredictionContext(parents, context.returnStates);
	}
	contextCache.add(updated);
	visited.put(updated, updated);
	visited.put(context, updated);

	return updated;
}

// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
	if (nodes === null) {
		nodes = [];
		return getAllContextNodes(context, nodes, visited);
	} else if (visited === null) {
		visited = new Map();
		return getAllContextNodes(context, nodes, visited);
	} else {
		if (context === null || visited.containsKey(context)) {
			return nodes;
		}
		visited.put(context, context);
		nodes.push(context);
		for (var i = 0; i < context.length; i++) {
			getAllContextNodes(context.getParent(i), nodes, visited);
		}
		return nodes;
	}
}

exports.merge = merge;
exports.PredictionContext = PredictionContext;
exports.PredictionContextCache = PredictionContextCache;
exports.SingletonPredictionContext = SingletonPredictionContext;
exports.predictionContextFromRuleContext = predictionContextFromRuleContext;
exports.getCachedPredictionContext = getCachedPredictionContext;


/***/ }),

/***/ "./node_modules/antlr4/Recognizer.js":
/*!*******************************************!*\
  !*** ./node_modules/antlr4/Recognizer.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
var ConsoleErrorListener = __webpack_require__(/*! ./error/ErrorListener */ "./node_modules/antlr4/error/ErrorListener.js").ConsoleErrorListener;
var ProxyErrorListener = __webpack_require__(/*! ./error/ErrorListener */ "./node_modules/antlr4/error/ErrorListener.js").ProxyErrorListener;

function Recognizer() {
    this._listeners = [ ConsoleErrorListener.INSTANCE ];
    this._interp = null;
    this._stateNumber = -1;
    return this;
}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};


Recognizer.prototype.checkVersion = function(toolVersion) {
    var runtimeVersion = "4.8";
    if (runtimeVersion!==toolVersion) {
        console.log("ANTLR runtime and generated code versions disagree: "+runtimeVersion+"!="+toolVersion);
    }
};

Recognizer.prototype.addErrorListener = function(listener) {
    this._listeners.push(listener);
};

Recognizer.prototype.removeErrorListeners = function() {
    this._listeners = [];
};

Recognizer.prototype.getTokenTypeMap = function() {
    var tokenNames = this.getTokenNames();
    if (tokenNames===null) {
        throw("The current recognizer does not provide a list of token names.");
    }
    var result = this.tokenTypeMapCache[tokenNames];
    if(result===undefined) {
        result = tokenNames.reduce(function(o, k, i) { o[k] = i; });
        result.EOF = Token.EOF;
        this.tokenTypeMapCache[tokenNames] = result;
    }
    return result;
};

// Get a map from rule names to rule indexes.
//
// <p>Used for XPath and tree pattern compilation.</p>
//
Recognizer.prototype.getRuleIndexMap = function() {
    var ruleNames = this.ruleNames;
    if (ruleNames===null) {
        throw("The current recognizer does not provide a list of rule names.");
    }
    var result = this.ruleIndexMapCache[ruleNames];
    if(result===undefined) {
        result = ruleNames.reduce(function(o, k, i) { o[k] = i; });
        this.ruleIndexMapCache[ruleNames] = result;
    }
    return result;
};

Recognizer.prototype.getTokenType = function(tokenName) {
    var ttype = this.getTokenTypeMap()[tokenName];
    if (ttype !==undefined) {
        return ttype;
    } else {
        return Token.INVALID_TYPE;
    }
};


// What is the error header, normally line/character position information?//
Recognizer.prototype.getErrorHeader = function(e) {
    var line = e.getOffendingToken().line;
    var column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
};


// How should a token be displayed in an error message? The default
//  is to display just the text, but during development you might
//  want to have a lot of information spit out.  Override in that case
//  to use t.toString() (which, for CommonToken, dumps everything about
//  the token). This is better than forcing you to override a method in
//  your token objects because you don't have to go modify your lexer
//  so that it creates a new Java type.
//
// @deprecated This method is not called by the ANTLR 4 Runtime. Specific
// implementations of {@link ANTLRErrorStrategy} may provide a similar
// feature when necessary. For example, see
// {@link DefaultErrorStrategy//getTokenErrorDisplay}.
//
Recognizer.prototype.getTokenErrorDisplay = function(t) {
    if (t===null) {
        return "<no token>";
    }
    var s = t.text;
    if (s===null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    s = s.replace("\n","\\n").replace("\r","\\r").replace("\t","\\t");
    return "'" + s + "'";
};

Recognizer.prototype.getErrorListenerDispatch = function() {
    return new ProxyErrorListener(this._listeners);
};

// subclass needs to override these if there are sempreds or actions
// that the ATN interp needs to execute
Recognizer.prototype.sempred = function(localctx, ruleIndex, actionIndex) {
    return true;
};

Recognizer.prototype.precpred = function(localctx , precedence) {
    return true;
};

//Indicate that the recognizer has changed internal state that is
//consistent with the ATN state passed in.  This way we always know
//where we are in the ATN as the parser goes along. The rule
//context objects form a stack that lets us see the stack of
//invoking rules. Combine this and we have complete ATN
//configuration information.

Object.defineProperty(Recognizer.prototype, "state", {
	get : function() {
		return this._stateNumber;
	},
	set : function(state) {
		this._stateNumber = state;
	}
});


exports.Recognizer = Recognizer;


/***/ }),

/***/ "./node_modules/antlr4/RuleContext.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/RuleContext.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

//  A rule context is a record of a single rule invocation. It knows
//  which context invoked it, if any. If there is no parent context, then
//  naturally the invoking state is not valid.  The parent link
//  provides a chain upwards from the current rule invocation to the root
//  of the invocation tree, forming a stack. We actually carry no
//  information about the rule associated with this context (except
//  when parsing). We keep only the state number of the invoking state from
//  the ATN submachine that invoked this. Contrast this with the s
//  pointer inside ParserRuleContext that tracks the current state
//  being "executed" for the current rule.
//
//  The parent contexts are useful for computing lookahead sets and
//  getting error information.
//
//  These objects are used during parsing and prediction.
//  For the special case of parsers, we use the subclass
//  ParserRuleContext.
//
//  @see ParserRuleContext
///

var RuleNode = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js").RuleNode;
var INVALID_INTERVAL = __webpack_require__(/*! ./tree/Tree */ "./node_modules/antlr4/tree/Tree.js").INVALID_INTERVAL;
var INVALID_ALT_NUMBER = __webpack_require__(/*! ./atn/ATN */ "./node_modules/antlr4/atn/ATN.js").INVALID_ALT_NUMBER;

function RuleContext(parent, invokingState) {
	RuleNode.call(this);
	// What context invoked this rule?
	this.parentCtx = parent || null;
	// What state invoked the rule associated with this context?
	// The "return address" is the followState of invokingState
	// If parent is null, this should be -1.
	this.invokingState = invokingState || -1;
	return this;
}

RuleContext.prototype = Object.create(RuleNode.prototype);
RuleContext.prototype.constructor = RuleContext;

RuleContext.prototype.depth = function() {
	var n = 0;
	var p = this;
	while (p !== null) {
		p = p.parentCtx;
		n += 1;
	}
	return n;
};

// A context is empty if there is no invoking state; meaning nobody call
// current context.
RuleContext.prototype.isEmpty = function() {
	return this.invokingState === -1;
};

// satisfy the ParseTree / SyntaxTree interface

RuleContext.prototype.getSourceInterval = function() {
	return INVALID_INTERVAL;
};

RuleContext.prototype.getRuleContext = function() {
	return this;
};

RuleContext.prototype.getPayload = function() {
	return this;
};

// Return the combined text of all child nodes. This method only considers
// tokens which have been added to the parse tree.
// <p>
// Since tokens on hidden channels (e.g. whitespace or comments) are not
// added to the parse trees, they will not appear in the output of this
// method.
// /
RuleContext.prototype.getText = function() {
	if (this.getChildCount() === 0) {
		return "";
	} else {
		return this.children.map(function(child) {
			return child.getText();
		}).join("");
	}
};

// For rule associated with this parse tree internal node, return
// the outer alternative number used to match the input. Default
// implementation does not compute nor store this alt num. Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
// to set it.
RuleContext.prototype.getAltNumber = function() { return INVALID_ALT_NUMBER; }

// Set the outer alternative number for this context node. Default
// implementation does nothing to avoid backing field overhead for
// trees that don't need it.  Create
// a subclass of ParserRuleContext with backing field and set
// option contextSuperClass.
RuleContext.prototype.setAltNumber = function(altNumber) { }

RuleContext.prototype.getChild = function(i) {
	return null;
};

RuleContext.prototype.getChildCount = function() {
	return 0;
};

RuleContext.prototype.accept = function(visitor) {
	return visitor.visitChildren(this);
};

//need to manage circular dependencies, so export now
exports.RuleContext = RuleContext;
var Trees = __webpack_require__(/*! ./tree/Trees */ "./node_modules/antlr4/tree/Trees.js").Trees;


// Print out a whole tree, not just a node, in LISP format
// (root child1 .. childN). Print just a node if this is a leaf.
//

RuleContext.prototype.toStringTree = function(ruleNames, recog) {
	return Trees.toStringTree(this, ruleNames, recog);
};

RuleContext.prototype.toString = function(ruleNames, stop) {
	ruleNames = ruleNames || null;
	stop = stop || null;
	var p = this;
	var s = "[";
	while (p !== null && p !== stop) {
		if (ruleNames === null) {
			if (!p.isEmpty()) {
				s += p.invokingState;
			}
		} else {
			var ri = p.ruleIndex;
			var ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
					: "" + ri;
			s += ruleName;
		}
		if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
			s += " ";
		}
		p = p.parentCtx;
	}
	s += "]";
	return s;
};



/***/ }),

/***/ "./node_modules/antlr4/Token.js":
/*!**************************************!*\
  !*** ./node_modules/antlr4/Token.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A token has properties: text, type, line, character position in the line
// (so we can ignore tabs), token channel, index, and source from which
// we obtained this token.

function Token() {
	this.source = null;
	this.type = null; // token type of the token
	this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
	this.start = null; // optional; return -1 if not implemented.
	this.stop = null; // optional; return -1 if not implemented.
	this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
	this.line = null; // line=1..n of the 1st character
	this.column = null; // beginning of the line at which it occurs, 0..n-1
	this._text = null; // text of the token.
	return this;
}

Token.INVALID_TYPE = 0;

// During lookahead operations, this "token" signifies we hit rule end ATN state
// and did not follow it despite needing to.
Token.EPSILON = -2;

Token.MIN_USER_TOKEN_TYPE = 1;

Token.EOF = -1;

// All tokens go to the parser (unless skip() is called in that rule)
// on a particular "channel". The parser tunes to a particular channel
// so that whitespace etc... can go to the parser on a "hidden" channel.

Token.DEFAULT_CHANNEL = 0;

// Anything on different channel than DEFAULT_CHANNEL is not parsed
// by parser.

Token.HIDDEN_CHANNEL = 1;

// Explicitly set the text for this token. If {code text} is not
// {@code null}, then {@link //getText} will return this value rather than
// extracting the text from the input.
//
// @param text The explicit text of the token, or {@code null} if the text
// should be obtained from the input along with the start and stop indexes
// of the token.

Object.defineProperty(Token.prototype, "text", {
	get : function() {
		return this._text;
	},
	set : function(text) {
		this._text = text;
	}
});

Token.prototype.getTokenSource = function() {
	return this.source[0];
};

Token.prototype.getInputStream = function() {
	return this.source[1];
};

function CommonToken(source, type, channel, start, stop) {
	Token.call(this);
	this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
	this.type = type !== undefined ? type : null;
	this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
	this.start = start !== undefined ? start : -1;
	this.stop = stop !== undefined ? stop : -1;
	this.tokenIndex = -1;
	if (this.source[0] !== null) {
		this.line = source[0].line;
		this.column = source[0].column;
	} else {
		this.column = -1;
	}
	return this;
}

CommonToken.prototype = Object.create(Token.prototype);
CommonToken.prototype.constructor = CommonToken;

// An empty {@link Pair} which is used as the default value of
// {@link //source} for tokens that do not have a source.
CommonToken.EMPTY_SOURCE = [ null, null ];

// Constructs a new {@link CommonToken} as a copy of another {@link Token}.
//
// <p>
// If {@code oldToken} is also a {@link CommonToken} instance, the newly
// constructed token will share a reference to the {@link //text} field and
// the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
// be assigned the result of calling {@link //getText}, and {@link //source}
// will be constructed from the result of {@link Token//getTokenSource} and
// {@link Token//getInputStream}.</p>
//
// @param oldToken The token to copy.
//
CommonToken.prototype.clone = function() {
	var t = new CommonToken(this.source, this.type, this.channel, this.start,
			this.stop);
	t.tokenIndex = this.tokenIndex;
	t.line = this.line;
	t.column = this.column;
	t.text = this.text;
	return t;
};

Object.defineProperty(CommonToken.prototype, "text", {
	get : function() {
		if (this._text !== null) {
			return this._text;
		}
		var input = this.getInputStream();
		if (input === null) {
			return null;
		}
		var n = input.size;
		if (this.start < n && this.stop < n) {
			return input.getText(this.start, this.stop);
		} else {
			return "<EOF>";
		}
	},
	set : function(text) {
		this._text = text;
	}
});

CommonToken.prototype.toString = function() {
	var txt = this.text;
	if (txt !== null) {
		txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
	} else {
		txt = "<no text>";
	}
	return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
			txt + "',<" + this.type + ">" +
			(this.channel > 0 ? ",channel=" + this.channel : "") + "," +
			this.line + ":" + this.column + "]";
};

exports.Token = Token;
exports.CommonToken = CommonToken;


/***/ }),

/***/ "./node_modules/antlr4/Utils.js":
/*!**************************************!*\
  !*** ./node_modules/antlr4/Utils.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function arrayToString(a) {
    return "[" + a.join(", ") + "]";
}

String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));

String.prototype.hashCode = function () {
    var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i,
        key = this.toString();

    remainder = key.length & 3; // key.length % 4
    bytes = key.length - remainder;
    h1 = String.prototype.seed;
    c1 = 0xcc9e2d51;
    c2 = 0x1b873593;
    i = 0;

    while (i < bytes) {
        k1 =
            ((key.charCodeAt(i) & 0xff)) |
            ((key.charCodeAt(++i) & 0xff) << 8) |
            ((key.charCodeAt(++i) & 0xff) << 16) |
            ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;

        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }

    k1 = 0;

    switch (remainder) {
        case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
            k1 ^= (key.charCodeAt(i) & 0xff);

            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
    }

    h1 ^= key.length;

    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;

    return h1 >>> 0;
};

function standardEqualsFunction(a, b) {
    return a.equals(b);
}

function standardHashCodeFunction(a) {
    return a.hashCode();
}

function Set(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Set.prototype, "length", {
    get: function () {
        var l = 0;
        for (var key in this.data) {
            if (key.indexOf("hash_") === 0) {
                l = l + this.data[key].length;
            }
        }
        return l;
    }
});

Set.prototype.add = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
        values.push(value);
        return value;
    } else {
        this.data[key] = [value];
        return value;
    }
};

Set.prototype.contains = function (value) {
    return this.get(value) != null;
};

Set.prototype.get = function (value) {
    var hash = this.hashFunction(value);
    var key = "hash_" + hash;
    if (key in this.data) {
        var values = this.data[key];
        for (var i = 0; i < values.length; i++) {
            if (this.equalsFunction(value, values[i])) {
                return values[i];
            }
        }
    }
    return null;
};

Set.prototype.values = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};

Set.prototype.toString = function () {
    return arrayToString(this.values());
};

function BitSet() {
    this.data = [];
    return this;
}

BitSet.prototype.add = function (value) {
    this.data[value] = true;
};

BitSet.prototype.or = function (set) {
    var bits = this;
    Object.keys(set.data).map(function (alt) {
        bits.add(alt);
    });
};

BitSet.prototype.remove = function (value) {
    delete this.data[value];
};

BitSet.prototype.contains = function (value) {
    return this.data[value] === true;
};

BitSet.prototype.values = function () {
    return Object.keys(this.data);
};

BitSet.prototype.minValue = function () {
    return Math.min.apply(null, this.values());
};

BitSet.prototype.hashCode = function () {
    var hash = new Hash();
    hash.update(this.values());
    return hash.finish();
};

BitSet.prototype.equals = function (other) {
    if (!(other instanceof BitSet)) {
        return false;
    }
    return this.hashCode() === other.hashCode();
};

Object.defineProperty(BitSet.prototype, "length", {
    get: function () {
        return this.values().length;
    }
});

BitSet.prototype.toString = function () {
    return "{" + this.values().join(", ") + "}";
};

function Map(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
    return this;
}

Object.defineProperty(Map.prototype, "length", {
    get: function () {
        var l = 0;
        for (var hashKey in this.data) {
            if (hashKey.indexOf("hash_") === 0) {
                l = l + this.data[hashKey].length;
            }
        }
        return l;
    }
});

Map.prototype.put = function (key, value) {
    var hashKey = "hash_" + this.hashFunction(key);
    if (hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key)) {
                var oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
        }
        entries.push({key:key, value:value});
        return value;
    } else {
        this.data[hashKey] = [{key:key, value:value}];
        return value;
    }
};

Map.prototype.containsKey = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return true;
        }
    }
    return false;
};

Map.prototype.get = function (key) {
    var hashKey = "hash_" + this.hashFunction(key);
    if(hashKey in this.data) {
        var entries = this.data[hashKey];
        for (var i = 0; i < entries.length; i++) {
            var entry = entries[i];
            if (this.equalsFunction(key, entry.key))
                return entry.value;
        }
    }
    return null;
};

Map.prototype.entries = function () {
    var l = [];
    for (var key in this.data) {
        if (key.indexOf("hash_") === 0) {
            l = l.concat(this.data[key]);
        }
    }
    return l;
};


Map.prototype.getKeys = function () {
    return this.entries().map(function(e) {
        return e.key;
    });
};


Map.prototype.getValues = function () {
    return this.entries().map(function(e) {
            return e.value;
    });
};


Map.prototype.toString = function () {
    var ss = this.entries().map(function(entry) {
        return '{' + entry.key + ':' + entry.value + '}';
    });
    return '[' + ss.join(", ") + ']';
};


function AltDict() {
    this.data = {};
    return this;
}


AltDict.prototype.get = function (key) {
    key = "k-" + key;
    if (key in this.data) {
        return this.data[key];
    } else {
        return null;
    }
};

AltDict.prototype.put = function (key, value) {
    key = "k-" + key;
    this.data[key] = value;
};

AltDict.prototype.values = function () {
    var data = this.data;
    var keys = Object.keys(this.data);
    return keys.map(function (key) {
        return data[key];
    });
};

function DoubleDict(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || Map;
    this.cacheMap = new this.defaultMapCtor();
    return this;
}

function Hash() {
    this.count = 0;
    this.hash = 0;
    return this;
}

Hash.prototype.update = function () {
    for(var i=0;i<arguments.length;i++) {
        var value = arguments[i];
        if (value == null)
            continue;
        if(Array.isArray(value))
            this.update.apply(this, value);
        else {
            var k = 0;
            switch (typeof(value)) {
                case 'undefined':
                case 'function':
                    continue;
                case 'number':
                case 'boolean':
                    k = value;
                    break;
                case 'string':
                    k = value.hashCode();
                    break;
                default:
                    if(value.updateHashCode)
                        value.updateHashCode(this);
                    else
                        console.log("No updateHashCode for " + value.toString())
                    continue;
            }
            k = k * 0xCC9E2D51;
            k = (k << 15) | (k >>> (32 - 15));
            k = k * 0x1B873593;
            this.count = this.count + 1;
            var hash = this.hash ^ k;
            hash = (hash << 13) | (hash >>> (32 - 13));
            hash = hash * 5 + 0xE6546B64;
            this.hash = hash;
        }
    }
};

Hash.prototype.finish = function () {
    var hash = this.hash ^ (this.count * 4);
    hash = hash ^ (hash >>> 16);
    hash = hash * 0x85EBCA6B;
    hash = hash ^ (hash >>> 13);
    hash = hash * 0xC2B2AE35;
    hash = hash ^ (hash >>> 16);
    return hash;
};

function hashStuff() {
    var hash = new Hash();
    hash.update.apply(hash, arguments);
    return hash.finish();
}

DoubleDict.prototype.get = function (a, b) {
    var d = this.cacheMap.get(a) || null;
    return d === null ? null : (d.get(b) || null);
};

DoubleDict.prototype.set = function (a, b, o) {
    var d = this.cacheMap.get(a) || null;
    if (d === null) {
        d = new this.defaultMapCtor();
        this.cacheMap.put(a, d);
    }
    d.put(b, o);
};


function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t")
         .replace(/\n/g, "\\n")
         .replace(/\r/g, "\\r");
    if (escapeSpaces) {
        s = s.replace(/ /g, "\u00B7");
    }
    return s;
}

function titleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1);
    });
};

function equalArrays(a, b)
{
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a == b)
        return true;
    if (a.length != b.length)
        return false;
    for (var i = 0; i < a.length; i++) {
        if (a[i] == b[i])
            continue;
        if (!a[i].equals(b[i]))
            return false;
    }
    return true;
};

exports.Hash = Hash;
exports.Set = Set;
exports.Map = Map;
exports.BitSet = BitSet;
exports.AltDict = AltDict;
exports.DoubleDict = DoubleDict;
exports.hashStuff = hashStuff;
exports.escapeWhitespace = escapeWhitespace;
exports.arrayToString = arrayToString;
exports.titleCase = titleCase;
exports.equalArrays = equalArrays;


/***/ }),

/***/ "./node_modules/antlr4/atn/ATN.js":
/*!****************************************!*\
  !*** ./node_modules/antlr4/atn/ATN.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var LL1Analyzer = __webpack_require__(/*! ./../LL1Analyzer */ "./node_modules/antlr4/LL1Analyzer.js").LL1Analyzer;
var IntervalSet = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").IntervalSet;

function ATN(grammarType , maxTokenType) {

    // Used for runtime deserialization of ATNs from strings///
    // The type of the ATN.
    this.grammarType = grammarType;
    // The maximum value for any symbol recognized by a transition in the ATN.
    this.maxTokenType = maxTokenType;
    this.states = [];
    // Each subrule/rule is a decision point and we must track them so we
    //  can go back later and build DFA predictors for them.  This includes
    //  all the rules, subrules, optional blocks, ()+, ()* etc...
    this.decisionToState = [];
    // Maps from rule index to starting state number.
    this.ruleToStartState = [];
    // Maps from rule index to stop state number.
    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    // For lexer ATNs, this maps the rule index to the resulting token type.
    // For parser ATNs, this maps the rule index to the generated bypass token
    // type if the
    // {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
    // deserialization option was specified; otherwise, this is {@code null}.
    this.ruleToTokenType = null;
    // For lexer ATNs, this is an array of {@link LexerAction} objects which may
    // be referenced by action transitions in the ATN.
    this.lexerActions = null;
    this.modeToStartState = [];

    return this;
}

// Compute the set of valid tokens that can occur starting in state {@code s}.
//  If {@code ctx} is null, the set of tokens will not include what can follow
//  the rule surrounding {@code s}. In other words, the set will be
//  restricted to tokens reachable staying within {@code s}'s rule.
ATN.prototype.nextTokensInContext = function(s, ctx) {
    var anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
};

// Compute the set of valid tokens that can occur starting in {@code s} and
// staying in same rule. {@link Token//EPSILON} is in set if we reach end of
// rule.
ATN.prototype.nextTokensNoContext = function(s) {
    if (s.nextTokenWithinRule !== null ) {
        return s.nextTokenWithinRule;
    }
    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
};

ATN.prototype.nextTokens = function(s, ctx) {
    if ( ctx===undefined ) {
        return this.nextTokensNoContext(s);
    } else {
        return this.nextTokensInContext(s, ctx);
    }
};

ATN.prototype.addState = function( state) {
    if ( state !== null ) {
        state.atn = this;
        state.stateNumber = this.states.length;
    }
    this.states.push(state);
};

ATN.prototype.removeState = function( state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
};

ATN.prototype.defineDecisionState = function( s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length-1;
    return s.decision;
};

ATN.prototype.getDecisionState = function( decision) {
    if (this.decisionToState.length===0) {
        return null;
    } else {
        return this.decisionToState[decision];
    }
};

// Computes the set of input symbols which could follow ATN state number
// {@code stateNumber} in the specified full {@code context}. This method
// considers the complete parser context, but does not evaluate semantic
// predicates (i.e. all predicates encountered during the calculation are
// assumed true). If a path in the ATN exists from the starting state to the
// {@link RuleStopState} of the outermost context without matching any
// symbols, {@link Token//EOF} is added to the returned set.
//
// <p>If {@code context} is {@code null}, it is treated as
// {@link ParserRuleContext//EMPTY}.</p>
//
// @param stateNumber the ATN state number
// @param context the full parse context
// @return The set of potentially valid input symbols which could follow the
// specified state in the specified context.
// @throws IllegalArgumentException if the ATN does not contain a state with
// number {@code stateNumber}
var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;

ATN.prototype.getExpectedTokens = function( stateNumber, ctx ) {
    if ( stateNumber < 0 || stateNumber >= this.states.length ) {
        throw("Invalid state number.");
    }
    var s = this.states[stateNumber];
    var following = this.nextTokens(s);
    if (!following.contains(Token.EPSILON)) {
        return following;
    }
    var expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);
    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
        var invokingState = this.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        following = this.nextTokens(rt.followState);
        expected.addSet(following);
        expected.removeOne(Token.EPSILON);
        ctx = ctx.parentCtx;
    }
    if (following.contains(Token.EPSILON)) {
        expected.addOne(Token.EOF);
    }
    return expected;
};

ATN.INVALID_ALT_NUMBER = 0;

exports.ATN = ATN;

/***/ }),

/***/ "./node_modules/antlr4/atn/ATNConfig.js":
/*!**********************************************!*\
  !*** ./node_modules/antlr4/atn/ATNConfig.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// A tuple: (ATN state, predicted alt, syntactic, semantic context).
//  The syntactic context is a graph-structured stack node whose
//  path(s) to the root is the rule invocation(s)
//  chain used to arrive at the state.  The semantic context is
//  the tree of semantic predicates encountered before reaching
//  an ATN state.
///

var DecisionState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").DecisionState;
var SemanticContext = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").SemanticContext;
var Hash = __webpack_require__(/*! ../Utils */ "./node_modules/antlr4/Utils.js").Hash;


function checkParams(params, isCfg) {
	if(params===null) {
		var result = { state:null, alt:null, context:null, semanticContext:null };
		if(isCfg) {
			result.reachesIntoOuterContext = 0;
		}
		return result;
	} else {
		var props = {};
		props.state = params.state || null;
		props.alt = (params.alt === undefined) ? null : params.alt;
		props.context = params.context || null;
		props.semanticContext = params.semanticContext || null;
		if(isCfg) {
			props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
			props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
		}
		return props;
	}
}

function ATNConfig(params, config) {
	this.checkContext(params, config);
	params = checkParams(params);
	config = checkParams(config, true);
    // The ATN state associated with this configuration///
    this.state = params.state!==null ? params.state : config.state;
    // What alt (or lexer rule) is predicted by this configuration///
    this.alt = params.alt!==null ? params.alt : config.alt;
    // The stack of invoking states leading to the rule/states associated
    //  with this config.  We track only those contexts pushed during
    //  execution of the ATN simulator.
    this.context = params.context!==null ? params.context : config.context;
    this.semanticContext = params.semanticContext!==null ? params.semanticContext :
        (config.semanticContext!==null ? config.semanticContext : SemanticContext.NONE);
    // We cannot execute predicates dependent upon local context unless
    // we know for sure we are in the correct context. Because there is
    // no way to do this efficiently, we simply cannot evaluate
    // dependent predicates unless we are in the rule that initially
    // invokes the ATN simulator.
    //
    // closure() tracks the depth of how far we dip into the
    // outer context: depth &gt; 0.  Note that it may not be totally
    // accurate depth since I don't ever decrement. TODO: make it a boolean then
    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    return this;
}

ATNConfig.prototype.checkContext = function(params, config) {
	if((params.context===null || params.context===undefined) &&
			(config===null || config.context===null || config.context===undefined)) {
		this.context = null;
	}
};


ATNConfig.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};


ATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
};

// An ATN configuration is equal to another if both have
//  the same state, they predict the same alternative, and
//  syntactic/semantic contexts are the same.

ATNConfig.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            (this.context===null ? other.context===null : this.context.equals(other.context)) &&
            this.semanticContext.equals(other.semanticContext) &&
            this.precedenceFilterSuppressed===other.precedenceFilterSuppressed;
    }
};


ATNConfig.prototype.hashCodeForConfigSet = function() {
    var hash = new Hash();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
};


ATNConfig.prototype.equalsForConfigSet = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof ATNConfig)) {
        return false;
    } else {
        return this.state.stateNumber===other.state.stateNumber &&
            this.alt===other.alt &&
            this.semanticContext.equals(other.semanticContext);
    }
};


ATNConfig.prototype.toString = function() {
    return "(" + this.state + "," + this.alt +
        (this.context!==null ? ",[" + this.context.toString() + "]" : "") +
        (this.semanticContext !== SemanticContext.NONE ?
                ("," + this.semanticContext.toString())
                : "") +
        (this.reachesIntoOuterContext>0 ?
                (",up=" + this.reachesIntoOuterContext)
                : "") + ")";
};


function LexerATNConfig(params, config) {
	ATNConfig.call(this, params, config);

    // This is the backing field for {@link //getLexerActionExecutor}.
	var lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config!==null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config!==null ? this.checkNonGreedyDecision(config, this.state) : false;
    return this;
}

LexerATNConfig.prototype = Object.create(ATNConfig.prototype);
LexerATNConfig.prototype.constructor = LexerATNConfig;

LexerATNConfig.prototype.updateHashCode = function(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
};

LexerATNConfig.prototype.equals = function(other) {
    return this === other ||
            (other instanceof LexerATNConfig &&
            this.passedThroughNonGreedyDecision == other.passedThroughNonGreedyDecision &&
            (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&
            ATNConfig.prototype.equals.call(this, other));
};

LexerATNConfig.prototype.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;

LexerATNConfig.prototype.equalsForConfigSet = LexerATNConfig.prototype.equals;


LexerATNConfig.prototype.checkNonGreedyDecision = function(source, target) {
    return source.passedThroughNonGreedyDecision ||
        (target instanceof DecisionState) && target.nonGreedy;
};

exports.ATNConfig = ATNConfig;
exports.LexerATNConfig = LexerATNConfig;

/***/ }),

/***/ "./node_modules/antlr4/atn/ATNConfigSet.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/atn/ATNConfigSet.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

//
// Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
// info about the set, with support for combining similar configurations using a
// graph-structured stack.
///

var ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
var Utils = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js");
var Hash = Utils.Hash;
var Set = Utils.Set;
var SemanticContext = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").SemanticContext;
var merge = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").merge;

function hashATNConfig(c) {
	return c.hashCodeForConfigSet();
}

function equalATNConfigs(a, b) {
	if ( a===b ) {
		return true;
	} else if ( a===null || b===null ) {
		return false;
	} else
       return a.equalsForConfigSet(b);
 }


function ATNConfigSet(fullCtx) {
	//
	// The reason that we need this is because we don't want the hash map to use
	// the standard hash code and equals. We need all configurations with the
	// same
	// {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
	// doubles
	// the number of objects associated with ATNConfigs. The other solution is
	// to
	// use a hash table that lets us specify the equals/hashcode operation.
	// All configs but hashed by (s, i, _, pi) not including context. Wiped out
	// when we go readonly as this set becomes a DFA state.
	this.configLookup = new Set(hashATNConfig, equalATNConfigs);
	// Indicates that this configuration set is part of a full context
	// LL prediction. It will be used to determine how to merge $. With SLL
	// it's a wildcard whereas it is not for LL context merge.
	this.fullCtx = fullCtx === undefined ? true : fullCtx;
	// Indicates that the set of configurations is read-only. Do not
	// allow any code to manipulate the set; DFA states will point at
	// the sets and they must not change. This does not protect the other
	// fields; in particular, conflictingAlts is set after
	// we've made this readonly.
	this.readOnly = false;
	// Track the elements as they are added to the set; supports get(i)///
	this.configs = [];

	// TODO: these fields make me pretty uncomfortable but nice to pack up info
	// together, saves recomputation
	// TODO: can we track conflicts as they are added to save scanning configs
	// later?
	this.uniqueAlt = 0;
	this.conflictingAlts = null;

	// Used in parser and lexer. In lexer, it indicates we hit a pred
	// while computing a closure operation. Don't make a DFA state from this.
	this.hasSemanticContext = false;
	this.dipsIntoOuterContext = false;

	this.cachedHashCode = -1;

	return this;
}

// Adding a new config means merging contexts with existing configs for
// {@code (s, i, pi, _)}, where {@code s} is the
// {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
// {@code pi} is the {@link ATNConfig//semanticContext}. We use
// {@code (s,i,pi)} as key.
//
// <p>This method updates {@link //dipsIntoOuterContext} and
// {@link //hasSemanticContext} when necessary.</p>
// /
ATNConfigSet.prototype.add = function(config, mergeCache) {
	if (mergeCache === undefined) {
		mergeCache = null;
	}
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (config.semanticContext !== SemanticContext.NONE) {
		this.hasSemanticContext = true;
	}
	if (config.reachesIntoOuterContext > 0) {
		this.dipsIntoOuterContext = true;
	}
	var existing = this.configLookup.add(config);
	if (existing === config) {
		this.cachedHashCode = -1;
		this.configs.push(config); // track order here
		return true;
	}
	// a previous (s,i,pi,_), merge with it and save result
	var rootIsWildcard = !this.fullCtx;
	var merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
	// no need to check for existing.context, config.context in cache
	// since only way to create new graphs is "call rule" and here. We
	// cache at both places.
	existing.reachesIntoOuterContext = Math.max( existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
	// make sure to preserve the precedence filter suppression during the merge
	if (config.precedenceFilterSuppressed) {
		existing.precedenceFilterSuppressed = true;
	}
	existing.context = merged; // replace context; no need to alt mapping
	return true;
};

ATNConfigSet.prototype.getStates = function() {
	var states = new Set();
	for (var i = 0; i < this.configs.length; i++) {
		states.add(this.configs[i].state);
	}
	return states;
};

ATNConfigSet.prototype.getPredicates = function() {
	var preds = [];
	for (var i = 0; i < this.configs.length; i++) {
		var c = this.configs[i].semanticContext;
		if (c !== SemanticContext.NONE) {
			preds.push(c.semanticContext);
		}
	}
	return preds;
};

Object.defineProperty(ATNConfigSet.prototype, "items", {
	get : function() {
		return this.configs;
	}
});

ATNConfigSet.prototype.optimizeConfigs = function(interpreter) {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	if (this.configLookup.length === 0) {
		return;
	}
	for (var i = 0; i < this.configs.length; i++) {
		var config = this.configs[i];
		config.context = interpreter.getCachedContext(config.context);
	}
};

ATNConfigSet.prototype.addAll = function(coll) {
	for (var i = 0; i < coll.length; i++) {
		this.add(coll[i]);
	}
	return false;
};

ATNConfigSet.prototype.equals = function(other) {
	return this === other ||
		(other instanceof ATNConfigSet &&
		Utils.equalArrays(this.configs, other.configs) &&
		this.fullCtx === other.fullCtx &&
		this.uniqueAlt === other.uniqueAlt &&
		this.conflictingAlts === other.conflictingAlts &&
		this.hasSemanticContext === other.hasSemanticContext &&
		this.dipsIntoOuterContext === other.dipsIntoOuterContext);
};

ATNConfigSet.prototype.hashCode = function() {
    var hash = new Hash();
	hash.update(this.configs);
    return hash.finish();
};


ATNConfigSet.prototype.updateHashCode = function(hash) {
	if (this.readOnly) {
		if (this.cachedHashCode === -1) {
            this.cachedHashCode = this.hashCode();
		}
        hash.update(this.cachedHashCode);
	} else {
        hash.update(this.hashCode());
	}
};


Object.defineProperty(ATNConfigSet.prototype, "length", {
	get : function() {
		return this.configs.length;
	}
});

ATNConfigSet.prototype.isEmpty = function() {
	return this.configs.length === 0;
};

ATNConfigSet.prototype.contains = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.contains(item);
};

ATNConfigSet.prototype.containsFast = function(item) {
	if (this.configLookup === null) {
		throw "This method is not implemented for readonly sets.";
	}
	return this.configLookup.containsFast(item);
};

ATNConfigSet.prototype.clear = function() {
	if (this.readOnly) {
		throw "This set is readonly";
	}
	this.configs = [];
	this.cachedHashCode = -1;
	this.configLookup = new Set();
};

ATNConfigSet.prototype.setReadonly = function(readOnly) {
	this.readOnly = readOnly;
	if (readOnly) {
		this.configLookup = null; // can't mod, no need for lookup cache
	}
};

ATNConfigSet.prototype.toString = function() {
	return Utils.arrayToString(this.configs) +
		(this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
		(this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
		(this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
		(this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
};

function OrderedATNConfigSet() {
	ATNConfigSet.call(this);
	this.configLookup = new Set();
	return this;
}

OrderedATNConfigSet.prototype = Object.create(ATNConfigSet.prototype);
OrderedATNConfigSet.prototype.constructor = OrderedATNConfigSet;

exports.ATNConfigSet = ATNConfigSet;
exports.OrderedATNConfigSet = OrderedATNConfigSet;


/***/ }),

/***/ "./node_modules/antlr4/atn/ATNDeserializationOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/antlr4/atn/ATNDeserializationOptions.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

function ATNDeserializationOptions(copyFrom) {
	if(copyFrom===undefined) {
		copyFrom = null;
	}
	this.readOnly = false;
    this.verifyATN = copyFrom===null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom===null ? false : copyFrom.generateRuleBypassTransitions;

    return this;
}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;

//    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

exports.ATNDeserializationOptions = ATNDeserializationOptions;


/***/ }),

/***/ "./node_modules/antlr4/atn/ATNDeserializer.js":
/*!****************************************************!*\
  !*** ./node_modules/antlr4/atn/ATNDeserializer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
var ATNType = __webpack_require__(/*! ./ATNType */ "./node_modules/antlr4/atn/ATNType.js").ATNType;
var ATNStates = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js");
var ATNState = ATNStates.ATNState;
var BasicState = ATNStates.BasicState;
var DecisionState = ATNStates.DecisionState;
var BlockStartState = ATNStates.BlockStartState;
var BlockEndState = ATNStates.BlockEndState;
var LoopEndState = ATNStates.LoopEndState;
var RuleStartState = ATNStates.RuleStartState;
var RuleStopState = ATNStates.RuleStopState;
var TokensStartState = ATNStates.TokensStartState;
var PlusLoopbackState = ATNStates.PlusLoopbackState;
var StarLoopbackState = ATNStates.StarLoopbackState;
var StarLoopEntryState = ATNStates.StarLoopEntryState;
var PlusBlockStartState = ATNStates.PlusBlockStartState;
var StarBlockStartState = ATNStates.StarBlockStartState;
var BasicBlockStartState = ATNStates.BasicBlockStartState;
var Transitions = __webpack_require__(/*! ./Transition */ "./node_modules/antlr4/atn/Transition.js");
var Transition = Transitions.Transition;
var AtomTransition = Transitions.AtomTransition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var RangeTransition = Transitions.RangeTransition;
var ActionTransition = Transitions.ActionTransition;
var EpsilonTransition = Transitions.EpsilonTransition;
var WildcardTransition = Transitions.WildcardTransition;
var PredicateTransition = Transitions.PredicateTransition;
var PrecedencePredicateTransition = Transitions.PrecedencePredicateTransition;
var IntervalSet = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").IntervalSet;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var ATNDeserializationOptions = __webpack_require__(/*! ./ATNDeserializationOptions */ "./node_modules/antlr4/atn/ATNDeserializationOptions.js").ATNDeserializationOptions;
var LexerActions = __webpack_require__(/*! ./LexerAction */ "./node_modules/antlr4/atn/LexerAction.js");
var LexerActionType = LexerActions.LexerActionType;
var LexerSkipAction = LexerActions.LexerSkipAction;
var LexerChannelAction = LexerActions.LexerChannelAction;
var LexerCustomAction = LexerActions.LexerCustomAction;
var LexerMoreAction = LexerActions.LexerMoreAction;
var LexerTypeAction = LexerActions.LexerTypeAction;
var LexerPushModeAction = LexerActions.LexerPushModeAction;
var LexerPopModeAction = LexerActions.LexerPopModeAction;
var LexerModeAction = LexerActions.LexerModeAction;
// This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance
var BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E";

//
// This UUID indicates the serialized ATN contains two sets of
// IntervalSets, where the second set's values are encoded as
// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
//
var ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089";

// This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.
var SUPPORTED_UUIDS = [ BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP ];

var SERIALIZED_VERSION = 3;

// This is the current serialized UUID.
var SERIALIZED_UUID = ADDED_UNICODE_SMP;

function initArray( length, value) {
	var tmp = [];
	tmp[length-1] = value;
	return tmp.map(function(i) {return value;});
}

function ATNDeserializer (options) {

    if ( options=== undefined || options === null ) {
        options = ATNDeserializationOptions.defaultOptions;
    }
    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;

    return this;
}

// Determines if a particular serialized representation of an ATN supports
// a particular feature, identified by the {@link UUID} used for serializing
// the ATN at the time the feature was first introduced.
//
// @param feature The {@link UUID} marking the first time the feature was
// supported in the serialized ATN.
// @param actualUuid The {@link UUID} of the actual serialized ATN which is
// currently being deserialized.
// @return {@code true} if the {@code actualUuid} value represents a
// serialized ATN at or after the feature identified by {@code feature} was
// introduced; otherwise, {@code false}.

ATNDeserializer.prototype.isFeatureSupported = function(feature, actualUuid) {
    var idx1 = SUPPORTED_UUIDS.indexOf(feature);
    if (idx1<0) {
        return false;
    }
    var idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
    return idx2 >= idx1;
};

ATNDeserializer.prototype.deserialize = function(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    var atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    var sets = [];
    // First, deserialize sets with 16-bit arguments <= U+FFFF.
    this.readSets(atn, sets, this.readInt.bind(this));
    // Next, if the ATN was serialized with the Unicode SMP feature,
    // deserialize sets with 32-bit arguments <= U+10FFFF.
    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
        this.readSets(atn, sets, this.readInt32.bind(this));
    }
    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);
    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER ) {
        this.generateRuleBypassTransitions(atn);
        // re-verify after modification
        this.verifyATN(atn);
    }
    return atn;
};

ATNDeserializer.prototype.reset = function(data) {
	var adjust = function(c) {
        var v = c.charCodeAt(0);
        return v>1  ? v-2 : v + 65534;
	};
    var temp = data.split("").map(adjust);
    // don't adjust the first value since that's the version number
    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
};

ATNDeserializer.prototype.checkVersion = function() {
    var version = this.readInt();
    if ( version !== SERIALIZED_VERSION ) {
        throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
    }
};

ATNDeserializer.prototype.checkUUID = function() {
    var uuid = this.readUUID();
    if (SUPPORTED_UUIDS.indexOf(uuid)<0) {
        throw ("Could not deserialize ATN with UUID: " + uuid +
                        " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID);
    }
    this.uuid = uuid;
};

ATNDeserializer.prototype.readATN = function() {
    var grammarType = this.readInt();
    var maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
};

ATNDeserializer.prototype.readStates = function(atn) {
	var j, pair, stateNumber;
    var loopBackStateNumbers = [];
    var endStateNumbers = [];
    var nstates = this.readInt();
    for(var i=0; i<nstates; i++) {
        var stype = this.readInt();
        // ignore bad type of states
        if (stype===ATNState.INVALID_TYPE) {
            atn.addState(null);
            continue;
        }
        var ruleIndex = this.readInt();
        if (ruleIndex === 0xFFFF) {
            ruleIndex = -1;
        }
        var s = this.stateFactory(stype, ruleIndex);
        if (stype === ATNState.LOOP_END) { // special case
            var loopBackStateNumber = this.readInt();
            loopBackStateNumbers.push([s, loopBackStateNumber]);
        } else if(s instanceof BlockStartState) {
            var endStateNumber = this.readInt();
            endStateNumbers.push([s, endStateNumber]);
        }
        atn.addState(s);
    }
    // delay the assignment of loop back and end states until we know all the
	// state instances have been initialized
    for (j=0; j<loopBackStateNumbers.length; j++) {
        pair = loopBackStateNumbers[j];
        pair[0].loopBackState = atn.states[pair[1]];
    }

    for (j=0; j<endStateNumbers.length; j++) {
        pair = endStateNumbers[j];
        pair[0].endState = atn.states[pair[1]];
    }

    var numNonGreedyStates = this.readInt();
    for (j=0; j<numNonGreedyStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].nonGreedy = true;
    }

    var numPrecedenceStates = this.readInt();
    for (j=0; j<numPrecedenceStates; j++) {
        stateNumber = this.readInt();
        atn.states[stateNumber].isPrecedenceRule = true;
    }
};

ATNDeserializer.prototype.readRules = function(atn) {
    var i;
    var nrules = this.readInt();
    if (atn.grammarType === ATNType.LEXER ) {
        atn.ruleToTokenType = initArray(nrules, 0);
    }
    atn.ruleToStartState = initArray(nrules, 0);
    for (i=0; i<nrules; i++) {
        var s = this.readInt();
        var startState = atn.states[s];
        atn.ruleToStartState[i] = startState;
        if ( atn.grammarType === ATNType.LEXER ) {
            var tokenType = this.readInt();
            if (tokenType === 0xFFFF) {
                tokenType = Token.EOF;
            }
            atn.ruleToTokenType[i] = tokenType;
        }
    }
    atn.ruleToStopState = initArray(nrules, 0);
    for (i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (!(state instanceof RuleStopState)) {
            continue;
        }
        atn.ruleToStopState[state.ruleIndex] = state;
        atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
};

ATNDeserializer.prototype.readModes = function(atn) {
    var nmodes = this.readInt();
    for (var i=0; i<nmodes; i++) {
        var s = this.readInt();
        atn.modeToStartState.push(atn.states[s]);
    }
};

ATNDeserializer.prototype.readSets = function(atn, sets, readUnicode) {
    var m = this.readInt();
    for (var i=0; i<m; i++) {
        var iset = new IntervalSet();
        sets.push(iset);
        var n = this.readInt();
        var containsEof = this.readInt();
        if (containsEof!==0) {
            iset.addOne(-1);
        }
        for (var j=0; j<n; j++) {
            var i1 = readUnicode();
            var i2 = readUnicode();
            iset.addRange(i1, i2);
        }
    }
};

ATNDeserializer.prototype.readEdges = function(atn, sets) {
	var i, j, state, trans, target;
    var nedges = this.readInt();
    for (i=0; i<nedges; i++) {
        var src = this.readInt();
        var trg = this.readInt();
        var ttype = this.readInt();
        var arg1 = this.readInt();
        var arg2 = this.readInt();
        var arg3 = this.readInt();
        trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
        var srcState = atn.states[src];
        srcState.addTransition(trans);
    }
    // edges for rule stop states can be derived, so they aren't serialized
    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for (j=0; j<state.transitions.length; j++) {
            var t = state.transitions[j];
            if (!(t instanceof RuleTransition)) {
                continue;
            }
			var outermostPrecedenceReturn = -1;
			if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
				if (t.precedence === 0) {
					outermostPrecedenceReturn = t.target.ruleIndex;
				}
			}

			trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
            atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
        }
    }

    for (i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        if (state instanceof BlockStartState) {
            // we need to know the end state to set its start state
            if (state.endState === null) {
                throw ("IllegalState");
            }
            // block end states can only be associated to a single block start
			// state
            if ( state.endState.startState !== null) {
                throw ("IllegalState");
            }
            state.endState.startState = state;
        }
        if (state instanceof PlusLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof PlusBlockStartState) {
                    target.loopBackState = state;
                }
            }
        } else if (state instanceof StarLoopbackState) {
            for (j=0; j<state.transitions.length; j++) {
                target = state.transitions[j].target;
                if (target instanceof StarLoopEntryState) {
                    target.loopBackState = state;
                }
            }
        }
    }
};

ATNDeserializer.prototype.readDecisions = function(atn) {
    var ndecisions = this.readInt();
    for (var i=0; i<ndecisions; i++) {
        var s = this.readInt();
        var decState = atn.states[s];
        atn.decisionToState.push(decState);
        decState.decision = i;
    }
};

ATNDeserializer.prototype.readLexerActions = function(atn) {
    if (atn.grammarType === ATNType.LEXER) {
        var count = this.readInt();
        atn.lexerActions = initArray(count, null);
        for (var i=0; i<count; i++) {
            var actionType = this.readInt();
            var data1 = this.readInt();
            if (data1 === 0xFFFF) {
                data1 = -1;
            }
            var data2 = this.readInt();
            if (data2 === 0xFFFF) {
                data2 = -1;
            }
            var lexerAction = this.lexerActionFactory(actionType, data1, data2);
            atn.lexerActions[i] = lexerAction;
        }
    }
};

ATNDeserializer.prototype.generateRuleBypassTransitions = function(atn) {
	var i;
    var count = atn.ruleToStartState.length;
    for(i=0; i<count; i++) {
        atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }
    for(i=0; i<count; i++) {
        this.generateRuleBypassTransition(atn, i);
    }
};

ATNDeserializer.prototype.generateRuleBypassTransition = function(atn, idx) {
	var i, state;
    var bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);

    var bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);

    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);

    bypassStop.startState = bypassStart;

    var excludeTransition = null;
    var endState = null;

    if (atn.ruleToStartState[idx].isPrecedenceRule) {
        // wrap from the beginning of the rule to the StarLoopEntryState
        endState = null;
        for(i=0; i<atn.states.length; i++) {
            state = atn.states[i];
            if (this.stateIsEndStateFor(state, idx)) {
                endState = state;
                excludeTransition = state.loopBackState.transitions[0];
                break;
            }
        }
        if (excludeTransition === null) {
            throw ("Couldn't identify final state of the precedence rule prefix section.");
        }
    } else {
        endState = atn.ruleToStopState[idx];
    }

    // all non-excluded transitions that currently target end state need to
	// target blockEnd instead
    for(i=0; i<atn.states.length; i++) {
        state = atn.states[i];
        for(var j=0; j<state.transitions.length; j++) {
            var transition = state.transitions[j];
            if (transition === excludeTransition) {
                continue;
            }
            if (transition.target === endState) {
                transition.target = bypassStop;
            }
        }
    }

    // all transitions leaving the rule start state need to leave blockStart
	// instead
    var ruleToStartState = atn.ruleToStartState[idx];
    var count = ruleToStartState.transitions.length;
    while ( count > 0) {
        bypassStart.addTransition(ruleToStartState.transitions[count-1]);
        ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    }
    // link the new states
    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));

    var matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
};

ATNDeserializer.prototype.stateIsEndStateFor = function(state, idx) {
    if ( state.ruleIndex !== idx) {
        return null;
    }
    if (!( state instanceof StarLoopEntryState)) {
        return null;
    }
    var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
    if (!( maybeLoopEndState instanceof LoopEndState)) {
        return null;
    }
    if (maybeLoopEndState.epsilonOnlyTransitions &&
        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
        return state;
    } else {
        return null;
    }
};

//
// Analyze the {@link StarLoopEntryState} states in the specified ATN to set
// the {@link StarLoopEntryState//isPrecedenceDecision} field to the
// correct value.
//
// @param atn The ATN.
//
ATNDeserializer.prototype.markPrecedenceDecisions = function(atn) {
	for(var i=0; i<atn.states.length; i++) {
		var state = atn.states[i];
		if (!( state instanceof StarLoopEntryState)) {
            continue;
        }
        // We analyze the ATN to determine if this ATN decision state is the
        // decision for the closure block that determines whether a
        // precedence rule should continue or complete.
        //
        if ( atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
            var maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
            if (maybeLoopEndState instanceof LoopEndState) {
                if ( maybeLoopEndState.epsilonOnlyTransitions &&
                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState)) {
                    state.isPrecedenceDecision = true;
                }
            }
        }
	}
};

ATNDeserializer.prototype.verifyATN = function(atn) {
    if (!this.deserializationOptions.verifyATN) {
        return;
    }
    // verify assumptions
	for(var i=0; i<atn.states.length; i++) {
        var state = atn.states[i];
        if (state === null) {
            continue;
        }
        this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
        if (state instanceof PlusBlockStartState) {
            this.checkCondition(state.loopBackState !== null);
        } else  if (state instanceof StarLoopEntryState) {
            this.checkCondition(state.loopBackState !== null);
            this.checkCondition(state.transitions.length === 2);
            if (state.transitions[0].target instanceof StarBlockStartState) {
                this.checkCondition(state.transitions[1].target instanceof LoopEndState);
                this.checkCondition(!state.nonGreedy);
            } else if (state.transitions[0].target instanceof LoopEndState) {
                this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
                this.checkCondition(state.nonGreedy);
            } else {
                throw("IllegalState");
            }
        } else if (state instanceof StarLoopbackState) {
            this.checkCondition(state.transitions.length === 1);
            this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
        } else if (state instanceof LoopEndState) {
            this.checkCondition(state.loopBackState !== null);
        } else if (state instanceof RuleStartState) {
            this.checkCondition(state.stopState !== null);
        } else if (state instanceof BlockStartState) {
            this.checkCondition(state.endState !== null);
        } else if (state instanceof BlockEndState) {
            this.checkCondition(state.startState !== null);
        } else if (state instanceof DecisionState) {
            this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
        } else {
            this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState));
        }
	}
};

ATNDeserializer.prototype.checkCondition = function(condition, message) {
    if (!condition) {
        if (message === undefined || message===null) {
            message = "IllegalState";
        }
        throw (message);
    }
};

ATNDeserializer.prototype.readInt = function() {
    return this.data[this.pos++];
};

ATNDeserializer.prototype.readInt32 = function() {
    var low = this.readInt();
    var high = this.readInt();
    return low | (high << 16);
};

ATNDeserializer.prototype.readLong = function() {
    var low = this.readInt32();
    var high = this.readInt32();
    return (low & 0x00000000FFFFFFFF) | (high << 32);
};

function createByteToHex() {
	var bth = [];
	for (var i = 0; i < 256; i++) {
		bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
	}
	return bth;
}

var byteToHex = createByteToHex();

ATNDeserializer.prototype.readUUID = function() {
	var bb = [];
	for(var i=7;i>=0;i--) {
		var int = this.readInt();
		/* jshint bitwise: false */
		bb[(2*i)+1] = int & 0xFF;
		bb[2*i] = (int >> 8) & 0xFF;
	}
    return byteToHex[bb[0]] + byteToHex[bb[1]] +
    byteToHex[bb[2]] + byteToHex[bb[3]] + '-' +
    byteToHex[bb[4]] + byteToHex[bb[5]] + '-' +
    byteToHex[bb[6]] + byteToHex[bb[7]] + '-' +
    byteToHex[bb[8]] + byteToHex[bb[9]] + '-' +
    byteToHex[bb[10]] + byteToHex[bb[11]] +
    byteToHex[bb[12]] + byteToHex[bb[13]] +
    byteToHex[bb[14]] + byteToHex[bb[15]];
};

ATNDeserializer.prototype.edgeFactory = function(atn, type, src, trg, arg1, arg2, arg3, sets) {
    var target = atn.states[trg];
    switch(type) {
    case Transition.EPSILON:
        return new EpsilonTransition(target);
    case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);
    case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);
    case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);
    case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);
    case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);
    case Transition.SET:
        return new SetTransition(target, sets[arg1]);
    case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);
    case Transition.WILDCARD:
        return new WildcardTransition(target);
    default:
        throw "The specified transition type: " + type + " is not valid.";
    }
};

ATNDeserializer.prototype.stateFactory = function(type, ruleIndex) {
    if (this.stateFactories === null) {
        var sf = [];
        sf[ATNState.INVALID_TYPE] = null;
        sf[ATNState.BASIC] = function() { return new BasicState(); };
        sf[ATNState.RULE_START] = function() { return new RuleStartState(); };
        sf[ATNState.BLOCK_START] = function() { return new BasicBlockStartState(); };
        sf[ATNState.PLUS_BLOCK_START] = function() { return new PlusBlockStartState(); };
        sf[ATNState.STAR_BLOCK_START] = function() { return new StarBlockStartState(); };
        sf[ATNState.TOKEN_START] = function() { return new TokensStartState(); };
        sf[ATNState.RULE_STOP] = function() { return new RuleStopState(); };
        sf[ATNState.BLOCK_END] = function() { return new BlockEndState(); };
        sf[ATNState.STAR_LOOP_BACK] = function() { return new StarLoopbackState(); };
        sf[ATNState.STAR_LOOP_ENTRY] = function() { return new StarLoopEntryState(); };
        sf[ATNState.PLUS_LOOP_BACK] = function() { return new PlusLoopbackState(); };
        sf[ATNState.LOOP_END] = function() { return new LoopEndState(); };
        this.stateFactories = sf;
    }
    if (type>this.stateFactories.length || this.stateFactories[type] === null) {
        throw("The specified state type " + type + " is not valid.");
    } else {
        var s = this.stateFactories[type]();
        if (s!==null) {
            s.ruleIndex = ruleIndex;
            return s;
        }
    }
};

ATNDeserializer.prototype.lexerActionFactory = function(type, data1, data2) {
    if (this.actionFactories === null) {
        var af = [];
        af[LexerActionType.CHANNEL] = function(data1, data2) { return new LexerChannelAction(data1); };
        af[LexerActionType.CUSTOM] = function(data1, data2) { return new LexerCustomAction(data1, data2); };
        af[LexerActionType.MODE] = function(data1, data2) { return new LexerModeAction(data1); };
        af[LexerActionType.MORE] = function(data1, data2) { return LexerMoreAction.INSTANCE; };
        af[LexerActionType.POP_MODE] = function(data1, data2) { return LexerPopModeAction.INSTANCE; };
        af[LexerActionType.PUSH_MODE] = function(data1, data2) { return new LexerPushModeAction(data1); };
        af[LexerActionType.SKIP] = function(data1, data2) { return LexerSkipAction.INSTANCE; };
        af[LexerActionType.TYPE] = function(data1, data2) { return new LexerTypeAction(data1); };
        this.actionFactories = af;
    }
    if (type>this.actionFactories.length || this.actionFactories[type] === null) {
        throw("The specified lexer action type " + type + " is not valid.");
    } else {
        return this.actionFactories[type](data1, data2);
    }
};


exports.ATNDeserializer = ATNDeserializer;

/***/ }),

/***/ "./node_modules/antlr4/atn/ATNSimulator.js":
/*!*************************************************!*\
  !*** ./node_modules/antlr4/atn/ATNSimulator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var DFAState = __webpack_require__(/*! ./../dfa/DFAState */ "./node_modules/antlr4/dfa/DFAState.js").DFAState;
var ATNConfigSet = __webpack_require__(/*! ./ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var getCachedPredictionContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").getCachedPredictionContext;
var Map = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").Map;

function ATNSimulator(atn, sharedContextCache) {

    // The context cache maps all PredictionContext objects that are ==
    //  to a single cached copy. This cache is shared across all contexts
    //  in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
    //  to use only cached nodes/graphs in addDFAState(). We don't want to
    //  fill this during closure() since there are lots of contexts that
    //  pop up but are not used ever again. It also greatly slows down closure().
    //
    //  <p>This cache makes a huge difference in memory and a little bit in speed.
    //  For the Java grammar on java.*, it dropped the memory requirements
    //  at the end from 25M to 16M. We don't store any of the full context
    //  graphs in the DFA because they are limited to local context only,
    //  but apparently there's a lot of repetition there as well. We optimize
    //  the config contexts before storing the config set in the DFA states
    //  by literally rebuilding them with cached subgraphs only.</p>
    //
    //  <p>I tried a cache for use during closure operations, that was
    //  whacked after each adaptivePredict(). It cost a little bit
    //  more time I think and doesn't save on the overall footprint
    //  so it's not worth the complexity.</p>
    ///
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
}

// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());


ATNSimulator.prototype.getCachedContext = function(context) {
    if (this.sharedContextCache ===null) {
        return context;
    }
    var visited = new Map();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
};

exports.ATNSimulator = ATNSimulator;


/***/ }),

/***/ "./node_modules/antlr4/atn/ATNState.js":
/*!*********************************************!*\
  !*** ./node_modules/antlr4/atn/ATNState.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// The following images show the relation of states and
// {@link ATNState//transitions} for various grammar constructs.
//
// <ul>
//
// <li>Solid edges marked with an &//0949; indicate a required
// {@link EpsilonTransition}.</li>
//
// <li>Dashed edges indicate locations where any transition derived from
// {@link Transition} might appear.</li>
//
// <li>Dashed nodes are place holders for either a sequence of linked
// {@link BasicState} states or the inclusion of a block representing a nested
// construct in one of the forms below.</li>
//
// <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
// any number of alternatives (one or more). Nodes without the {@code ...} only
// support the exact number of alternatives shown in the diagram.</li>
//
// </ul>
//
// <h2>Basic Blocks</h2>
//
// <h3>Rule</h3>
//
// <embed src="images/Rule.svg" type="image/svg+xml"/>
//
// <h3>Block of 1 or more alternatives</h3>
//
// <embed src="images/Block.svg" type="image/svg+xml"/>
//
// <h2>Greedy Loops</h2>
//
// <h3>Greedy Closure: {@code (...)*}</h3>
//
// <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Positive Closure: {@code (...)+}</h3>
//
// <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
//
// <h3>Greedy Optional: {@code (...)?}</h3>
//
// <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
//
// <h2>Non-Greedy Loops</h2>
//
// <h3>Non-Greedy Closure: {@code (...)*?}</h3>
//
// <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
//
// <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
//
// <h3>Non-Greedy Optional: {@code (...)??}</h3>
//
// <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
//

var INITIAL_NUM_TRANSITIONS = 4;

function ATNState() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects
    this.epsilonOnlyTransitions = false;
    // Track the transitions emanating from this ATN state.
    this.transitions = [];
    // Used to cache lookahead during parsing, not used during construction
    this.nextTokenWithinRule = null;
    return this;
}

// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;

ATNState.serializationNames = [
            "INVALID",
            "BASIC",
            "RULE_START",
            "BLOCK_START",
            "PLUS_BLOCK_START",
            "STAR_BLOCK_START",
            "TOKEN_START",
            "RULE_STOP",
            "BLOCK_END",
            "STAR_LOOP_BACK",
            "STAR_LOOP_ENTRY",
            "PLUS_LOOP_BACK",
            "LOOP_END" ];

ATNState.INVALID_STATE_NUMBER = -1;

ATNState.prototype.toString = function() {
	return this.stateNumber;
};

ATNState.prototype.equals = function(other) {
    if (other instanceof ATNState) {
        return this.stateNumber===other.stateNumber;
    } else {
        return false;
    }
};

ATNState.prototype.isNonGreedyExitState = function() {
    return false;
};


ATNState.prototype.addTransition = function(trans, index) {
	if(index===undefined) {
		index = -1;
	}
    if (this.transitions.length===0) {
        this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if(this.epsilonOnlyTransitions !== trans.isEpsilon) {
        this.epsilonOnlyTransitions = false;
    }
    if (index===-1) {
        this.transitions.push(trans);
    } else {
        this.transitions.splice(index, 1, trans);
    }
};

function BasicState() {
	ATNState.call(this);
    this.stateType = ATNState.BASIC;
    return this;
}

BasicState.prototype = Object.create(ATNState.prototype);
BasicState.prototype.constructor = BasicState;


function DecisionState() {
	ATNState.call(this);
    this.decision = -1;
    this.nonGreedy = false;
    return this;
}

DecisionState.prototype = Object.create(ATNState.prototype);
DecisionState.prototype.constructor = DecisionState;


//  The start of a regular {@code (...)} block.
function BlockStartState() {
	DecisionState.call(this);
	this.endState = null;
	return this;
}

BlockStartState.prototype = Object.create(DecisionState.prototype);
BlockStartState.prototype.constructor = BlockStartState;


function BasicBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.BLOCK_START;
	return this;
}

BasicBlockStartState.prototype = Object.create(BlockStartState.prototype);
BasicBlockStartState.prototype.constructor = BasicBlockStartState;


// Terminal node of a simple {@code (a|b|c)} block.
function BlockEndState() {
	ATNState.call(this);
	this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
}

BlockEndState.prototype = Object.create(ATNState.prototype);
BlockEndState.prototype.constructor = BlockEndState;


// The last node in the ATN for a rule, unless that rule is the start symbol.
//  In that case, there is one transition to EOF. Later, we might encode
//  references to all calls to this rule to compute FOLLOW sets for
//  error handling.
//
function RuleStopState() {
	ATNState.call(this);
    this.stateType = ATNState.RULE_STOP;
    return this;
}

RuleStopState.prototype = Object.create(ATNState.prototype);
RuleStopState.prototype.constructor = RuleStopState;

function RuleStartState() {
	ATNState.call(this);
	this.stateType = ATNState.RULE_START;
	this.stopState = null;
	this.isPrecedenceRule = false;
	return this;
}

RuleStartState.prototype = Object.create(ATNState.prototype);
RuleStartState.prototype.constructor = RuleStartState;

// Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
//  one to the loop back to start of the block and one to exit.
//
function PlusLoopbackState() {
	DecisionState.call(this);
	this.stateType = ATNState.PLUS_LOOP_BACK;
	return this;
}

PlusLoopbackState.prototype = Object.create(DecisionState.prototype);
PlusLoopbackState.prototype.constructor = PlusLoopbackState;


// Start of {@code (A|B|...)+} loop. Technically a decision state, but
//  we don't use for code generation; somebody might need it, so I'm defining
//  it for completeness. In reality, the {@link PlusLoopbackState} node is the
//  real decision-making note for {@code A+}.
//
function PlusBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
}

PlusBlockStartState.prototype = Object.create(BlockStartState.prototype);
PlusBlockStartState.prototype.constructor = PlusBlockStartState;

// The block that begins a closure loop.
function StarBlockStartState() {
	BlockStartState.call(this);
	this.stateType = ATNState.STAR_BLOCK_START;
	return this;
}

StarBlockStartState.prototype = Object.create(BlockStartState.prototype);
StarBlockStartState.prototype.constructor = StarBlockStartState;


function StarLoopbackState() {
	ATNState.call(this);
	this.stateType = ATNState.STAR_LOOP_BACK;
	return this;
}

StarLoopbackState.prototype = Object.create(ATNState.prototype);
StarLoopbackState.prototype.constructor = StarLoopbackState;


function StarLoopEntryState() {
	DecisionState.call(this);
	this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null;
    // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
    this.isPrecedenceDecision = null;
    return this;
}

StarLoopEntryState.prototype = Object.create(DecisionState.prototype);
StarLoopEntryState.prototype.constructor = StarLoopEntryState;


// Mark the end of a * or + loop.
function LoopEndState() {
	ATNState.call(this);
	this.stateType = ATNState.LOOP_END;
	this.loopBackState = null;
	return this;
}

LoopEndState.prototype = Object.create(ATNState.prototype);
LoopEndState.prototype.constructor = LoopEndState;


// The Tokens rule start state linking to each lexer rule start state */
function TokensStartState() {
	DecisionState.call(this);
	this.stateType = ATNState.TOKEN_START;
	return this;
}

TokensStartState.prototype = Object.create(DecisionState.prototype);
TokensStartState.prototype.constructor = TokensStartState;

exports.ATNState = ATNState;
exports.BasicState = BasicState;
exports.DecisionState = DecisionState;
exports.BlockStartState = BlockStartState;
exports.BlockEndState = BlockEndState;
exports.LoopEndState = LoopEndState;
exports.RuleStartState = RuleStartState;
exports.RuleStopState = RuleStopState;
exports.TokensStartState = TokensStartState;
exports.PlusLoopbackState = PlusLoopbackState;
exports.StarLoopbackState = StarLoopbackState;
exports.StarLoopEntryState = StarLoopEntryState;
exports.PlusBlockStartState = PlusBlockStartState;
exports.StarBlockStartState = StarBlockStartState;
exports.BasicBlockStartState = BasicBlockStartState;


/***/ }),

/***/ "./node_modules/antlr4/atn/ATNType.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/atn/ATNType.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents the type of recognizer an ATN applies to.

function ATNType() {

}

ATNType.LEXER = 0;
ATNType.PARSER = 1;

exports.ATNType = ATNType;



/***/ }),

/***/ "./node_modules/antlr4/atn/LexerATNSimulator.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/atn/LexerATNSimulator.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// When we hit an accept state in either the DFA or the ATN, we
//  have to notify the character stream to start buffering characters
//  via {@link IntStream//mark} and record the current state. The current sim state
//  includes the current index into the input, the current line,
//  and current character position in that line. Note that the Lexer is
//  tracking the starting line and characterization of the token. These
//  variables track the "state" of the simulator when it hits an accept state.
//
//  <p>We track these variables separately for the DFA and ATN simulation
//  because the DFA simulation often has to fail over to the ATN
//  simulation. If the ATN simulation fails, we need the DFA to fall
//  back to its previously accepted state, if any. If the ATN succeeds,
//  then the ATN does the accept and the DFA simulator that invoked it
//  can simply return the predicted token type.</p>
///

var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var Lexer = __webpack_require__(/*! ./../Lexer */ "./node_modules/antlr4/Lexer.js").Lexer;
var ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
var ATNSimulator = __webpack_require__(/*! ./ATNSimulator */ "./node_modules/antlr4/atn/ATNSimulator.js").ATNSimulator;
var DFAState = __webpack_require__(/*! ./../dfa/DFAState */ "./node_modules/antlr4/dfa/DFAState.js").DFAState;
var ATNConfigSet = __webpack_require__(/*! ./ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var OrderedATNConfigSet = __webpack_require__(/*! ./ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").OrderedATNConfigSet;
var PredictionContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").PredictionContext;
var SingletonPredictionContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").SingletonPredictionContext;
var RuleStopState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").RuleStopState;
var LexerATNConfig = __webpack_require__(/*! ./ATNConfig */ "./node_modules/antlr4/atn/ATNConfig.js").LexerATNConfig;
var Transition = __webpack_require__(/*! ./Transition */ "./node_modules/antlr4/atn/Transition.js").Transition;
var LexerActionExecutor = __webpack_require__(/*! ./LexerActionExecutor */ "./node_modules/antlr4/atn/LexerActionExecutor.js").LexerActionExecutor;
var LexerNoViableAltException = __webpack_require__(/*! ./../error/Errors */ "./node_modules/antlr4/error/Errors.js").LexerNoViableAltException;

function resetSimState(sim) {
	sim.index = -1;
	sim.line = 0;
	sim.column = -1;
	sim.dfaState = null;
}

function SimState() {
	resetSimState(this);
	return this;
}

SimState.prototype.reset = function() {
	resetSimState(this);
};

function LexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
	this.decisionToDFA = decisionToDFA;
	this.recog = recog;
	// The current token's starting index into the character stream.
	// Shared across DFA to ATN simulation in case the ATN fails and the
	// DFA did not have a previous accept state. In this case, we use the
	// ATN-generated exception object.
	this.startIndex = -1;
	// line number 1..n within the input///
	this.line = 1;
	// The index of the character relative to the beginning of the line
	// 0..n-1///
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
	// Used during DFA/ATN exec to record the most recent accept configuration
	// info
	this.prevAccept = new SimState();
	// done
	return this;
}

LexerATNSimulator.prototype = Object.create(ATNSimulator.prototype);
LexerATNSimulator.prototype.constructor = LexerATNSimulator;

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;

LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;

LexerATNSimulator.prototype.copyState = function(simulator) {
	this.column = simulator.column;
	this.line = simulator.line;
	this.mode = simulator.mode;
	this.startIndex = simulator.startIndex;
};

LexerATNSimulator.prototype.match = function(input, mode) {
	this.match_calls += 1;
	this.mode = mode;
	var mark = input.mark();
	try {
		this.startIndex = input.index;
		this.prevAccept.reset();
		var dfa = this.decisionToDFA[mode];
		if (dfa.s0 === null) {
			return this.matchATN(input);
		} else {
			return this.execATN(input, dfa.s0);
		}
	} finally {
		input.release(mark);
	}
};

LexerATNSimulator.prototype.reset = function() {
	this.prevAccept.reset();
	this.startIndex = -1;
	this.line = 1;
	this.column = 0;
	this.mode = Lexer.DEFAULT_MODE;
};

LexerATNSimulator.prototype.matchATN = function(input) {
	var startState = this.atn.modeToStartState[this.mode];

	if (LexerATNSimulator.debug) {
		console.log("matchATN mode " + this.mode + " start: " + startState);
	}
	var old_mode = this.mode;
	var s0_closure = this.computeStartState(input, startState);
	var suppressEdge = s0_closure.hasSemanticContext;
	s0_closure.hasSemanticContext = false;

	var next = this.addDFAState(s0_closure);
	if (!suppressEdge) {
		this.decisionToDFA[this.mode].s0 = next;
	}

	var predict = this.execATN(input, next);

	if (LexerATNSimulator.debug) {
		console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
	}
	return predict;
};

LexerATNSimulator.prototype.execATN = function(input, ds0) {
	if (LexerATNSimulator.debug) {
		console.log("start state closure=" + ds0.configs);
	}
	if (ds0.isAcceptState) {
		// allow zero-length tokens
		this.captureSimState(this.prevAccept, input, ds0);
	}
	var t = input.LA(1);
	var s = ds0; // s is current/from DFA state

	while (true) { // while more work
		if (LexerATNSimulator.debug) {
			console.log("execATN loop starting closure: " + s.configs);
		}

		// As we move src->trg, src->trg, we keep track of the previous trg to
		// avoid looking up the DFA state again, which is expensive.
		// If the previous target was already part of the DFA, we might
		// be able to avoid doing a reach operation upon t. If s!=null,
		// it means that semantic predicates didn't prevent us from
		// creating a DFA state. Once we know s!=null, we check to see if
		// the DFA state has an edge already for t. If so, we can just reuse
		// it's configuration set; there's no point in re-computing it.
		// This is kind of like doing DFA simulation within the ATN
		// simulation because DFA simulation is really just a way to avoid
		// computing reach/closure sets. Technically, once we know that
		// we have a previously added DFA state, we could jump over to
		// the DFA simulator. But, that would mean popping back and forth
		// a lot and making things more complicated algorithmically.
		// This optimization makes a lot of sense for loops within DFA.
		// A character will take us back to an existing DFA state
		// that already has lots of edges out of it. e.g., .* in comments.
		// print("Target for:" + str(s) + " and:" + str(t))
		var target = this.getExistingTargetState(s, t);
		// print("Existing:" + str(target))
		if (target === null) {
			target = this.computeTargetState(input, s, t);
			// print("Computed:" + str(target))
		}
		if (target === ATNSimulator.ERROR) {
			break;
		}
		// If this is a consumable input element, make sure to consume before
		// capturing the accept state so the input index, line, and char
		// position accurately reflect the state of the interpreter at the
		// end of the token.
		if (t !== Token.EOF) {
			this.consume(input);
		}
		if (target.isAcceptState) {
			this.captureSimState(this.prevAccept, input, target);
			if (t === Token.EOF) {
				break;
			}
		}
		t = input.LA(1);
		s = target; // flip; current DFA target becomes new src/from state
	}
	return this.failOrAccept(this.prevAccept, input, s.configs, t);
};

// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param s The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
LexerATNSimulator.prototype.getExistingTargetState = function(s, t) {
	if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
		return null;
	}

	var target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
	if(target===undefined) {
		target = null;
	}
	if (LexerATNSimulator.debug && target !== null) {
		console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
	}
	return target;
};

// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param input The input stream
// @param s The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
LexerATNSimulator.prototype.computeTargetState = function(input, s, t) {
	var reach = new OrderedATNConfigSet();
	// if we don't find an existing DFA state
	// Fill reach starting from closure, following t transitions
	this.getReachableConfigSet(input, s.configs, reach, t);

	if (reach.items.length === 0) { // we got nowhere on t from s
		if (!reach.hasSemanticContext) {
			// we got nowhere on t, don't throw out this knowledge; it'd
			// cause a failover from DFA later.
			this.addDFAEdge(s, t, ATNSimulator.ERROR);
		}
		// stop when we can't match any more char
		return ATNSimulator.ERROR;
	}
	// Add an edge from s to target DFA found/created for reach
	return this.addDFAEdge(s, t, null, reach);
};

LexerATNSimulator.prototype.failOrAccept = function(prevAccept, input, reach, t) {
	if (this.prevAccept.dfaState !== null) {
		var lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
		this.accept(input, lexerActionExecutor, this.startIndex,
				prevAccept.index, prevAccept.line, prevAccept.column);
		return prevAccept.dfaState.prediction;
	} else {
		// if no accept and EOF is first char, return EOF
		if (t === Token.EOF && input.index === this.startIndex) {
			return Token.EOF;
		}
		throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
	}
};

// Given a starting configuration set, figure out all ATN configurations
// we can reach upon input {@code t}. Parameter {@code reach} is a return
// parameter.
LexerATNSimulator.prototype.getReachableConfigSet = function(input, closure,
		reach, t) {
	// this is used to skip processing for configs which have a lower priority
	// than a config that already reached an accept state for the same rule
	var skipAlt = ATN.INVALID_ALT_NUMBER;
	for (var i = 0; i < closure.items.length; i++) {
		var cfg = closure.items[i];
		var currentAltReachedAcceptState = (cfg.alt === skipAlt);
		if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
			continue;
		}
		if (LexerATNSimulator.debug) {
			console.log("testing %s at %s\n", this.getTokenName(t), cfg
					.toString(this.recog, true));
		}
		for (var j = 0; j < cfg.state.transitions.length; j++) {
			var trans = cfg.state.transitions[j]; // for each transition
			var target = this.getReachableTarget(trans, t);
			if (target !== null) {
				var lexerActionExecutor = cfg.lexerActionExecutor;
				if (lexerActionExecutor !== null) {
					lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
				}
				var treatEofAsEpsilon = (t === Token.EOF);
				var config = new LexerATNConfig({state:target, lexerActionExecutor:lexerActionExecutor}, cfg);
				if (this.closure(input, config, reach,
						currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
					// any remaining configs for this alt have a lower priority
					// than the one that just reached an accept state.
					skipAlt = cfg.alt;
				}
			}
		}
	}
};

LexerATNSimulator.prototype.accept = function(input, lexerActionExecutor,
		startIndex, index, line, charPos) {
	if (LexerATNSimulator.debug) {
		console.log("ACTION %s\n", lexerActionExecutor);
	}
	// seek to after last char in token
	input.seek(index);
	this.line = line;
	this.column = charPos;
	if (lexerActionExecutor !== null && this.recog !== null) {
		lexerActionExecutor.execute(this.recog, input, startIndex);
	}
};

LexerATNSimulator.prototype.getReachableTarget = function(trans, t) {
	if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
		return trans.target;
	} else {
		return null;
	}
};

LexerATNSimulator.prototype.computeStartState = function(input, p) {
	var initialContext = PredictionContext.EMPTY;
	var configs = new OrderedATNConfigSet();
	for (var i = 0; i < p.transitions.length; i++) {
		var target = p.transitions[i].target;
        var cfg = new LexerATNConfig({state:target, alt:i+1, context:initialContext}, null);
		this.closure(input, cfg, configs, false, false, false);
	}
	return configs;
};

// Since the alternatives within any lexer decision are ordered by
// preference, this method stops pursuing the closure as soon as an accept
// state is reached. After the first accept state is reached by depth-first
// search from {@code config}, all other (potentially reachable) states for
// this rule would have a lower priority.
//
// @return {@code true} if an accept state is reached, otherwise
// {@code false}.
LexerATNSimulator.prototype.closure = function(input, config, configs,
		currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (LexerATNSimulator.debug) {
		console.log("closure(" + config.toString(this.recog, true) + ")");
	}
	if (config.state instanceof RuleStopState) {
		if (LexerATNSimulator.debug) {
			if (this.recog !== null) {
				console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
			} else {
				console.log("closure at rule stop %s\n", config);
			}
		}
		if (config.context === null || config.context.hasEmptyPath()) {
			if (config.context === null || config.context.isEmpty()) {
				configs.add(config);
				return true;
			} else {
				configs.add(new LexerATNConfig({ state:config.state, context:PredictionContext.EMPTY}, config));
				currentAltReachedAcceptState = true;
			}
		}
		if (config.context !== null && !config.context.isEmpty()) {
			for (var i = 0; i < config.context.length; i++) {
				if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
					var newContext = config.context.getParent(i); // "pop" return state
					var returnState = this.atn.states[config.context.getReturnState(i)];
					cfg = new LexerATNConfig({ state:returnState, context:newContext }, config);
					currentAltReachedAcceptState = this.closure(input, cfg,
							configs, currentAltReachedAcceptState, speculative,
							treatEofAsEpsilon);
				}
			}
		}
		return currentAltReachedAcceptState;
	}
	// optimization
	if (!config.state.epsilonOnlyTransitions) {
		if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
			configs.add(config);
		}
	}
	for (var j = 0; j < config.state.transitions.length; j++) {
		var trans = config.state.transitions[j];
		cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
		if (cfg !== null) {
			currentAltReachedAcceptState = this.closure(input, cfg, configs,
					currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
		}
	}
	return currentAltReachedAcceptState;
};

// side-effect: can alter configs.hasSemanticContext
LexerATNSimulator.prototype.getEpsilonTarget = function(input, config, trans,
		configs, speculative, treatEofAsEpsilon) {
	var cfg = null;
	if (trans.serializationType === Transition.RULE) {
		var newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
		cfg = new LexerATNConfig( { state:trans.target, context:newContext}, config);
	} else if (trans.serializationType === Transition.PRECEDENCE) {
		throw "Precedence predicates are not supported in lexers.";
	} else if (trans.serializationType === Transition.PREDICATE) {
		// Track traversing semantic predicates. If we traverse,
		// we cannot add a DFA state for this "reach" computation
		// because the DFA would not test the predicate again in the
		// future. Rather than creating collections of semantic predicates
		// like v3 and testing them on prediction, v4 will test them on the
		// fly all the time using the ATN not the DFA. This is slower but
		// semantically it's not used that often. One of the key elements to
		// this predicate mechanism is not adding DFA states that see
		// predicates immediately afterwards in the ATN. For example,

		// a : ID {p1}? | ID {p2}? ;

		// should create the start state for rule 'a' (to save start state
		// competition), but should not create target of ID state. The
		// collection of ATN states the following ID references includes
		// states reached by traversing predicates. Since this is when we
		// test them, we cannot cash the DFA state target of ID.

		if (LexerATNSimulator.debug) {
			console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
		}
		configs.hasSemanticContext = true;
		if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
			cfg = new LexerATNConfig({ state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.ACTION) {
		if (config.context === null || config.context.hasEmptyPath()) {
			// execute actions anywhere in the start rule for a token.
			//
			// TODO: if the entry rule is invoked recursively, some
			// actions may be executed during the recursive call. The
			// problem can appear when hasEmptyPath() is true but
			// isEmpty() is false. In this case, the config needs to be
			// split into two contexts - one with just the empty path
			// and another with everything but the empty path.
			// Unfortunately, the current algorithm does not allow
			// getEpsilonTarget to return two configurations, so
			// additional modifications are needed before we can support
			// the split operation.
			var lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor,
					this.atn.lexerActions[trans.actionIndex]);
			cfg = new LexerATNConfig({ state:trans.target, lexerActionExecutor:lexerActionExecutor }, config);
		} else {
			// ignore actions in referenced rules
			cfg = new LexerATNConfig( { state:trans.target}, config);
		}
	} else if (trans.serializationType === Transition.EPSILON) {
		cfg = new LexerATNConfig({ state:trans.target}, config);
	} else if (trans.serializationType === Transition.ATOM ||
				trans.serializationType === Transition.RANGE ||
				trans.serializationType === Transition.SET) {
		if (treatEofAsEpsilon) {
			if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
				cfg = new LexerATNConfig( { state:trans.target }, config);
			}
		}
	}
	return cfg;
};

// Evaluate a predicate specified in the lexer.
//
// <p>If {@code speculative} is {@code true}, this method was called before
// {@link //consume} for the matched character. This method should call
// {@link //consume} before evaluating the predicate to ensure position
// sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
// and {@link Lexer//getcolumn}, properly reflect the current
// lexer state. This method should restore {@code input} and the simulator
// to the original state before returning (i.e. undo the actions made by the
// call to {@link //consume}.</p>
//
// @param input The input stream.
// @param ruleIndex The rule containing the predicate.
// @param predIndex The index of the predicate within the rule.
// @param speculative {@code true} if the current index in {@code input} is
// one character before the predicate's location.
//
// @return {@code true} if the specified predicate evaluates to
// {@code true}.
// /
LexerATNSimulator.prototype.evaluatePredicate = function(input, ruleIndex,
		predIndex, speculative) {
	// assume true if no recognizer was provided
	if (this.recog === null) {
		return true;
	}
	if (!speculative) {
		return this.recog.sempred(null, ruleIndex, predIndex);
	}
	var savedcolumn = this.column;
	var savedLine = this.line;
	var index = input.index;
	var marker = input.mark();
	try {
		this.consume(input);
		return this.recog.sempred(null, ruleIndex, predIndex);
	} finally {
		this.column = savedcolumn;
		this.line = savedLine;
		input.seek(index);
		input.release(marker);
	}
};

LexerATNSimulator.prototype.captureSimState = function(settings, input, dfaState) {
	settings.index = input.index;
	settings.line = this.line;
	settings.column = this.column;
	settings.dfaState = dfaState;
};

LexerATNSimulator.prototype.addDFAEdge = function(from_, tk, to, cfgs) {
	if (to === undefined) {
		to = null;
	}
	if (cfgs === undefined) {
		cfgs = null;
	}
	if (to === null && cfgs !== null) {
		// leading to this call, ATNConfigSet.hasSemanticContext is used as a
		// marker indicating dynamic predicate evaluation makes this edge
		// dependent on the specific input sequence, so the static edge in the
		// DFA should be omitted. The target DFAState is still created since
		// execATN has the ability to resynchronize with the DFA state cache
		// following the predicate evaluation step.
		//
		// TJP notes: next time through the DFA, we see a pred again and eval.
		// If that gets us to a previously created (but dangling) DFA
		// state, we can continue in pure DFA mode from there.
		// /
		var suppressEdge = cfgs.hasSemanticContext;
		cfgs.hasSemanticContext = false;

		to = this.addDFAState(cfgs);

		if (suppressEdge) {
			return to;
		}
	}
	// add the edge
	if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
		// Only track edges within the DFA bounds
		return to;
	}
	if (LexerATNSimulator.debug) {
		console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
	}
	if (from_.edges === null) {
		// make room for tokens 1..n and -1 masquerading as index 0
		from_.edges = [];
	}
	from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

	return to;
};

// Add a new DFA state if there isn't one with this set of
// configurations already. This method also detects the first
// configuration containing an ATN rule stop state. Later, when
// traversing the DFA, we will know which rule to accept.
LexerATNSimulator.prototype.addDFAState = function(configs) {
	var proposed = new DFAState(null, configs);
	var firstConfigWithRuleStopState = null;
	for (var i = 0; i < configs.items.length; i++) {
		var cfg = configs.items[i];
		if (cfg.state instanceof RuleStopState) {
			firstConfigWithRuleStopState = cfg;
			break;
		}
	}
	if (firstConfigWithRuleStopState !== null) {
		proposed.isAcceptState = true;
		proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
		proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
	}
	var dfa = this.decisionToDFA[this.mode];
	var existing = dfa.states.get(proposed);
	if (existing!==null) {
		return existing;
	}
	var newState = proposed;
	newState.stateNumber = dfa.states.length;
	configs.setReadonly(true);
	newState.configs = configs;
	dfa.states.add(newState);
	return newState;
};

LexerATNSimulator.prototype.getDFA = function(mode) {
	return this.decisionToDFA[mode];
};

// Get the text matched so far for the current token.
LexerATNSimulator.prototype.getText = function(input) {
	// index is first lookahead char, don't include.
	return input.getText(this.startIndex, input.index - 1);
};

LexerATNSimulator.prototype.consume = function(input) {
	var curChar = input.LA(1);
	if (curChar === "\n".charCodeAt(0)) {
		this.line += 1;
		this.column = 0;
	} else {
		this.column += 1;
	}
	input.consume();
};

LexerATNSimulator.prototype.getTokenName = function(tt) {
	if (tt === -1) {
		return "EOF";
	} else {
		return "'" + String.fromCharCode(tt) + "'";
	}
};

exports.LexerATNSimulator = LexerATNSimulator;


/***/ }),

/***/ "./node_modules/antlr4/atn/LexerAction.js":
/*!************************************************!*\
  !*** ./node_modules/antlr4/atn/LexerAction.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
 //

function LexerActionType() {
}

LexerActionType.CHANNEL = 0;     //The type of a {@link LexerChannelAction} action.
LexerActionType.CUSTOM = 1;      //The type of a {@link LexerCustomAction} action.
LexerActionType.MODE = 2;        //The type of a {@link LexerModeAction} action.
LexerActionType.MORE = 3;        //The type of a {@link LexerMoreAction} action.
LexerActionType.POP_MODE = 4;    //The type of a {@link LexerPopModeAction} action.
LexerActionType.PUSH_MODE = 5;   //The type of a {@link LexerPushModeAction} action.
LexerActionType.SKIP = 6;        //The type of a {@link LexerSkipAction} action.
LexerActionType.TYPE = 7;        //The type of a {@link LexerTypeAction} action.

function LexerAction(action) {
    this.actionType = action;
    this.isPositionDependent = false;
    return this;
}

LexerAction.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish()
};

LexerAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType);
};

LexerAction.prototype.equals = function(other) {
    return this === other;
};



//
// Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
//
// <p>The {@code skip} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerSkipAction() {
	LexerAction.call(this, LexerActionType.SKIP);
	return this;
}

LexerSkipAction.prototype = Object.create(LexerAction.prototype);
LexerSkipAction.prototype.constructor = LexerSkipAction;

// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();

LexerSkipAction.prototype.execute = function(lexer) {
    lexer.skip();
};

LexerSkipAction.prototype.toString = function() {
	return "skip";
};

//  Implements the {@code type} lexer action by calling {@link Lexer//setType}
// with the assigned type.
function LexerTypeAction(type) {
	LexerAction.call(this, LexerActionType.TYPE);
	this.type = type;
	return this;
}

LexerTypeAction.prototype = Object.create(LexerAction.prototype);
LexerTypeAction.prototype.constructor = LexerTypeAction;

LexerTypeAction.prototype.execute = function(lexer) {
    lexer.type = this.type;
};

LexerTypeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.type);
};


LexerTypeAction.prototype.equals = function(other) {
    if(this === other) {
        return true;
    } else if (! (other instanceof LexerTypeAction)) {
        return false;
    } else {
        return this.type === other.type;
    }
};

LexerTypeAction.prototype.toString = function() {
    return "type(" + this.type + ")";
};

// Implements the {@code pushMode} lexer action by calling
// {@link Lexer//pushMode} with the assigned mode.
function LexerPushModeAction(mode) {
	LexerAction.call(this, LexerActionType.PUSH_MODE);
    this.mode = mode;
    return this;
}

LexerPushModeAction.prototype = Object.create(LexerAction.prototype);
LexerPushModeAction.prototype.constructor = LexerPushModeAction;

// <p>This action is implemented by calling {@link Lexer//pushMode} with the
// value provided by {@link //getMode}.</p>
LexerPushModeAction.prototype.execute = function(lexer) {
    lexer.pushMode(this.mode);
};

LexerPushModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerPushModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerPushModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerPushModeAction.prototype.toString = function() {
	return "pushMode(" + this.mode + ")";
};


// Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
//
// <p>The {@code popMode} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerPopModeAction() {
	LexerAction.call(this,LexerActionType.POP_MODE);
	return this;
}

LexerPopModeAction.prototype = Object.create(LexerAction.prototype);
LexerPopModeAction.prototype.constructor = LexerPopModeAction;

LexerPopModeAction.INSTANCE = new LexerPopModeAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerPopModeAction.prototype.execute = function(lexer) {
    lexer.popMode();
};

LexerPopModeAction.prototype.toString = function() {
	return "popMode";
};

// Implements the {@code more} lexer action by calling {@link Lexer//more}.
//
// <p>The {@code more} command does not have any parameters, so this action is
// implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
function LexerMoreAction() {
	LexerAction.call(this, LexerActionType.MORE);
	return this;
}

LexerMoreAction.prototype = Object.create(LexerAction.prototype);
LexerMoreAction.prototype.constructor = LexerMoreAction;

LexerMoreAction.INSTANCE = new LexerMoreAction();

// <p>This action is implemented by calling {@link Lexer//popMode}.</p>
LexerMoreAction.prototype.execute = function(lexer) {
    lexer.more();
};

LexerMoreAction.prototype.toString = function() {
    return "more";
};


// Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
// the assigned mode.
function LexerModeAction(mode) {
	LexerAction.call(this, LexerActionType.MODE);
    this.mode = mode;
    return this;
}

LexerModeAction.prototype = Object.create(LexerAction.prototype);
LexerModeAction.prototype.constructor = LexerModeAction;

// <p>This action is implemented by calling {@link Lexer//mode} with the
// value provided by {@link //getMode}.</p>
LexerModeAction.prototype.execute = function(lexer) {
    lexer.mode(this.mode);
};

LexerModeAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.mode);
};

LexerModeAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerModeAction)) {
        return false;
    } else {
        return this.mode === other.mode;
    }
};

LexerModeAction.prototype.toString = function() {
    return "mode(" + this.mode + ")";
};

// Executes a custom lexer action by calling {@link Recognizer//action} with the
// rule and action indexes assigned to the custom action. The implementation of
// a custom action is added to the generated code for the lexer in an override
// of {@link Recognizer//action} when the grammar is compiled.
//
// <p>This class may represent embedded actions created with the <code>{...}</code>
// syntax in ANTLR 4, as well as actions created for lexer commands where the
// command argument could not be evaluated when the grammar was compiled.</p>


    // Constructs a custom lexer action with the specified rule and action
    // indexes.
    //
    // @param ruleIndex The rule index to use for calls to
    // {@link Recognizer//action}.
    // @param actionIndex The action index to use for calls to
    // {@link Recognizer//action}.

function LexerCustomAction(ruleIndex, actionIndex) {
	LexerAction.call(this, LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
    return this;
}

LexerCustomAction.prototype = Object.create(LexerAction.prototype);
LexerCustomAction.prototype.constructor = LexerCustomAction;

// <p>Custom actions are implemented by calling {@link Lexer//action} with the
// appropriate rule and action indexes.</p>
LexerCustomAction.prototype.execute = function(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
};

LexerCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerCustomAction)) {
        return false;
    } else {
        return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
};

// Implements the {@code channel} lexer action by calling
// {@link Lexer//setChannel} with the assigned channel.
// Constructs a new {@code channel} action with the specified channel value.
// @param channel The channel value to pass to {@link Lexer//setChannel}.
function LexerChannelAction(channel) {
	LexerAction.call(this, LexerActionType.CHANNEL);
    this.channel = channel;
    return this;
}

LexerChannelAction.prototype = Object.create(LexerAction.prototype);
LexerChannelAction.prototype.constructor = LexerChannelAction;

// <p>This action is implemented by calling {@link Lexer//setChannel} with the
// value provided by {@link //getChannel}.</p>
LexerChannelAction.prototype.execute = function(lexer) {
    lexer._channel = this.channel;
};

LexerChannelAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.channel);
};

LexerChannelAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerChannelAction)) {
        return false;
    } else {
        return this.channel === other.channel;
    }
};

LexerChannelAction.prototype.toString = function() {
    return "channel(" + this.channel + ")";
};

// This implementation of {@link LexerAction} is used for tracking input offsets
// for position-dependent actions within a {@link LexerActionExecutor}.
//
// <p>This action is not serialized as part of the ATN, and is only required for
// position-dependent lexer actions which appear at a location other than the
// end of a rule. For more information about DFA optimizations employed for
// lexer actions, see {@link LexerActionExecutor//append} and
// {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>

// Constructs a new indexed custom action by associating a character offset
// with a {@link LexerAction}.
//
// <p>Note: This class is only required for lexer actions for which
// {@link LexerAction//isPositionDependent} returns {@code true}.</p>
//
// @param offset The offset into the input {@link CharStream}, relative to
// the token start index, at which the specified lexer action should be
// executed.
// @param action The lexer action to execute at a particular offset in the
// input {@link CharStream}.
function LexerIndexedCustomAction(offset, action) {
	LexerAction.call(this, action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
    return this;
}

LexerIndexedCustomAction.prototype = Object.create(LexerAction.prototype);
LexerIndexedCustomAction.prototype.constructor = LexerIndexedCustomAction;

// <p>This method calls {@link //execute} on the result of {@link //getAction}
// using the provided {@code lexer}.</p>
LexerIndexedCustomAction.prototype.execute = function(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
};

LexerIndexedCustomAction.prototype.updateHashCode = function(hash) {
    hash.update(this.actionType, this.offset, this.action);
};

LexerIndexedCustomAction.prototype.equals = function(other) {
    if (this === other) {
        return true;
    } else if (! (other instanceof LexerIndexedCustomAction)) {
        return false;
    } else {
        return this.offset === other.offset && this.action === other.action;
    }
};


exports.LexerActionType = LexerActionType;
exports.LexerSkipAction = LexerSkipAction;
exports.LexerChannelAction = LexerChannelAction;
exports.LexerCustomAction = LexerCustomAction;
exports.LexerIndexedCustomAction = LexerIndexedCustomAction;
exports.LexerMoreAction = LexerMoreAction;
exports.LexerTypeAction = LexerTypeAction;
exports.LexerPushModeAction = LexerPushModeAction;
exports.LexerPopModeAction = LexerPopModeAction;
exports.LexerModeAction = LexerModeAction;

/***/ }),

/***/ "./node_modules/antlr4/atn/LexerActionExecutor.js":
/*!********************************************************!*\
  !*** ./node_modules/antlr4/atn/LexerActionExecutor.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// Represents an executor for a sequence of lexer actions which traversed during
// the matching operation of a lexer rule (token).
//
// <p>The executor tracks position information for position-dependent lexer actions
// efficiently, ensuring that actions appearing only at the end of the rule do
// not cause bloating of the {@link DFA} created for the lexer.</p>

var hashStuff = __webpack_require__(/*! ../Utils */ "./node_modules/antlr4/Utils.js").hashStuff;
var LexerIndexedCustomAction = __webpack_require__(/*! ./LexerAction */ "./node_modules/antlr4/atn/LexerAction.js").LexerIndexedCustomAction;

function LexerActionExecutor(lexerActions) {
	this.lexerActions = lexerActions === null ? [] : lexerActions;
	// Caches the result of {@link //hashCode} since the hash code is an element
	// of the performance-critical {@link LexerATNConfig//hashCode} operation.
	this.cachedHashCode = hashStuff(lexerActions); // "".join([str(la) for la in
	// lexerActions]))
	return this;
}

// Creates a {@link LexerActionExecutor} which executes the actions for
// the input {@code lexerActionExecutor} followed by a specified
// {@code lexerAction}.
//
// @param lexerActionExecutor The executor for actions already traversed by
// the lexer while matching a token within a particular
// {@link LexerATNConfig}. If this is {@code null}, the method behaves as
// though it were an empty executor.
// @param lexerAction The lexer action to execute after the actions
// specified in {@code lexerActionExecutor}.
//
// @return A {@link LexerActionExecutor} for executing the combine actions
// of {@code lexerActionExecutor} and {@code lexerAction}.
LexerActionExecutor.append = function(lexerActionExecutor, lexerAction) {
	if (lexerActionExecutor === null) {
		return new LexerActionExecutor([ lexerAction ]);
	}
	var lexerActions = lexerActionExecutor.lexerActions.concat([ lexerAction ]);
	return new LexerActionExecutor(lexerActions);
};

// Creates a {@link LexerActionExecutor} which encodes the current offset
// for position-dependent lexer actions.
//
// <p>Normally, when the executor encounters lexer actions where
// {@link LexerAction//isPositionDependent} returns {@code true}, it calls
// {@link IntStream//seek} on the input {@link CharStream} to set the input
// position to the <em>end</em> of the current token. This behavior provides
// for efficient DFA representation of lexer actions which appear at the end
// of a lexer rule, even when the lexer rule matches a variable number of
// characters.</p>
//
// <p>Prior to traversing a match transition in the ATN, the current offset
// from the token start index is assigned to all position-dependent lexer
// actions which have not already been assigned a fixed offset. By storing
// the offsets relative to the token start index, the DFA representation of
// lexer actions which appear in the middle of tokens remains efficient due
// to sharing among tokens of the same length, regardless of their absolute
// position in the input stream.</p>
//
// <p>If the current executor already has offsets assigned to all
// position-dependent lexer actions, the method returns {@code this}.</p>
//
// @param offset The current offset to assign to all position-dependent
// lexer actions which do not already have offsets assigned.
//
// @return A {@link LexerActionExecutor} which stores input stream offsets
// for all position-dependent lexer actions.
// /
LexerActionExecutor.prototype.fixOffsetBeforeMatch = function(offset) {
	var updatedLexerActions = null;
	for (var i = 0; i < this.lexerActions.length; i++) {
		if (this.lexerActions[i].isPositionDependent &&
				!(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
			if (updatedLexerActions === null) {
				updatedLexerActions = this.lexerActions.concat([]);
			}
			updatedLexerActions[i] = new LexerIndexedCustomAction(offset,
					this.lexerActions[i]);
		}
	}
	if (updatedLexerActions === null) {
		return this;
	} else {
		return new LexerActionExecutor(updatedLexerActions);
	}
};

// Execute the actions encapsulated by this executor within the context of a
// particular {@link Lexer}.
//
// <p>This method calls {@link IntStream//seek} to set the position of the
// {@code input} {@link CharStream} prior to calling
// {@link LexerAction//execute} on a position-dependent action. Before the
// method returns, the input position will be restored to the same position
// it was in when the method was invoked.</p>
//
// @param lexer The lexer instance.
// @param input The input stream which is the source for the current token.
// When this method is called, the current {@link IntStream//index} for
// {@code input} should be the start of the following token, i.e. 1
// character past the end of the current token.
// @param startIndex The token start index. This value may be passed to
// {@link IntStream//seek} to set the {@code input} position to the beginning
// of the token.
// /
LexerActionExecutor.prototype.execute = function(lexer, input, startIndex) {
	var requiresSeek = false;
	var stopIndex = input.index;
	try {
		for (var i = 0; i < this.lexerActions.length; i++) {
			var lexerAction = this.lexerActions[i];
			if (lexerAction instanceof LexerIndexedCustomAction) {
				var offset = lexerAction.offset;
				input.seek(startIndex + offset);
				lexerAction = lexerAction.action;
				requiresSeek = (startIndex + offset) !== stopIndex;
			} else if (lexerAction.isPositionDependent) {
				input.seek(stopIndex);
				requiresSeek = false;
			}
			lexerAction.execute(lexer);
		}
	} finally {
		if (requiresSeek) {
			input.seek(stopIndex);
		}
	}
};

LexerActionExecutor.prototype.hashCode = function() {
	return this.cachedHashCode;
};

LexerActionExecutor.prototype.updateHashCode = function(hash) {
    hash.update(this.cachedHashCode);
};


LexerActionExecutor.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof LexerActionExecutor)) {
		return false;
	} else if (this.cachedHashCode != other.cachedHashCode) {
		return false;
	} else if (this.lexerActions.length != other.lexerActions.length) {
		return false;
	} else {
		var numActions = this.lexerActions.length
		for (var idx = 0; idx < numActions; ++idx) {
			if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
				return false;
			}
		}
		return true;
	}
};

exports.LexerActionExecutor = LexerActionExecutor;


/***/ }),

/***/ "./node_modules/antlr4/atn/ParserATNSimulator.js":
/*!*******************************************************!*\
  !*** ./node_modules/antlr4/atn/ParserATNSimulator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
//
// <p>
// The basic complexity of the adaptive strategy makes it harder to understand.
// We begin with ATN simulation to build paths in a DFA. Subsequent prediction
// requests go through the DFA first. If they reach a state without an edge for
// the current symbol, the algorithm fails over to the ATN simulation to
// complete the DFA path for the current input (until it finds a conflict state
// or uniquely predicting state).</p>
//
// <p>
// All of that is done without using the outer context because we want to create
// a DFA that is not dependent upon the rule invocation stack when we do a
// prediction. One DFA works in all contexts. We avoid using context not
// necessarily because it's slower, although it can be, but because of the DFA
// caching problem. The closure routine only considers the rule invocation stack
// created during prediction beginning in the decision rule. For example, if
// prediction occurs without invoking another rule's ATN, there are no context
// stacks in the configurations. When lack of context leads to a conflict, we
// don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
// strategy (versus full LL(*)).</p>
//
// <p>
// When SLL yields a configuration set with conflict, we rewind the input and
// retry the ATN simulation, this time using full outer context without adding
// to the DFA. Configuration context stacks will be the full invocation stacks
// from the start rule. If we get a conflict using full context, then we can
// definitively say we have a true ambiguity for that input sequence. If we
// don't get a conflict, it implies that the decision is sensitive to the outer
// context. (It is not context-sensitive in the sense of context-sensitive
// grammars.)</p>
//
// <p>
// The next time we reach this DFA state with an SLL conflict, through DFA
// simulation, we will again retry the ATN simulation using full context mode.
// This is slow because we can't save the results and have to "interpret" the
// ATN each time we get that input.</p>
//
// <p>
// <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
//
// <p>
// We could cache results from full context to predicted alternative easily and
// that saves a lot of time but doesn't work in presence of predicates. The set
// of visible predicates from the ATN start state changes depending on the
// context, because closure can fall off the end of a rule. I tried to cache
// tuples (stack context, semantic context, predicted alt) but it was slower
// than interpreting and much more complicated. Also required a huge amount of
// memory. The goal is not to create the world's fastest parser anyway. I'd like
// to keep this algorithm simple. By launching multiple threads, we can improve
// the speed of parsing across a large number of files.</p>
//
// <p>
// There is no strict ordering between the amount of input used by SLL vs LL,
// which makes it really hard to build a cache for full context. Let's say that
// we have input A B C that leads to an SLL conflict with full context X. That
// implies that using X we might only use A B but we could also use A B C D to
// resolve conflict. Input A B C D could predict alternative 1 in one position
// in the input and A B C E could predict alternative 2 in another position in
// input. The conflicting SLL configurations could still be non-unique in the
// full context prediction, which would lead us to requiring more input than the
// original A B C.	To make a	prediction cache work, we have to track	the exact
// input	used during the previous prediction. That amounts to a cache that maps
// X to a specific DFA for that context.</p>
//
// <p>
// Something should be done for left-recursive expression predictions. They are
// likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
// with full LL thing Sam does.</p>
//
// <p>
// <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
//
// <p>
// We avoid doing full context retry when the outer context is empty, we did not
// dip into the outer context by falling off the end of the decision state rule,
// or when we force SLL mode.</p>
//
// <p>
// As an example of the not dip into outer context case, consider as super
// constructor calls versus function calls. One grammar might look like
// this:</p>
//
// <pre>
// ctorBody
//   : '{' superCall? stat* '}'
//   ;
// </pre>
//
// <p>
// Or, you might see something like</p>
//
// <pre>
// stat
//   : superCall ';'
//   | expression ';'
//   | ...
//   ;
// </pre>
//
// <p>
// In both cases I believe that no closure operations will dip into the outer
// context. In the first case ctorBody in the worst case will stop at the '}'.
// In the 2nd case it should stop at the ';'. Both cases should stay within the
// entry rule and not dip into the outer context.</p>
//
// <p>
// <strong>PREDICATES</strong></p>
//
// <p>
// Predicates are always evaluated if present in either SLL or LL both. SLL and
// LL simulation deals with predicates differently. SLL collects predicates as
// it performs closure operations like ANTLR v3 did. It delays predicate
// evaluation until it reaches and accept state. This allows us to cache the SLL
// ATN simulation whereas, if we had evaluated predicates on-the-fly during
// closure, the DFA state configuration sets would be different and we couldn't
// build up a suitable DFA.</p>
//
// <p>
// When building a DFA accept state during ATN simulation, we evaluate any
// predicates and return the sole semantically valid alternative. If there is
// more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
// we throw an exception. Alternatives without predicates act like they have
// true predicates. The simple way to think about it is to strip away all
// alternatives with false predicates and choose the minimum alternative that
// remains.</p>
//
// <p>
// When we start in the DFA and reach an accept state that's predicated, we test
// those and return the minimum semantically viable alternative. If no
// alternatives are viable, we throw an exception.</p>
//
// <p>
// During full LL ATN simulation, closure always evaluates predicates and
// on-the-fly. This is crucial to reducing the configuration set size during
// closure. It hits a landmine when parsing with the Java grammar, for example,
// without this on-the-fly evaluation.</p>
//
// <p>
// <strong>SHARING DFA</strong></p>
//
// <p>
// All instances of the same parser share the same decision DFAs through a
// static field. Each instance gets its own ATN simulator but they share the
// same {@link //decisionToDFA} field. They also share a
// {@link PredictionContextCache} object that makes sure that all
// {@link PredictionContext} objects are shared among the DFA states. This makes
// a big size difference.</p>
//
// <p>
// <strong>THREAD SAFETY</strong></p>
//
// <p>
// The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
// it adds a new DFA object to that array. {@link //addDFAEdge}
// locks on the DFA for the current decision when setting the
// {@link DFAState//edges} field. {@link //addDFAState} locks on
// the DFA for the current decision when looking up a DFA state to see if it
// already exists. We must make sure that all requests to add DFA states that
// are equivalent result in the same shared DFA object. This is because lots of
// threads will be trying to update the DFA at once. The
// {@link //addDFAState} method also locks inside the DFA lock
// but this time on the shared context cache when it rebuilds the
// configurations' {@link PredictionContext} objects using cached
// subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
// safe as long as we can guarantee that all threads referencing
// {@code s.edge[t]} get the same physical target {@link DFAState}, or
// {@code null}. Once into the DFA, the DFA simulation does not reference the
// {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
// targets. The DFA simulator will either find {@link DFAState//edges} to be
// {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
// {@code dfa.edges[t]} to be non-null. The
// {@link //addDFAEdge} method could be racing to set the field
// but in either case the DFA simulator works; if {@code null}, and requests ATN
// simulation. It could also race trying to get {@code dfa.edges[t]}, but either
// way it will work because it's not doing a test and set operation.</p>
//
// <p>
// <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
// Parsing)</strong></p>
//
// <p>
// Sam pointed out that if SLL does not give a syntax error, then there is no
// point in doing full LL, which is slower. We only have to try LL if we get a
// syntax error. For maximum speed, Sam starts the parser set to pure SLL
// mode with the {@link BailErrorStrategy}:</p>
//
// <pre>
// parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
// parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
// </pre>
//
// <p>
// If it does not get a syntax error, then we're done. If it does get a syntax
// error, we need to retry with the combined SLL/LL strategy.</p>
//
// <p>
// The reason this works is as follows. If there are no SLL conflicts, then the
// grammar is SLL (at least for that input set). If there is an SLL conflict,
// the full LL analysis must yield a set of viable alternatives which is a
// subset of the alternatives reported by SLL. If the LL set is a singleton,
// then the grammar is LL but not SLL. If the LL set is the same size as the SLL
// set, the decision is SLL. If the LL set has size &gt; 1, then that decision
// is truly ambiguous on the current input. If the LL set is smaller, then the
// SLL conflict resolution might choose an alternative that the full LL would
// rule out as a possibility based upon better context information. If that's
// the case, then the SLL parse will definitely get an error because the full LL
// analysis says it's not viable. If SLL conflict resolution chooses an
// alternative within the LL set, them both SLL and LL would choose the same
// alternative because they both choose the minimum of multiple conflicting
// alternatives.</p>
//
// <p>
// Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
// a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
// parsing will get an error because SLL will pursue alternative 1. If
// <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
// choose the same alternative because alternative one is the minimum of either
// set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
// error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
//
// <p>
// Of course, if the input is invalid, then we will get an error for sure in
// both SLL and LL parsing. Erroneous input will therefore require 2 passes over
// the input.</p>
//

var Utils = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js");
var Set = Utils.Set;
var BitSet = Utils.BitSet;
var DoubleDict = Utils.DoubleDict;
var ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
var ATNState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").ATNState;
var ATNConfig = __webpack_require__(/*! ./ATNConfig */ "./node_modules/antlr4/atn/ATNConfig.js").ATNConfig;
var ATNConfigSet = __webpack_require__(/*! ./ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var DFAState = __webpack_require__(/*! ./../dfa/DFAState */ "./node_modules/antlr4/dfa/DFAState.js").DFAState;
var PredPrediction = __webpack_require__(/*! ./../dfa/DFAState */ "./node_modules/antlr4/dfa/DFAState.js").PredPrediction;
var ATNSimulator = __webpack_require__(/*! ./ATNSimulator */ "./node_modules/antlr4/atn/ATNSimulator.js").ATNSimulator;
var PredictionMode = __webpack_require__(/*! ./PredictionMode */ "./node_modules/antlr4/atn/PredictionMode.js").PredictionMode;
var RuleContext = __webpack_require__(/*! ./../RuleContext */ "./node_modules/antlr4/RuleContext.js").RuleContext;
var ParserRuleContext = __webpack_require__(/*! ./../ParserRuleContext */ "./node_modules/antlr4/ParserRuleContext.js").ParserRuleContext;
var SemanticContext = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").SemanticContext;
var StarLoopEntryState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").StarLoopEntryState;
var RuleStopState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").RuleStopState;
var PredictionContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").PredictionContext;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var Transitions = __webpack_require__(/*! ./Transition */ "./node_modules/antlr4/atn/Transition.js");
var Transition = Transitions.Transition;
var SetTransition = Transitions.SetTransition;
var NotSetTransition = Transitions.NotSetTransition;
var RuleTransition = Transitions.RuleTransition;
var ActionTransition = Transitions.ActionTransition;
var NoViableAltException = __webpack_require__(/*! ./../error/Errors */ "./node_modules/antlr4/error/Errors.js").NoViableAltException;

var SingletonPredictionContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").SingletonPredictionContext;
var predictionContextFromRuleContext = __webpack_require__(/*! ./../PredictionContext */ "./node_modules/antlr4/PredictionContext.js").predictionContextFromRuleContext;

function ParserATNSimulator(parser, atn, decisionToDFA, sharedContextCache) {
	ATNSimulator.call(this, atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA;
    // SLL, LL, or LL + exact ambig detection?//
    this.predictionMode = PredictionMode.LL;
    // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    // Each prediction operation uses a cache for merge of prediction contexts.
    //  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
    //  isn't synchronized but we're ok since two threads shouldn't reuse same
    //  parser/atnsim object because it can only handle one input at a time.
    //  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
    //  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
    //  also be examined during cache lookup.
    //
    this.mergeCache = null;
    return this;
}

ParserATNSimulator.prototype = Object.create(ATNSimulator.prototype);
ParserATNSimulator.prototype.constructor = ParserATNSimulator;

ParserATNSimulator.prototype.debug = false;
ParserATNSimulator.prototype.debug_closure = false;
ParserATNSimulator.prototype.debug_add = false;
ParserATNSimulator.prototype.debug_list_atn_decisions = false;
ParserATNSimulator.prototype.dfa_debug = false;
ParserATNSimulator.prototype.retry_debug = false;


ParserATNSimulator.prototype.reset = function() {
};

ParserATNSimulator.prototype.adaptivePredict = function(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("adaptivePredict decision " + decision +
                               " exec LA(1)==" + this.getLookaheadName(input) +
                               " line " + input.LT(1).line + ":" +
                               input.LT(1).column);
    }
    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;

    var dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    var m = input.mark();
    var index = input.index;

    // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?
    try {
        var s0;
        if (dfa.precedenceDfa) {
            // the start state for a precedence DFA depends on the current
            // parser precedence, and is provided by a DFA method.
            s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
        } else {
            // the start state for a "regular" DFA is just s0
            s0 = dfa.s0;
        }
        if (s0===null) {
            if (outerContext===null) {
                outerContext = RuleContext.EMPTY;
            }
            if (this.debug || this.debug_list_atn_decisions) {
                console.log("predictATN decision " + dfa.decision +
                                   " exec LA(1)==" + this.getLookaheadName(input) +
                                   ", outerContext=" + outerContext.toString(this.parser.ruleNames));
            }

            var fullCtx = false;
            var s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

            if( dfa.precedenceDfa) {
                // If this is a precedence DFA, we use applyPrecedenceFilter
                // to convert the computed start state to a precedence start
                // state. We then use DFA.setPrecedenceStartState to set the
                // appropriate start state for the precedence level rather
                // than simply setting DFA.s0.
                //
                dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
                s0_closure = this.applyPrecedenceFilter(s0_closure);
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
            } else {
                s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
                dfa.s0 = s0;
            }
        }
        var alt = this.execATN(dfa, s0, input, index, outerContext);
        if (this.debug) {
            console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames));
        }
        return alt;
    } finally {
        this._dfa = null;
        this.mergeCache = null; // wack cache after each prediction
        input.seek(index);
        input.release(m);
    }
};
// Performs ATN simulation to compute a predicted alternative based
//  upon the remaining input, but also updates the DFA cache to avoid
//  having to traverse the ATN again for the same input sequence.

// There are some key conditions we're looking for after computing a new
// set of ATN configs (proposed DFA state):
      // if the set is empty, there is no viable alternative for current symbol
      // does the state uniquely predict an alternative?
      // does the state have a conflict that would prevent us from
      //   putting it on the work list?

// We also have some key operations to do:
      // add an edge from previous DFA state to potentially new DFA state, D,
      //   upon current symbol but only if adding to work list, which means in all
      //   cases except no viable alternative (and possibly non-greedy decisions?)
      // collecting predicates and adding semantic context to DFA accept states
      // adding rule context to context-sensitive DFA accept states
      // consuming an input symbol
      // reporting a conflict
      // reporting an ambiguity
      // reporting a context sensitivity
      // reporting insufficient predicates

// cover these cases:
//    dead end
//    single alt
//    single alt + preds
//    conflict
//    conflict + preds
//
ParserATNSimulator.prototype.execATN = function(dfa, s0, input, startIndex, outerContext ) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATN decision " + dfa.decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" + input.LT(1).column);
    }
    var alt;
    var previousD = s0;

    if (this.debug) {
        console.log("s0 = " + s0);
    }
    var t = input.LA(1);
    while(true) { // while more work
        var D = this.getExistingTargetState(previousD, t);
        if(D===null) {
            D = this.computeTargetState(dfa, previousD, t);
        }
        if(D===ATNSimulator.ERROR) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for SLL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
            input.seek(startIndex);
            alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        if(D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
            // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
            var conflictingAlts = null;
            if (D.predicates!==null) {
                if (this.debug) {
                    console.log("DFA state has preds in DFA sim LL failover");
                }
                var conflictIndex = input.index;
                if(conflictIndex !== startIndex) {
                    input.seek(startIndex);
                }
                conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (conflictingAlts.length===1) {
                    if(this.debug) {
                        console.log("Full LL avoided");
                    }
                    return conflictingAlts.minValue();
                }
                if (conflictIndex !== startIndex) {
                    // restore the index so reporting the fallback to full
                    // context occurs with the index at the correct spot
                    input.seek(conflictIndex);
                }
            }
            if (this.dfa_debug) {
                console.log("ctx sensitive state " + outerContext +" in " + D);
            }
            var fullCtx = true;
            var s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
            this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
            alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
            return alt;
        }
        if (D.isAcceptState) {
            if (D.predicates===null) {
                return D.prediction;
            }
            var stopIndex = input.index;
            input.seek(startIndex);
            var alts = this.evalSemanticContext(D.predicates, outerContext, true);
            if (alts.length===0) {
                throw this.noViableAlt(input, outerContext, D.configs, startIndex);
            } else if (alts.length===1) {
                return alts.minValue();
            } else {
                // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                return alts.minValue();
            }
        }
        previousD = D;

        if (t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
};
//
// Get an existing target state for an edge in the DFA. If the target state
// for the edge has not yet been computed or is otherwise not available,
// this method returns {@code null}.
//
// @param previousD The current DFA state
// @param t The next input symbol
// @return The existing target DFA state for the given input symbol
// {@code t}, or {@code null} if the target state for this edge is not
// already cached
//
ParserATNSimulator.prototype.getExistingTargetState = function(previousD, t) {
    var edges = previousD.edges;
    if (edges===null) {
        return null;
    } else {
        return edges[t + 1] || null;
    }
};
//
// Compute a target state for an edge in the DFA, and attempt to add the
// computed state and corresponding edge to the DFA.
//
// @param dfa The DFA
// @param previousD The current DFA state
// @param t The next input symbol
//
// @return The computed target DFA state for the given input symbol
// {@code t}. If {@code t} does not lead to a valid DFA state, this method
// returns {@link //ERROR}.
//
ParserATNSimulator.prototype.computeTargetState = function(dfa, previousD, t) {
   var reach = this.computeReachSet(previousD.configs, t, false);
    if(reach===null) {
        this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
        return ATNSimulator.ERROR;
    }
    // create new target state; we'll add to DFA after it's complete
    var D = new DFAState(null, reach);

    var predictedAlt = this.getUniqueAlt(reach);

    if (this.debug) {
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) +
                    ", previous=" + previousD.configs +
                    ", configs=" + reach +
                    ", predict=" + predictedAlt +
                    ", allSubsetsConflict=" +
                    PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                    this.getConflictingAlts(reach));
    }
    if (predictedAlt!==ATN.INVALID_ALT_NUMBER) {
        // NO CONFLICT, UNIQUELY PREDICTED ALT
        D.isAcceptState = true;
        D.configs.uniqueAlt = predictedAlt;
        D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
        // MORE THAN ONE VIABLE ALTERNATIVE
        D.configs.conflictingAlts = this.getConflictingAlts(reach);
        D.requiresFullContext = true;
        // in SLL-only mode, we will stop at this state and return the minimum alt
        D.isAcceptState = true;
        D.prediction = D.configs.conflictingAlts.minValue();
    }
    if (D.isAcceptState && D.configs.hasSemanticContext) {
        this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
        if( D.predicates!==null) {
            D.prediction = ATN.INVALID_ALT_NUMBER;
        }
    }
    // all adds to dfa are done after we've created full D state
    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
};

ParserATNSimulator.prototype.predicateDFAState = function(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    var nalts = decisionState.transitions.length;
    // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts
    var altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    var altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
    if (altToPred!==null) {
        dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
        dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
        // There are preds in configs but they might go away
        // when OR'd together like {p}? || NONE == NONE. If neither
        // alt has preds, resolve to min alt
        dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
};

// comes back with reach.uniqueAlt set to a valid alt
ParserATNSimulator.prototype.execATNWithFullContext = function(dfa, D, // how far we got before failing over
                                     s0,
                                     input,
                                     startIndex,
                                     outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
        console.log("execATNWithFullContext "+s0);
    }
    var fullCtx = true;
    var foundExactAmbig = false;
    var reach = null;
    var previous = s0;
    input.seek(startIndex);
    var t = input.LA(1);
    var predictedAlt = -1;
    while (true) { // while more work
        reach = this.computeReachSet(previous, t, fullCtx);
        if (reach===null) {
            // if any configs in previous dipped into outer context, that
            // means that input up to t actually finished entry rule
            // at least for LL decision. Full LL doesn't dip into outer
            // so don't need special case.
            // We will get an error no matter what so delay until after
            // decision; better error message. Also, no reachable target
            // ATN states in SLL implies LL will also get nowhere.
            // If conflict in states that dip out, choose min since we
            // will get error no matter what.
            var e = this.noViableAlt(input, outerContext, previous, startIndex);
            input.seek(startIndex);
            var alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
            if(alt!==ATN.INVALID_ALT_NUMBER) {
                return alt;
            } else {
                throw e;
            }
        }
        var altSubSets = PredictionMode.getConflictingAltSubsets(reach);
        if(this.debug) {
            console.log("LL altSubSets=" + altSubSets + ", predict=" +
                  PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                  PredictionMode.resolvesToJustOneViableAlt(altSubSets));
        }
        reach.uniqueAlt = this.getUniqueAlt(reach);
        // unique prediction?
        if(reach.uniqueAlt!==ATN.INVALID_ALT_NUMBER) {
            predictedAlt = reach.uniqueAlt;
            break;
        } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
            predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);
            if(predictedAlt !== ATN.INVALID_ALT_NUMBER) {
                break;
            }
        } else {
            // In exact ambiguity mode, we never try to terminate early.
            // Just keeps scarfing until we know what the conflict is
            if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
                foundExactAmbig = true;
                predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
                break;
            }
            // else there are multiple non-conflicting subsets or
            // we're not sure what the ambiguity is yet.
            // So, keep going.
        }
        previous = reach;
        if( t !== Token.EOF) {
            input.consume();
            t = input.LA(1);
        }
    }
    // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.
    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER ) {
        this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
        return predictedAlt;
    }
    // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.

    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:

    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]

    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.

    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);

    return predictedAlt;
};

ParserATNSimulator.prototype.computeReachSet = function(closure, t, fullCtx) {
    if (this.debug) {
        console.log("in computeReachSet, starting closure: " + closure);
    }
    if( this.mergeCache===null) {
        this.mergeCache = new DoubleDict();
    }
    var intermediate = new ATNConfigSet(fullCtx);

    // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.

    var skippedStopStates = null;

    // First figure out where we can reach on input t
    for (var i=0; i<closure.items.length;i++) {
        var c = closure.items[i];
        if(this.debug_add) {
            console.log("testing " + this.getTokenName(t) + " at " + c);
        }
        if (c.state instanceof RuleStopState) {
            if (fullCtx || t === Token.EOF) {
                if (skippedStopStates===null) {
                    skippedStopStates = [];
                }
                skippedStopStates.push(c);
                if(this.debug_add) {
                    console.log("added " + c + " to skippedStopStates");
                }
            }
            continue;
        }
        for(var j=0;j<c.state.transitions.length;j++) {
            var trans = c.state.transitions[j];
            var target = this.getReachableTarget(trans, t);
            if (target!==null) {
                var cfg = new ATNConfig({state:target}, c);
                intermediate.add(cfg, this.mergeCache);
                if(this.debug_add) {
                    console.log("added " + cfg + " to intermediate");
                }
            }
        }
    }
    // Now figure out where the reach operation can take us...
    var reach = null;

    // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //
    if (skippedStopStates===null && t!==Token.EOF) {
        if (intermediate.items.length===1) {
            // Don't pursue the closure if there is just one state.
            // It can only have one alternative; just add to result
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        } else if (this.getUniqueAlt(intermediate)!==ATN.INVALID_ALT_NUMBER) {
            // Also don't pursue the closure if there is unique alternative
            // among the configurations.
            reach = intermediate;
        }
    }
    // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //
    if (reach===null) {
        reach = new ATNConfigSet(fullCtx);
        var closureBusy = new Set();
        var treatEofAsEpsilon = t === Token.EOF;
        for (var k=0; k<intermediate.items.length;k++) {
            this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
        }
    }
    if (t === Token.EOF) {
        // After consuming EOF no additional input is possible, so we are
        // only interested in configurations which reached the end of the
        // decision rule (local context) or end of the start rule (full
        // context). Update reach to contain only these configurations. This
        // handles both explicit EOF transitions in the grammar and implicit
        // EOF transitions following the end of the decision or start rule.
        //
        // When reach==intermediate, no closure operation was performed. In
        // this case, removeAllConfigsNotInRuleStopState needs to check for
        // reachable rule stop states as well as configurations already in
        // a rule stop state.
        //
        // This is handled before the configurations in skippedStopStates,
        // because any configurations potentially added from that list are
        // already guaranteed to meet this condition whether or not it's
        // required.
        //
        reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    }
    // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //
    if (skippedStopStates!==null && ( (! fullCtx) || (! PredictionMode.hasConfigInRuleStopState(reach)))) {
        for (var l=0; l<skippedStopStates.length;l++) {
            reach.add(skippedStopStates[l], this.mergeCache);
        }
    }
    if (reach.items.length===0) {
        return null;
    } else {
        return reach;
    }
};
//
// Return a configuration set containing only the configurations from
// {@code configs} which are in a {@link RuleStopState}. If all
// configurations in {@code configs} are already in a rule stop state, this
// method simply returns {@code configs}.
//
// <p>When {@code lookToEndOfRule} is true, this method uses
// {@link ATN//nextTokens} for each configuration in {@code configs} which is
// not already in a rule stop state to see if a rule stop state is reachable
// from the configuration via epsilon-only transitions.</p>
//
// @param configs the configuration set to update
// @param lookToEndOfRule when true, this method checks for rule stop states
// reachable by epsilon-only transitions from each configuration in
// {@code configs}.
//
// @return {@code configs} if all configurations in {@code configs} are in a
// rule stop state, otherwise return a new configuration set containing only
// the configurations from {@code configs} which are in a rule stop state
//
ParserATNSimulator.prototype.removeAllConfigsNotInRuleStopState = function(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return configs;
    }
    var result = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length;i++) {
        var config = configs.items[i];
        if (config.state instanceof RuleStopState) {
            result.add(config, this.mergeCache);
            continue;
        }
        if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
            var nextTokens = this.atn.nextTokens(config.state);
            if (nextTokens.contains(Token.EPSILON)) {
                var endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                result.add(new ATNConfig({state:endOfRuleState}, config), this.mergeCache);
            }
        }
    }
    return result;
};

ParserATNSimulator.prototype.computeStartState = function(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    var initialContext = predictionContextFromRuleContext(this.atn, ctx);
    var configs = new ATNConfigSet(fullCtx);
    for(var i=0;i<p.transitions.length;i++) {
        var target = p.transitions[i].target;
        var c = new ATNConfig({ state:target, alt:i+1, context:initialContext }, null);
        var closureBusy = new Set();
        this.closure(c, configs, closureBusy, true, fullCtx, false);
    }
    return configs;
};

//
// This method transforms the start state computed by
// {@link //computeStartState} to the special start state used by a
// precedence DFA for a particular precedence value. The transformation
// process applies the following changes to the start state's configuration
// set.
//
// <ol>
// <li>Evaluate the precedence predicates for each configuration using
// {@link SemanticContext//evalPrecedence}.</li>
// <li>Remove all configurations which predict an alternative greater than
// 1, for which another configuration that predicts alternative 1 is in the
// same ATN state with the same prediction context. This transformation is
// valid for the following reasons:
// <ul>
// <li>The closure block cannot contain any epsilon transitions which bypass
// the body of the closure, so all states reachable via alternative 1 are
// part of the precedence alternatives of the transformed left-recursive
// rule.</li>
// <li>The "primary" portion of a left recursive rule cannot contain an
// epsilon transition, so the only way an alternative other than 1 can exist
// in a state that is also reachable via alternative 1 is by nesting calls
// to the left-recursive rule, with the outer calls not being at the
// preferred precedence level.</li>
// </ul>
// </li>
// </ol>
//
// <p>
// The prediction context must be considered by this filter to address
// situations like the following.
// </p>
// <code>
// <pre>
// grammar TA;
// prog: statement* EOF;
// statement: letterA | statement letterA 'b' ;
// letterA: 'a';
// </pre>
// </code>
// <p>
// If the above grammar, the ATN state immediately before the token
// reference {@code 'a'} in {@code letterA} is reachable from the left edge
// of both the primary and closure blocks of the left-recursive rule
// {@code statement}. The prediction context associated with each of these
// configurations distinguishes between them, and prevents the alternative
// which stepped out to {@code prog} (and then back in to {@code statement}
// from being eliminated by the filter.
// </p>
//
// @param configs The configuration set computed by
// {@link //computeStartState} as the start state for the DFA.
// @return The transformed configuration set representing the start state
// for a precedence DFA at a particular precedence level (determined by
// calling {@link Parser//getPrecedence}).
//
ParserATNSimulator.prototype.applyPrecedenceFilter = function(configs) {
	var config;
	var statesFromAlt1 = [];
    var configSet = new ATNConfigSet(configs.fullCtx);
    for(var i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        // handle alt 1 first
        if (config.alt !== 1) {
            continue;
        }
        var updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
        if (updatedContext===null) {
            // the configuration was eliminated
            continue;
        }
        statesFromAlt1[config.state.stateNumber] = config.context;
        if (updatedContext !== config.semanticContext) {
            configSet.add(new ATNConfig({semanticContext:updatedContext}, config), this.mergeCache);
        } else {
            configSet.add(config, this.mergeCache);
        }
    }
    for(i=0; i<configs.items.length; i++) {
        config = configs.items[i];
        if (config.alt === 1) {
            // already handled
            continue;
        }
        // In the future, this elimination step could be updated to also
        // filter the prediction context for alternatives predicting alt>1
        // (basically a graph subtraction algorithm).
		if (!config.precedenceFilterSuppressed) {
            var context = statesFromAlt1[config.state.stateNumber] || null;
            if (context!==null && context.equals(config.context)) {
                // eliminated
                continue;
            }
		}
        configSet.add(config, this.mergeCache);
    }
    return configSet;
};

ParserATNSimulator.prototype.getReachableTarget = function(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
        return trans.target;
    } else {
        return null;
    }
};

ParserATNSimulator.prototype.getPredsForAmbigAlts = function(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    var altToPred = [];
    for(var i=0;i<configs.items.length;i++) {
        var c = configs.items[i];
        if(ambigAlts.contains( c.alt )) {
            altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
        }
    }
    var nPredAlts = 0;
    for (i =1;i< nalts+1;i++) {
        var pred = altToPred[i] || null;
        if (pred===null) {
            altToPred[i] = SemanticContext.NONE;
        } else if (pred !== SemanticContext.NONE) {
            nPredAlts += 1;
        }
    }
    // nonambig alts are null in altToPred
    if (nPredAlts===0) {
        altToPred = null;
    }
    if (this.debug) {
        console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }
    return altToPred;
};

ParserATNSimulator.prototype.getPredicatePredictions = function(ambigAlts, altToPred) {
    var pairs = [];
    var containsPredicate = false;
    for (var i=1; i<altToPred.length;i++) {
        var pred = altToPred[i];
        // unpredicated is indicated by SemanticContext.NONE
        if( ambigAlts!==null && ambigAlts.contains( i )) {
            pairs.push(new PredPrediction(pred, i));
        }
        if (pred !== SemanticContext.NONE) {
            containsPredicate = true;
        }
    }
    if (! containsPredicate) {
        return null;
    }
    return pairs;
};

//
// This method is used to improve the localization of error messages by
// choosing an alternative rather than throwing a
// {@link NoViableAltException} in particular prediction scenarios where the
// {@link //ERROR} state was reached during ATN simulation.
//
// <p>
// The default implementation of this method uses the following
// algorithm to identify an ATN configuration which successfully parsed the
// decision entry rule. Choosing such an alternative ensures that the
// {@link ParserRuleContext} returned by the calling rule will be complete
// and valid, and the syntax error will be reported later at a more
// localized location.</p>
//
// <ul>
// <li>If a syntactically valid path or paths reach the end of the decision rule and
// they are semantically valid if predicated, return the min associated alt.</li>
// <li>Else, if a semantically invalid but syntactically valid path exist
// or paths exist, return the minimum associated alt.
// </li>
// <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
// </ul>
//
// <p>
// In some scenarios, the algorithm described above could predict an
// alternative which will result in a {@link FailedPredicateException} in
// the parser. Specifically, this could occur if the <em>only</em> configuration
// capable of successfully parsing to the end of the decision rule is
// blocked by a semantic predicate. By choosing this alternative within
// {@link //adaptivePredict} instead of throwing a
// {@link NoViableAltException}, the resulting
// {@link FailedPredicateException} in the parser will identify the specific
// predicate which is preventing the parser from successfully parsing the
// decision rule, which helps developers identify and correct logic errors
// in semantic predicates.
// </p>
//
// @param configs The ATN configurations which were valid immediately before
// the {@link //ERROR} state was reached
// @param outerContext The is the \gamma_0 initial parser context from the paper
// or the parser stack at the instant before prediction commences.
//
// @return The value to return from {@link //adaptivePredict}, or
// {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
// identified and {@link //adaptivePredict} should report an error instead.
//
ParserATNSimulator.prototype.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule = function(configs, outerContext) {
    var cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    var semValidConfigs = cfgs[0];
    var semInvalidConfigs = cfgs[1];
    var alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
    if (alt!==ATN.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
        return alt;
    }
    // Is there a syntactically valid path with a failed pred?
    if (semInvalidConfigs.items.length>0) {
        alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
        if (alt!==ATN.INVALID_ALT_NUMBER) { // syntactically viable path exists
            return alt;
        }
    }
    return ATN.INVALID_ALT_NUMBER;
};

ParserATNSimulator.prototype.getAltThatFinishedDecisionEntryRule = function(configs) {
    var alts = [];
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.reachesIntoOuterContext>0 || ((c.state instanceof RuleStopState) && c.context.hasEmptyPath())) {
            if(alts.indexOf(c.alt)<0) {
                alts.push(c.alt);
            }
        }
    }
    if (alts.length===0) {
        return ATN.INVALID_ALT_NUMBER;
    } else {
        return Math.min.apply(null, alts);
    }
};
// Walk the list of configurations and split them according to
//  those that have preds evaluating to true/false.  If no pred, assume
//  true pred and include in succeeded set.  Returns Pair of sets.
//
//  Create a new set so as not to alter the incoming parameter.
//
//  Assumption: the input stream has been restored to the starting point
//  prediction, which is where predicates need to evaluate.
//
ParserATNSimulator.prototype.splitAccordingToSemanticValidity = function( configs, outerContext) {
    var succeeded = new ATNConfigSet(configs.fullCtx);
    var failed = new ATNConfigSet(configs.fullCtx);
    for(var i=0;i<configs.items.length; i++) {
        var c = configs.items[i];
        if (c.semanticContext !== SemanticContext.NONE) {
            var predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
            if (predicateEvaluationResult) {
                succeeded.add(c);
            } else {
                failed.add(c);
            }
        } else {
            succeeded.add(c);
        }
    }
    return [succeeded, failed];
};

// Look through a list of predicate/alt pairs, returning alts for the
//  pairs that win. A {@code NONE} predicate indicates an alt containing an
//  unpredicated config which behaves as "always true." If !complete
//  then we stop at the first predicate that evaluates to true. This
//  includes pairs with null predicates.
//
ParserATNSimulator.prototype.evalSemanticContext = function(predPredictions, outerContext, complete) {
    var predictions = new BitSet();
    for(var i=0;i<predPredictions.length;i++) {
    	var pair = predPredictions[i];
        if (pair.pred === SemanticContext.NONE) {
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
            continue;
        }
        var predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
        if (this.debug || this.dfa_debug) {
            console.log("eval pred " + pair + "=" + predicateEvaluationResult);
        }
        if (predicateEvaluationResult) {
            if (this.debug || this.dfa_debug) {
                console.log("PREDICT " + pair.alt);
            }
            predictions.add(pair.alt);
            if (! complete) {
                break;
            }
        }
    }
    return predictions;
};

// TODO: If we are doing predicates, there is no point in pursuing
//     closure operations if we reach a DFA state that uniquely predicts
//     alternative. We will not be caching that DFA state and it is a
//     waste to pursue the closure. Might have to advance when we do
//     ambig detection thought :(
//

ParserATNSimulator.prototype.closure = function(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    var initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates,
                             fullCtx, initialDepth, treatEofAsEpsilon);
};


ParserATNSimulator.prototype.closureCheckingStopState = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
        console.log("closure(" + config.toString(this.parser,true) + ")");
        // console.log("configs(" + configs.toString() + ")");
        if(config.reachesIntoOuterContext>50) {
            throw "problem";
        }
    }
    if (config.state instanceof RuleStopState) {
        // We hit rule end. If we have context info, use it
        // run thru all possible stack tops in ctx
        if (! config.context.isEmpty()) {
            for ( var i =0; i<config.context.length; i++) {
                if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
                    if (fullCtx) {
                        configs.add(new ATNConfig({state:config.state, context:PredictionContext.EMPTY}, config), this.mergeCache);
                        continue;
                    } else {
                        // we have no context info, just chase follow links (if greedy)
                        if (this.debug) {
                            console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                        }
                        this.closure_(config, configs, closureBusy, collectPredicates,
                                 fullCtx, depth, treatEofAsEpsilon);
                    }
                    continue;
                }
                var returnState = this.atn.states[config.context.getReturnState(i)];
                var newContext = config.context.getParent(i); // "pop" return state
                var parms = {state:returnState, alt:config.alt, context:newContext, semanticContext:config.semanticContext};
                var c = new ATNConfig(parms, null);
                // While we have context to pop back from, we may have
                // gotten that context AFTER having falling off a rule.
                // Make sure we track that we are now out of context.
                c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
            }
            return;
        } else if( fullCtx) {
            // reached end of start rule
            configs.add(config, this.mergeCache);
            return;
        } else {
            // else if we have no context info, just chase follow links (if greedy)
            if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
            }
        }
    }
    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
};


// Do the actual work of walking epsilon edges//
ParserATNSimulator.prototype.closure_ = function(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    var p = config.state;
    // optimization
    if (! p.epsilonOnlyTransitions) {
        configs.add(config, this.mergeCache);
        // make sure to not return here, because EOF transitions can act as
        // both epsilon transitions and non-epsilon transitions.
    }
    for(var i = 0;i<p.transitions.length; i++) {
        if(i==0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
            continue;

        var t = p.transitions[i];
        var continueCollecting = collectPredicates && !(t instanceof ActionTransition);
        var c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
        if (c!==null) {
            var newDepth = depth;
            if ( config.state instanceof RuleStopState) {
                // target fell off end of rule; mark resulting c as having dipped into outer context
                // We can't get here if incoming config was rule stop and we had context
                // track how far we dip into outer context.  Might
                // come in handy and we avoid evaluating context dependent
                // preds if this is > 0.
				if (this._dfa !== null && this._dfa.precedenceDfa) {
					if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
						c.precedenceFilterSuppressed = true;
					}
				}

                c.reachesIntoOuterContext += 1;
                if (closureBusy.add(c)!==c) {
                    // avoid infinite recursion for right-recursive rules
                    continue;
                }
                configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                newDepth -= 1;
                if (this.debug) {
                    console.log("dips into outer ctx: " + c);
                }
            } else {
                if (!t.isEpsilon && closureBusy.add(c)!==c){
                    // avoid infinite recursion for EOF* and EOF+
                    continue;
                }
                if (t instanceof RuleTransition) {
                    // latch when newDepth goes negative - once we step out of the entry context we can't return
                    if (newDepth >= 0) {
                        newDepth += 1;
                    }
                }
            }
            this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
        }
    }
};


ParserATNSimulator.prototype.canDropLoopEntryEdgeInLeftRecursiveRule = function(config) {
    // return False
    var p = config.state;
    // First check to see if we are in StarLoopEntryState generated during
    // left-recursion elimination. For efficiency, also check if
    // the context has an empty stack case. If so, it would mean
    // global FOLLOW so we can't perform optimization
    // Are we the special loop entry/exit state? or SLL wildcard
    if(p.stateType != ATNState.STAR_LOOP_ENTRY)
        return false;
    if(p.stateType != ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||
           config.context.isEmpty() || config.context.hasEmptyPath())
        return false;

    // Require all return states to return back to the same rule that p is in.
    var numCtxs = config.context.length;
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnState = this.atn.states[config.context.getReturnState(i)];
        if (returnState.ruleIndex != p.ruleIndex)
            return false;
    }

    var decisionStartState = p.transitions[0].target;
    var blockEndStateNum = decisionStartState.endState.stateNumber;
    var blockEndState = this.atn.states[blockEndStateNum];

    // Verify that the top of each stack context leads to loop entry/exit
    // state through epsilon edges and w/o leaving rule.
    for(var i=0; i<numCtxs; i++) { // for each stack context
        var returnStateNumber = config.context.getReturnState(i);
        var returnState = this.atn.states[returnStateNumber];
        // all states must have single outgoing epsilon edge
        if (returnState.transitions.length != 1 || !returnState.transitions[0].isEpsilon)
            return false;

        // Look for prefix op case like 'not expr', (' type ')' expr
        var returnStateTarget = returnState.transitions[0].target;
        if ( returnState.stateType == ATNState.BLOCK_END && returnStateTarget == p )
            continue;

        // Look for 'expr op expr' or case where expr's return state is block end
        // of (...)* internal block; the block end points to loop back
        // which points to p but we don't need to check that
        if ( returnState == blockEndState )
            continue;

        // Look for ternary expr ? expr : expr. The return state points at block end,
        // which points at loop entry state
        if ( returnStateTarget == blockEndState )
            continue;

        // Look for complex prefix 'between expr and expr' case where 2nd expr's
        // return state points at block end state of (...)* internal block
        if (returnStateTarget.stateType == ATNState.BLOCK_END && returnStateTarget.transitions.length == 1
                && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target == p)
            continue;

        // anything else ain't conforming
        return false;
    }
    return true;
};


ParserATNSimulator.prototype.getRuleName = function( index) {
    if (this.parser!==null && index>=0) {
        return this.parser.ruleNames[index];
    } else {
        return "<rule " + index + ">";
    }
};

ParserATNSimulator.prototype.getEpsilonTarget = function(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch(t.serializationType) {
    case Transition.RULE:
        return this.ruleTransition(config, t);
    case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
    case Transition.ACTION:
        return this.actionTransition(config, t);
    case Transition.EPSILON:
        return new ATNConfig({state:t.target}, config);
    case Transition.ATOM:
    case Transition.RANGE:
    case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
            if (t.matches(Token.EOF, 0, 1)) {
                return new ATNConfig({state: t.target}, config);
            }
        }
        return null;
    default:
    	return null;
    }
};

ParserATNSimulator.prototype.actionTransition = function(config, t) {
    if (this.debug) {
        var index = t.actionIndex==-1 ? 65535 : t.actionIndex;
        console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }
    return new ATNConfig({state:t.target}, config);
};

ParserATNSimulator.prototype.precedenceTransition = function(config, pt,  collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                pt.precedence + ">=_p, ctx dependent=true");
        if (this.parser!==null) {
        	console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && inContext) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.predTransition = function(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
        console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
        if (this.parser!==null) {
            console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
        }
    }
    var c = null;
    if (collectPredicates && ((pt.isCtxDependent && inContext) || ! pt.isCtxDependent)) {
        if (fullCtx) {
            // In full context mode, we can evaluate predicates on-the-fly
            // during closure, which dramatically reduces the size of
            // the config sets. It also obviates the need to test predicates
            // later during conflict resolution.
            var currentPosition = this._input.index;
            this._input.seek(this._startIndex);
            var predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
            this._input.seek(currentPosition);
            if (predSucceeds) {
                c = new ATNConfig({state:pt.target}, config); // no pred context
            }
        } else {
            var newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
            c = new ATNConfig({state:pt.target, semanticContext:newSemCtx}, config);
        }
    } else {
        c = new ATNConfig({state:pt.target}, config);
    }
    if (this.debug) {
        console.log("config from pred transition=" + c);
    }
    return c;
};

ParserATNSimulator.prototype.ruleTransition = function(config, t) {
    if (this.debug) {
        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }
    var returnState = t.followState;
    var newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({state:t.target, context:newContext}, config );
};

ParserATNSimulator.prototype.getConflictingAlts = function(configs) {
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
};

 // Sam pointed out a problem with the previous definition, v3, of
 // ambiguous states. If we have another state associated with conflicting
 // alternatives, we should keep going. For example, the following grammar
 //
 // s : (ID | ID ID?) ';' ;
 //
 // When the ATN simulation reaches the state before ';', it has a DFA
 // state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
 // 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
 // because alternative to has another way to continue, via [6|2|[]].
 // The key is that we have a single state that has config's only associated
 // with a single alternative, 2, and crucially the state transitions
 // among the configurations are all non-epsilon transitions. That means
 // we don't consider any conflicts that include alternative 2. So, we
 // ignore the conflict between alts 1 and 2. We ignore a set of
 // conflicting alts when there is an intersection with an alternative
 // associated with a single alt state in the state&rarr;config-list map.
 //
 // It's also the case that we might have two conflicting configurations but
 // also a 3rd nonconflicting configuration for a different alternative:
 // [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
 //
 // a : A | A | A B ;
 //
 // After matching input A, we reach the stop state for rule A, state 1.
 // State 8 is the state right before B. Clearly alternatives 1 and 2
 // conflict and no amount of further lookahead will separate the two.
 // However, alternative 3 will be able to continue and so we do not
 // stop working on this state. In the previous example, we're concerned
 // with states associated with the conflicting alternatives. Here alt
 // 3 is not associated with the conflicting configs, but since we can continue
 // looking for input reasonably, I don't declare the state done. We
 // ignore a set of conflicting alts when we have an alternative
 // that we still need to pursue.
//

ParserATNSimulator.prototype.getConflictingAltsOrUniqueAlt = function(configs) {
    var conflictingAlts = null;
    if (configs.uniqueAlt!== ATN.INVALID_ALT_NUMBER) {
        conflictingAlts = new BitSet();
        conflictingAlts.add(configs.uniqueAlt);
    } else {
        conflictingAlts = configs.conflictingAlts;
    }
    return conflictingAlts;
};

ParserATNSimulator.prototype.getTokenName = function( t) {
    if (t===Token.EOF) {
        return "EOF";
    }
    if( this.parser!==null && this.parser.literalNames!==null) {
        if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
            console.log("" + t + " ttype out of range: " + this.parser.literalNames);
            console.log("" + this.parser.getInputStream().getTokens());
        } else {
            var name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
            return name + "<" + t + ">";
        }
    }
    return "" + t;
};

ParserATNSimulator.prototype.getLookaheadName = function(input) {
    return this.getTokenName(input.LA(1));
};

// Used for debugging in adaptivePredict around execATN but I cut
//  it out for clarity now that alg. works well. We can leave this
//  "dead" code for a bit.
//
ParserATNSimulator.prototype.dumpDeadEndConfigs = function(nvae) {
    console.log("dead end configs: ");
    var decs = nvae.getDeadEndConfigs();
    for(var i=0; i<decs.length; i++) {
    	var c = decs[i];
        var trans = "no edges";
        if (c.state.transitions.length>0) {
            var t = c.state.transitions[0];
            if (t instanceof AtomTransition) {
                trans = "Atom "+ this.getTokenName(t.label);
            } else if (t instanceof SetTransition) {
                var neg = (t instanceof NotSetTransition);
                trans = (neg ? "~" : "") + "Set " + t.set;
            }
        }
        console.error(c.toString(this.parser, true) + ":" + trans);
    }
};

ParserATNSimulator.prototype.noViableAlt = function(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
};

ParserATNSimulator.prototype.getUniqueAlt = function(configs) {
    var alt = ATN.INVALID_ALT_NUMBER;
    for(var i=0;i<configs.items.length;i++) {
    	var c = configs.items[i];
        if (alt === ATN.INVALID_ALT_NUMBER) {
            alt = c.alt // found first alt
        } else if( c.alt!==alt) {
            return ATN.INVALID_ALT_NUMBER;
        }
    }
    return alt;
};

//
// Add an edge to the DFA, if possible. This method calls
// {@link //addDFAState} to ensure the {@code to} state is present in the
// DFA. If {@code from} is {@code null}, or if {@code t} is outside the
// range of edges that can be represented in the DFA tables, this method
// returns without adding the edge to the DFA.
//
// <p>If {@code to} is {@code null}, this method returns {@code null}.
// Otherwise, this method returns the {@link DFAState} returned by calling
// {@link //addDFAState} for the {@code to} state.</p>
//
// @param dfa The DFA
// @param from The source state for the edge
// @param t The input symbol
// @param to The target state for the edge
//
// @return If {@code to} is {@code null}, this method returns {@code null};
// otherwise this method returns the result of calling {@link //addDFAState}
// on {@code to}
//
ParserATNSimulator.prototype.addDFAEdge = function(dfa, from_, t, to) {
    if( this.debug) {
        console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }
    if (to===null) {
        return null;
    }
    to = this.addDFAState(dfa, to); // used existing if possible not incoming
    if (from_===null || t < -1 || t > this.atn.maxTokenType) {
        return to;
    }
    if (from_.edges===null) {
        from_.edges = [];
    }
    from_.edges[t+1] = to; // connect

    if (this.debug) {
        var literalNames = this.parser===null ? null : this.parser.literalNames;
        var symbolicNames = this.parser===null ? null : this.parser.symbolicNames;
        console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }
    return to;
};
//
// Add state {@code D} to the DFA if it is not already present, and return
// the actual instance stored in the DFA. If a state equivalent to {@code D}
// is already in the DFA, the existing state is returned. Otherwise this
// method returns {@code D} after adding it to the DFA.
//
// <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
// does not change the DFA.</p>
//
// @param dfa The dfa
// @param D The DFA state to add
// @return The state stored in the DFA. This will be either the existing
// state if {@code D} is already in the DFA, or {@code D} itself if the
// state was not already present.
//
ParserATNSimulator.prototype.addDFAState = function(dfa, D) {
    if (D == ATNSimulator.ERROR) {
        return D;
    }
    var existing = dfa.states.get(D);
    if(existing!==null) {
        return existing;
    }
    D.stateNumber = dfa.states.length;
    if (! D.configs.readOnly) {
        D.configs.optimizeConfigs(this);
        D.configs.setReadonly(true);
    }
    dfa.states.add(D);
    if (this.debug) {
        console.log("adding new DFA state: " + D);
    }
    return D;
};

ParserATNSimulator.prototype.reportAttemptingFullContext = function(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
};

ParserATNSimulator.prototype.reportContextSensitivity = function(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
};

// If context sensitive parsing, we know it's ambiguity not conflict//
ParserATNSimulator.prototype.reportAmbiguity = function(dfa, D, startIndex, stopIndex,
                               exact, ambigAlts, configs ) {
    if (this.debug || this.retry_debug) {
        var interval = new Interval(startIndex, stopIndex + 1);
        console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                           ", input=" + this.parser.getTokenStream().getText(interval));
    }
    if (this.parser!==null) {
        this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
};

exports.ParserATNSimulator = ParserATNSimulator;

/***/ }),

/***/ "./node_modules/antlr4/atn/PredictionMode.js":
/*!***************************************************!*\
  !*** ./node_modules/antlr4/atn/PredictionMode.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//
//
// This enumeration defines the prediction modes available in ANTLR 4 along with
// utility methods for analyzing configuration sets for conflicts and/or
// ambiguities.

var Set = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").Set;
var Map = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").Map;
var BitSet = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").BitSet;
var AltDict = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").AltDict;
var ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
var RuleStopState = __webpack_require__(/*! ./ATNState */ "./node_modules/antlr4/atn/ATNState.js").RuleStopState;
var ATNConfigSet = __webpack_require__(/*! ./ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var ATNConfig = __webpack_require__(/*! ./ATNConfig */ "./node_modules/antlr4/atn/ATNConfig.js").ATNConfig;
var SemanticContext = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").SemanticContext;
var Hash = __webpack_require__(/*! ../Utils */ "./node_modules/antlr4/Utils.js").Hash;
var hashStuff = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").hashStuff;
var equalArrays = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").equalArrays;

function PredictionMode() {
	return this;
}

//
// The SLL(*) prediction mode. This prediction mode ignores the current
// parser context when making predictions. This is the fastest prediction
// mode, and provides correct results for many grammars. This prediction
// mode is more powerful than the prediction mode provided by ANTLR 3, but
// may result in syntax errors for grammar and input combinations which are
// not SLL.
//
// <p>
// When using this prediction mode, the parser will either return a correct
// parse tree (i.e. the same parse tree that would be returned with the
// {@link //LL} prediction mode), or it will report a syntax error. If a
// syntax error is encountered when using the {@link //SLL} prediction mode,
// it may be due to either an actual syntax error in the input or indicate
// that the particular combination of grammar and input requires the more
// powerful {@link //LL} prediction abilities to complete successfully.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.SLL = 0;
//
// The LL(*) prediction mode. This prediction mode allows the current parser
// context to be used for resolving SLL conflicts that occur during
// prediction. This is the fastest prediction mode that guarantees correct
// parse results for all combinations of grammars with syntactically correct
// inputs.
//
// <p>
// When using this prediction mode, the parser will make correct decisions
// for all syntactically-correct grammar and input combinations. However, in
// cases where the grammar is truly ambiguous this prediction mode might not
// report a precise answer for <em>exactly which</em> alternatives are
// ambiguous.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL = 1;
//
// The LL(*) prediction mode with exact ambiguity detection. In addition to
// the correctness guarantees provided by the {@link //LL} prediction mode,
// this prediction mode instructs the prediction algorithm to determine the
// complete and exact set of ambiguous alternatives for every ambiguous
// decision encountered while parsing.
//
// <p>
// This prediction mode may be used for diagnosing ambiguities during
// grammar development. Due to the performance overhead of calculating sets
// of ambiguous alternatives, this prediction mode should be avoided when
// the exact results are not necessary.</p>
//
// <p>
// This prediction mode does not provide any guarantees for prediction
// behavior for syntactically-incorrect inputs.</p>
//
PredictionMode.LL_EXACT_AMBIG_DETECTION = 2;


//
// Computes the SLL prediction termination condition.
//
// <p>
// This method computes the SLL prediction termination condition for both of
// the following cases.</p>
//
// <ul>
// <li>The usual SLL+LL fallback upon SLL conflict</li>
// <li>Pure SLL without LL fallback</li>
// </ul>
//
// <p><strong>COMBINED SLL+LL PARSING</strong></p>
//
// <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
// ensured regardless of how the termination condition is computed by this
// method. Due to the substantially higher cost of LL prediction, the
// prediction should only fall back to LL when the additional lookahead
// cannot lead to a unique SLL prediction.</p>
//
// <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
// conflicting subsets should fall back to full LL, even if the
// configuration sets don't resolve to the same alternative (e.g.
// {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
// configuration, SLL could continue with the hopes that more lookahead will
// resolve via one of those non-conflicting configurations.</p>
//
// <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
// stops when it sees only conflicting configuration subsets. In contrast,
// full LL keeps going when there is uncertainty.</p>
//
// <p><strong>HEURISTIC</strong></p>
//
// <p>As a heuristic, we stop prediction when we see any conflicting subset
// unless we see a state that only has one alternative associated with it.
// The single-alt-state thing lets prediction continue upon rules like
// (otherwise, it would admit defeat too soon):</p>
//
// <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
//
// <p>When the ATN simulation reaches the state before {@code ';'}, it has a
// DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
// {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
// processing this node because alternative to has another way to continue,
// via {@code [6|2|[]]}.</p>
//
// <p>It also let's us continue for this rule:</p>
//
// <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
//
// <p>After matching input A, we reach the stop state for rule A, state 1.
// State 8 is the state right before B. Clearly alternatives 1 and 2
// conflict and no amount of further lookahead will separate the two.
// However, alternative 3 will be able to continue and so we do not stop
// working on this state. In the previous example, we're concerned with
// states associated with the conflicting alternatives. Here alt 3 is not
// associated with the conflicting configs, but since we can continue
// looking for input reasonably, don't declare the state done.</p>
//
// <p><strong>PURE SLL PARSING</strong></p>
//
// <p>To handle pure SLL parsing, all we have to do is make sure that we
// combine stack contexts for configurations that differ only by semantic
// predicate. From there, we can do the usual SLL termination heuristic.</p>
//
// <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
//
// <p>SLL decisions don't evaluate predicates until after they reach DFA stop
// states because they need to create the DFA cache that works in all
// semantic situations. In contrast, full LL evaluates predicates collected
// during start state computation so it can ignore predicates thereafter.
// This means that SLL termination detection can totally ignore semantic
// predicates.</p>
//
// <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
// semantic predicate contexts so we might see two configurations like the
// following.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
//
// <p>Before testing these configurations against others, we have to merge
// {@code x} and {@code x'} (without modifying the existing configurations).
// For example, we test {@code (x+x')==x''} when looking for conflicts in
// the following configurations.</p>
//
// <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
//
// <p>If the configuration set has predicates (as indicated by
// {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
// the configurations to strip out all of the predicates so that a standard
// {@link ATNConfigSet} will merge everything ignoring predicates.</p>
//
PredictionMode.hasSLLConflictTerminatingPrediction = function( mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
        return true;
    }
    // pure SLL mode parsing
    if (mode === PredictionMode.SLL) {
        // Don't bother with combining configs from different semantic
        // contexts if we can fail over to full LL; costs more time
        // since we'll often fail over anyway.
        if (configs.hasSemanticContext) {
            // dup configs, tossing out semantic predicates
            var dup = new ATNConfigSet();
            for(var i=0;i<configs.items.length;i++) {
            	var c = configs.items[i];
                c = new ATNConfig({semanticContext:SemanticContext.NONE}, c);
                dup.add(c);
            }
            configs = dup;
        }
        // now we have combined contexts for configs with dissimilar preds
    }
    // pure SLL or combined SLL+LL mode parsing
    var altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
};

// Checks if any configuration in {@code configs} is in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if any configuration in {@code configs} is in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.hasConfigInRuleStopState = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (c.state instanceof RuleStopState) {
            return true;
        }
	}
    return false;
};

// Checks if all configurations in {@code configs} are in a
// {@link RuleStopState}. Configurations meeting this condition have reached
// the end of the decision rule (local context) or end of start rule (full
// context).
//
// @param configs the configuration set to test
// @return {@code true} if all configurations in {@code configs} are in a
// {@link RuleStopState}, otherwise {@code false}
PredictionMode.allConfigsInRuleStopStates = function(configs) {
	for(var i=0;i<configs.items.length;i++) {
		var c = configs.items[i];
        if (!(c.state instanceof RuleStopState)) {
            return false;
        }
	}
    return true;
};

//
// Full LL prediction termination.
//
// <p>Can we stop looking ahead during ATN simulation or is there some
// uncertainty as to which alternative we will ultimately pick, after
// consuming more input? Even if there are partial conflicts, we might know
// that everything is going to resolve to the same minimum alternative. That
// means we can stop since no more lookahead will change that fact. On the
// other hand, there might be multiple conflicts that resolve to different
// minimums. That means we need more look ahead to decide which of those
// alternatives we should predict.</p>
//
// <p>The basic idea is to split the set of configurations {@code C}, into
// conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
// non-conflicting configurations. Two configurations conflict if they have
// identical {@link ATNConfig//state} and {@link ATNConfig//context} values
// but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
// and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
//
// <p>Reduce these configuration subsets to the set of possible alternatives.
// You can compute the alternative subsets in one pass as follows:</p>
//
// <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
// {@code C} holding {@code s} and {@code ctx} fixed.</p>
//
// <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>
//
// <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
//
// <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
// {@code s} and {@code ctx}.</p>
//
// <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
// the union of these alternative subsets is a singleton, then no amount of
// more lookahead will help us. We will always pick that alternative. If,
// however, there is more than one alternative, then we are uncertain which
// alternative to predict and must continue looking for resolution. We may
// or may not discover an ambiguity in the future, even if there are no
// conflicting subsets this round.</p>
//
// <p>The biggest sin is to terminate early because it means we've made a
// decision but were uncertain as to the eventual outcome. We haven't used
// enough lookahead. On the other hand, announcing a conflict too late is no
// big deal; you will still have the conflict. It's just inefficient. It
// might even look until the end of file.</p>
//
// <p>No special consideration for semantic predicates is required because
// predicates are evaluated on-the-fly for full LL prediction, ensuring that
// no configuration contains a semantic context during the termination
// check.</p>
//
// <p><strong>CONFLICTING CONFIGS</strong></p>
//
// <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
// when {@code i!=j} but {@code x=x'}. Because we merge all
// {@code (s, i, _)} configurations together, that means that there are at
// most {@code n} configurations associated with state {@code s} for
// {@code n} possible alternatives in the decision. The merged stacks
// complicate the comparison of configuration contexts {@code x} and
// {@code x'}. Sam checks to see if one is a subset of the other by calling
// merge and checking to see if the merged result is either {@code x} or
// {@code x'}. If the {@code x} associated with lowest alternative {@code i}
// is the superset, then {@code i} is the only possible prediction since the
// others resolve to {@code min(i)} as well. However, if {@code x} is
// associated with {@code j>i} then at least one stack configuration for
// {@code j} is not in conflict with alternative {@code i}. The algorithm
// should keep going, looking for more lookahead due to the uncertainty.</p>
//
// <p>For simplicity, I'm doing a equality check between {@code x} and
// {@code x'} that lets the algorithm continue to consume lookahead longer
// than necessary. The reason I like the equality is of course the
// simplicity but also because that is the test you need to detect the
// alternatives that are actually in conflict.</p>
//
// <p><strong>CONTINUE/STOP RULE</strong></p>
//
// <p>Continue if union of resolved alternative sets from non-conflicting and
// conflicting alternative subsets has more than one alternative. We are
// uncertain about which alternative to predict.</p>
//
// <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
// alternatives are still in the running for the amount of input we've
// consumed at this point. The conflicting sets let us to strip away
// configurations that won't lead to more states because we resolve
// conflicts to the configuration with a minimum alternate for the
// conflicting set.</p>
//
// <p><strong>CASES</strong></p>
//
// <ul>
//
// <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
//
// <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
// {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
// {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1,3}} =&gt; continue
// </li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
// {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
// {@code {1}} =&gt; stop and predict 1</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
// {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
// ambiguity {@code {1,2}}</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
// {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {2}} = {@code {1,2}} =&gt; continue</li>
//
// <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
// {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
// {@code {3}} = {@code {1,3}} =&gt; continue</li>
//
// </ul>
//
// <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
//
// <p>If all states report the same conflicting set of alternatives, then we
// know we have the exact ambiguity set.</p>
//
// <p><code>|A_<em>i</em>|&gt;1</code> and
// <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
//
// <p>In other words, we continue examining lookahead until all {@code A_i}
// have more than one alternative and all {@code A_i} are the same. If
// {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
// because the resolved set is {@code {1}}. To determine what the real
// ambiguity is, we have to know whether the ambiguity is between one and
// two or one and three so we keep going. We can only stop prediction when
// we need exact ambiguity detection when the sets look like
// {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
//
PredictionMode.resolvesToJustOneViableAlt = function(altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
};

//
// Determines if every alternative subset in {@code altsets} contains more
// than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every {@link BitSet} in {@code altsets} has
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.allSubsetsConflict = function(altsets) {
    return ! PredictionMode.hasNonConflictingAltSet(altsets);
};
//
// Determines if any single alternative subset in {@code altsets} contains
// exactly one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
//
PredictionMode.hasNonConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length===1) {
            return true;
        }
	}
    return false;
};

//
// Determines if any single alternative subset in {@code altsets} contains
// more than one alternative.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if {@code altsets} contains a {@link BitSet} with
// {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
//
PredictionMode.hasConflictingAltSet = function(altsets) {
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (alts.length>1) {
            return true;
        }
	}
    return false;
};

//
// Determines if every alternative subset in {@code altsets} is equivalent.
//
// @param altsets a collection of alternative subsets
// @return {@code true} if every member of {@code altsets} is equal to the
// others, otherwise {@code false}
//
PredictionMode.allSubsetsEqual = function(altsets) {
    var first = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        if (first === null) {
            first = alts;
        } else if (alts!==first) {
            return false;
        }
	}
    return true;
};

//
// Returns the unique alternative predicted by all alternative subsets in
// {@code altsets}. If no such alternative exists, this method returns
// {@link ATN//INVALID_ALT_NUMBER}.
//
// @param altsets a collection of alternative subsets
//
PredictionMode.getUniqueAlt = function(altsets) {
    var all = PredictionMode.getAlts(altsets);
    if (all.length===1) {
        return all.minValue();
    } else {
        return ATN.INVALID_ALT_NUMBER;
    }
};

// Gets the complete set of represented alternatives for a collection of
// alternative subsets. This method returns the union of each {@link BitSet}
// in {@code altsets}.
//
// @param altsets a collection of alternative subsets
// @return the set of represented alternatives in {@code altsets}
//
PredictionMode.getAlts = function(altsets) {
    var all = new BitSet();
    altsets.map( function(alts) { all.or(alts); });
    return all;
};

//
// This function gets the conflicting alt subsets from a configuration set.
// For each configuration {@code c} in {@code configs}:
//
// <pre>
// map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
// alt and not pred
// </pre>

PredictionMode.getConflictingAltSubsets = function(configs) {
    var configToAlts = new Map();
    configToAlts.hashFunction = function(cfg) { hashStuff(cfg.state.stateNumber, cfg.context); };
    configToAlts.equalsFunction = function(c1, c2) { return c1.state.stateNumber==c2.state.stateNumber && c1.context.equals(c2.context);}
    configs.items.map(function(cfg) {
        var alts = configToAlts.get(cfg);
        if (alts === null) {
            alts = new BitSet();
            configToAlts.put(cfg, alts);
        }
        alts.add(cfg.alt);
	});
    return configToAlts.getValues();
};

//
// Get a map from state to alt subset from a configuration set. For each
// configuration {@code c} in {@code configs}:
//
// <pre>
// map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
// </pre>
//
PredictionMode.getStateToAltMap = function(configs) {
    var m = new AltDict();
    configs.items.map(function(c) {
        var alts = m.get(c.state);
        if (alts === null) {
            alts = new BitSet();
            m.put(c.state, alts);
        }
        alts.add(c.alt);
    });
    return m;
};

PredictionMode.hasStateAssociatedWithOneAlt = function(configs) {
    var values = PredictionMode.getStateToAltMap(configs).values();
    for(var i=0;i<values.length;i++) {
        if (values[i].length===1) {
            return true;
        }
    }
    return false;
};

PredictionMode.getSingleViableAlt = function(altsets) {
    var result = null;
	for(var i=0;i<altsets.length;i++) {
		var alts = altsets[i];
        var minAlt = alts.minValue();
        if(result===null) {
            result = minAlt;
        } else if(result!==minAlt) { // more than 1 viable alt
            return ATN.INVALID_ALT_NUMBER;
        }
	}
    return result;
};

exports.PredictionMode = PredictionMode;


/***/ }),

/***/ "./node_modules/antlr4/atn/SemanticContext.js":
/*!****************************************************!*\
  !*** ./node_modules/antlr4/atn/SemanticContext.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

// A tree structure used to record the semantic context in which
//  an ATN configuration is valid.  It's either a single predicate,
//  a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
//
//  <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
//  {@link SemanticContext} within the scope of this outer class.</p>
//

var Set = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").Set;
var Hash = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").Hash;

function SemanticContext() {
	return this;
}

SemanticContext.prototype.hashCode = function() {
    var hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
};

// For context independent predicates, we evaluate them without a local
// context (i.e., null context). That way, we can evaluate them without
// having to create proper rule-specific context during prediction (as
// opposed to the parser, which creates them naturally). In a practical
// sense, this avoids a cast exception from RuleContext to myruleContext.
//
// <p>For context dependent predicates, we must pass in a local context so that
// references such as $arg evaluate properly as _localctx.arg. We only
// capture context dependent predicates in the context in which we begin
// prediction, so we passed in the outer context here in case of context
// dependent predicate evaluation.</p>
//
SemanticContext.prototype.evaluate = function(parser, outerContext) {
};

//
// Evaluate the precedence predicates for the context and reduce the result.
//
// @param parser The parser instance.
// @param outerContext The current parser context object.
// @return The simplified semantic context after precedence predicates are
// evaluated, which will be one of the following values.
// <ul>
// <li>{@link //NONE}: if the predicate simplifies to {@code true} after
// precedence predicates are evaluated.</li>
// <li>{@code null}: if the predicate simplifies to {@code false} after
// precedence predicates are evaluated.</li>
// <li>{@code this}: if the semantic context is not changed as a result of
// precedence predicate evaluation.</li>
// <li>A non-{@code null} {@link SemanticContext}: the new simplified
// semantic context after precedence predicates are evaluated.</li>
// </ul>
//
SemanticContext.prototype.evalPrecedence = function(parser, outerContext) {
	return this;
};

SemanticContext.andContext = function(a, b) {
	if (a === null || a === SemanticContext.NONE) {
		return b;
	}
	if (b === null || b === SemanticContext.NONE) {
		return a;
	}
	var result = new AND(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

SemanticContext.orContext = function(a, b) {
	if (a === null) {
		return b;
	}
	if (b === null) {
		return a;
	}
	if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
		return SemanticContext.NONE;
	}
	var result = new OR(a, b);
	if (result.opnds.length === 1) {
		return result.opnds[0];
	} else {
		return result;
	}
};

function Predicate(ruleIndex, predIndex, isCtxDependent) {
	SemanticContext.call(this);
	this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
	this.predIndex = predIndex === undefined ? -1 : predIndex;
	this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
	return this;
}

Predicate.prototype = Object.create(SemanticContext.prototype);
Predicate.prototype.constructor = Predicate;

//The default {@link SemanticContext}, which is semantically equivalent to
//a predicate of the form {@code {true}?}.
//
SemanticContext.NONE = new Predicate();


Predicate.prototype.evaluate = function(parser, outerContext) {
	var localctx = this.isCtxDependent ? outerContext : null;
	return parser.sempred(localctx, this.ruleIndex, this.predIndex);
};

Predicate.prototype.updateHashCode = function(hash) {
	hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

Predicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof Predicate)) {
		return false;
	} else {
		return this.ruleIndex === other.ruleIndex &&
				this.predIndex === other.predIndex &&
				this.isCtxDependent === other.isCtxDependent;
	}
};

Predicate.prototype.toString = function() {
	return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
};

function PrecedencePredicate(precedence) {
	SemanticContext.call(this);
	this.precedence = precedence === undefined ? 0 : precedence;
}

PrecedencePredicate.prototype = Object.create(SemanticContext.prototype);
PrecedencePredicate.prototype.constructor = PrecedencePredicate;

PrecedencePredicate.prototype.evaluate = function(parser, outerContext) {
	return parser.precpred(outerContext, this.precedence);
};

PrecedencePredicate.prototype.evalPrecedence = function(parser, outerContext) {
	if (parser.precpred(outerContext, this.precedence)) {
		return SemanticContext.NONE;
	} else {
		return null;
	}
};

PrecedencePredicate.prototype.compareTo = function(other) {
	return this.precedence - other.precedence;
};

PrecedencePredicate.prototype.updateHashCode = function(hash) {
    hash.update(31);
};

PrecedencePredicate.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof PrecedencePredicate)) {
		return false;
	} else {
		return this.precedence === other.precedence;
	}
};

PrecedencePredicate.prototype.toString = function() {
	return "{"+this.precedence+">=prec}?";
};



PrecedencePredicate.filterPrecedencePredicates = function(set) {
	var result = [];
	set.values().map( function(context) {
		if (context instanceof PrecedencePredicate) {
			result.push(context);
		}
	});
	return result;
};


// A semantic context which is true whenever none of the contained contexts
// is false.
//
function AND(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof AND) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof AND) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}
	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the lowest precedence
		var reduced = null;
		precedencePredicates.map( function(p) {
			if(reduced===null || p.precedence<reduced.precedence) {
				reduced = p;
			}
		});
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

AND.prototype = Object.create(SemanticContext.prototype);
AND.prototype.constructor = AND;

AND.prototype.equals = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof AND)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

AND.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "AND");
};
//
// {@inheritDoc}
//
// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
AND.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (!this.opnds[i].evaluate(parser, outerContext)) {
			return false;
		}
	}
	return true;
};

AND.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === null) {
			// The AND context is false if any element is false
			return null;
		} else if (evaluated !== SemanticContext.NONE) {
			// Reduce the result by skipping true elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were true, so the AND context is true
		return SemanticContext.NONE;
	}
	var result = null;
	operands.map(function(o) {
		result = result === null ? o : SemanticContext.andContext(result, o);
	});
	return result;
};

AND.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "&& " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

//
// A semantic context which is true whenever at least one of the contained
// contexts is true.
//
function OR(a, b) {
	SemanticContext.call(this);
	var operands = new Set();
	if (a instanceof OR) {
		a.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(a);
	}
	if (b instanceof OR) {
		b.opnds.map(function(o) {
			operands.add(o);
		});
	} else {
		operands.add(b);
	}

	var precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);
	if (precedencePredicates.length > 0) {
		// interested in the transition with the highest precedence
		var s = precedencePredicates.sort(function(a, b) {
			return a.compareTo(b);
		});
		var reduced = s[s.length-1];
		operands.add(reduced);
	}
	this.opnds = operands.values();
	return this;
}

OR.prototype = Object.create(SemanticContext.prototype);
OR.prototype.constructor = OR;

OR.prototype.constructor = function(other) {
	if (this === other) {
		return true;
	} else if (!(other instanceof OR)) {
		return false;
	} else {
		return this.opnds === other.opnds;
	}
};

OR.prototype.updateHashCode = function(hash) {
    hash.update(this.opnds, "OR");
};

// <p>
// The evaluation of predicates by this context is short-circuiting, but
// unordered.</p>
//
OR.prototype.evaluate = function(parser, outerContext) {
	for (var i = 0; i < this.opnds.length; i++) {
		if (this.opnds[i].evaluate(parser, outerContext)) {
			return true;
		}
	}
	return false;
};

OR.prototype.evalPrecedence = function(parser, outerContext) {
	var differs = false;
	var operands = [];
	for (var i = 0; i < this.opnds.length; i++) {
		var context = this.opnds[i];
		var evaluated = context.evalPrecedence(parser, outerContext);
		differs |= (evaluated !== context);
		if (evaluated === SemanticContext.NONE) {
			// The OR context is true if any element is true
			return SemanticContext.NONE;
		} else if (evaluated !== null) {
			// Reduce the result by skipping false elements
			operands.push(evaluated);
		}
	}
	if (!differs) {
		return this;
	}
	if (operands.length === 0) {
		// all elements were false, so the OR context is false
		return null;
	}
	var result = null;
	operands.map(function(o) {
		return result === null ? o : SemanticContext.orContext(result, o);
	});
	return result;
};

OR.prototype.toString = function() {
	var s = "";
	this.opnds.map(function(o) {
		s += "|| " + o.toString();
	});
	return s.length > 3 ? s.slice(3) : s;
};

exports.SemanticContext = SemanticContext;
exports.PrecedencePredicate = PrecedencePredicate;
exports.Predicate = Predicate;


/***/ }),

/***/ "./node_modules/antlr4/atn/Transition.js":
/*!***********************************************!*\
  !*** ./node_modules/antlr4/atn/Transition.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//  An ATN transition between any two ATN states.  Subclasses define
//  atom, set, epsilon, action, predicate, rule transitions.
//
//  <p>This is a one way link.  It emanates from a state (usually via a list of
//  transitions) and has a target state.</p>
//
//  <p>Since we never have to change the ATN transitions once we construct it,
//  we can fix these transitions as specific classes. The DFA transitions
//  on the other hand need to update the labels as it adds transitions to
//  the states. We'll use the term Edge for the DFA to distinguish them from
//  ATN transitions.</p>

var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var IntervalSet = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").IntervalSet;
var Predicate = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").Predicate;
var PrecedencePredicate = __webpack_require__(/*! ./SemanticContext */ "./node_modules/antlr4/atn/SemanticContext.js").PrecedencePredicate;

function Transition (target) {
    // The target of this transition.
    if (target===undefined || target===null) {
        throw "target cannot be null.";
    }
    this.target = target;
    // Are we epsilon, action, sempred?
    this.isEpsilon = false;
    this.label = null;
    return this;
}
    // constants for serialization
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
Transition.PREDICATE = 4; // e.g., {isType(input.LT(1))}?
Transition.ATOM = 5;
Transition.ACTION = 6;
Transition.SET = 7; // ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;

Transition.serializationNames = [
            "INVALID",
            "EPSILON",
            "RANGE",
            "RULE",
            "PREDICATE",
            "ATOM",
            "ACTION",
            "SET",
            "NOT_SET",
            "WILDCARD",
            "PRECEDENCE"
        ];

Transition.serializationTypes = {
        EpsilonTransition: Transition.EPSILON,
        RangeTransition: Transition.RANGE,
        RuleTransition: Transition.RULE,
        PredicateTransition: Transition.PREDICATE,
        AtomTransition: Transition.ATOM,
        ActionTransition: Transition.ACTION,
        SetTransition: Transition.SET,
        NotSetTransition: Transition.NOT_SET,
        WildcardTransition: Transition.WILDCARD,
        PrecedencePredicateTransition: Transition.PRECEDENCE
    };


// TODO: make all transitions sets? no, should remove set edges
function AtomTransition(target, label) {
	Transition.call(this, target);
	this.label_ = label; // The token type or character value; or, signifies special label.
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
    return this;
}

AtomTransition.prototype = Object.create(Transition.prototype);
AtomTransition.prototype.constructor = AtomTransition;

AtomTransition.prototype.makeLabel = function() {
	var s = new IntervalSet();
    s.addOne(this.label_);
    return s;
};

AtomTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
    return this.label_ === symbol;
};

AtomTransition.prototype.toString = function() {
	return this.label_;
};

function RuleTransition(ruleStart, ruleIndex, precedence, followState) {
	Transition.call(this, ruleStart);
    this.ruleIndex = ruleIndex; // ptr to the rule definition object for this rule ref
    this.precedence = precedence;
    this.followState = followState; // what node to begin computations following ref to rule
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
    return this;
}

RuleTransition.prototype = Object.create(Transition.prototype);
RuleTransition.prototype.constructor = RuleTransition;

RuleTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};


function EpsilonTransition(target, outermostPrecedenceReturn) {
	Transition.call(this, target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    return this;
}

EpsilonTransition.prototype = Object.create(Transition.prototype);
EpsilonTransition.prototype.constructor = EpsilonTransition;

EpsilonTransition.prototype.matches = function( symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

EpsilonTransition.prototype.toString = function() {
	return "epsilon";
};

function RangeTransition(target, start, stop) {
	Transition.call(this, target);
	this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
    return this;
}

RangeTransition.prototype = Object.create(Transition.prototype);
RangeTransition.prototype.constructor = RangeTransition;

RangeTransition.prototype.makeLabel = function() {
    var s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
};

RangeTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= this.start && symbol <= this.stop;
};

RangeTransition.prototype.toString = function() {
	return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
};

function AbstractPredicateTransition(target) {
	Transition.call(this, target);
	return this;
}

AbstractPredicateTransition.prototype = Object.create(Transition.prototype);
AbstractPredicateTransition.prototype.constructor = AbstractPredicateTransition;

function PredicateTransition(target, ruleIndex, predIndex, isCtxDependent) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

PredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PredicateTransition.prototype.constructor = PredicateTransition;

PredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PredicateTransition.prototype.getPredicate = function() {
	return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
};

PredicateTransition.prototype.toString = function() {
	return "pred_" + this.ruleIndex + ":" + this.predIndex;
};

function ActionTransition(target, ruleIndex, actionIndex, isCtxDependent) {
	Transition.call(this, target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex===undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent===undefined ? false : isCtxDependent; // e.g., $i ref in pred
    this.isEpsilon = true;
    return this;
}

ActionTransition.prototype = Object.create(Transition.prototype);
ActionTransition.prototype.constructor = ActionTransition;


ActionTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

ActionTransition.prototype.toString = function() {
	return "action_" + this.ruleIndex + ":" + this.actionIndex;
};


// A transition containing a set of values.
function SetTransition(target, set) {
	Transition.call(this, target);
	this.serializationType = Transition.SET;
    if (set !==undefined && set !==null) {
        this.label = set;
    } else {
        this.label = new IntervalSet();
        this.label.addOne(Token.INVALID_TYPE);
    }
    return this;
}

SetTransition.prototype = Object.create(Transition.prototype);
SetTransition.prototype.constructor = SetTransition;

SetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return this.label.contains(symbol);
};


SetTransition.prototype.toString = function() {
	return this.label.toString();
};

function NotSetTransition(target, set) {
	SetTransition.call(this, target, set);
	this.serializationType = Transition.NOT_SET;
	return this;
}

NotSetTransition.prototype = Object.create(SetTransition.prototype);
NotSetTransition.prototype.constructor = NotSetTransition;

NotSetTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
			!SetTransition.prototype.matches.call(this, symbol, minVocabSymbol, maxVocabSymbol);
};

NotSetTransition.prototype.toString = function() {
	return '~' + SetTransition.prototype.toString.call(this);
};

function WildcardTransition(target) {
	Transition.call(this, target);
	this.serializationType = Transition.WILDCARD;
	return this;
}

WildcardTransition.prototype = Object.create(Transition.prototype);
WildcardTransition.prototype.constructor = WildcardTransition;


WildcardTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
};

WildcardTransition.prototype.toString = function() {
	return ".";
};

function PrecedencePredicateTransition(target, precedence) {
	AbstractPredicateTransition.call(this, target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
    return this;
}

PrecedencePredicateTransition.prototype = Object.create(AbstractPredicateTransition.prototype);
PrecedencePredicateTransition.prototype.constructor = PrecedencePredicateTransition;

PrecedencePredicateTransition.prototype.matches = function(symbol, minVocabSymbol,  maxVocabSymbol) {
	return false;
};

PrecedencePredicateTransition.prototype.getPredicate = function() {
	return new PrecedencePredicate(this.precedence);
};

PrecedencePredicateTransition.prototype.toString = function() {
	return this.precedence + " >= _p";
};

exports.Transition = Transition;
exports.AtomTransition = AtomTransition;
exports.SetTransition = SetTransition;
exports.NotSetTransition = NotSetTransition;
exports.RuleTransition = RuleTransition;
exports.ActionTransition = ActionTransition;
exports.EpsilonTransition = EpsilonTransition;
exports.RangeTransition = RangeTransition;
exports.WildcardTransition = WildcardTransition;
exports.PredicateTransition = PredicateTransition;
exports.PrecedencePredicateTransition = PrecedencePredicateTransition;
exports.AbstractPredicateTransition = AbstractPredicateTransition;

/***/ }),

/***/ "./node_modules/antlr4/atn/index.js":
/*!******************************************!*\
  !*** ./node_modules/antlr4/atn/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.ATN = __webpack_require__(/*! ./ATN */ "./node_modules/antlr4/atn/ATN.js").ATN;
exports.ATNDeserializer = __webpack_require__(/*! ./ATNDeserializer */ "./node_modules/antlr4/atn/ATNDeserializer.js").ATNDeserializer;
exports.LexerATNSimulator = __webpack_require__(/*! ./LexerATNSimulator */ "./node_modules/antlr4/atn/LexerATNSimulator.js").LexerATNSimulator;
exports.ParserATNSimulator = __webpack_require__(/*! ./ParserATNSimulator */ "./node_modules/antlr4/atn/ParserATNSimulator.js").ParserATNSimulator;
exports.PredictionMode = __webpack_require__(/*! ./PredictionMode */ "./node_modules/antlr4/atn/PredictionMode.js").PredictionMode;


/***/ }),

/***/ "./node_modules/antlr4/dfa/DFA.js":
/*!****************************************!*\
  !*** ./node_modules/antlr4/dfa/DFA.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Set = __webpack_require__(/*! ../Utils */ "./node_modules/antlr4/Utils.js").Set;
var DFAState = __webpack_require__(/*! ./DFAState */ "./node_modules/antlr4/dfa/DFAState.js").DFAState;
var StarLoopEntryState = __webpack_require__(/*! ../atn/ATNState */ "./node_modules/antlr4/atn/ATNState.js").StarLoopEntryState;
var ATNConfigSet = __webpack_require__(/*! ./../atn/ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var DFASerializer = __webpack_require__(/*! ./DFASerializer */ "./node_modules/antlr4/dfa/DFASerializer.js").DFASerializer;
var LexerDFASerializer = __webpack_require__(/*! ./DFASerializer */ "./node_modules/antlr4/dfa/DFASerializer.js").LexerDFASerializer;



function DFA(atnStartState, decision) {
	if (decision === undefined) {
		decision = 0;
	}
	// From which ATN state did we create this DFA?
	this.atnStartState = atnStartState;
	this.decision = decision;
	// A set of all DFA states. Use {@link Map} so we can get old state back
	// ({@link Set} only allows you to see if it's there).
	this._states = new Set();
	this.s0 = null;
	// {@code true} if this DFA is for a precedence decision; otherwise,
	// {@code false}. This is the backing field for {@link //isPrecedenceDfa},
	// {@link //setPrecedenceDfa}.
	this.precedenceDfa = false;
    if (atnStartState instanceof StarLoopEntryState)
    {
        if (atnStartState.isPrecedenceDecision) {
            this.precedenceDfa = true;
            var precedenceState = new DFAState(null, new ATNConfigSet());
            precedenceState.edges = [];
            precedenceState.isAcceptState = false;
            precedenceState.requiresFullContext = false;
            this.s0 = precedenceState;
        }
    }
	return this;
}

// Get the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @return The start state corresponding to the specified precedence, or
// {@code null} if no start state exists for the specified precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()

DFA.prototype.getPrecedenceStartState = function(precedence) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	// s0.edges is never null for a precedence DFA
	if (precedence < 0 || precedence >= this.s0.edges.length) {
		return null;
	}
	return this.s0.edges[precedence] || null;
};

// Set the start state for a specific precedence value.
//
// @param precedence The current precedence.
// @param startState The start state corresponding to the specified
// precedence.
//
// @throws IllegalStateException if this is not a precedence DFA.
// @see //isPrecedenceDfa()
//
DFA.prototype.setPrecedenceStartState = function(precedence, startState) {
	if (!(this.precedenceDfa)) {
		throw ("Only precedence DFAs may contain a precedence start state.");
	}
	if (precedence < 0) {
		return;
	}

	// synchronization on s0 here is ok. when the DFA is turned into a
	// precedence DFA, s0 will be initialized once and not updated again
	// s0.edges is never null for a precedence DFA
	this.s0.edges[precedence] = startState;
};

//
// Sets whether this is a precedence DFA. If the specified value differs
// from the current DFA configuration, the following actions are taken;
// otherwise no changes are made to the current DFA.
//
// <ul>
// <li>The {@link //states} map is cleared</li>
// <li>If {@code precedenceDfa} is {@code false}, the initial state
// {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
// {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
// store the start states for individual precedence values.</li>
// <li>The {@link //precedenceDfa} field is updated</li>
// </ul>
//
// @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
// {@code false}

DFA.prototype.setPrecedenceDfa = function(precedenceDfa) {
	if (this.precedenceDfa!==precedenceDfa) {
		this._states = new DFAStatesSet();
		if (precedenceDfa) {
			var precedenceState = new DFAState(null, new ATNConfigSet());
			precedenceState.edges = [];
			precedenceState.isAcceptState = false;
			precedenceState.requiresFullContext = false;
			this.s0 = precedenceState;
		} else {
			this.s0 = null;
		}
		this.precedenceDfa = precedenceDfa;
	}
};

Object.defineProperty(DFA.prototype, "states", {
	get : function() {
		return this._states;
	}
});

// Return a list of all states in this DFA, ordered by state number.
DFA.prototype.sortedStates = function() {
	var list = this._states.values();
	return list.sort(function(a, b) {
		return a.stateNumber - b.stateNumber;
	});
};

DFA.prototype.toString = function(literalNames, symbolicNames) {
	literalNames = literalNames || null;
	symbolicNames = symbolicNames || null;
	if (this.s0 === null) {
		return "";
	}
	var serializer = new DFASerializer(this, literalNames, symbolicNames);
	return serializer.toString();
};

DFA.prototype.toLexerString = function() {
	if (this.s0 === null) {
		return "";
	}
	var serializer = new LexerDFASerializer(this);
	return serializer.toString();
};

exports.DFA = DFA;


/***/ }),

/***/ "./node_modules/antlr4/dfa/DFASerializer.js":
/*!**************************************************!*\
  !*** ./node_modules/antlr4/dfa/DFASerializer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// A DFA walker that knows how to dump them to serialized strings.#/


function DFASerializer(dfa, literalNames, symbolicNames) {
	this.dfa = dfa;
	this.literalNames = literalNames || [];
	this.symbolicNames = symbolicNames || [];
	return this;
}

DFASerializer.prototype.toString = function() {
   if(this.dfa.s0 === null) {
       return null;
   }
   var buf = "";
   var states = this.dfa.sortedStates();
   for(var i=0;i<states.length;i++) {
       var s = states[i];
       if(s.edges!==null) {
            var n = s.edges.length;
            for(var j=0;j<n;j++) {
                var t = s.edges[j] || null;
                if(t!==null && t.stateNumber !== 0x7FFFFFFF) {
                    buf = buf.concat(this.getStateString(s));
                    buf = buf.concat("-");
                    buf = buf.concat(this.getEdgeLabel(j));
                    buf = buf.concat("->");
                    buf = buf.concat(this.getStateString(t));
                    buf = buf.concat('\n');
                }
            }
       }
   }
   return buf.length===0 ? null : buf;
};

DFASerializer.prototype.getEdgeLabel = function(i) {
    if (i===0) {
        return "EOF";
    } else if(this.literalNames !==null || this.symbolicNames!==null) {
        return this.literalNames[i-1] || this.symbolicNames[i-1];
    } else {
        return String.fromCharCode(i-1);
    }
};

DFASerializer.prototype.getStateString = function(s) {
    var baseStateStr = ( s.isAcceptState ? ":" : "") + "s" + s.stateNumber + ( s.requiresFullContext ? "^" : "");
    if(s.isAcceptState) {
        if (s.predicates !== null) {
            return baseStateStr + "=>" + s.predicates.toString();
        } else {
            return baseStateStr + "=>" + s.prediction.toString();
        }
    } else {
        return baseStateStr;
    }
};

function LexerDFASerializer(dfa) {
	DFASerializer.call(this, dfa, null);
	return this;
}

LexerDFASerializer.prototype = Object.create(DFASerializer.prototype);
LexerDFASerializer.prototype.constructor = LexerDFASerializer;

LexerDFASerializer.prototype.getEdgeLabel = function(i) {
	return "'" + String.fromCharCode(i) + "'";
};

exports.DFASerializer = DFASerializer;
exports.LexerDFASerializer = LexerDFASerializer;



/***/ }),

/***/ "./node_modules/antlr4/dfa/DFAState.js":
/*!*********************************************!*\
  !*** ./node_modules/antlr4/dfa/DFAState.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

var ATNConfigSet = __webpack_require__(/*! ./../atn/ATNConfigSet */ "./node_modules/antlr4/atn/ATNConfigSet.js").ATNConfigSet;
var Utils = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js");
var Hash = Utils.Hash;
var Set = Utils.Set;

// Map a predicate to a predicted alternative.///

function PredPrediction(pred, alt) {
	this.alt = alt;
	this.pred = pred;
	return this;
}

PredPrediction.prototype.toString = function() {
	return "(" + this.pred + ", " + this.alt + ")";
};

// A DFA state represents a set of possible ATN configurations.
// As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
// to keep track of all possible states the ATN can be in after
// reading each input symbol. That is to say, after reading
// input a1a2..an, the DFA is in a state that represents the
// subset T of the states of the ATN that are reachable from the
// ATN's start state along some path labeled a1a2..an."
// In conventional NFA&rarr;DFA conversion, therefore, the subset T
// would be a bitset representing the set of states the
// ATN could be in. We need to track the alt predicted by each
// state as well, however. More importantly, we need to maintain
// a stack of states, tracking the closure operations as they
// jump from rule to rule, emulating rule invocations (method calls).
// I have to add a stack to simulate the proper lookahead sequences for
// the underlying LL grammar from which the ATN was derived.
//
// <p>I use a set of ATNConfig objects not simple states. An ATNConfig
// is both a state (ala normal conversion) and a RuleContext describing
// the chain of rules (if any) followed to arrive at that state.</p>
//
// <p>A DFA state may have multiple references to a particular state,
// but with different ATN contexts (with same or different alts)
// meaning that state was reached via a different set of rule invocations.</p>
// /

function DFAState(stateNumber, configs) {
	if (stateNumber === null) {
		stateNumber = -1;
	}
	if (configs === null) {
		configs = new ATNConfigSet();
	}
	this.stateNumber = stateNumber;
	this.configs = configs;
	// {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
	// {@link Token//EOF} maps to {@code edges[0]}.
	this.edges = null;
	this.isAcceptState = false;
	// if accept state, what ttype do we match or alt do we predict?
	// This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link
	// //predicates}{@code !=null} or
	// {@link //requiresFullContext}.
	this.prediction = 0;
	this.lexerActionExecutor = null;
	// Indicates that this state was created during SLL prediction that
	// discovered a conflict between the configurations in the state. Future
	// {@link ParserATNSimulator//execATN} invocations immediately jumped doing
	// full context prediction if this field is true.
	this.requiresFullContext = false;
	// During SLL parsing, this is a list of predicates associated with the
	// ATN configurations of the DFA state. When we have predicates,
	// {@link //requiresFullContext} is {@code false} since full context
	// prediction evaluates predicates
	// on-the-fly. If this is not null, then {@link //prediction} is
	// {@link ATN//INVALID_ALT_NUMBER}.
	//
	// <p>We only use these for non-{@link //requiresFullContext} but
	// conflicting states. That
	// means we know from the context (it's $ or we don't dip into outer
	// context) that it's an ambiguity not a conflict.</p>
	//
	// <p>This list is computed by {@link
	// ParserATNSimulator//predicateDFAState}.</p>
	this.predicates = null;
	return this;
}

// Get the set of all alts mentioned by all ATN configurations in this
// DFA state.
DFAState.prototype.getAltSet = function() {
	var alts = new Set();
	if (this.configs !== null) {
		for (var i = 0; i < this.configs.length; i++) {
			var c = this.configs[i];
			alts.add(c.alt);
		}
	}
	if (alts.length === 0) {
		return null;
	} else {
		return alts;
	}
};

// Two {@link DFAState} instances are equal if their ATN configuration sets
// are the same. This method is used to see if a state already exists.
//
// <p>Because the number of alternatives and number of ATN configurations are
// finite, there is a finite number of DFA states that can be processed.
// This is necessary to show that the algorithm terminates.</p>
//
// <p>Cannot test the DFA state numbers here because in
// {@link ParserATNSimulator//addDFAState} we need to know if any other state
// exists that has this exact set of ATN configurations. The
// {@link //stateNumber} is irrelevant.</p>
DFAState.prototype.equals = function(other) {
	// compare set of ATN configurations in this set with other
	return this === other ||
			(other instanceof DFAState &&
				this.configs.equals(other.configs));
};

DFAState.prototype.toString = function() {
	var s = "" + this.stateNumber + ":" + this.configs;
	if(this.isAcceptState) {
        s = s + "=>";
        if (this.predicates !== null)
            s = s + this.predicates;
        else
            s = s + this.prediction;
    }
	return s;
};

DFAState.prototype.hashCode = function() {
	var hash = new Hash();
	hash.update(this.configs);
    return hash.finish();
};

exports.DFAState = DFAState;
exports.PredPrediction = PredPrediction;


/***/ }),

/***/ "./node_modules/antlr4/dfa/index.js":
/*!******************************************!*\
  !*** ./node_modules/antlr4/dfa/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.DFA = __webpack_require__(/*! ./DFA */ "./node_modules/antlr4/dfa/DFA.js").DFA;
exports.DFASerializer = __webpack_require__(/*! ./DFASerializer */ "./node_modules/antlr4/dfa/DFASerializer.js").DFASerializer;
exports.LexerDFASerializer = __webpack_require__(/*! ./DFASerializer */ "./node_modules/antlr4/dfa/DFASerializer.js").LexerDFASerializer;
exports.PredPrediction = __webpack_require__(/*! ./DFAState */ "./node_modules/antlr4/dfa/DFAState.js").PredPrediction;


/***/ }),

/***/ "./node_modules/antlr4/error/DiagnosticErrorListener.js":
/*!**************************************************************!*\
  !*** ./node_modules/antlr4/error/DiagnosticErrorListener.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

//
// This implementation of {@link ANTLRErrorListener} can be used to identify
// certain potential correctness and performance problems in grammars. "Reports"
// are made by calling {@link Parser//notifyErrorListeners} with the appropriate
// message.
//
// <ul>
// <li><b>Ambiguities</b>: These are cases where more than one path through the
// grammar can match the input.</li>
// <li><b>Weak context sensitivity</b>: These are cases where full-context
// prediction resolved an SLL conflict to a unique alternative which equaled the
// minimum alternative of the SLL conflict.</li>
// <li><b>Strong (forced) context sensitivity</b>: These are cases where the
// full-context prediction resolved an SLL conflict to a unique alternative,
// <em>and</em> the minimum alternative of the SLL conflict was found to not be
// a truly viable alternative. Two-stage parsing cannot be used for inputs where
// this situation occurs.</li>
// </ul>

var BitSet = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js").BitSet;
var ErrorListener = __webpack_require__(/*! ./ErrorListener */ "./node_modules/antlr4/error/ErrorListener.js").ErrorListener;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;

function DiagnosticErrorListener(exactOnly) {
	ErrorListener.call(this);
	exactOnly = exactOnly || true;
	// whether all ambiguities or only exact ambiguities are reported.
	this.exactOnly = exactOnly;
	return this;
}

DiagnosticErrorListener.prototype = Object.create(ErrorListener.prototype);
DiagnosticErrorListener.prototype.constructor = DiagnosticErrorListener;

DiagnosticErrorListener.prototype.reportAmbiguity = function(recognizer, dfa,
		startIndex, stopIndex, exact, ambigAlts, configs) {
	if (this.exactOnly && !exact) {
		return;
	}
	var msg = "reportAmbiguity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			": ambigAlts=" +
			this.getConflictingAlts(ambigAlts, configs) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportAttemptingFullContext = function(
		recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	var msg = "reportAttemptingFullContext d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.reportContextSensitivity = function(
		recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	var msg = "reportContextSensitivity d=" +
			this.getDecisionDescription(recognizer, dfa) +
			", input='" +
			recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
	recognizer.notifyErrorListeners(msg);
};

DiagnosticErrorListener.prototype.getDecisionDescription = function(recognizer, dfa) {
	var decision = dfa.decision;
	var ruleIndex = dfa.atnStartState.ruleIndex;

	var ruleNames = recognizer.ruleNames;
	if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
		return "" + decision;
	}
	var ruleName = ruleNames[ruleIndex] || null;
	if (ruleName === null || ruleName.length === 0) {
		return "" + decision;
	}
	return "" + decision + " (" + ruleName + ")";
};

//
// Computes the set of conflicting or ambiguous alternatives from a
// configuration set, if that information was not already provided by the
// parser.
//
// @param reportedAlts The set of conflicting or ambiguous alternatives, as
// reported by the parser.
// @param configs The conflicting or ambiguous configuration set.
// @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
// returns the set of alternatives represented in {@code configs}.
//
DiagnosticErrorListener.prototype.getConflictingAlts = function(reportedAlts, configs) {
	if (reportedAlts !== null) {
		return reportedAlts;
	}
	var result = new BitSet();
	for (var i = 0; i < configs.items.length; i++) {
		result.add(configs.items[i].alt);
	}
	return "{" + result.values().join(", ") + "}";
};

exports.DiagnosticErrorListener = DiagnosticErrorListener;

/***/ }),

/***/ "./node_modules/antlr4/error/ErrorListener.js":
/*!****************************************************!*\
  !*** ./node_modules/antlr4/error/ErrorListener.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// Provides an empty default implementation of {@link ANTLRErrorListener}. The
// default implementation of each method does nothing, but can be overridden as
// necessary.

function ErrorListener() {
	return this;
}

ErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
};

ErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
};

ErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
};

ErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
};

function ConsoleErrorListener() {
	ErrorListener.call(this);
	return this;
}

ConsoleErrorListener.prototype = Object.create(ErrorListener.prototype);
ConsoleErrorListener.prototype.constructor = ConsoleErrorListener;

//
// Provides a default instance of {@link ConsoleErrorListener}.
//
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

//
// {@inheritDoc}
//
// <p>
// This implementation prints messages to {@link System//err} containing the
// values of {@code line}, {@code charPositionInLine}, and {@code msg} using
// the following format.</p>
//
// <pre>
// line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
// </pre>
//
ConsoleErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
};

function ProxyErrorListener(delegates) {
	ErrorListener.call(this);
    if (delegates===null) {
        throw "delegates";
    }
    this.delegates = delegates;
	return this;
}

ProxyErrorListener.prototype = Object.create(ErrorListener.prototype);
ProxyErrorListener.prototype.constructor = ProxyErrorListener;

ProxyErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(function(d) { d.syntaxError(recognizer, offendingSymbol, line, column, msg, e); });
};

ProxyErrorListener.prototype.reportAmbiguity = function(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(function(d) { d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs); });
};

ProxyErrorListener.prototype.reportAttemptingFullContext = function(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
	this.delegates.map(function(d) { d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs); });
};

ProxyErrorListener.prototype.reportContextSensitivity = function(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
	this.delegates.map(function(d) { d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs); });
};

exports.ErrorListener = ErrorListener;
exports.ConsoleErrorListener = ConsoleErrorListener;
exports.ProxyErrorListener = ProxyErrorListener;



/***/ }),

/***/ "./node_modules/antlr4/error/ErrorStrategy.js":
/*!****************************************************!*\
  !*** ./node_modules/antlr4/error/ErrorStrategy.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//
/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
//

var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var Errors = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js");
var NoViableAltException = Errors.NoViableAltException;
var InputMismatchException = Errors.InputMismatchException;
var FailedPredicateException = Errors.FailedPredicateException;
var ParseCancellationException = Errors.ParseCancellationException;
var ATNState = __webpack_require__(/*! ./../atn/ATNState */ "./node_modules/antlr4/atn/ATNState.js").ATNState;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var IntervalSet = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").IntervalSet;

function ErrorStrategy() {

}

ErrorStrategy.prototype.reset = function(recognizer){
};

ErrorStrategy.prototype.recoverInline = function(recognizer){
};

ErrorStrategy.prototype.recover = function(recognizer, e){
};

ErrorStrategy.prototype.sync = function(recognizer){
};

ErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer){
};

ErrorStrategy.prototype.reportError = function(recognizer){
};



// This is the default implementation of {@link ANTLRErrorStrategy} used for
// error reporting and recovery in ANTLR parsers.
//
function DefaultErrorStrategy() {
	ErrorStrategy.call(this);
    // Indicates whether the error strategy is currently "recovering from an
    // error". This is used to suppress reporting multiple error messages while
    // attempting to recover from a detected syntax error.
    //
    // @see //inErrorRecoveryMode
    //
    this.errorRecoveryMode = false;

    // The index into the input stream where the last error occurred.
    // This is used to prevent infinite loops where an error is found
    // but no token is consumed during recovery...another error is found,
    // ad nauseum. This is a failsafe mechanism to guarantee that at least
    // one token/tree node is consumed for two errors.
    //
    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    return this;
}

DefaultErrorStrategy.prototype = Object.create(ErrorStrategy.prototype);
DefaultErrorStrategy.prototype.constructor = DefaultErrorStrategy;

// <p>The default implementation simply calls {@link //endErrorCondition} to
// ensure that the handler is not in error recovery mode.</p>
DefaultErrorStrategy.prototype.reset = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// This method is called to enter error recovery mode when a recognition
// exception is reported.
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.beginErrorCondition = function(recognizer) {
    this.errorRecoveryMode = true;
};

DefaultErrorStrategy.prototype.inErrorRecoveryMode = function(recognizer) {
    return this.errorRecoveryMode;
};

//
// This method is called to leave error recovery mode after recovering from
// a recognition exception.
//
// @param recognizer
//
DefaultErrorStrategy.prototype.endErrorCondition = function(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
};

//
// {@inheritDoc}
//
// <p>The default implementation simply calls {@link //endErrorCondition}.</p>
//
DefaultErrorStrategy.prototype.reportMatch = function(recognizer) {
    this.endErrorCondition(recognizer);
};

//
// {@inheritDoc}
//
// <p>The default implementation returns immediately if the handler is already
// in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
// and dispatches the reporting task based on the runtime type of {@code e}
// according to the following table.</p>
//
// <ul>
// <li>{@link NoViableAltException}: Dispatches the call to
// {@link //reportNoViableAlternative}</li>
// <li>{@link InputMismatchException}: Dispatches the call to
// {@link //reportInputMismatch}</li>
// <li>{@link FailedPredicateException}: Dispatches the call to
// {@link //reportFailedPredicate}</li>
// <li>All other types: calls {@link Parser//notifyErrorListeners} to report
// the exception</li>
// </ul>
//
DefaultErrorStrategy.prototype.reportError = function(recognizer, e) {
   // if we've already reported an error and have not matched a token
   // yet successfully, don't report any errors.
    if(this.inErrorRecoveryMode(recognizer)) {
        return; // don't report spurious errors
    }
    this.beginErrorCondition(recognizer);
    if ( e instanceof NoViableAltException ) {
        this.reportNoViableAlternative(recognizer, e);
    } else if ( e instanceof InputMismatchException ) {
        this.reportInputMismatch(recognizer, e);
    } else if ( e instanceof FailedPredicateException ) {
        this.reportFailedPredicate(recognizer, e);
    } else {
        console.log("unknown recognition error type: " + e.constructor.name);
        console.log(e.stack);
        recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
};
//
// {@inheritDoc}
//
// <p>The default implementation resynchronizes the parser by consuming tokens
// until we find one in the resynchronization set--loosely the set of tokens
// that can follow the current rule.</p>
//
DefaultErrorStrategy.prototype.recover = function(recognizer, e) {
    if (this.lastErrorIndex===recognizer.getInputStream().index &&
        this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state)>=0) {
		// uh oh, another error at same token index and previously-visited
		// state in ATN; must be a case where LT(1) is in the recovery
		// token set so nothing got consumed. Consume a single token
		// at least to prevent an infinite loop; this is a failsafe.
		recognizer.consume();
    }
    this.lastErrorIndex = recognizer._input.index;
    if (this.lastErrorStates === null) {
        this.lastErrorStates = [];
    }
    this.lastErrorStates.push(recognizer.state);
    var followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
};

// The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
// that the current lookahead symbol is consistent with what were expecting
// at this point in the ATN. You can call this anytime but ANTLR only
// generates code to check before subrules/loops and each iteration.
//
// <p>Implements Jim Idle's magic sync mechanism in closures and optional
// subrules. E.g.,</p>
//
// <pre>
// a : sync ( stuff sync )* ;
// sync : {consume to what can follow sync} ;
// </pre>
//
// At the start of a sub rule upon error, {@link //sync} performs single
// token deletion, if possible. If it can't do that, it bails on the current
// rule and uses the default error recovery, which consumes until the
// resynchronization set of the current rule.
//
// <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
// with an empty alternative), then the expected set includes what follows
// the subrule.</p>
//
// <p>During loop iteration, it consumes until it sees a token that can start a
// sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
// stay in the loop as long as possible.</p>
//
// <p><strong>ORIGINS</strong></p>
//
// <p>Previous versions of ANTLR did a poor job of their recovery within loops.
// A single mismatch token or missing token would force the parser to bail
// out of the entire rules surrounding the loop. So, for rule</p>
//
// <pre>
// classDef : 'class' ID '{' member* '}'
// </pre>
//
// input with an extra token between members would force the parser to
// consume until it found the next class definition rather than the next
// member definition of the current class.
//
// <p>This functionality cost a little bit of effort because the parser has to
// compare token set at the start of the loop and at each iteration. If for
// some reason speed is suffering for you, you can turn off this
// functionality by simply overriding this method as a blank { }.</p>
//
DefaultErrorStrategy.prototype.sync = function(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    var s = recognizer._interp.atn.states[recognizer.state];
    var la = recognizer.getTokenStream().LA(1);
    // try cheaper subset first; might get lucky. seems to shave a wee bit off
    var nextTokens = recognizer.atn.nextTokens(s);
    if (nextTokens.contains(Token.EPSILON) || nextTokens.contains(la)) {
        return;
    }
    switch (s.stateType) {
    case ATNState.BLOCK_START:
    case ATNState.STAR_BLOCK_START:
    case ATNState.PLUS_BLOCK_START:
    case ATNState.STAR_LOOP_ENTRY:
       // report error and recover if possible
        if( this.singleTokenDeletion(recognizer) !== null) {
            return;
        } else {
            throw new InputMismatchException(recognizer);
        }
        break;
    case ATNState.PLUS_LOOP_BACK:
    case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        var expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;
    default:
        // do nothing if we can't identify the exact kind of ATN state
    }
};

// This is called by {@link //reportError} when the exception is a
// {@link NoViableAltException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportNoViableAlternative = function(recognizer, e) {
    var tokens = recognizer.getTokenStream();
    var input;
    if(tokens !== null) {
        if (e.startToken.type===Token.EOF) {
            input = "<EOF>";
        } else {
            input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
        }
    } else {
        input = "<unknown input>";
    }
    var msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is an
// {@link InputMismatchException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportInputMismatch = function(recognizer, e) {
    var msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
          " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

//
// This is called by {@link //reportError} when the exception is a
// {@link FailedPredicateException}.
//
// @see //reportError
//
// @param recognizer the parser instance
// @param e the recognition exception
//
DefaultErrorStrategy.prototype.reportFailedPredicate = function(recognizer, e) {
    var ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    var msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
};

// This method is called to report a syntax error which requires the removal
// of a token from the input stream. At the time this method is called, the
// erroneous symbol is current {@code LT(1)} symbol and has not yet been
// removed from the input stream. When this method returns,
// {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenDeletion} identifies
// single-token deletion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportUnwantedToken = function(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var tokenName = this.getTokenErrorDisplay(t);
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "extraneous input " + tokenName + " expecting " +
        expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
};
// This method is called to report a syntax error which requires the
// insertion of a missing token into the input stream. At the time this
// method is called, the missing token has not yet been inserted. When this
// method returns, {@code recognizer} is in error recovery mode.
//
// <p>This method is called when {@link //singleTokenInsertion} identifies
// single-token insertion as a viable recovery strategy for a mismatched
// input error.</p>
//
// <p>The default implementation simply returns if the handler is already in
// error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
// enter error recovery mode, followed by calling
// {@link Parser//notifyErrorListeners}.</p>
//
// @param recognizer the parser instance
//
DefaultErrorStrategy.prototype.reportMissingToken = function(recognizer) {
    if ( this.inErrorRecoveryMode(recognizer)) {
        return;
    }
    this.beginErrorCondition(recognizer);
    var t = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
          " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
};

// <p>The default implementation attempts to recover from the mismatched input
// by using single token insertion and deletion as described below. If the
// recovery attempt fails, this method throws an
// {@link InputMismatchException}.</p>
//
// <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
//
// <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
// right token, however, then assume {@code LA(1)} is some extra spurious
// token and delete it. Then consume and return the next token (which was
// the {@code LA(2)} token) as the successful result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenDeletion}.</p>
//
// <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
//
// <p>If current token (at {@code LA(1)}) is consistent with what could come
// after the expected {@code LA(1)} token, then assume the token is missing
// and use the parser's {@link TokenFactory} to create it on the fly. The
// "insertion" is performed by returning the created token as the successful
// result of the match operation.</p>
//
// <p>This recovery strategy is implemented by {@link
// //singleTokenInsertion}.</p>
//
// <p><strong>EXAMPLE</strong></p>
//
// <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
// the parser returns from the nested call to {@code expr}, it will have
// call chain:</p>
//
// <pre>
// stat &rarr; expr &rarr; atom
// </pre>
//
// and it will be trying to match the {@code ')'} at this point in the
// derivation:
//
// <pre>
// =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
// ^
// </pre>
//
// The attempt to match {@code ')'} will fail when it sees {@code ';'} and
// call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
// is in the set of tokens that can follow the {@code ')'} token reference
// in rule {@code atom}. It can assume that you forgot the {@code ')'}.
//
DefaultErrorStrategy.prototype.recoverInline = function(recognizer) {
    // SINGLE TOKEN DELETION
    var matchedSymbol = this.singleTokenDeletion(recognizer);
    if (matchedSymbol !== null) {
        // we have deleted the extra token.
        // now, move past ttype token as if all were ok
        recognizer.consume();
        return matchedSymbol;
    }
    // SINGLE TOKEN INSERTION
    if (this.singleTokenInsertion(recognizer)) {
        return this.getMissingSymbol(recognizer);
    }
    // even that didn't work; must throw the exception
    throw new InputMismatchException(recognizer);
};

//
// This method implements the single-token insertion inline error recovery
// strategy. It is called by {@link //recoverInline} if the single-token
// deletion strategy fails to recover from the mismatched input. If this
// method returns {@code true}, {@code recognizer} will be in error recovery
// mode.
//
// <p>This method determines whether or not single-token insertion is viable by
// checking if the {@code LA(1)} input symbol could be successfully matched
// if it were instead the {@code LA(2)} symbol. If this method returns
// {@code true}, the caller is responsible for creating and inserting a
// token with the correct type to produce this behavior.</p>
//
// @param recognizer the parser instance
// @return {@code true} if single-token insertion is a viable recovery
// strategy for the current mismatched input, otherwise {@code false}
//
DefaultErrorStrategy.prototype.singleTokenInsertion = function(recognizer) {
    var currentSymbolType = recognizer.getTokenStream().LA(1);
    // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token
    var atn = recognizer._interp.atn;
    var currentState = atn.states[recognizer.state];
    var next = currentState.transitions[0].target;
    var expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
    if (expectingAtLL2.contains(currentSymbolType) ){
        this.reportMissingToken(recognizer);
        return true;
    } else {
        return false;
    }
};

// This method implements the single-token deletion inline error recovery
// strategy. It is called by {@link //recoverInline} to attempt to recover
// from mismatched input. If this method returns null, the parser and error
// handler state will not have changed. If this method returns non-null,
// {@code recognizer} will <em>not</em> be in error recovery mode since the
// returned token was a successful match.
//
// <p>If the single-token deletion is successful, this method calls
// {@link //reportUnwantedToken} to report the error, followed by
// {@link Parser//consume} to actually "delete" the extraneous token. Then,
// before returning {@link //reportMatch} is called to signal a successful
// match.</p>
//
// @param recognizer the parser instance
// @return the successfully matched {@link Token} instance if single-token
// deletion successfully recovers from the mismatched input, otherwise
// {@code null}
//
DefaultErrorStrategy.prototype.singleTokenDeletion = function(recognizer) {
    var nextTokenType = recognizer.getTokenStream().LA(2);
    var expecting = this.getExpectedTokens(recognizer);
    if (expecting.contains(nextTokenType)) {
        this.reportUnwantedToken(recognizer);
        // print("recoverFromMismatchedToken deleting " \
        // + str(recognizer.getTokenStream().LT(1)) \
        // + " since " + str(recognizer.getTokenStream().LT(2)) \
        // + " is what we want", file=sys.stderr)
        recognizer.consume(); // simply delete extra token
        // we want to return the token we're actually matching
        var matchedSymbol = recognizer.getCurrentToken();
        this.reportMatch(recognizer); // we know current token is correct
        return matchedSymbol;
    } else {
        return null;
    }
};

// Conjure up a missing token during error recovery.
//
// The recognizer attempts to recover from single missing
// symbols. But, actions might refer to that missing symbol.
// For example, x=ID {f($x);}. The action clearly assumes
// that there has been an identifier matched previously and that
// $x points at that token. If that token is missing, but
// the next token in the stream is what we want we assume that
// this token is missing and we keep going. Because we
// have to return some token to replace the missing token,
// we have to conjure one up. This method gives the user control
// over the tokens returned for missing tokens. Mostly,
// you will want to create something special for identifier
// tokens. For literals such as '{' and ',', the default
// action in the parser or tree parser works. It simply creates
// a CommonToken of the appropriate type. The text will be the token.
// If you change what tokens must be created by the lexer,
// override this method to create the appropriate tokens.
//
DefaultErrorStrategy.prototype.getMissingSymbol = function(recognizer) {
    var currentSymbol = recognizer.getCurrentToken();
    var expecting = this.getExpectedTokens(recognizer);
    var expectedTokenType = expecting.first(); // get any element
    var tokenText;
    if (expectedTokenType===Token.EOF) {
        tokenText = "<missing EOF>";
    } else {
        tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }
    var current = currentSymbol;
    var lookback = recognizer.getTokenStream().LT(-1);
    if (current.type===Token.EOF && lookback !== null) {
        current = lookback;
    }
    return recognizer.getTokenFactory().create(current.source,
        expectedTokenType, tokenText, Token.DEFAULT_CHANNEL,
        -1, -1, current.line, current.column);
};

DefaultErrorStrategy.prototype.getExpectedTokens = function(recognizer) {
    return recognizer.getExpectedTokens();
};

// How should a token be displayed in an error message? The default
// is to display just the text, but during development you might
// want to have a lot of information spit out. Override in that case
// to use t.toString() (which, for CommonToken, dumps everything about
// the token). This is better than forcing you to override a method in
// your token objects because you don't have to go modify your lexer
// so that it creates a new Java type.
//
DefaultErrorStrategy.prototype.getTokenErrorDisplay = function(t) {
    if (t === null) {
        return "<no token>";
    }
    var s = t.text;
    if (s === null) {
        if (t.type===Token.EOF) {
            s = "<EOF>";
        } else {
            s = "<" + t.type + ">";
        }
    }
    return this.escapeWSAndQuote(s);
};

DefaultErrorStrategy.prototype.escapeWSAndQuote = function(s) {
    s = s.replace(/\n/g,"\\n");
    s = s.replace(/\r/g,"\\r");
    s = s.replace(/\t/g,"\\t");
    return "'" + s + "'";
};

// Compute the error recovery set for the current rule. During
// rule invocation, the parser pushes the set of tokens that can
// follow that rule reference on the stack; this amounts to
// computing FIRST of what follows the rule reference in the
// enclosing rule. See LinearApproximator.FIRST().
// This local follow set only includes tokens
// from within the rule; i.e., the FIRST computation done by
// ANTLR stops at the end of a rule.
//
// EXAMPLE
//
// When you find a "no viable alt exception", the input is not
// consistent with any of the alternatives for rule r. The best
// thing to do is to consume tokens until you see something that
// can legally follow a call to r//or* any rule that called r.
// You don't want the exact set of viable next tokens because the
// input might just be missing a token--you might consume the
// rest of the input looking for one of the missing tokens.
//
// Consider grammar:
//
// a : '[' b ']'
// | '(' b ')'
// ;
// b : c '^' INT ;
// c : ID
// | INT
// ;
//
// At each rule invocation, the set of tokens that could follow
// that rule is pushed on a stack. Here are the various
// context-sensitive follow sets:
//
// FOLLOW(b1_in_a) = FIRST(']') = ']'
// FOLLOW(b2_in_a) = FIRST(')') = ')'
// FOLLOW(c_in_b) = FIRST('^') = '^'
//
// Upon erroneous input "[]", the call chain is
//
// a -> b -> c
//
// and, hence, the follow context stack is:
//
// depth follow set start of rule execution
// 0 <EOF> a (from main())
// 1 ']' b
// 2 '^' c
//
// Notice that ')' is not included, because b would have to have
// been called from a different context in rule a for ')' to be
// included.
//
// For error recovery, we cannot consider FOLLOW(c)
// (context-sensitive or otherwise). We need the combined set of
// all context-sensitive FOLLOW sets--the set of all tokens that
// could follow any reference in the call chain. We need to
// resync to one of those tokens. Note that FOLLOW(c)='^' and if
// we resync'd to that token, we'd consume until EOF. We need to
// sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
// In this case, for input "[]", LA(1) is ']' and in the set, so we would
// not consume anything. After printing an error, rule c would
// return normally. Rule b would not find the required '^' though.
// At this point, it gets a mismatched token error and throws an
// exception (since LA(1) is not in the viable following token
// set). The rule exception handler tries to recover, but finds
// the same recovery set and doesn't consume anything. Rule b
// exits normally returning to rule a. Now it finds the ']' (and
// with the successful match exits errorRecovery mode).
//
// So, you can see that the parser walks up the call chain looking
// for the token that was a member of the recovery set.
//
// Errors are not generated in errorRecovery mode.
//
// ANTLR's error recovery mechanism is based upon original ideas:
//
// "Algorithms + Data Structures = Programs" by Niklaus Wirth
//
// and
//
// "A note on error recovery in recursive descent parsers":
// http://portal.acm.org/citation.cfm?id=947902.947905
//
// Later, Josef Grosch had some good ideas:
//
// "Efficient and Comfortable Error Recovery in Recursive Descent
// Parsers":
// ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
//
// Like Grosch I implement context-sensitive FOLLOW sets that are combined
// at run-time upon error to avoid overhead during parsing.
//
DefaultErrorStrategy.prototype.getErrorRecoverySet = function(recognizer) {
    var atn = recognizer._interp.atn;
    var ctx = recognizer._ctx;
    var recoverSet = new IntervalSet();
    while (ctx !== null && ctx.invokingState>=0) {
        // compute what follows who invoked us
        var invokingState = atn.states[ctx.invokingState];
        var rt = invokingState.transitions[0];
        var follow = atn.nextTokens(rt.followState);
        recoverSet.addSet(follow);
        ctx = ctx.parentCtx;
    }
    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
};

// Consume tokens until one matches the given token set.//
DefaultErrorStrategy.prototype.consumeUntil = function(recognizer, set) {
    var ttype = recognizer.getTokenStream().LA(1);
    while( ttype !== Token.EOF && !set.contains(ttype)) {
        recognizer.consume();
        ttype = recognizer.getTokenStream().LA(1);
    }
};

//
// This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
// by immediately canceling the parse operation with a
// {@link ParseCancellationException}. The implementation ensures that the
// {@link ParserRuleContext//exception} field is set for all parse tree nodes
// that were not completed prior to encountering the error.
//
// <p>
// This error strategy is useful in the following scenarios.</p>
//
// <ul>
// <li><strong>Two-stage parsing:</strong> This error strategy allows the first
// stage of two-stage parsing to immediately terminate if an error is
// encountered, and immediately fall back to the second stage. In addition to
// avoiding wasted work by attempting to recover from errors here, the empty
// implementation of {@link BailErrorStrategy//sync} improves the performance of
// the first stage.</li>
// <li><strong>Silent validation:</strong> When syntax errors are not being
// reported or logged, and the parse result is simply ignored if errors occur,
// the {@link BailErrorStrategy} avoids wasting work on recovering from errors
// when the result will be ignored either way.</li>
// </ul>
//
// <p>
// {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
//
// @see Parser//setErrorHandler(ANTLRErrorStrategy)
//
function BailErrorStrategy() {
	DefaultErrorStrategy.call(this);
	return this;
}

BailErrorStrategy.prototype = Object.create(DefaultErrorStrategy.prototype);
BailErrorStrategy.prototype.constructor = BailErrorStrategy;

// Instead of recovering from exception {@code e}, re-throw it wrapped
// in a {@link ParseCancellationException} so it is not caught by the
// rule function catches. Use {@link Exception//getCause()} to get the
// original {@link RecognitionException}.
//
BailErrorStrategy.prototype.recover = function(recognizer, e) {
    var context = recognizer._ctx;
    while (context !== null) {
        context.exception = e;
        context = context.parentCtx;
    }
    throw new ParseCancellationException(e);
};

// Make sure we don't attempt to recover inline; if the parser
// successfully recovers, it won't throw an exception.
//
BailErrorStrategy.prototype.recoverInline = function(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
};

// Make sure we don't attempt to recover from problems in subrules.//
BailErrorStrategy.prototype.sync = function(recognizer) {
    // pass
};

exports.BailErrorStrategy = BailErrorStrategy;
exports.DefaultErrorStrategy = DefaultErrorStrategy;


/***/ }),

/***/ "./node_modules/antlr4/error/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/antlr4/error/Errors.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

// The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
//  3 kinds of errors: prediction errors, failed predicate errors, and
//  mismatched input errors. In each case, the parser knows where it is
//  in the input, where it is in the ATN, the rule invocation stack,
//  and what kind of problem occurred.

var PredicateTransition = __webpack_require__(/*! ./../atn/Transition */ "./node_modules/antlr4/atn/Transition.js").PredicateTransition;

function RecognitionException(params) {
	Error.call(this);
	if (!!Error.captureStackTrace) {
        Error.captureStackTrace(this, RecognitionException);
	} else {
		var stack = new Error().stack;
	}
	this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    // The current {@link Token} when an error occurred. Since not all streams
    // support accessing symbols by index, we have to track the {@link Token}
    // instance itself.
    this.offendingToken = null;
    // Get the ATN state number the parser was in at the time the error
    // occurred. For {@link NoViableAltException} and
    // {@link LexerNoViableAltException} exceptions, this is the
    // {@link DecisionState} number. For others, it is the state whose outgoing
    // edge we couldn't match.
    this.offendingState = -1;
    if (this.recognizer!==null) {
        this.offendingState = this.recognizer.state;
    }
    return this;
}

RecognitionException.prototype = Object.create(Error.prototype);
RecognitionException.prototype.constructor = RecognitionException;

// <p>If the state number is not known, this method returns -1.</p>

//
// Gets the set of input symbols which could potentially follow the
// previously matched symbol at the time this exception was thrown.
//
// <p>If the set of expected tokens is not known and could not be computed,
// this method returns {@code null}.</p>
//
// @return The set of token types that could potentially follow the current
// state in the ATN, or {@code null} if the information is not available.
// /
RecognitionException.prototype.getExpectedTokens = function() {
    if (this.recognizer!==null) {
        return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
        return null;
    }
};

RecognitionException.prototype.toString = function() {
    return this.message;
};

function LexerNoViableAltException(lexer, input, startIndex, deadEndConfigs) {
	RecognitionException.call(this, {message:"", recognizer:lexer, input:input, ctx:null});
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
    return this;
}

LexerNoViableAltException.prototype = Object.create(RecognitionException.prototype);
LexerNoViableAltException.prototype.constructor = LexerNoViableAltException;

LexerNoViableAltException.prototype.toString = function() {
    var symbol = "";
    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
        symbol = this.input.getText((this.startIndex,this.startIndex));
    }
    return "LexerNoViableAltException" + symbol;
};

// Indicates that the parser could not decide which of two or more paths
// to take based upon the remaining input. It tracks the starting token
// of the offending input and also knows where the parser was
// in the various paths when the error. Reported by reportNoViableAlternative()
//
function NoViableAltException(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
	ctx = ctx || recognizer._ctx;
	offendingToken = offendingToken || recognizer.getCurrentToken();
	startToken = startToken || recognizer.getCurrentToken();
	input = input || recognizer.getInputStream();
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:input, ctx:ctx});
    // Which configurations did we try at input.index() that couldn't match
	// input.LT(1)?//
    this.deadEndConfigs = deadEndConfigs;
    // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)
    this.startToken = startToken;
    this.offendingToken = offendingToken;
}

NoViableAltException.prototype = Object.create(RecognitionException.prototype);
NoViableAltException.prototype.constructor = NoViableAltException;

// This signifies any kind of mismatched input exceptions such as
// when the current input does not match the expected token.
//
function InputMismatchException(recognizer) {
	RecognitionException.call(this, {message:"", recognizer:recognizer, input:recognizer.getInputStream(), ctx:recognizer._ctx});
    this.offendingToken = recognizer.getCurrentToken();
}

InputMismatchException.prototype = Object.create(RecognitionException.prototype);
InputMismatchException.prototype.constructor = InputMismatchException;

// A semantic predicate failed during validation. Validation of predicates
// occurs when normally parsing the alternative just like matching a token.
// Disambiguating predicate evaluation occurs when we test a predicate during
// prediction.

function FailedPredicateException(recognizer, predicate, message) {
	RecognitionException.call(this, {message:this.formatMessage(predicate,message || null), recognizer:recognizer,
                         input:recognizer.getInputStream(), ctx:recognizer._ctx});
    var s = recognizer._interp.atn.states[recognizer.state];
    var trans = s.transitions[0];
    if (trans instanceof PredicateTransition) {
        this.ruleIndex = trans.ruleIndex;
        this.predicateIndex = trans.predIndex;
    } else {
        this.ruleIndex = 0;
        this.predicateIndex = 0;
    }
    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
    return this;
}

FailedPredicateException.prototype = Object.create(RecognitionException.prototype);
FailedPredicateException.prototype.constructor = FailedPredicateException;

FailedPredicateException.prototype.formatMessage = function(predicate, message) {
    if (message !==null) {
        return message;
    } else {
        return "failed predicate: {" + predicate + "}?";
    }
};

function ParseCancellationException() {
	Error.call(this);
	Error.captureStackTrace(this, ParseCancellationException);
	return this;
}

ParseCancellationException.prototype = Object.create(Error.prototype);
ParseCancellationException.prototype.constructor = ParseCancellationException;

exports.RecognitionException = RecognitionException;
exports.NoViableAltException = NoViableAltException;
exports.LexerNoViableAltException = LexerNoViableAltException;
exports.InputMismatchException = InputMismatchException;
exports.FailedPredicateException = FailedPredicateException;
exports.ParseCancellationException = ParseCancellationException;


/***/ }),

/***/ "./node_modules/antlr4/error/index.js":
/*!********************************************!*\
  !*** ./node_modules/antlr4/error/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

exports.RecognitionException = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js").RecognitionException;
exports.NoViableAltException = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js").NoViableAltException;
exports.LexerNoViableAltException = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js").LexerNoViableAltException;
exports.InputMismatchException = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js").InputMismatchException;
exports.FailedPredicateException = __webpack_require__(/*! ./Errors */ "./node_modules/antlr4/error/Errors.js").FailedPredicateException;
exports.DiagnosticErrorListener = __webpack_require__(/*! ./DiagnosticErrorListener */ "./node_modules/antlr4/error/DiagnosticErrorListener.js").DiagnosticErrorListener;
exports.BailErrorStrategy = __webpack_require__(/*! ./ErrorStrategy */ "./node_modules/antlr4/error/ErrorStrategy.js").BailErrorStrategy;
exports.ErrorListener = __webpack_require__(/*! ./ErrorListener */ "./node_modules/antlr4/error/ErrorListener.js").ErrorListener;


/***/ }),

/***/ "./node_modules/antlr4/index.js":
/*!**************************************!*\
  !*** ./node_modules/antlr4/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.atn = __webpack_require__(/*! ./atn/index */ "./node_modules/antlr4/atn/index.js");
exports.codepointat = __webpack_require__(/*! ./polyfills/codepointat */ "./node_modules/antlr4/polyfills/codepointat.js");
exports.dfa = __webpack_require__(/*! ./dfa/index */ "./node_modules/antlr4/dfa/index.js");
exports.fromcodepoint = __webpack_require__(/*! ./polyfills/fromcodepoint */ "./node_modules/antlr4/polyfills/fromcodepoint.js");
exports.tree = __webpack_require__(/*! ./tree/index */ "./node_modules/antlr4/tree/index.js");
exports.error = __webpack_require__(/*! ./error/index */ "./node_modules/antlr4/error/index.js");
exports.Token = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").Token;
exports.CharStreams = __webpack_require__(/*! ./CharStreams */ "./node_modules/antlr4/CharStreams.js").CharStreams;
exports.CommonToken = __webpack_require__(/*! ./Token */ "./node_modules/antlr4/Token.js").CommonToken;
exports.InputStream = __webpack_require__(/*! ./InputStream */ "./node_modules/antlr4/InputStream.js").InputStream;
exports.FileStream = __webpack_require__(/*! ./FileStream */ "./node_modules/antlr4/FileStream.js").FileStream;
exports.CommonTokenStream = __webpack_require__(/*! ./CommonTokenStream */ "./node_modules/antlr4/CommonTokenStream.js").CommonTokenStream;
exports.Lexer = __webpack_require__(/*! ./Lexer */ "./node_modules/antlr4/Lexer.js").Lexer;
exports.Parser = __webpack_require__(/*! ./Parser */ "./node_modules/antlr4/Parser.js").Parser;
var pc = __webpack_require__(/*! ./PredictionContext */ "./node_modules/antlr4/PredictionContext.js");
exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = __webpack_require__(/*! ./ParserRuleContext */ "./node_modules/antlr4/ParserRuleContext.js").ParserRuleContext;
exports.Interval = __webpack_require__(/*! ./IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
exports.Utils = __webpack_require__(/*! ./Utils */ "./node_modules/antlr4/Utils.js");


/***/ }),

/***/ "./node_modules/antlr4/polyfills/codepointat.js":
/*!******************************************************!*\
  !*** ./node_modules/antlr4/polyfills/codepointat.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var codePointAt = function(position) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			var size = string.length;
			// `ToInteger`
			var index = position ? Number(position) : 0;
			if (index != index) { // better `isNaN`
				index = 0;
			}
			// Account for out-of-bounds indices:
			if (index < 0 || index >= size) {
				return undefined;
			}
			// Get the first code unit
			var first = string.charCodeAt(index);
			var second;
			if ( // check if its the start of a surrogate pair
				first >= 0xD800 && first <= 0xDBFF && // high surrogate
				size > index + 1 // there is a next code unit
			) {
				second = string.charCodeAt(index + 1);
				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
				}
			}
			return first;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'codePointAt', {
				'value': codePointAt,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.codePointAt = codePointAt;
		}
	}());
}


/***/ }),

/***/ "./node_modules/antlr4/polyfills/fromcodepoint.js":
/*!********************************************************!*\
  !*** ./node_modules/antlr4/polyfills/fromcodepoint.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
	(function() {
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var stringFromCharCode = String.fromCharCode;
		var floor = Math.floor;
		var fromCodePoint = function(_) {
			var MAX_SIZE = 0x4000;
			var codeUnits = [];
			var highSurrogate;
			var lowSurrogate;
			var index = -1;
			var length = arguments.length;
			if (!length) {
				return '';
			}
			var result = '';
			while (++index < length) {
				var codePoint = Number(arguments[index]);
				if (
					!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
					codePoint < 0 || // not a valid Unicode code point
					codePoint > 0x10FFFF || // not a valid Unicode code point
					floor(codePoint) != codePoint // not an integer
				) {
					throw RangeError('Invalid code point: ' + codePoint);
				}
				if (codePoint <= 0xFFFF) { // BMP code point
					codeUnits.push(codePoint);
				} else { // Astral code point; split in surrogate halves
					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
					codePoint -= 0x10000;
					highSurrogate = (codePoint >> 10) + 0xD800;
					lowSurrogate = (codePoint % 0x400) + 0xDC00;
					codeUnits.push(highSurrogate, lowSurrogate);
				}
				if (index + 1 == length || codeUnits.length > MAX_SIZE) {
					result += stringFromCharCode.apply(null, codeUnits);
					codeUnits.length = 0;
				}
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String, 'fromCodePoint', {
				'value': fromCodePoint,
				'configurable': true,
				'writable': true
			});
		} else {
			String.fromCodePoint = fromCodePoint;
		}
	}());
}


/***/ }),

/***/ "./node_modules/antlr4/tree/Tree.js":
/*!******************************************!*\
  !*** ./node_modules/antlr4/tree/Tree.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
///

// The basic notion of a tree has a parent, a payload, and a list of children.
//  It is the most abstract interface for all the trees used by ANTLR.
///

var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var Interval = __webpack_require__(/*! ./../IntervalSet */ "./node_modules/antlr4/IntervalSet.js").Interval;
var INVALID_INTERVAL = new Interval(-1, -2);
var Utils = __webpack_require__(/*! ../Utils.js */ "./node_modules/antlr4/Utils.js");


function Tree() {
	return this;
}

function SyntaxTree() {
	Tree.call(this);
	return this;
}

SyntaxTree.prototype = Object.create(Tree.prototype);
SyntaxTree.prototype.constructor = SyntaxTree;

function ParseTree() {
	SyntaxTree.call(this);
	return this;
}

ParseTree.prototype = Object.create(SyntaxTree.prototype);
ParseTree.prototype.constructor = ParseTree;

function RuleNode() {
	ParseTree.call(this);
	return this;
}

RuleNode.prototype = Object.create(ParseTree.prototype);
RuleNode.prototype.constructor = RuleNode;

function TerminalNode() {
	ParseTree.call(this);
	return this;
}

TerminalNode.prototype = Object.create(ParseTree.prototype);
TerminalNode.prototype.constructor = TerminalNode;

function ErrorNode() {
	TerminalNode.call(this);
	return this;
}

ErrorNode.prototype = Object.create(TerminalNode.prototype);
ErrorNode.prototype.constructor = ErrorNode;

function ParseTreeVisitor() {
	return this;
}

ParseTreeVisitor.prototype.visit = function(ctx) {
 	if (Array.isArray(ctx)) {
		return ctx.map(function(child) {
            return child.accept(this);
        }, this);
	} else {
		return ctx.accept(this);
	}
};

ParseTreeVisitor.prototype.visitChildren = function(ctx) {
	if (ctx.children) {
		return this.visit(ctx.children);
	} else {
		return null;
	}
}

ParseTreeVisitor.prototype.visitTerminal = function(node) {
};

ParseTreeVisitor.prototype.visitErrorNode = function(node) {
};


function ParseTreeListener() {
	return this;
}

ParseTreeListener.prototype.visitTerminal = function(node) {
};

ParseTreeListener.prototype.visitErrorNode = function(node) {
};

ParseTreeListener.prototype.enterEveryRule = function(node) {
};

ParseTreeListener.prototype.exitEveryRule = function(node) {
};

function TerminalNodeImpl(symbol) {
	TerminalNode.call(this);
	this.parentCtx = null;
	this.symbol = symbol;
	return this;
}

TerminalNodeImpl.prototype = Object.create(TerminalNode.prototype);
TerminalNodeImpl.prototype.constructor = TerminalNodeImpl;

TerminalNodeImpl.prototype.getChild = function(i) {
	return null;
};

TerminalNodeImpl.prototype.getSymbol = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getParent = function() {
	return this.parentCtx;
};

TerminalNodeImpl.prototype.getPayload = function() {
	return this.symbol;
};

TerminalNodeImpl.prototype.getSourceInterval = function() {
	if (this.symbol === null) {
		return INVALID_INTERVAL;
	}
	var tokenIndex = this.symbol.tokenIndex;
	return new Interval(tokenIndex, tokenIndex);
};

TerminalNodeImpl.prototype.getChildCount = function() {
	return 0;
};

TerminalNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitTerminal(this);
};

TerminalNodeImpl.prototype.getText = function() {
	return this.symbol.text;
};

TerminalNodeImpl.prototype.toString = function() {
	if (this.symbol.type === Token.EOF) {
		return "<EOF>";
	} else {
		return this.symbol.text;
	}
};

// Represents a token that was consumed during resynchronization
// rather than during a valid match operation. For example,
// we will create this kind of a node during single token insertion
// and deletion as well as during "consume until error recovery set"
// upon no viable alternative exceptions.

function ErrorNodeImpl(token) {
	TerminalNodeImpl.call(this, token);
	return this;
}

ErrorNodeImpl.prototype = Object.create(TerminalNodeImpl.prototype);
ErrorNodeImpl.prototype.constructor = ErrorNodeImpl;

ErrorNodeImpl.prototype.isErrorNode = function() {
	return true;
};

ErrorNodeImpl.prototype.accept = function(visitor) {
	return visitor.visitErrorNode(this);
};

function ParseTreeWalker() {
	return this;
}

ParseTreeWalker.prototype.walk = function(listener, t) {
	var errorNode = t instanceof ErrorNode ||
			(t.isErrorNode !== undefined && t.isErrorNode());
	if (errorNode) {
		listener.visitErrorNode(t);
	} else if (t instanceof TerminalNode) {
		listener.visitTerminal(t);
	} else {
		this.enterRule(listener, t);
		for (var i = 0; i < t.getChildCount(); i++) {
			var child = t.getChild(i);
			this.walk(listener, child);
		}
		this.exitRule(listener, t);
	}
};
//
// The discovery of a rule node, involves sending two events: the generic
// {@link ParseTreeListener//enterEveryRule} and a
// {@link RuleContext}-specific event. First we trigger the generic and then
// the rule specific. We to them in reverse order upon finishing the node.
//
ParseTreeWalker.prototype.enterRule = function(listener, r) {
	var ctx = r.getRuleContext();
	listener.enterEveryRule(ctx);
	ctx.enterRule(listener);
};

ParseTreeWalker.prototype.exitRule = function(listener, r) {
	var ctx = r.getRuleContext();
	ctx.exitRule(listener);
	listener.exitEveryRule(ctx);
};

ParseTreeWalker.DEFAULT = new ParseTreeWalker();

exports.RuleNode = RuleNode;
exports.ErrorNode = ErrorNode;
exports.TerminalNode = TerminalNode;
exports.ErrorNodeImpl = ErrorNodeImpl;
exports.TerminalNodeImpl = TerminalNodeImpl;
exports.ParseTreeListener = ParseTreeListener;
exports.ParseTreeVisitor = ParseTreeVisitor;
exports.ParseTreeWalker = ParseTreeWalker;
exports.INVALID_INTERVAL = INVALID_INTERVAL;


/***/ }),

/***/ "./node_modules/antlr4/tree/Trees.js":
/*!*******************************************!*\
  !*** ./node_modules/antlr4/tree/Trees.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Utils = __webpack_require__(/*! ./../Utils */ "./node_modules/antlr4/Utils.js");
var Token = __webpack_require__(/*! ./../Token */ "./node_modules/antlr4/Token.js").Token;
var RuleNode = __webpack_require__(/*! ./Tree */ "./node_modules/antlr4/tree/Tree.js").RuleNode;
var ErrorNode = __webpack_require__(/*! ./Tree */ "./node_modules/antlr4/tree/Tree.js").ErrorNode;
var TerminalNode = __webpack_require__(/*! ./Tree */ "./node_modules/antlr4/tree/Tree.js").TerminalNode;
var ParserRuleContext = __webpack_require__(/*! ./../ParserRuleContext */ "./node_modules/antlr4/ParserRuleContext.js").ParserRuleContext;
var RuleContext = __webpack_require__(/*! ./../RuleContext */ "./node_modules/antlr4/RuleContext.js").RuleContext;
var INVALID_ALT_NUMBER = __webpack_require__(/*! ./../atn/ATN */ "./node_modules/antlr4/atn/ATN.js").INVALID_ALT_NUMBER;


/** A set of utility routines useful for all kinds of ANTLR trees. */
function Trees() {
}

// Print out a whole tree in LISP form. {@link //getNodeText} is used on the
//  node payloads to get the text for the nodes.  Detect
//  parse trees and extract data appropriately.
Trees.toStringTree = function(tree, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
       ruleNames = recog.ruleNames;
    }
    var s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    var c = tree.getChildCount();
    if(c===0) {
        return s;
    }
    var res = "(" + s + ' ';
    if(c>0) {
        s = Trees.toStringTree(tree.getChild(0), ruleNames);
        res = res.concat(s);
    }
    for(var i=1;i<c;i++) {
        s = Trees.toStringTree(tree.getChild(i), ruleNames);
        res = res.concat(' ' + s);
    }
    res = res.concat(")");
    return res;
};

Trees.getNodeText = function(t, ruleNames, recog) {
	ruleNames = ruleNames || null;
	recog = recog || null;
    if(recog!==null) {
        ruleNames = recog.ruleNames;
    }
    if(ruleNames!==null) {
       if (t instanceof RuleContext) {
           var altNumber = t.getAltNumber();
           if ( altNumber!=INVALID_ALT_NUMBER ) {
               return ruleNames[t.ruleIndex]+":"+altNumber;
           }
           return ruleNames[t.ruleIndex];
       } else if ( t instanceof ErrorNode) {
           return t.toString();
       } else if(t instanceof TerminalNode) {
           if(t.symbol!==null) {
               return t.symbol.text;
           }
       }
    }
    // no recog for rule names
    var payload = t.getPayload();
    if (payload instanceof Token ) {
       return payload.text;
    }
    return t.getPayload().toString();
};


// Return ordered list of all children of this node
Trees.getChildren = function(t) {
	var list = [];
	for(var i=0;i<t.getChildCount();i++) {
		list.push(t.getChild(i));
	}
	return list;
};

// Return a list of all ancestors of this node.  The first node of
//  list is the root and the last is the parent of this node.
//
Trees.getAncestors = function(t) {
    var ancestors = [];
    t = t.getParent();
    while(t!==null) {
        ancestors = [t].concat(ancestors);
        t = t.getParent();
    }
    return ancestors;
};

Trees.findAllTokenNodes = function(t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
};

Trees.findAllRuleNodes = function(t, ruleIndex) {
	return Trees.findAllNodes(t, ruleIndex, false);
};

Trees.findAllNodes = function(t, index, findTokens) {
	var nodes = [];
	Trees._findAllNodes(t, index, findTokens, nodes);
	return nodes;
};

Trees._findAllNodes = function(t, index, findTokens, nodes) {
	// check this node (the root) first
	if(findTokens && (t instanceof TerminalNode)) {
		if(t.symbol.type===index) {
			nodes.push(t);
		}
	} else if(!findTokens && (t instanceof ParserRuleContext)) {
		if(t.ruleIndex===index) {
			nodes.push(t);
		}
	}
	// check children
	for(var i=0;i<t.getChildCount();i++) {
		Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
	}
};

Trees.descendants = function(t) {
	var nodes = [t];
    for(var i=0;i<t.getChildCount();i++) {
        nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }
    return nodes;
};


exports.Trees = Trees;

/***/ }),

/***/ "./node_modules/antlr4/tree/index.js":
/*!*******************************************!*\
  !*** ./node_modules/antlr4/tree/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

var Tree = __webpack_require__(/*! ./Tree */ "./node_modules/antlr4/tree/Tree.js");
exports.Trees = __webpack_require__(/*! ./Trees */ "./node_modules/antlr4/tree/Trees.js").Trees;
exports.RuleNode = Tree.RuleNode;
exports.ParseTreeListener = Tree.ParseTreeListener;
exports.ParseTreeVisitor = Tree.ParseTreeVisitor;
exports.ParseTreeWalker = Tree.ParseTreeWalker;


/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./src/compiler/astNode.ts":
/*!*********************************!*\
  !*** ./src/compiler/astNode.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NegationNode = exports.TernaryOperatorNode = exports.DivisionNode = exports.SubtractionNode = exports.MultiplicationNode = exports.AdditionNode = exports.FunctionNode = exports.DerivativeNode = exports.ConstantNode = exports.VarIdentifierNode = exports.MacroExpressionNode = exports.SumExpressionNode = exports.ExpressionNode = exports.BoolConstantNode = exports.BoolOrNode = exports.BoolAndNode = exports.BoolNENode = exports.BoolENode = exports.BoolGENode = exports.BoolGNode = exports.BoolLENode = exports.BoolLNode = exports.BoolNegationNode = exports.BoolExpressionNode = exports.LoopStatementNode = exports.Bounds = exports.SetterNode = exports.ConstantStatementNode = exports.InitialConditionNode = exports.StateNode = exports.TransitionNode = exports.MacroStatementNode = exports.EquationNode = exports.StatementNode = exports.SystemDefinition = exports.ASTNode = exports.TextPosition = exports.NodeType = void 0;
//TODO
exports.NodeType = {
    _Equation: 2,
    _MacroDefinition: 3,
    _Constant: 4,
    _InitialCondition: 5,
    _VarIdentifier: 6,
    _Loop: 7,
    _Condition: 8,
    _Function: 9,
    _ConstantStatement: 10,
    _Setter: 11,
    _Derivative: 12,
    _Addition: 13,
    _Subtraction: 14,
    _Multiplication: 15,
    _Division: 16,
    _Negation: 17,
    _Summation: 18,
    _Less: 19,
    _LessEqual: 20,
    _Greater: 21,
    _GreaterEqual: 22,
    _Equal: 23,
    _NotEqual: 24,
    _And: 25,
    _Or: 26,
    _Not: 27,
    _State: 28,
    _Macro: 29,
    _Transition: 30,
    _BoolConstant: 31,
    _Ternary: 32
};
class TextPosition {
    constructor(line, column, start, stop) {
        this.line = line;
        this.column = column;
        this.start = start;
        this.stop = stop;
    }
    static invalid() {
        return new TextPosition(-1, -1, -1, -1);
    }
}
exports.TextPosition = TextPosition;
class ASTNode {
    constructor(type) {
        this.type = type;
        this.textPos = TextPosition.invalid();
    }
    setTextPos(textPos) {
        this.textPos = textPos;
        return this;
    }
}
exports.ASTNode = ASTNode;
class SystemDefinition {
    constructor(statements) {
        this.statements = statements;
    }
}
exports.SystemDefinition = SystemDefinition;
class StatementNode extends ASTNode {
    constructor(type) {
        super(type);
    }
}
exports.StatementNode = StatementNode;
class EquationNode extends StatementNode {
    constructor(label, left, right) {
        super(exports.NodeType._Equation);
        this.label = label;
        this.left = left;
        this.right = right;
    }
}
exports.EquationNode = EquationNode;
class MacroStatementNode extends StatementNode {
    constructor(id, args, expression) {
        super(exports.NodeType._MacroDefinition);
        this.id = id;
        this.args = args;
        this.expression = expression;
    }
}
exports.MacroStatementNode = MacroStatementNode;
class TransitionNode extends ASTNode {
    constructor(prevStates, condition) {
        super(exports.NodeType._Transition);
        this.prevStates = prevStates;
        this.condition = condition;
    }
}
exports.TransitionNode = TransitionNode;
class StateNode extends StatementNode {
    constructor(id, isTerminal, stateTransitions, statements) {
        super(exports.NodeType._State);
        this.id = id;
        this.isTerminal = isTerminal;
        this.stateTransitions = stateTransitions;
        this.statements = statements;
    }
}
exports.StateNode = StateNode;
class InitialConditionNode extends StatementNode {
    constructor(id, expression) {
        super(exports.NodeType._InitialCondition);
        this.id = id;
        this.expression = expression;
    }
}
exports.InitialConditionNode = InitialConditionNode;
class ConstantStatementNode extends StatementNode {
    constructor(id, expression) {
        super(exports.NodeType._ConstantStatement);
        this.id = id;
        this.expression = expression;
    }
}
exports.ConstantStatementNode = ConstantStatementNode;
class SetterNode extends ASTNode {
    constructor(id, expression) {
        super(exports.NodeType._Setter);
        this.id = id;
        this.expression = expression;
    }
}
exports.SetterNode = SetterNode;
class Bounds {
    constructor(l, r) {
        this.l = l;
        this.r = r;
    }
}
exports.Bounds = Bounds;
class LoopStatementNode extends StatementNode {
    constructor(iterator, bounds, statements) {
        super(exports.NodeType._Loop);
        this.iterator = iterator;
        this.bounds = bounds;
        this.statements = statements;
    }
    ;
}
exports.LoopStatementNode = LoopStatementNode;
class BoolExpressionNode extends ASTNode {
    constructor(type) {
        super(type);
    }
}
exports.BoolExpressionNode = BoolExpressionNode;
class BoolNegationNode extends BoolExpressionNode {
    constructor(inner) {
        super(exports.NodeType._Negation);
        this.inner = inner;
    }
    clone() {
        return new BoolNegationNode(this.inner.clone());
    }
}
exports.BoolNegationNode = BoolNegationNode;
class BoolLNode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Less);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolLNode(this.left.clone(), this.right.clone());
    }
}
exports.BoolLNode = BoolLNode;
class BoolLENode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._LessEqual);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolLENode(this.left.clone(), this.right.clone());
    }
}
exports.BoolLENode = BoolLENode;
class BoolGNode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Greater);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolGNode(this.left.clone(), this.right.clone());
    }
}
exports.BoolGNode = BoolGNode;
class BoolGENode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._GreaterEqual);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolGENode(this.left.clone(), this.right.clone());
    }
}
exports.BoolGENode = BoolGENode;
class BoolENode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Equal);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolENode(this.left.clone(), this.right.clone());
    }
}
exports.BoolENode = BoolENode;
class BoolNENode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._NotEqual);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolNENode(this.left.clone(), this.right.clone());
    }
}
exports.BoolNENode = BoolNENode;
class BoolAndNode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._And);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolAndNode(this.left.clone(), this.right.clone());
    }
}
exports.BoolAndNode = BoolAndNode;
class BoolOrNode extends BoolExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Or);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new BoolOrNode(this.left.clone(), this.right.clone());
    }
}
exports.BoolOrNode = BoolOrNode;
class BoolConstantNode extends BoolExpressionNode {
    constructor(value) {
        super(exports.NodeType._BoolConstant);
        this.value = value;
    }
    clone() {
        return new BoolConstantNode(this.value);
    }
}
exports.BoolConstantNode = BoolConstantNode;
class ExpressionNode extends ASTNode {
    constructor(type) {
        super(type);
    }
}
exports.ExpressionNode = ExpressionNode;
class SumExpressionNode extends ExpressionNode {
    constructor(iterator, bounds, expression) {
        super(exports.NodeType._Summation);
        this.iterator = iterator;
        this.bounds = bounds;
        this.expression = expression;
    }
    clone() {
        return new SumExpressionNode(this.iterator, new Bounds(this.bounds.l, this.bounds.r), this.expression.clone());
    }
}
exports.SumExpressionNode = SumExpressionNode;
class MacroExpressionNode extends ExpressionNode {
    constructor(id, args) {
        super(exports.NodeType._Macro);
        this.id = id;
        this.args = args;
    }
    clone() {
        return new MacroExpressionNode(this.id, this.args.map(function (item) { return item.clone(); }));
    }
}
exports.MacroExpressionNode = MacroExpressionNode;
class VarIdentifierNode extends ExpressionNode {
    constructor(id, indicies) {
        super(exports.NodeType._VarIdentifier);
        this.id = id;
        this.indicies = indicies;
    }
    clone() {
        return new VarIdentifierNode(this.id, this.indicies.map(function (item) { return item.clone(); }));
    }
}
exports.VarIdentifierNode = VarIdentifierNode;
class ConstantNode extends ExpressionNode {
    constructor(value) {
        super(exports.NodeType._Constant);
        this.value = value;
    }
    clone() {
        return new ConstantNode(this.value);
    }
}
exports.ConstantNode = ConstantNode;
class DerivativeNode extends ExpressionNode {
    constructor(id) {
        super(exports.NodeType._Derivative);
        this.id = id;
    }
    clone() {
        return new DerivativeNode(this.id.clone());
    }
}
exports.DerivativeNode = DerivativeNode;
class FunctionNode extends ExpressionNode {
    constructor(name, args) {
        super(exports.NodeType._Function);
        this.name = name;
        this.args = args;
    }
    clone() {
        return new FunctionNode(this.name, this.args.map(function (item) { return item.clone(); }));
    }
}
exports.FunctionNode = FunctionNode;
class AdditionNode extends ExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Addition);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new AdditionNode(this.left.clone(), this.right.clone());
    }
}
exports.AdditionNode = AdditionNode;
class MultiplicationNode extends ExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Multiplication);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new MultiplicationNode(this.left.clone(), this.right.clone());
    }
}
exports.MultiplicationNode = MultiplicationNode;
class SubtractionNode extends ExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Subtraction);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new SubtractionNode(this.left.clone(), this.right.clone());
    }
}
exports.SubtractionNode = SubtractionNode;
class DivisionNode extends ExpressionNode {
    constructor(left, right) {
        super(exports.NodeType._Division);
        this.left = left;
        this.right = right;
    }
    clone() {
        return new DivisionNode(this.left.clone(), this.right.clone());
    }
}
exports.DivisionNode = DivisionNode;
class TernaryOperatorNode extends ExpressionNode {
    constructor(cond, tr, fls) {
        super(exports.NodeType._Ternary);
        this.condition = cond;
        this.true = tr;
        this.false = fls;
    }
    clone() {
        return new TernaryOperatorNode(this.condition.clone(), this.true.clone(), this.false.clone());
    }
}
exports.TernaryOperatorNode = TernaryOperatorNode;
class NegationNode extends ExpressionNode {
    constructor(inner) {
        super(exports.NodeType._Negation);
        this.inner = inner;
    }
    clone() {
        return new NegationNode(this.inner.clone());
    }
}
exports.NegationNode = NegationNode;
/*class ConditionalStatementNode extends StatementNode{
    condition:BoolExpressionNode;
    if:ConditionalBodyNode;
    else:ConditionalBodyNode|null;
    constructor(){
        super(NodeType._ConditionBody);
    }
}
class ConditionalBodyNode extends ASTNode{
    equations:EquationNode;
    setters:SetterNode;
}*/


/***/ }),

/***/ "./src/compiler/compiler.ts":
/*!**********************************!*\
  !*** ./src/compiler/compiler.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DAECompiler = void 0;
const astNode_1 = __webpack_require__(/*! ./astNode */ "./src/compiler/astNode.ts");
const visitor_1 = __importDefault(__webpack_require__(/*! ./visitor */ "./src/compiler/visitor.ts"));
const index_1 = __importDefault(__webpack_require__(/*! antlr4/index */ "./node_modules/antlr4/index.js"));
const odeGrammarLexer_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarLexer.js */ "./src/grammar/antlrOutput/odeGrammarLexer.js"));
const odeGrammarParser_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarParser.js */ "./src/grammar/antlrOutput/odeGrammarParser.js"));
const errorListener_1 = __importDefault(__webpack_require__(/*! ./errorListener */ "./src/compiler/errorListener.ts"));
const error_1 = __importDefault(__webpack_require__(/*! ./error */ "./src/compiler/error.ts"));
const customEDAESystem_1 = __webpack_require__(/*! ../dae/customEDAESystem */ "./src/dae/customEDAESystem.ts");
const customIDAESystem_1 = __webpack_require__(/*! ../dae/customIDAESystem */ "./src/dae/customIDAESystem.ts");
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const expressionCompiler_1 = __webpack_require__(/*! ./expressionCompiler */ "./src/compiler/expressionCompiler.ts");
const compilerContext_1 = __webpack_require__(/*! ./compilerContext */ "./src/compiler/compilerContext.ts");
const compilerError_1 = __webpack_require__(/*! ./compilerError */ "./src/compiler/compilerError.ts");
class VariableEntry {
    constructor(name, isAlgebraic, initialValue = 0) {
        this.name = name;
        this.initialValue = initialValue;
        this.isAlgebraic = isAlgebraic;
    }
}
class EquationEntry {
    constructor(expression, isAlgebraic, texPos) {
        this.expression = expression;
        this.isAlgebraic = isAlgebraic;
        this.texPox = texPos;
    }
}
class DAECompiler {
    constructor() {
        this.epsilon = 0.001;
        this.errors = [];
        this.equations = {};
        this.context = null;
        this.macros = {};
        this.variables = {};
        this.constants = {};
    }
    compileExplicit(text) {
        this.isExplicit = true;
        var chars = new index_1.default.InputStream(text);
        var lexer = new odeGrammarLexer_js_1.default.odeGrammarLexer(chars);
        lexer.removeErrorListeners();
        var listener = new errorListener_1.default(this.errors);
        lexer.addErrorListener(listener);
        //@ts-ignore
        lexer.strictMode = false;
        var tokens = new index_1.default.CommonTokenStream(lexer);
        var parser = new odeGrammarParser_js_1.default.odeGrammarParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(listener);
        var visitor = new visitor_1.default();
        parser.buildParseTrees = true;
        var tree = parser.dae();
        //@ts-ignore
        //console.log(tree.toStringTree(parser.ruleNames));
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let daeSystemDef = visitor.startDAE(tree, listener);
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        daeSystemDef.statements.forEach(function (item) {
            this.compileStatement(item);
        }, this);
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let x = [];
        let z = [];
        let x0 = [];
        Object.entries(this.variables).forEach(function ([key, variable]) {
            if (variable.isAlgebraic)
                z.push(key);
            else {
                x.push(key);
                x0.push(variable.initialValue);
            }
        });
        //prepare variable indicies
        let algContext = { indicies: {}, errors: this.errors };
        let difContext = { indicies: {}, errors: this.errors };
        x.forEach(function (item, index) {
            algContext.indicies[item] = index;
            difContext.indicies[item] = index;
        });
        z.forEach(function (item, index) {
            difContext.indicies[item] = index + x.length;
        });
        algContext.indicies["t"] = x.length;
        difContext.indicies["t"] = x.length + z.length;
        let f = [];
        let g = [];
        let self = this;
        Object.entries(this.variables).forEach(function ([key, variable]) {
            if (!self.equations.hasOwnProperty(key)) {
                self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Missing equation for variable "${key}"`));
                return;
            }
            let equation = self.equations[key];
            if (variable.isAlgebraic != equation.isAlgebraic) {
                self.errors.push(new error_1.default(equation.texPox, `Non compatible types of variable and equation "${key}"`));
                return;
            }
            if (variable.isAlgebraic) {
                g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
            }
            else {
                f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
            }
        });
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let dfdx = [];
        let dfdz = [];
        let dgdx = [];
        f.forEach(function (item) {
            let dxRow = [];
            x.forEach(function (_x) {
                dxRow.push(item.differentiate(_x, this.epsilon).simplify());
            }, this);
            dfdx.push(dxRow);
            let dzRow = [];
            z.forEach(function (_z) {
                dzRow.push(item.differentiate(_z, this.epsilon).simplify());
            }, this);
            dfdz.push(dzRow);
        }, this);
        g.forEach(function (item) {
            let dxRow = [];
            x.forEach(function (_x) {
                dxRow.push(item.differentiate(_x, this.epsilon).simplify());
            }, this);
            dgdx.push(dxRow);
        }, this);
        return { system: new customEDAESystem_1.CustomEDAESystem(f, g, dfdx, dfdz, dgdx), x0: new vector_1.vector(x0), x: x, z: z };
    }
    compileImplicit(text) {
        this.isExplicit = false;
        var chars = new index_1.default.InputStream(text);
        var lexer = new odeGrammarLexer_js_1.default.odeGrammarLexer(chars);
        lexer.removeErrorListeners();
        var listener = new errorListener_1.default(this.errors);
        lexer.addErrorListener(listener);
        //@ts-ignore
        lexer.strictMode = false;
        var tokens = new index_1.default.CommonTokenStream(lexer);
        var parser = new odeGrammarParser_js_1.default.odeGrammarParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(listener);
        var visitor = new visitor_1.default();
        parser.buildParseTrees = true;
        var tree = parser.dae();
        //@ts-ignore
        //console.log(tree.toStringTree(parser.ruleNames));
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let daeSystemDef = visitor.startDAE(tree, listener);
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        daeSystemDef.statements.forEach(function (item) {
            this.compileStatement(item);
        }, this);
        let x = [];
        let z = [];
        let x0 = [];
        let z0 = [];
        Object.entries(this.variables).forEach(function ([key, variable]) {
            if (variable.isAlgebraic) {
                z.push(key);
                z0.push(variable.initialValue);
            }
            else {
                x.push(key);
                x0.push(variable.initialValue);
            }
        });
        //prepare variable indicies
        //x,z,t
        let algContext = { indicies: {}, errors: this.errors };
        //x,dx,z,t
        let difContext = { indicies: {}, errors: this.errors };
        x.forEach(function (item, index) {
            algContext.indicies[item] = index;
            difContext.indicies[item] = index;
            difContext.indicies[item + "'"] = index + x.length;
        });
        z.forEach(function (item, index) {
            algContext.indicies[item] = index + x.length;
            difContext.indicies[item] = index + 2 * x.length;
        });
        algContext.indicies["t"] = x.length + z.length;
        difContext.indicies["t"] = 2 * x.length + z.length;
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let algEquations = [];
        let difEquations = [];
        Object.entries(this.equations).forEach(function ([key, value]) {
            if (value.isAlgebraic)
                algEquations.push(key);
            else
                difEquations.push(key);
        });
        if (difEquations.length != x.length) {
            this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of dif. equations: ${difEquations.length}, dif. variables: ${x.length}`));
        }
        if (algEquations.length != z.length) {
            this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of alg. equations: ${algEquations.length}, alg. variables: ${z.length}`));
        }
        let f = [];
        let g = [];
        let self = this;
        algEquations.forEach(function (label) {
            let equation = self.equations[label];
            g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
        }, this);
        difEquations.forEach(function (label) {
            let equation = self.equations[label];
            f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
        }, this);
        if (algContext.errors.length > 0 || difContext.errors.length > 0) {
            throw new compilerError_1.CompilerError(algContext.errors.concat(difContext.errors));
        }
        let dfdx = [];
        let dfddx = [];
        let dfdz = [];
        let dgdx = [];
        let dgdz = [];
        f.forEach(function (item) {
            let dxRow = [];
            let ddxRow = [];
            x.forEach(function (_x) {
                dxRow.push(item.differentiate(_x, this.epsilon).simplify());
                ddxRow.push(item.differentiate(_x + "'", this.epsilon).simplify());
            }, this);
            dfdx.push(dxRow);
            dfddx.push(ddxRow);
            let dzRow = [];
            z.forEach(function (_z) {
                dzRow.push(item.differentiate(_z, this.epsilon).simplify());
            }, this);
            dfdz.push(dzRow);
        }, this);
        g.forEach(function (item) {
            let dxRow = [];
            x.forEach(function (_x) {
                dxRow.push(item.differentiate(_x, this.epsilon).simplify());
            }, this);
            dgdx.push(dxRow);
            let dzRow = [];
            z.forEach(function (_z) {
                dzRow.push(item.differentiate(_z, this.epsilon).simplify());
            }, this);
            dgdz.push(dzRow);
        }, this);
        return { system: new customIDAESystem_1.CustomIDAESystem(f, g, dfdx, dfddx, dfdz, dgdx, dgdz), x0: new vector_1.vector(x0), x: x, z0: new vector_1.vector(z0), z: z };
    }
    getSymbolName(node) {
        let result = node.id;
        let self = this;
        node.indicies.forEach(function (item, index) {
            let indexValue = (expressionCompiler_1.compileExpression(self.expandExpression(item.clone()), { indicies: {}, errors: self.errors })).eval({});
            if (Number.isInteger(indexValue)) {
                result += `[${indexValue}]`;
                return;
            }
            else {
                self.errors.push(new error_1.default(node.textPos, `Expression for ${index} index value of variable "${node.id}" is not constant`));
            }
        });
        return result;
    }
    expandBoolExpression(node) {
        switch (node.type) {
            case astNode_1.NodeType._And: {
                let and = node;
                and.left = this.expandBoolExpression(and.left);
                and.right = this.expandBoolExpression(and.right);
                return and;
            }
            case astNode_1.NodeType._Or: {
                let or = node;
                or.left = this.expandBoolExpression(or.left);
                or.right = this.expandBoolExpression(or.right);
                return or;
            }
            case astNode_1.NodeType._Not: {
                let not = node;
                not.inner = this.expandExpression(not.inner);
                return not;
            }
            case astNode_1.NodeType._Greater: {
                let g = node;
                g.left = this.expandExpression(g.left);
                g.right = this.expandExpression(g.right);
                return g;
            }
            case astNode_1.NodeType._GreaterEqual: {
                let ge = node;
                ge.left = this.expandExpression(ge.left);
                ge.right = this.expandExpression(ge.right);
                return ge;
            }
            case astNode_1.NodeType._Less: {
                let l = node;
                l.left = this.expandExpression(l.left);
                l.right = this.expandExpression(l.right);
                return l;
            }
            case astNode_1.NodeType._LessEqual: {
                let le = node;
                le.left = this.expandExpression(le.left);
                le.right = this.expandExpression(le.right);
                return le;
            }
            case astNode_1.NodeType._Equal: {
                let e = node;
                e.left = this.expandExpression(e.left);
                e.right = this.expandExpression(e.right);
                return e;
            }
            case astNode_1.NodeType._NotEqual: {
                let ne = node;
                ne.left = this.expandExpression(ne.left);
                ne.right = this.expandExpression(ne.right);
                return ne;
            }
            case astNode_1.NodeType._BoolConstant: {
                return node;
            }
            default:
                this.errors.push(new error_1.default(node.textPos, "Unexpected boolean expression type at expandBoolExpression()"));
                return new astNode_1.BoolConstantNode(false);
        }
    }
    expandExpression(node) {
        switch (node.type) {
            case astNode_1.NodeType._Addition: {
                let add = node;
                add.left = this.expandExpression(add.left);
                add.right = this.expandExpression(add.right);
                return add;
            }
            case astNode_1.NodeType._Subtraction: {
                let sub = node;
                sub.left = this.expandExpression(sub.left);
                sub.right = this.expandExpression(sub.right);
                return sub;
            }
            case astNode_1.NodeType._Multiplication: {
                let mult = node;
                mult.left = this.expandExpression(mult.left);
                mult.right = this.expandExpression(mult.right);
                return mult;
            }
            case astNode_1.NodeType._Division: {
                let div = node;
                div.left = this.expandExpression(div.left);
                div.right = this.expandExpression(div.right);
                return div;
            }
            case astNode_1.NodeType._Negation: {
                let neg = node;
                neg.inner = this.expandExpression(neg.inner);
                return neg;
            }
            case astNode_1.NodeType._Derivative: {
                let der = node;
                let id = this.expandExpression(der.id);
                if (id instanceof astNode_1.VarIdentifierNode && id.id != "t") {
                    if (this.variables.hasOwnProperty(id.id)) {
                        this.variables[id.id].isAlgebraic = false;
                    }
                    else {
                        this.variables[id.id] = new VariableEntry(id.id, false);
                    }
                    der.id = id;
                    return der;
                }
                this.errors.push(new error_1.default(node.textPos, `Incorrect symbol in derivative`));
                return new astNode_1.ConstantNode(0);
            }
            case astNode_1.NodeType._Function: {
                let fun = node;
                for (let i = 0; i < fun.args.length; i++) {
                    fun.args[i] = this.expandExpression(fun.args[i]);
                }
                return fun;
            }
            case astNode_1.NodeType._VarIdentifier: {
                let _var = node;
                if (_var.indicies.length == 0) {
                    let _context = this.context;
                    while (_context != null) {
                        if (_context instanceof compilerContext_1.LoopContext) {
                            if (_context.iterator == _var.id) {
                                return new astNode_1.ConstantNode(_context.index);
                            }
                        }
                        else if (_context instanceof compilerContext_1.MacroContext) {
                            if (_context.args.hasOwnProperty(_var.id)) {
                                return this.expandExpression(_context.args[_var.id].clone());
                            }
                        }
                        _context = _context.previous;
                    }
                }
                _var.id = this.getSymbolName(_var);
                _var.indicies = [];
                if (this.constants.hasOwnProperty(_var.id)) {
                    return new astNode_1.ConstantNode(this.constants[_var.id]);
                }
                if (_var.id != "t") {
                    if (!this.variables.hasOwnProperty(_var.id)) {
                        this.variables[_var.id] = new VariableEntry(_var.id, true);
                    }
                }
                return _var;
            }
            case astNode_1.NodeType._Constant: {
                return node;
            }
            case astNode_1.NodeType._Summation: {
                let summation = node;
                if (summation.bounds.l > summation.bounds.r) {
                    this.errors.push(new error_1.default(node.textPos, `Left bound of summation is bigger then right bound`));
                    return new astNode_1.ConstantNode(0);
                }
                let sum = [];
                let _context = new compilerContext_1.LoopContext(this.context, summation.iterator);
                this.context = _context;
                for (let i = summation.bounds.l; i <= summation.bounds.r; i++) {
                    _context.index = i;
                    sum.push(this.expandExpression(summation.expression.clone()));
                }
                //return this.expandExpression(summation.expression);
                this.context = this.context.previous;
                let result = sum[0];
                if (sum.length == 1)
                    return result;
                for (let i = 1; i < sum.length; i++) {
                    result = new astNode_1.AdditionNode(result, sum[i]);
                }
                return result;
            }
            case astNode_1.NodeType._Macro: {
                let macro = node;
                let macroName = this.getSymbolName(macro.id);
                let macroDef = this.macros[macroName];
                if (macroDef == undefined) {
                    this.errors.push(new error_1.default(node.textPos, `Undefined macro "${macroName}"`));
                    return new astNode_1.ConstantNode(0);
                }
                if (macroDef.args.length != macro.args.length) {
                    this.errors.push(new error_1.default(node.textPos, `Invalid number of arguments in macro "${macroName}"`));
                    return new astNode_1.ConstantNode(0);
                }
                let args = {};
                macro.args.forEach(function (item, index) {
                    args[macroDef.args[index]] = item.clone();
                });
                this.context = new compilerContext_1.MacroContext(this.context, args);
                let result = this.expandExpression(macroDef.expression.clone());
                this.context = this.context.previous;
                return result;
            }
            case astNode_1.NodeType._Ternary: {
                let ter = node;
                ter.condition = this.expandBoolExpression(ter.condition);
                ter.true = this.expandExpression(ter.true);
                ter.false = this.expandExpression(ter.false);
                return ter;
            }
            default:
                this.errors.push(new error_1.default(node.textPos, "Unexpected expression type at validateExpression()"));
                return new astNode_1.ConstantNode(0);
        }
    }
    compileConstant(node) {
        let constant = this.getSymbolName(node.id);
        if (constant == "t") {
            this.errors.push(new error_1.default(node.textPos, 'Invalid use of time variable'));
        }
        else if (this.variables.hasOwnProperty(constant)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of variable "${constant}"`));
        }
        else if (this.constants.hasOwnProperty(constant)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of constant "${constant}"`));
        }
        else {
            try {
                this.constants[constant] = (expressionCompiler_1.compileExpression(this.expandExpression(node.expression.clone()), { indicies: {}, errors: this.errors })).eval({});
            }
            catch (error) {
                this.errors.push(new error_1.default(node.textPos, error));
            }
        }
    }
    compileInitialCondition(node) {
        let variable = this.getSymbolName(node.id);
        let value = 0;
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of time variable`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}"`));
            return;
        }
        try {
            value = (expressionCompiler_1.compileExpression(this.expandExpression(node.expression.clone()), { indicies: {}, errors: this.errors })).eval({});
        }
        catch (error) {
            this.errors.push(new error_1.default(node.textPos, `Can't evaluate initial condition for variable "${variable}"`));
            this.errors.push(new error_1.default(node.textPos, error));
            return;
        }
        if (this.variables.hasOwnProperty(variable)) {
            this.variables[variable].initialValue = value;
        }
        else {
            this.variables[variable] = new VariableEntry(variable, true, value);
        }
    }
    compileAlgEquation(node) {
        let variable = this.getSymbolName(node.left);
        if (this.equations.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Multiple equations for variable "${variable}"`));
            return;
        }
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of time variable`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}"`));
            return;
        }
        if (!this.variables.hasOwnProperty(variable)) {
            this.variables[variable] = new VariableEntry(variable, true);
        }
        let equation = this.expandExpression(node.right.clone());
        //right side shouldn't have any derivatives
        if (expressionCompiler_1.hasDerivative(equation)) {
            this.errors.push(new error_1.default(node.textPos, `Right hand side expression for variable "${variable}" contains derivatives`));
            return;
        }
        this.equations[variable] = new EquationEntry(equation, true, node.textPos);
    }
    compileDifEquation(node) {
        let variable = this.getSymbolName(node.left.id);
        if (this.equations.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Multiple equations for variable "${variable}"`));
            return;
        }
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}"`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of constant "${variable}"`));
            return;
        }
        if (this.variables.hasOwnProperty(variable)) {
            this.variables[variable].isAlgebraic = false;
        }
        else {
            this.variables[variable] = new VariableEntry(variable, false);
        }
        let equation = this.expandExpression(node.right.clone());
        if (expressionCompiler_1.hasDerivative(equation)) {
            this.errors.push(new error_1.default(node.textPos, `Right hand side expression for variable "${variable}" contains derivatives`));
            return;
        }
        this.equations[variable] = new EquationEntry(equation, false, node.textPos);
    }
    compileExplicitEquation(node) {
        if (node.left instanceof astNode_1.VarIdentifierNode) {
            this.compileAlgEquation(node);
        }
        else if (node.left instanceof astNode_1.DerivativeNode) {
            this.compileDifEquation(node);
        }
        else {
            this.errors.push(new error_1.default(node.textPos, `Equation should be in explicit form`));
        }
    }
    compileImplicitEquation(node) {
        let label = (node.label != null ? this.getSymbolName(node.label) : (Object.keys(this.equations).length + 1));
        let equation = new astNode_1.SubtractionNode(node.left, node.right);
        equation = this.expandExpression(equation.clone()); //TODO add variables to variablesTable and remove validate
        this.equations[label] = new EquationEntry(equation, !expressionCompiler_1.hasDerivative(equation), node.textPos);
    }
    compileLoop(node) {
        let _context = new compilerContext_1.LoopContext(this.context, node.iterator);
        this.context = _context;
        let statements = node.statements;
        let self = this;
        node.bounds.forEach(function (bounds) {
            if (bounds.l > bounds.r) {
                self.errors.push(new error_1.default(node.textPos, `Left bound value "${bounds.l}" is higher then right bound value "${bounds.r}"`));
                return;
            }
            for (let i = bounds.l; i <= bounds.r; i++) {
                _context.index = i;
                statements.forEach(function (statement) {
                    self.compileStatement(statement);
                });
            }
        });
        this.context = this.context.previous;
    }
    compileMacro(node) {
        let macroName = this.getSymbolName(node.id);
        if (this.macros.hasOwnProperty(macroName)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of macro "${macroName}"`));
            return;
        }
        this.macros[macroName] = node;
    }
    compileStatement(node) {
        switch (node.type) {
            case astNode_1.NodeType._ConstantStatement: {
                this.compileConstant(node);
                break;
            }
            case astNode_1.NodeType._InitialCondition: {
                this.compileInitialCondition(node);
                break;
            }
            case astNode_1.NodeType._Equation: {
                if (this.isExplicit)
                    this.compileExplicitEquation(node);
                else
                    this.compileImplicitEquation(node);
                break;
            }
            case astNode_1.NodeType._Loop: {
                this.compileLoop(node);
                break;
            }
            case astNode_1.NodeType._MacroDefinition: {
                this.compileMacro(node);
                break;
            }
            default:
                this.errors.push(new error_1.default(node.textPos, `Unexpected statement type at compileStatement()`));
        }
    }
}
exports.DAECompiler = DAECompiler;


/***/ }),

/***/ "./src/compiler/compilerContext.ts":
/*!*****************************************!*\
  !*** ./src/compiler/compilerContext.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MacroContext = exports.LoopContext = exports.CompilerContext = void 0;
class CompilerContext {
    constructor(previous) {
        this.previous = previous;
    }
}
exports.CompilerContext = CompilerContext;
class LoopContext extends CompilerContext {
    constructor(previous, iterator) {
        super(previous);
        this.iterator = iterator;
    }
}
exports.LoopContext = LoopContext;
class MacroContext extends CompilerContext {
    constructor(previous, args) {
        super(previous);
        this.args = args;
    }
}
exports.MacroContext = MacroContext;


/***/ }),

/***/ "./src/compiler/compilerError.ts":
/*!***************************************!*\
  !*** ./src/compiler/compilerError.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CompilerError = void 0;
class CompilerError extends Error {
    constructor(messages) {
        super();
        this.messages = messages;
    }
}
exports.CompilerError = CompilerError;


/***/ }),

/***/ "./src/compiler/error.ts":
/*!*******************************!*\
  !*** ./src/compiler/error.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ErrorMessage {
    constructor(textPos, message) {
        this.textPos = textPos;
        this.message = message;
    }
    print() {
        if (this.textPos.line != -1)
            return `${this.message} at line:${this.textPos.line}, position:${this.textPos.column}`;
        return this.message;
    }
}
exports.default = ErrorMessage;


/***/ }),

/***/ "./src/compiler/errorListener.ts":
/*!***************************************!*\
  !*** ./src/compiler/errorListener.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = __importDefault(__webpack_require__(/*! antlr4/error/ */ "./node_modules/antlr4/error/index.js"));
const error_2 = __importDefault(__webpack_require__(/*! ./error */ "./src/compiler/error.ts"));
const astNode_1 = __webpack_require__(/*! ./astNode */ "./src/compiler/astNode.ts");
class ErrorListener extends error_1.default.ErrorListener {
    constructor(errors) {
        super();
        this.errors = errors;
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        this.errors.push(new error_2.default(new astNode_1.TextPosition(line, column, offendingSymbol.start, offendingSymbol.stop), msg));
    }
    add(textPos, msg) {
        this.errors.push(new error_2.default(textPos, msg));
    }
}
exports.default = ErrorListener;


/***/ }),

/***/ "./src/compiler/expression.ts":
/*!************************************!*\
  !*** ./src/compiler/expression.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BoolConstant = exports.BoolNot = exports.LEqual = exports.Less = exports.GEqual = exports.Greater = exports.NotEqual = exports.Equal = exports.Or = exports.And = exports.BoolExpression = exports.TernaryOperator = exports.Variable = exports.Function = exports.Division = exports.Subtraction = exports.Addition = exports.Multiplication = exports.Negation = exports.Constant = exports.Expression = exports.NodeType = void 0;
const functions_1 = __webpack_require__(/*! ./functions */ "./src/compiler/functions.ts");
exports.NodeType = {
    _Constant: 0,
    _Function: 1,
    _Variable: 2,
    _Ternary: 3,
    _Division: 4,
    _Multiplication: 5,
    _Negation: 6,
    _Subtraction: 7,
    _Addition: 8
};
class Expression {
    constructor(type) {
        this.type = type;
    }
}
exports.Expression = Expression;
class Constant extends Expression {
    constructor(value) {
        super(exports.NodeType._Constant);
        this.value = value;
    }
    clone() {
        return new Constant(this.value);
    }
    differentiate(variable, epsilon) {
        return new Constant(0.0);
    }
    eval(variableMap) {
        return this.value;
    }
    execute(variableValues) {
        return this.value;
    }
    simplify() {
        return this.clone();
    }
    print() {
        return this.value.toString();
    }
}
exports.Constant = Constant;
class Negation extends Expression {
    constructor(inner) {
        super(exports.NodeType._Negation);
        this.inner = inner;
    }
    clone() {
        return new Negation(this.inner.clone());
    }
    differentiate(variable, epsilon) {
        return new Negation(this.inner.differentiate(variable, epsilon));
    }
    eval(variableMap) {
        return -this.inner.eval(variableMap);
    }
    execute(variableValues) {
        return -this.inner.execute(variableValues);
    }
    simplify() {
        let node = this.inner.simplify();
        if (node instanceof Constant)
            return new Constant(-node.value);
        if (node instanceof Negation) {
            return node.inner;
        }
        return new Negation(node);
    }
    print() {
        let arg = this.inner.print();
        return "-" + (this.inner.type >= this.type ? "(" + arg + ")" : arg);
    }
}
exports.Negation = Negation;
class BinaryOp extends Expression {
    constructor(type, left, right) {
        super(type);
        this.left = left;
        this.right = right;
    }
}
class Multiplication extends BinaryOp {
    constructor(left, right) {
        super(exports.NodeType._Multiplication, left, right);
    }
    clone() {
        return new Multiplication(this.left.clone(), this.right.clone());
    }
    differentiate(variable, epsilon) {
        return new Addition(new Multiplication(this.left.differentiate(variable, epsilon), this.right.clone()), new Multiplication(this.left.clone(), this.right.differentiate(variable, epsilon)));
    }
    eval(variableMap) {
        return this.left.eval(variableMap) * this.right.eval(variableMap);
    }
    execute(variableValues) {
        return this.left.execute(variableValues) * this.right.execute(variableValues);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant) {
            if (r instanceof Constant) {
                return new Constant(l.value * r.value);
            }
            if (Math.abs(l.value) == 0.0)
                return l;
            if (l.value == 1)
                return r;
            if (l.value == -1)
                return new Negation(r);
        }
        else if (r instanceof Constant) {
            if (Math.abs(r.value) == 0.0)
                return r;
            if (r.value == 1)
                return l;
            if (r.value == -1)
                return new Negation(l);
        }
        return new Multiplication(l, r);
    }
    print() {
        let l = this.left.print();
        let r = this.right.print();
        return (this.left.type > this.type ? "(" + l + ")" : l) + "*" + (this.right.type > this.type ? "(" + r + ")" : r);
    }
}
exports.Multiplication = Multiplication;
class Addition extends BinaryOp {
    constructor(left, right) {
        super(exports.NodeType._Addition, left, right);
    }
    clone() {
        return new Addition(this.left.clone(), this.right.clone());
    }
    differentiate(variable, epsilon) {
        return new Addition(this.left.differentiate(variable, epsilon), this.right.differentiate(variable, epsilon));
    }
    eval(variableMap) {
        return this.left.eval(variableMap) + this.right.eval(variableMap);
    }
    execute(variableValues) {
        return this.left.execute(variableValues) + this.right.execute(variableValues);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant) {
            if (r instanceof Constant) {
                return new Constant(l.value + r.value);
            }
            if (Math.abs(l.value) == 0)
                return r;
        }
        else if (r instanceof Constant) {
            if (Math.abs(r.value) == 0.0)
                return l;
        }
        return new Addition(l, r);
    }
    print() {
        let l = this.left.print();
        let r = this.right.print();
        return (this.left.type > this.type ? "(" + l + ")" : l) + "+" + (this.right.type > this.type ? "(" + r + ")" : r);
    }
}
exports.Addition = Addition;
class Subtraction extends BinaryOp {
    constructor(left, right) {
        super(exports.NodeType._Subtraction, left, right);
    }
    clone() {
        return new Subtraction(this.left.clone(), this.right.clone());
    }
    differentiate(variable, epsilon) {
        return new Subtraction(this.left.differentiate(variable, epsilon), this.right.differentiate(variable, epsilon));
    }
    eval(variableMap) {
        return this.left.eval(variableMap) - this.right.eval(variableMap);
    }
    execute(variableValues) {
        return this.left.execute(variableValues) - this.right.execute(variableValues);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant) {
            if (r instanceof Constant) {
                return new Constant(l.value - r.value);
            }
            if (Math.abs(l.value) == 0)
                return new Negation(r);
        }
        else if (r instanceof Constant) {
            if (Math.abs(r.value) == 0)
                return l;
        }
        return new Subtraction(l, r);
    }
    print() {
        let l = this.left.print();
        let r = this.right.print();
        return (this.left.type > this.type ? "(" + l + ")" : l) + "-" + (this.right.type >= this.type ? "(" + r + ")" : r);
    }
}
exports.Subtraction = Subtraction;
class Division extends BinaryOp {
    constructor(left, right) {
        super(exports.NodeType._Division, left, right);
    }
    clone() {
        return new Division(this.left.clone(), this.right.clone());
    }
    differentiate(variable, epsilon) {
        return new Subtraction(new Division(this.left.differentiate(variable, epsilon), this.right.clone()), new Multiplication(this.right.differentiate(variable, epsilon), new Division(this.left.clone(), new Function("pow", [
            this.right.clone(), new Constant(2)
        ]))));
    }
    eval(variableMap) {
        return this.left.eval(variableMap) / this.right.eval(variableMap);
    }
    execute(variableValues) {
        return this.left.execute(variableValues) / this.right.execute(variableValues);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant) {
            if (Math.abs(l.value) == 0.0)
                return l;
            if (r instanceof Constant) {
                return new Constant(l.value / r.value);
            }
        }
        else if (r instanceof Constant) {
            if (r.value == 1)
                return l;
            if (r.value == -1)
                return new Negation(l);
        }
        return new Division(l, r);
    }
    print() {
        let l = this.left.print();
        let r = this.right.print();
        return (this.left.type >= this.type ? "(" + l + ")" : l) + "/" + (this.right.type >= this.type ? "(" + r + ")" : r);
    }
}
exports.Division = Division;
class Function extends Expression {
    constructor(functionName, args) {
        super(exports.NodeType._Function);
        this.functionName = functionName;
        this.function = functions_1.functionDictionary[functionName];
        this.args = args;
        if (this.function === undefined)
            throw `Unknown function \"${functionName}`;
        if (this.function.argCount != args.length)
            throw `Incorrect number of arguments in function \"${functionName}: ${args.length}, ${this.function.argCount} expected`;
    }
    clone() {
        return new Function(this.functionName, this.args.map(function (item) {
            return item.clone();
        }));
    }
    differentiate(variable, epsilon) {
        if (this.args.length == 0)
            return new Constant(0.0);
        if (this.args.length == 1) {
            return new Multiplication(this.args[0].differentiate(variable, epsilon), this.getDerivative(0, epsilon));
        }
        let root = new Addition(null, null);
        let current = root;
        for (let i = 0; i < this.args.length - 1; i++) {
            current.left = new Multiplication(this.args[i].differentiate(variable, epsilon), this.getDerivative(i, epsilon));
            if (i < this.args.length - 2) {
                current.right = new Addition(null, null);
                current = current.right;
            }
        }
        current.right = new Multiplication(this.args[this.args.length - 1].differentiate(variable, epsilon), this.getDerivative(this.args.length - 1, epsilon));
        return root;
    }
    eval(variableMap) {
        let args = this.args.map((item) => {
            return item.eval(variableMap);
        });
        return this.function.exec(args);
    }
    execute(variableValues) {
        let args = this.args.map((item) => {
            return item.execute(variableValues);
        });
        return this.function.exec(args);
    }
    getDerivative(index, epsilon) {
        if (this.function.derivatives === null) { //use backward difference{
            let argumentsBackward = this.args.slice();
            argumentsBackward[index] = new Subtraction(argumentsBackward[index], new Constant(epsilon));
            return new Division(new Subtraction(new Function(this.functionName, this.args), new Function(this.functionName, argumentsBackward)), new Constant(epsilon));
        }
        return this.function.derivatives[index](this.args);
    }
    simplify() {
        let constantArgs = true;
        let args = this.args.map((item) => {
            let _item = item.simplify();
            constantArgs = constantArgs && (item instanceof Constant);
            return _item;
        });
        if (constantArgs) {
            let constArgs = args.map((item) => { return item.value; });
            return new Constant(this.function.exec(constArgs));
        }
        this.args = args;
        return this;
    }
    print() {
        let args = this.args.map((item) => item.print());
        let result = this.function.name + "(";
        this.args.forEach((item, index) => {
            result += (index > 0 ? ", " : "") + item.print();
        });
        return result + ")";
    }
}
exports.Function = Function;
class Variable extends Expression {
    constructor(index, name) {
        super(exports.NodeType._Variable);
        this.index = index;
        this.name = name;
    }
    clone() {
        return new Variable(this.index, this.name);
    }
    differentiate(variable, epsilon) {
        if (variable == this.name)
            return new Constant(1.0);
        return new Constant(0.0);
    }
    eval(variableMap) {
        return variableMap[this.name];
    }
    execute(variableValues) {
        return variableValues[this.index];
    }
    simplify() {
        return this.clone();
    }
    print() {
        return this.name;
    }
}
exports.Variable = Variable;
class TernaryOperator extends Expression {
    constructor(condition, t, f) {
        super(exports.NodeType._Ternary);
        this.condition = condition;
        this.t = t;
        this.f = f;
    }
    clone() {
        return new TernaryOperator(this.condition.clone(), this.t.clone(), this.f.clone());
    }
    differentiate(variable, epsilon) {
        return new TernaryOperator(this.condition.clone(), this.t.differentiate(variable, epsilon), this.f.differentiate(variable, epsilon));
    }
    eval(variableMap) {
        if (this.condition.eval(variableMap)) {
            return this.t.eval(variableMap);
        }
        return this.f.eval(variableMap);
    }
    execute(variableValues) {
        if (this.condition.execute(variableValues)) {
            return this.t.execute(variableValues);
        }
        return this.f.execute(variableValues);
    }
    simplify() {
        let condition = this.condition.simplify();
        if (condition instanceof BoolConstant) {
            let constant = condition;
            if (constant.value)
                return this.t.simplify();
            return this.f.simplify();
        }
        return new TernaryOperator(condition, this.t.simplify(), this.f.simplify());
    }
    print() {
        return `{${this.condition.print()}?${this.t.print()}:${this.f.print()}}`;
    }
}
exports.TernaryOperator = TernaryOperator;
class BoolExpression {
}
exports.BoolExpression = BoolExpression;
class BoolBinaryOp extends BoolExpression {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
    }
}
class BoolBinaryExpOp extends BoolExpression {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
    }
}
class And extends BoolBinaryOp {
    clone() {
        return new And(this.left.clone(), this.right.clone());
    }
    eval(variableMap) {
        return this.left.eval(variableMap) && this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) && this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        if (l instanceof BoolConstant) {
            if (l.value == false)
                return l;
            return this.right.simplify();
        }
        let r = this.right.simplify();
        if (r instanceof BoolConstant) {
            if (r.value == false) {
                return r;
            }
            return l;
        }
        return new And(l, r);
    }
    convertToExpression(epsilon) {
        return new Function("min", [this.left.convertToExpression(epsilon), this.right.convertToExpression(epsilon)]);
    }
    print() {
        return `(${this.left.print()}) and (${this.right.print()})`;
    }
}
exports.And = And;
class Or extends BoolBinaryOp {
    clone() {
        return new Or(this.left.clone(), this.right.clone());
    }
    eval(variableMap) {
        return this.left.eval(variableMap) || this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) || this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        if (l instanceof BoolConstant) {
            if (l.value == true)
                return l;
            return this.right.simplify();
        }
        let r = this.right.simplify();
        if (r instanceof BoolConstant) {
            if (r.value == true) {
                return r;
            }
            return l;
        }
        return new Or(l, r);
    }
    convertToExpression(epsilon) {
        return new Function("max", [this.left.convertToExpression(epsilon), this.right.convertToExpression(epsilon)]);
    }
    print() {
        return `(${this.left.print()}) or (${this.right.print()})`;
    }
}
exports.Or = Or;
class Equal extends BoolBinaryExpOp {
    clone() {
        return new Equal(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) == this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) == this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value == r.value);
        }
        return new Equal(l, r);
    }
    convertToExpression(epsilon) {
        return new Subtraction(new Constant(epsilon * epsilon), new Function("pow", [new Subtraction(this.left.clone(), this.right.clone()), new Constant(2)]));
    }
    print() {
        return `${this.left.print()} = ${this.right.print()}`;
    }
}
exports.Equal = Equal;
class NotEqual extends BoolBinaryExpOp {
    clone() {
        return new NotEqual(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) != this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) != this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value != r.value);
        }
        return new NotEqual(l, r);
    }
    convertToExpression(epsilon) {
        return new Addition(new Constant(-epsilon * epsilon), new Function("pow", [new Subtraction(this.left.clone(), this.right.clone()), new Constant(2)]));
    }
    print() {
        return `${this.left.print()} != ${this.right.print()}`;
    }
}
exports.NotEqual = NotEqual;
class Greater extends BoolBinaryExpOp {
    clone() {
        return new Greater(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) > this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) > this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value > r.value);
        }
        return new Greater(l, r);
    }
    convertToExpression(epsilon) {
        return new Subtraction(this.left.clone(), this.right.clone());
    }
    print() {
        return `${this.left.print()}>${this.right.print()}`;
    }
}
exports.Greater = Greater;
class GEqual extends BoolBinaryExpOp {
    clone() {
        return new GEqual(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) >= this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) >= this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value >= r.value);
        }
        return new GEqual(l, r);
    }
    convertToExpression(epsilon) {
        return new Addition(new Subtraction(this.left.clone(), this.right.clone()), new Constant(epsilon));
    }
    print() {
        return `${this.left.print()} >= ${this.right.print()}`;
    }
}
exports.GEqual = GEqual;
class Less extends BoolBinaryExpOp {
    clone() {
        return new Less(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) < this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) < this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value < r.value);
        }
        return new Less(l, r);
    }
    convertToExpression(epsilon) {
        return new Subtraction(this.right.clone(), this.left.clone());
    }
    print() {
        return `${this.left.print()} < ${this.right.print()}`;
    }
}
exports.Less = Less;
class LEqual extends BoolBinaryExpOp {
    clone() {
        return new LEqual(this.left, this.right);
    }
    eval(variableMap) {
        return this.left.eval(variableMap) <= this.right.eval(variableMap);
    }
    execute(variableMap) {
        return this.left.execute(variableMap) <= this.right.execute(variableMap);
    }
    simplify() {
        let l = this.left.simplify();
        let r = this.right.simplify();
        if (l instanceof Constant && r instanceof Constant) {
            return new BoolConstant(l.value <= r.value);
        }
        return new LEqual(l, r);
    }
    convertToExpression(epsilon) {
        return new Addition(new Subtraction(this.right.clone(), this.left.clone()), new Constant(epsilon));
    }
    print() {
        return `${this.left.print()} <= ${this.right.print()}`;
    }
}
exports.LEqual = LEqual;
class BoolNot extends BoolExpression {
    constructor(inner) {
        super();
        this.inner = inner;
    }
    clone() {
        return new BoolNot(this.inner.clone());
    }
    execute(variableValues) {
        return !this.inner.execute(variableValues);
    }
    eval(variableMap) {
        return !this.inner.eval(variableMap);
    }
    simplify() {
        let i = this.inner.simplify();
        if (i instanceof BoolConstant) {
            return new BoolConstant(!i.value);
        }
        return new BoolNot(i);
    }
    convertToExpression(epsilon) {
        return new Constant(-this.inner.convertToExpression(epsilon));
    }
    print() {
        return `!(${this.inner.print()})`;
    }
}
exports.BoolNot = BoolNot;
class BoolConstant extends BoolExpression {
    constructor(value) {
        super();
        this.value = value;
    }
    clone() {
        return new BoolConstant(this.value);
    }
    eval(variableMap) {
        return this.value;
    }
    execute(variableValues) {
        return this.value;
    }
    simplify() {
        return this.clone();
    }
    convertToExpression() {
        return new Constant(this.value ? 1 : -1);
    }
    print() {
        return this.value ? "true" : "false";
    }
}
exports.BoolConstant = BoolConstant;


/***/ }),

/***/ "./src/compiler/expressionCompiler.ts":
/*!********************************************!*\
  !*** ./src/compiler/expressionCompiler.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileExpression = exports.compileBoolExpression = exports.hasDerivative = exports.ExpCompilerContext = void 0;
const error_1 = __importDefault(__webpack_require__(/*! ./error */ "./src/compiler/error.ts"));
const astNode_1 = __webpack_require__(/*! ./astNode */ "./src/compiler/astNode.ts");
const expression_1 = __webpack_require__(/*! ./expression */ "./src/compiler/expression.ts");
class ExpCompilerContext {
}
exports.ExpCompilerContext = ExpCompilerContext;
function hasDerivative(node) {
    switch (node.type) {
        case astNode_1.NodeType._Addition: {
            let add = node;
            return hasDerivative(add.left) || hasDerivative(add.right);
        }
        case astNode_1.NodeType._Subtraction: {
            let sub = node;
            return hasDerivative(sub.left) || hasDerivative(sub.right);
        }
        case astNode_1.NodeType._Multiplication: {
            let mul = node;
            return hasDerivative(mul.left) || hasDerivative(mul.right);
        }
        case astNode_1.NodeType._Division: {
            let div = node;
            return hasDerivative(div.left) || hasDerivative(div.right);
        }
        case astNode_1.NodeType._Negation: {
            let neg = node;
            return hasDerivative(neg.inner);
        }
        case astNode_1.NodeType._Function: {
            let fun = node;
            let result = false;
            fun.args.forEach(function (arg) {
                result = result || hasDerivative(arg);
            });
            return result;
        }
        case astNode_1.NodeType._Ternary: {
            let ter = node;
            return hasDerivative(ter.condition) || hasDerivative(ter.true) || hasDerivative(ter.false);
        }
        case astNode_1.NodeType._Constant: {
            return false;
        }
        case astNode_1.NodeType._Derivative: {
            return true;
        }
        case astNode_1.NodeType._VarIdentifier: {
            return false;
        }
        case astNode_1.NodeType._And: {
            let and = node;
            return hasDerivative(and.left) || hasDerivative(and.right);
        }
        case astNode_1.NodeType._Or: {
            let or = node;
            return hasDerivative(or.left) || hasDerivative(or.right);
        }
        case astNode_1.NodeType._Not: {
            let not = node;
            return hasDerivative(not.inner);
        }
        case astNode_1.NodeType._Greater: {
            let g = node;
            return hasDerivative(g.left) || hasDerivative(g.right);
        }
        case astNode_1.NodeType._GreaterEqual: {
            let ge = node;
            return hasDerivative(ge.left) || hasDerivative(ge.right);
        }
        case astNode_1.NodeType._Less: {
            let l = node;
            return hasDerivative(l.left) || hasDerivative(l.right);
        }
        case astNode_1.NodeType._LessEqual: {
            let le = node;
            return hasDerivative(le.left) || hasDerivative(le.right);
        }
        case astNode_1.NodeType._Equal: {
            let e = node;
            return hasDerivative(e.left) || hasDerivative(e.right);
        }
        case astNode_1.NodeType._NotEqual: {
            let ne = node;
            return hasDerivative(ne.left) || hasDerivative(ne.right);
        }
        case astNode_1.NodeType._BoolConstant: {
            return false;
        }
        default:
            throw new Error("Unexpected node type in hasDerivative()");
    }
}
exports.hasDerivative = hasDerivative;
function compileBoolExpression(item, context) {
    switch (item.type) {
        case astNode_1.NodeType._And: {
            let and = item;
            return new expression_1.And(compileBoolExpression(and.left, context), compileBoolExpression(and.right, context));
        }
        case astNode_1.NodeType._Or: {
            let or = item;
            return new expression_1.Or(compileBoolExpression(or.left, context), compileBoolExpression(or.right, context));
        }
        case astNode_1.NodeType._Not: {
            let not = item;
            return new expression_1.BoolNot(compileBoolExpression(not.inner, context));
        }
        case astNode_1.NodeType._Greater: {
            let g = item;
            return new expression_1.Greater(compileExpression(g.left, context), compileExpression(g.right, context));
        }
        case astNode_1.NodeType._GreaterEqual: {
            let ge = item;
            return new expression_1.GEqual(compileExpression(ge.left, context), compileExpression(ge.right, context));
        }
        case astNode_1.NodeType._Less: {
            let l = item;
            return new expression_1.Less(compileExpression(l.left, context), compileExpression(l.right, context));
        }
        case astNode_1.NodeType._LessEqual: {
            let le = item;
            return new expression_1.LEqual(compileExpression(le.left, context), compileExpression(le.right, context));
        }
        case astNode_1.NodeType._Equal: {
            let e = item;
            return new expression_1.Equal(compileExpression(e.left, context), compileExpression(e.right, context));
        }
        case astNode_1.NodeType._NotEqual: {
            let ne = item;
            return new expression_1.NotEqual(compileExpression(ne.left, context), compileExpression(ne.right, context));
        }
        case astNode_1.NodeType._BoolConstant: {
            let bc = item;
            return new expression_1.BoolConstant(bc.value);
        }
        default:
            context.errors.push(new error_1.default(item.textPos, "Unexpected boolean expression type at compileExpression()"));
            return new expression_1.BoolConstant(false);
    }
}
exports.compileBoolExpression = compileBoolExpression;
function compileExpression(item, context) {
    switch (item.type) {
        case astNode_1.NodeType._Addition: {
            let add = item;
            return new expression_1.Addition(compileExpression(add.left, context), compileExpression(add.right, context));
        }
        case astNode_1.NodeType._Subtraction: {
            let sub = item;
            return new expression_1.Subtraction(compileExpression(sub.left, context), compileExpression(sub.right, context));
        }
        case astNode_1.NodeType._Multiplication: {
            let mul = item;
            return new expression_1.Multiplication(compileExpression(mul.left, context), compileExpression(mul.right, context));
        }
        case astNode_1.NodeType._Division: {
            let div = item;
            return new expression_1.Division(compileExpression(div.left, context), compileExpression(div.right, context));
        }
        case astNode_1.NodeType._Negation: {
            let neg = item;
            return new expression_1.Negation(compileExpression(neg.inner, context));
        }
        case astNode_1.NodeType._Function: {
            let fun = item;
            try {
                return new expression_1.Function(fun.name, fun.args.map(function (arg) {
                    return compileExpression(arg, context);
                }));
            }
            catch (exception) {
                context.errors.push(new error_1.default(item.textPos, exception));
                return new expression_1.Constant(0);
            }
        }
        case astNode_1.NodeType._Constant: {
            let con = item;
            return new expression_1.Constant(con.value);
        }
        case astNode_1.NodeType._Ternary: {
            let ter = item;
            return new expression_1.TernaryOperator(compileBoolExpression(ter.condition, context), compileExpression(ter.true, context), compileExpression(ter.false, context));
        }
        case astNode_1.NodeType._VarIdentifier: {
            let _var = item;
            if (_var.indicies.length > 0) {
                window.alert("Var identifier compiler assert!");
                return new expression_1.Constant(0);
            }
            if (context.indicies.hasOwnProperty(_var.id)) {
                return new expression_1.Variable(context.indicies[_var.id], _var.id);
            }
            context.errors.push(new error_1.default(item.textPos, `Unknown variable "${_var.id}" at compileExpression()`));
            return new expression_1.Constant(0);
        }
        case astNode_1.NodeType._Derivative: {
            let _der = item;
            let id = _der.id.id + "'";
            if (_der.id.indicies.length > 0) {
                window.alert("Var identifier compiler assert!");
                return new expression_1.Constant(0);
            }
            if (context.indicies.hasOwnProperty(id)) {
                return new expression_1.Variable(context.indicies[id], id);
            }
            context.errors.push(new error_1.default(item.textPos, `Unknown variable "${id}" at compileExpression()`));
            return new expression_1.Constant(0);
        }
        default:
            context.errors.push(new error_1.default(item.textPos, "Unexpected expression type at compileExpression()"));
            return new expression_1.Constant(0);
    }
}
exports.compileExpression = compileExpression;


/***/ }),

/***/ "./src/compiler/functions.ts":
/*!***********************************!*\
  !*** ./src/compiler/functions.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.functionDictionary = exports.FunctionDef = void 0;
const expression_1 = __webpack_require__(/*! ./expression */ "./src/compiler/expression.ts");
class FunctionDef {
    constructor(name, argCount, derivatives) {
        this.name = name;
        this.argCount = argCount;
        this.derivatives = derivatives;
    }
    getDerivative(index, args) {
        return this.derivatives[index](args);
    }
}
exports.FunctionDef = FunctionDef;
class sin extends FunctionDef {
    constructor() {
        super("sin", 1, [sin.der]);
    }
    exec(args) {
        return Math.sin(args[0]);
    }
    static der(args) {
        return new expression_1.Function("cos", args);
    }
}
class cos extends FunctionDef {
    constructor() {
        super("cos", 1, [cos.der]);
    }
    exec(args) {
        return Math.cos(args[0]);
    }
    static der(args) {
        return new expression_1.Negation(new expression_1.Function("cos", args));
    }
}
class sinc extends FunctionDef {
    constructor() {
        super("sinc", 1, [sinc.der]);
    }
    exec(args) {
        if (args[0] < 0.0001)
            return 1.0 - args[0] * args[0] / 6.0 * (1. - args[0] * args[0] / 20); //truncated maclaurin series 
        return Math.sin(args[0]) / args[0];
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Subtraction(new expression_1.Function("cos", args), new expression_1.Function("sinc", args)), args[0]);
    }
}
;
class tan extends FunctionDef {
    constructor() {
        super("tan", 1, [tan.der]);
    }
    exec(args) {
        return Math.tan(args[0]);
    }
    static der(args) {
        return new expression_1.Function("pow", [
            new expression_1.Function("cos", args),
            new expression_1.Constant(2)
        ]);
    }
}
;
class cot extends FunctionDef {
    constructor() {
        super("cot", 1, [cot.der]);
    }
    exec(args) {
        return Math.cos(args[0]) / Math.sin(args[0]);
    }
    static der(args) {
        return new expression_1.Negation(new expression_1.Function("pow", [
            new expression_1.Function("sin", args),
            new expression_1.Constant(2)
        ]));
    }
}
;
class asin extends FunctionDef {
    constructor() {
        super("asin", 1, [asin.der]);
    }
    exec(args) {
        return Math.asin(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1.0), new expression_1.Function("sqrt", [
            new expression_1.Subtraction(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0]))
        ]));
    }
}
;
class acos extends FunctionDef {
    constructor() {
        super("acos", 1, [acos.der]);
    }
    exec(args) {
        return Math.acos(args[0]);
    }
    static der(args) {
        return new expression_1.Negation(new expression_1.Division(new expression_1.Constant(1.0), new expression_1.Function("sqrt", [
            new expression_1.Subtraction(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0]))
        ])));
    }
}
;
class atan extends FunctionDef {
    constructor() {
        super("atan", 1, [atan.der]);
    }
    exec(args) {
        return Math.atan(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1.0), new expression_1.Addition(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0])));
    }
}
;
class acot extends FunctionDef {
    constructor() {
        super("acot", 1, [acot.der]);
    }
    exec(args) {
        return Math.PI / 2 - Math.atan(args[0]);
    }
    static der(args) {
        return new expression_1.Negation(new expression_1.Division(new expression_1.Constant(1.0), new expression_1.Addition(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0]))));
    }
}
;
class sinh extends FunctionDef {
    constructor() {
        super("sinh", 1, [sinh.der]);
    }
    exec(args) {
        return Math.sinh(args[0]);
    }
    static der(args) {
        return new expression_1.Function("cosh", args);
    }
}
;
class cosh extends FunctionDef {
    constructor() {
        super("cosh", 1, [cosh.der]);
    }
    exec(args) {
        return Math.cosh(args[0]);
    }
    static der(args) {
        return new expression_1.Function("sinh", args);
    }
}
;
class tanh extends FunctionDef {
    constructor() {
        super("tanh", 1, [tanh.der]);
    }
    exec(args) {
        return Math.tanh(args[0]);
    }
    static der(args) {
        return new expression_1.Function("pow", [
            new expression_1.Function("cosh", args),
            new expression_1.Constant(-2)
        ]);
    }
}
;
class coth extends FunctionDef {
    constructor() {
        super("coth", 1, [coth.der]);
    }
    exec(args) {
        return 1.0 / Math.tanh(args[0]);
    }
    static der(args) {
        return new expression_1.Negation(new expression_1.Function("pow", [
            new expression_1.Function("sinh", args),
            new expression_1.Constant(-2)
        ]));
    }
}
;
class asinh extends FunctionDef {
    constructor() {
        super("asinh", 1, [asinh.der]);
    }
    exec(args) {
        return Math.asinh(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1), new expression_1.Function("sqrt", [new expression_1.Addition(new expression_1.Multiplication(args[0], args[0]), new expression_1.Constant(1))]));
    }
}
;
class acosh extends FunctionDef {
    constructor() {
        super("acosh", 1, [acosh.der]);
    }
    exec(args) {
        return Math.acosh(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1), new expression_1.Function("sqrt", [new expression_1.Subtraction(new expression_1.Multiplication(args[0], args[0]), new expression_1.Constant(1))]));
    }
}
;
class atanh extends FunctionDef {
    constructor() {
        super("atanh", 1, [atanh.der]);
    }
    exec(args) {
        return Math.atanh(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1), new expression_1.Subtraction(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0])));
    }
}
;
class acoth extends FunctionDef {
    constructor() {
        super("acoth", 1, [acoth.der]);
    }
    exec(args) {
        return 0.5 * Math.log((1 + args[0]) / (args[0] - 1));
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1), new expression_1.Subtraction(new expression_1.Constant(1), new expression_1.Multiplication(args[0], args[0])));
    }
}
;
class erf extends FunctionDef {
    constructor() {
        super("erf", 1, [erf.der]);
    }
    static call(x) {
        var sign = Math.sign(x);
        x = Math.abs(x);
        var a1 = 0.254829592;
        var a2 = -0.284496736;
        var a3 = 1.421413741;
        var a4 = -1.453152027;
        var a5 = 1.061405429;
        var p = 0.3275911;
        var t = 1.0 / (1.0 + p * x);
        var y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        return sign * y;
    }
    exec(args) {
        return erf.call(args[0]);
    }
    static der(args) {
        return new expression_1.Multiplication(new expression_1.Constant(2.0 / Math.sqrt(Math.PI)), new expression_1.Function("exp", [new expression_1.Negation(new expression_1.Multiplication(args[0], args[0]))]));
    }
}
;
class exp extends FunctionDef {
    constructor() {
        super("exp", 1, [exp.der]);
    }
    exec(args) {
        return Math.exp(args[0]);
    }
    static der(args) {
        return new expression_1.Function("exp", args);
    }
}
;
class pow extends FunctionDef {
    constructor() {
        super("pow", 2, [pow.derX, pow.derY]);
    }
    exec(args) {
        return Math.pow(args[0], args[1]);
    }
    static derX(args) {
        return new expression_1.Multiplication(args[1], new expression_1.Function("pow", [
            args[0], new expression_1.Subtraction(args[1], new expression_1.Constant(1))
        ]));
    }
    static derY(args) {
        return new expression_1.Multiplication(new expression_1.Function("ln", [args[0]]), new expression_1.Function("pow", args));
    }
}
;
class ln extends FunctionDef {
    constructor() {
        super("ln", 1, [ln.der]);
    }
    exec(args) {
        return Math.log(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1.0), args[0]);
    }
}
;
class log extends FunctionDef {
    constructor() {
        super("log", 2, [log.derX, log.derY]);
    }
    exec(args) {
        return Math.log(args[1]) / Math.log(args[0]);
    }
    static derX(args) {
        return new expression_1.Division(new expression_1.Function("ln", [args[1]]), new expression_1.Multiplication(new expression_1.Function("pow", [
            new expression_1.Function("ln", [args[0]]),
            new expression_1.Constant(2)
        ]), args[0]));
    }
    static derY(args) {
        return new expression_1.Division(new expression_1.Constant(1), new expression_1.Multiplication(args[1], new expression_1.Function("ln", [args[0]])));
    }
}
;
class lg extends FunctionDef {
    constructor() {
        super("lg", 1, [lg.der]);
    }
    exec(args) {
        return Math.log10(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(1.0 / Math.log(10)), args[0]);
    }
}
;
class sqrt extends FunctionDef {
    constructor() {
        super("sqrt", 1, [sqrt.der]);
    }
    exec(args) {
        return Math.sqrt(args[0]);
    }
    static der(args) {
        return new expression_1.Division(new expression_1.Constant(0.5), new expression_1.Function("sqrt", args));
    }
}
;
class abs extends FunctionDef {
    constructor() {
        super("abs", 1, [abs.der]);
    }
    exec(args) {
        return Math.abs(args[0]);
    }
    static der(args) {
        return new expression_1.Function("step", args);
    }
}
;
class min extends FunctionDef {
    constructor() {
        super("min", 2, null);
    }
    exec(args) {
        return Math.min(args[0], args[1]);
    }
}
;
class max extends FunctionDef {
    constructor() {
        super("max", 2, null);
    }
    exec(args) {
        return Math.max(args[0], args[1]);
    }
}
;
class sign extends FunctionDef {
    constructor() {
        super("sign", 1, null);
    }
    exec(args) {
        return Math.sign(args[0]);
    }
}
;
class step extends FunctionDef {
    constructor() {
        super("step", 1, null);
    }
    static call(x) {
        return x < 0 ? 0 : 1;
    }
    exec(args) {
        return step.call(args[0]);
    }
}
;
class frac extends FunctionDef {
    constructor() {
        super("frac", 1, null);
    }
    static call(x) {
        return (x - Math.floor(x));
    }
    exec(args) {
        return frac.call(args[0]);
    }
}
class smoothstep extends FunctionDef {
    constructor() {
        super("smoothstep", 1, null);
    }
    static call(x) {
        x = Math.max(Math.min(1, x), 0);
        return x * x * (3 - 2 * x);
    }
    exec(args) {
        return smoothstep.call(args[0]);
    }
}
;
class e extends FunctionDef {
    constructor() {
        super("e", 0, []);
    }
    exec(args) {
        return Math.E;
    }
}
;
class pi extends FunctionDef {
    constructor() {
        super("pi", 0, []);
    }
    exec(args) {
        return Math.PI;
    }
}
;
exports.functionDictionary = {
    sin: new sin(),
    cos: new cos(),
    tan: new tan(),
    cot: new cot(),
    asin: new asin(),
    acos: new acos(),
    atan: new atan(),
    acot: new acot(),
    sinh: new sinh(),
    cosh: new cosh(),
    tanh: new tanh(),
    coth: new coth(),
    asinh: new asinh(),
    acosh: new acosh(),
    atanh: new atanh(),
    acoth: new acoth(),
    erf: new erf(),
    exp: new exp(),
    pow: new pow(),
    ln: new ln(),
    log: new log(),
    lg: new lg(),
    sqrt: new sqrt(),
    abs: new abs(),
    min: new min(),
    max: new max(),
    sign: new sign(),
    step: new step(),
    frac: new frac(),
    smoothstep: new smoothstep(),
    e: new e(),
    pi: new pi(),
    sinc: new sinc()
};


/***/ }),

/***/ "./src/compiler/hybridCompiler.ts":
/*!****************************************!*\
  !*** ./src/compiler/hybridCompiler.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HybridSystemCompiler = void 0;
const edaeHybridSystem_1 = __webpack_require__(/*! ../dae/edaeHybridSystem */ "./src/dae/edaeHybridSystem.ts");
const astNode_1 = __webpack_require__(/*! ./astNode */ "./src/compiler/astNode.ts");
const idaeHybridSystem_1 = __webpack_require__(/*! ../dae/idaeHybridSystem */ "./src/dae/idaeHybridSystem.ts");
const error_1 = __importDefault(__webpack_require__(/*! ./error */ "./src/compiler/error.ts"));
const errorListener_1 = __importDefault(__webpack_require__(/*! ./errorListener */ "./src/compiler/errorListener.ts"));
const visitor_1 = __importDefault(__webpack_require__(/*! ./visitor */ "./src/compiler/visitor.ts"));
const index_1 = __importDefault(__webpack_require__(/*! antlr4/index */ "./node_modules/antlr4/index.js"));
const odeGrammarLexer_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarLexer.js */ "./src/grammar/antlrOutput/odeGrammarLexer.js"));
const odeGrammarParser_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarParser.js */ "./src/grammar/antlrOutput/odeGrammarParser.js"));
const compilerContext_1 = __webpack_require__(/*! ./compilerContext */ "./src/compiler/compilerContext.ts");
const expressionCompiler_1 = __webpack_require__(/*! ./expressionCompiler */ "./src/compiler/expressionCompiler.ts");
const customEDAEHybridState_1 = __webpack_require__(/*! ../dae/customEDAEHybridState */ "./src/dae/customEDAEHybridState.ts");
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const customHybridStateLink_1 = __webpack_require__(/*! ../dae/customHybridStateLink */ "./src/dae/customHybridStateLink.ts");
const customIDAEHybridState_1 = __webpack_require__(/*! ../dae/customIDAEHybridState */ "./src/dae/customIDAEHybridState.ts");
const compilerError_1 = __webpack_require__(/*! ./compilerError */ "./src/compiler/compilerError.ts");
class VariableEntry {
    constructor(name, isAlgebraic, initialValue = 0) {
        this.name = name;
        this.initialValue = initialValue;
        this.isAlgebraic = isAlgebraic;
    }
}
class EquationEntry {
    constructor(expression, isAlgebraic) {
        this.expression = expression;
        this.isAlgebraic = isAlgebraic;
    }
}
class Transition {
    constructor(incidentStates, condition) {
        this.incidentStates = incidentStates;
        this.condition = condition;
    }
}
class State {
    constructor() {
        this.equations = {};
        this.setters = {};
        this.transitions = [];
        this.isTerminal = false;
    }
}
class HybridSystemCompiler {
    constructor() {
        this.constants = {};
        this.states = { initial: new State() };
        this.variables = {};
        this.context = null;
        this.errors = [];
        this.currentState = "initial";
        this.epsilon = 1e-3;
        this.boolExpEpsilon = 1e-8;
    }
    compileExplicit(text) {
        this.isExplicit = true;
        var chars = new index_1.default.InputStream(text);
        var lexer = new odeGrammarLexer_js_1.default.odeGrammarLexer(chars);
        lexer.removeErrorListeners();
        var listener = new errorListener_1.default(this.errors);
        lexer.addErrorListener(listener);
        //@ts-ignore
        lexer.strictMode = false;
        var tokens = new index_1.default.CommonTokenStream(lexer);
        var parser = new odeGrammarParser_js_1.default.odeGrammarParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(listener);
        var visitor = new visitor_1.default();
        parser.buildParseTrees = true;
        var tree = parser.hybrid();
        //@ts-ignore
        //console.log(tree.toStringTree(parser.ruleNames));
        //check for parser/lexer errors
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let daeSystemDef = visitor.startHybrid(tree, listener);
        //for debug purposes
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let self = this;
        daeSystemDef.statements.forEach(function (item) {
            self.compileStatement(item);
        });
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        //set variable indicies
        let x = [];
        let z = [];
        let x0 = [];
        Object.entries(this.variables).forEach(function ([key, variable]) {
            if (variable.isAlgebraic) {
                z.push(key);
            }
            else {
                x.push(key);
                x0.push(variable.initialValue);
            }
        });
        //prepare variable indicies
        let algContext = { indicies: {}, errors: this.errors };
        let difContext = { indicies: {}, errors: this.errors };
        x.forEach(function (item, index) {
            algContext.indicies[item] = index;
            difContext.indicies[item] = index;
        });
        z.forEach(function (item, index) {
            difContext.indicies[item] = index + x.length;
        });
        algContext.indicies["t"] = x.length;
        difContext.indicies["t"] = x.length + z.length;
        //compile initial state
        let states = [];
        {
            let initialState = this.states["initial"];
            let f = [];
            let g = [];
            Object.entries(this.variables).forEach(function ([key, variable]) {
                if (!initialState.equations.hasOwnProperty(key)) {
                    self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Missing equation for variable "${key}" in initial state`));
                    return;
                }
                let equation = initialState.equations[key];
                if (variable.isAlgebraic != equation.isAlgebraic) {
                    self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Non compatible types of variable and equation "${key}" in initial state`));
                    return;
                }
                if (variable.isAlgebraic) {
                    g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
                }
                else {
                    f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
                }
            });
            let dfdx = [];
            let dfdz = [];
            let dgdx = [];
            let dgdt = [];
            f.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dfdx.push(dxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dfdz.push(dzRow);
            });
            g.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dgdx.push(dxRow);
                dgdt.push(item.differentiate("t", self.epsilon));
            });
            states.push(new customEDAEHybridState_1.CustomEDAEHybridState("initial", [], false).init(f, g, dfdx, dfdz, dgdx, dgdt));
        }
        //compile states
        let stateIndicies = { initial: 0 };
        Object.entries(this.states).forEach(function ([key, state]) {
            //skip initial state
            if (key == "initial")
                return;
            let f = [];
            let g = [];
            //check equations
            Object.entries(self.variables).forEach(function ([key, variable]) {
                if (!state.equations.hasOwnProperty(key)) {
                    //copy equations from initial state
                    if (variable.isAlgebraic) {
                        g.push(states[0]._g[g.length]);
                    }
                    else {
                        f.push(states[0]._f[f.length]);
                    }
                    return;
                }
                let equation = state.equations[key];
                if (variable.isAlgebraic != equation.isAlgebraic) {
                    self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Non compatible types of variable and equation "${key}" in state "${key}"`));
                    return;
                }
                if (variable.isAlgebraic) {
                    g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
                }
                else {
                    f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
                }
            });
            //compile derivatives
            let dfdx = [];
            let dfdz = [];
            let dgdx = [];
            let dgdt = [];
            f.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dfdx.push(dxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dfdz.push(dzRow);
            });
            g.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dgdx.push(dxRow);
                dgdt.push(item.differentiate("t", self.epsilon));
            });
            stateIndicies[key] = states.length;
            states.push(new customEDAEHybridState_1.CustomEDAEHybridState(key, [], false).init(f, g, dfdx, dfdz, dgdx, dgdt));
        });
        //compile transitions
        Object.entries(this.states).forEach(function ([key, state]) {
            if (key == "initial")
                return;
            //compile setters
            let setters = [];
            Object.entries(state.setters).forEach(function ([key, setter]) {
                if (self.variables[key].isAlgebraic) {
                    return;
                }
                let variableIndex = algContext.indicies[key];
                setters.push({ index: variableIndex, expression: expressionCompiler_1.compileExpression(setter, difContext).simplify() });
            });
            let newStateIndex = stateIndicies[key];
            state.transitions.forEach(function (transition) {
                let p = expressionCompiler_1.compileBoolExpression(transition.condition, difContext).simplify().convertToExpression(self.boolExpEpsilon);
                let dpdt = p.differentiate("t", self.epsilon).simplify();
                let dpdx = [];
                let dpdz = [];
                Object.entries(self.variables).forEach(function ([key, variable]) {
                    if (variable.isAlgebraic) {
                        dpdz.push(p.differentiate(key, self.epsilon).simplify());
                    }
                    else {
                        dpdx.push(p.differentiate(key, self.epsilon).simplify());
                    }
                });
                transition.incidentStates.forEach(function (incidentState) {
                    if (!self.states.hasOwnProperty(incidentState)) {
                        self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Unknown incident state "${incidentState}" in transition rule for state "${key}"`));
                        return;
                    }
                    states[stateIndicies[incidentState]].pushLink(new customHybridStateLink_1.CustomHybridStateLink(newStateIndex, setters, p, dpdx, dpdz, dpdt));
                });
            });
        });
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        return { system: new edaeHybridSystem_1.EDAEHybridSystem(states), x0: new vector_1.vector(x0), x: x, z: z };
        //return {system:,x0:,x:,z:};
    }
    compileImplicit(text) {
        this.isExplicit = false;
        var chars = new index_1.default.InputStream(text);
        var lexer = new odeGrammarLexer_js_1.default.odeGrammarLexer(chars);
        lexer.removeErrorListeners();
        var listener = new errorListener_1.default(this.errors);
        lexer.addErrorListener(listener);
        //@ts-ignore
        lexer.strictMode = false;
        var tokens = new index_1.default.CommonTokenStream(lexer);
        var parser = new odeGrammarParser_js_1.default.odeGrammarParser(tokens);
        parser.removeErrorListeners();
        parser.addErrorListener(listener);
        var visitor = new visitor_1.default();
        parser.buildParseTrees = true;
        var tree = parser.hybrid();
        //@ts-ignore
        //console.log(tree.toStringTree(parser.ruleNames));
        //check for parser/lexer errors
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let daeSystemDef = visitor.startHybrid(tree, listener);
        //for debug purposes
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        let self = this;
        daeSystemDef.statements.forEach(function (item) {
            self.compileStatement(item);
        });
        let x = [];
        let z = [];
        let x0 = [];
        let z0 = [];
        Object.entries(this.variables).forEach(function ([key, variable]) {
            if (variable.isAlgebraic) {
                z.push(key);
                z0.push(variable.initialValue);
            }
            else {
                x.push(key);
                x0.push(variable.initialValue);
            }
        });
        //prepare variable indicies
        //x,z,t
        let algContext = { indicies: {}, errors: this.errors };
        //x,dx,z,t
        let difContext = { indicies: {}, errors: this.errors };
        x.forEach(function (item, index) {
            algContext.indicies[item] = index;
            difContext.indicies[item] = index;
            difContext.indicies[item + "'"] = index + x.length;
        });
        z.forEach(function (item, index) {
            algContext.indicies[item] = index + x.length;
            difContext.indicies[item] = index + 2 * x.length;
        });
        algContext.indicies["t"] = x.length + z.length;
        difContext.indicies["t"] = 2 * x.length + z.length;
        let initialState = this.states["initial"];
        let equationIndicies = {};
        //compile initial state
        let states = [];
        {
            let f = [];
            let g = [];
            Object.entries(initialState.equations).forEach(function ([key, equation]) {
                if (equation.isAlgebraic) {
                    equationIndicies[key] = g.length;
                    g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
                }
                else {
                    equationIndicies[key] = f.length;
                    f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
                }
            });
            if (f.length != x.length) {
                this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of dif. equations: ${f.length}, dif. variables: ${x.length} in state "initial"`));
            }
            if (g.length != z.length) {
                this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of alg. equations: ${g.length}, alg. variables: ${z.length} in state "initial"`));
            }
            //check for equations number;
            let dfdx = [];
            let dfddx = [];
            let dfdz = [];
            let dgdx = [];
            let dgdz = [];
            let dgdt = [];
            f.forEach(function (item) {
                let dxRow = [];
                let ddxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                    ddxRow.push(item.differentiate(_x + "'", self.epsilon).simplify());
                });
                dfdx.push(dxRow);
                dfddx.push(ddxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dfdz.push(dzRow);
            });
            g.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dgdx.push(dxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dgdz.push(dzRow);
                dgdt.push(item.differentiate("t", self.epsilon));
            });
            states.push(new customIDAEHybridState_1.CustomIDAEHybridState("initial", [], false).init(f, g, dfdx, dfddx, dfdz, dgdx, dgdz, dgdt));
        }
        //compile states
        let stateIndicies = { initial: 0 };
        Object.entries(this.states).forEach(function ([key, state]) {
            //skip initial state
            if (key == "initial")
                return;
            let f = [];
            let g = [];
            //check equations
            Object.entries(initialState.equations).forEach(function ([equationKey, equation]) {
                if (!state.equations.hasOwnProperty(equationKey)) {
                    //copy equations from initial state
                    if (equation.isAlgebraic) {
                        g.push(states[0]._g[equationIndicies[equationKey]]);
                    }
                    else {
                        f.push(states[0]._f[equationIndicies[equationKey]]);
                    }
                    return;
                }
                let stateEquation = state.equations[equationKey];
                if (stateEquation.isAlgebraic) {
                    g.push(expressionCompiler_1.compileExpression(equation.expression, algContext).simplify());
                }
                else {
                    f.push(expressionCompiler_1.compileExpression(equation.expression, difContext).simplify());
                }
            });
            Object.keys(state.equations).forEach(function (equationKey) {
                if (!initialState.equations.hasOwnProperty(equationKey)) {
                    self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `State "${key}" contains excess equation "${equationKey}"`));
                }
            });
            if (Object.keys(state.equations).length != states[0]._f.length + states[0]._g.length)
                this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `State ${f.length}, dif. variables: ${x.length}`));
            if (f.length != x.length) {
                this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of dif. equations: ${f.length}, dif. variables: ${x.length} in state "${key}"`));
            }
            if (g.length != z.length) {
                this.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Number of alg. equations: ${g.length}, alg. variables: ${z.length} in state "${key}"`));
            }
            let dfdx = [];
            let dfddx = [];
            let dfdz = [];
            let dgdx = [];
            let dgdz = [];
            let dgdt = [];
            f.forEach(function (item) {
                let dxRow = [];
                let ddxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                    ddxRow.push(item.differentiate(_x + "'", self.epsilon).simplify());
                });
                dfdx.push(dxRow);
                dfddx.push(ddxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dfdz.push(dzRow);
            });
            g.forEach(function (item) {
                let dxRow = [];
                x.forEach(function (_x) {
                    dxRow.push(item.differentiate(_x, self.epsilon).simplify());
                });
                dgdx.push(dxRow);
                let dzRow = [];
                z.forEach(function (_z) {
                    dzRow.push(item.differentiate(_z, self.epsilon).simplify());
                });
                dgdz.push(dzRow);
                dgdt.push(item.differentiate("t", self.epsilon));
            });
            stateIndicies[key] = states.length;
            states.push(new customIDAEHybridState_1.CustomIDAEHybridState("initial", [], false).init(f, g, dfdx, dfddx, dfdz, dgdx, dgdz, dgdt));
        });
        //compile transitions
        Object.entries(this.states).forEach(function ([key, state]) {
            if (key == "initial")
                return;
            //compile setters
            let setters = [];
            Object.entries(state.setters).forEach(function ([key, setter]) {
                if (self.variables[key].isAlgebraic) {
                    return;
                }
                let variableIndex = algContext.indicies[key];
                setters.push({ index: variableIndex, expression: expressionCompiler_1.compileExpression(setter, difContext).simplify() });
            });
            let newStateIndex = stateIndicies[key];
            state.transitions.forEach(function (transition) {
                let p = expressionCompiler_1.compileBoolExpression(transition.condition, difContext).simplify().convertToExpression(self.boolExpEpsilon);
                let dpdt = p.differentiate("t", self.epsilon).simplify();
                let dpdx = [];
                let dpdz = [];
                Object.entries(self.variables).forEach(function ([key, variable]) {
                    if (variable.isAlgebraic) {
                        dpdz.push(p.differentiate(key, self.epsilon).simplify());
                    }
                    else {
                        dpdx.push(p.differentiate(key, self.epsilon).simplify());
                    }
                });
                transition.incidentStates.forEach(function (incidentState) {
                    if (!self.states.hasOwnProperty(incidentState)) {
                        self.errors.push(new error_1.default(astNode_1.TextPosition.invalid(), `Unknown incident state "${incidentState}" in transition rule for state "${key}"`));
                        return;
                    }
                    states[stateIndicies[incidentState]].pushLink(new customHybridStateLink_1.CustomHybridStateLink(newStateIndex, setters, p, dpdx, dpdz, dpdt));
                });
            });
        });
        if (this.errors.length > 0) {
            throw new compilerError_1.CompilerError(this.errors);
        }
        return { system: new idaeHybridSystem_1.IDAEHybridSystem(states), x0: new vector_1.vector(x0), z0: new vector_1.vector(z0), x: x, z: z };
    }
    expandBoolExpression(node) {
        switch (node.type) {
            case astNode_1.NodeType._And: {
                let and = node;
                and.left = this.expandBoolExpression(and.left);
                and.right = this.expandBoolExpression(and.right);
                return and;
            }
            case astNode_1.NodeType._Or: {
                let or = node;
                or.left = this.expandBoolExpression(or.left);
                or.right = this.expandBoolExpression(or.right);
                return or;
            }
            case astNode_1.NodeType._Not: {
                let not = node;
                not.inner = this.expandExpression(not.inner);
                return not;
            }
            case astNode_1.NodeType._Greater: {
                let g = node;
                g.left = this.expandExpression(g.left);
                g.right = this.expandExpression(g.right);
                return g;
            }
            case astNode_1.NodeType._GreaterEqual: {
                let ge = node;
                ge.left = this.expandExpression(ge.left);
                ge.right = this.expandExpression(ge.right);
                return ge;
            }
            case astNode_1.NodeType._Less: {
                let l = node;
                l.left = this.expandExpression(l.left);
                l.right = this.expandExpression(l.right);
                return l;
            }
            case astNode_1.NodeType._LessEqual: {
                let le = node;
                le.left = this.expandExpression(le.left);
                le.right = this.expandExpression(le.right);
                return le;
            }
            case astNode_1.NodeType._Equal: {
                let e = node;
                e.left = this.expandExpression(e.left);
                e.right = this.expandExpression(e.right);
                return e;
            }
            case astNode_1.NodeType._NotEqual: {
                let ne = node;
                ne.left = this.expandExpression(ne.left);
                ne.right = this.expandExpression(ne.right);
                return ne;
            }
            case astNode_1.NodeType._BoolConstant: {
                return node;
            }
            default:
                this.errors.push(new error_1.default(node.textPos, "Unexpected boolean expression type at expandBoolExpression()"));
                return new astNode_1.BoolConstantNode(false);
        }
    }
    expandExpression(node) {
        //throw new Error("Not implemented");
        switch (node.type) {
            case astNode_1.NodeType._Addition: {
                let add = node;
                add.left = this.expandExpression(add.left);
                add.right = this.expandExpression(add.right);
                return add;
            }
            case astNode_1.NodeType._Subtraction: {
                let sub = node;
                sub.left = this.expandExpression(sub.left);
                sub.right = this.expandExpression(sub.right);
                return sub;
            }
            case astNode_1.NodeType._Multiplication: {
                let mult = node;
                mult.left = this.expandExpression(mult.left);
                mult.right = this.expandExpression(mult.right);
                return mult;
            }
            case astNode_1.NodeType._Division: {
                let div = node;
                div.left = this.expandExpression(div.left);
                div.right = this.expandExpression(div.right);
                return div;
            }
            case astNode_1.NodeType._Negation: {
                let neg = node;
                neg.inner = this.expandExpression(neg.inner);
                return neg;
            }
            case astNode_1.NodeType._Derivative: {
                let der = node;
                let id = this.expandExpression(der.id);
                if (id instanceof astNode_1.VarIdentifierNode && id.id != "t") {
                    if (this.variables.hasOwnProperty(id.id)) {
                        this.variables[id.id].isAlgebraic = false;
                    }
                    else {
                        this.variables[id.id] = new VariableEntry(id.id, false);
                    }
                    der.id = id;
                    return der;
                }
                this.errors.push(new error_1.default(node.textPos, `Incorrect symbol in derivative`));
                return new astNode_1.ConstantNode(0);
            }
            case astNode_1.NodeType._Function: {
                let fun = node;
                for (let i = 0; i < fun.args.length; i++) {
                    fun.args[i] = this.expandExpression(fun.args[i]);
                }
                return fun;
            }
            case astNode_1.NodeType._VarIdentifier: {
                let _var = node;
                if (_var.indicies.length == 0) {
                    let _context = this.context;
                    while (_context != null) {
                        if (_context instanceof compilerContext_1.LoopContext) {
                            if (_context.iterator == _var.id) {
                                return new astNode_1.ConstantNode(_context.index);
                            }
                        }
                        else if (_context instanceof compilerContext_1.MacroContext) {
                            if (_context.args.hasOwnProperty(_var.id)) {
                                return this.expandExpression(_context.args[_var.id].clone());
                            }
                        }
                        _context = _context.previous;
                    }
                }
                _var.id = this.getSymbolString(_var);
                _var.indicies = [];
                if (this.constants.hasOwnProperty(_var.id)) {
                    return new astNode_1.ConstantNode(this.constants[_var.id]);
                }
                if (_var.id != "t") {
                    if (!this.variables.hasOwnProperty(_var.id)) {
                        this.variables[_var.id] = new VariableEntry(_var.id, true);
                    }
                }
                return _var;
            }
            case astNode_1.NodeType._Constant: {
                return node;
            }
            case astNode_1.NodeType._Summation: {
                let summation = node;
                if (summation.bounds.l > summation.bounds.r) {
                    this.errors.push(new error_1.default(node.textPos, `Left bound of summation is bigger then right bound`));
                    return new astNode_1.ConstantNode(0);
                }
                let sum = [];
                let _context = new compilerContext_1.LoopContext(this.context, summation.iterator);
                this.context = _context;
                for (let i = summation.bounds.l; i <= summation.bounds.r; i++) {
                    _context.index = i;
                    sum.push(this.expandExpression(summation.expression.clone()));
                }
                //return this.expandExpression(summation.expression);
                this.context = this.context.previous;
                let result = sum[0];
                if (sum.length == 1)
                    return result;
                for (let i = 1; i < sum.length; i++) {
                    result = new astNode_1.AdditionNode(result, sum[i]);
                }
                return result;
            }
            case astNode_1.NodeType._Macro: {
                let macro = node;
                let macroName = this.getSymbolString(macro.id);
                let macroDef = this.macros[macroName];
                if (macroDef == undefined) {
                    this.errors.push(new error_1.default(node.textPos, `Undefined macro "${macroName}"`));
                    return new astNode_1.ConstantNode(0);
                }
                if (macroDef.args.length != macro.args.length) {
                    this.errors.push(new error_1.default(node.textPos, `Invalid number of arguments in macro "${macroName}"`));
                    return new astNode_1.ConstantNode(0);
                }
                let args = {};
                macro.args.forEach(function (item, index) {
                    args[macroDef.args[index]] = item.clone();
                });
                this.context = new compilerContext_1.MacroContext(this.context, args);
                let result = this.expandExpression(macroDef.expression.clone());
                this.context = this.context.previous;
                return result;
            }
            case astNode_1.NodeType._Ternary: {
                let ter = node;
                ter.condition = this.expandBoolExpression(ter.condition);
                ter.true = this.expandExpression(ter.true);
                ter.false = this.expandExpression(ter.false);
                return ter;
            }
            default:
                this.errors.push(new error_1.default(node.textPos, "Unexpected expression type at validateExpression()"));
                return new astNode_1.ConstantNode(0);
        }
    }
    getSymbolString(symbol) {
        let result = symbol.id;
        let self = this;
        symbol.indicies.forEach(function (item, index) {
            let indexValue = (expressionCompiler_1.compileExpression(self.expandExpression(item.clone()), { indicies: {}, errors: self.errors })).eval({});
            if (Number.isInteger(indexValue)) {
                result += `[${self.context.index}]`;
                return;
            }
            else {
                self.errors.push(new error_1.default(symbol.textPos, `Expression for ${index} index value of symbol "${symbol.id}" is not constant`));
            }
        });
        return result;
    }
    compileLoop(node) {
        let _context = new compilerContext_1.LoopContext(this.context, node.iterator);
        this.context = _context;
        let statements = node.statements;
        let self = this;
        node.bounds.forEach(function (bounds) {
            if (bounds.l > bounds.r) {
                self.errors.push(new error_1.default(node.textPos, `Left bound value "${bounds.l}" is higher then right bound value "${bounds.r}"`));
                return;
            }
            for (let i = bounds.l; i < bounds.r; i++) {
                _context.index = i;
                statements.forEach(function (statement) {
                    self.compileStatement(statement);
                });
            }
        });
        this.context = this.context.previous;
    }
    ;
    compileInitialCondition(node) {
        let variable = this.getSymbolString(node.id);
        if (this.currentState != "initial") {
            this.errors.push(new error_1.default(node.textPos, `Definition of initial condition for variable "${variable}" not in the global scope`));
            return;
        }
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of time variable`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}"`));
            return;
        }
        let value = 0;
        try {
            value = (expressionCompiler_1.compileExpression(this.expandExpression(node.expression.clone()), { indicies: {}, errors: this.errors })).eval({});
        }
        catch (error) {
            this.errors.push(new error_1.default(node.textPos, `Can't evaluate initial condition for variable "${variable}"`));
            this.errors.push(new error_1.default(node.textPos, error));
            return;
        }
        if (this.variables.hasOwnProperty(variable)) {
            this.variables[variable].initialValue = value;
        }
        else {
            this.variables[variable] = new VariableEntry(variable, true, value);
        }
    }
    compileMacroDefinition(node) {
        if (this.currentState != "initial") {
            this.errors.push(new error_1.default(node.textPos, `Definition of macro "${node.id}" not in the global scope`));
            return;
        }
        let macroName = this.getSymbolString(node.id);
        if (this.macros.hasOwnProperty(macroName)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of macro "${macroName}"`));
            return;
        }
        this.macros[macroName] = node;
    }
    compileConstantStatement(node) {
        let constant = this.getSymbolString(node.id);
        if (this.currentState != "initial") {
            this.errors.push(new error_1.default(node.textPos, `Definition of constant "${constant}" not in the global scope`));
            return;
        }
        if (constant == "t") {
            this.errors.push(new error_1.default(node.textPos, 'Invalid use of time variable'));
        }
        else if (this.variables.hasOwnProperty(constant)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of variable "${constant}"`));
        }
        else if (this.constants.hasOwnProperty(constant)) {
            this.errors.push(new error_1.default(node.textPos, `Redefenition of constant "${constant}"`));
        }
        else {
            try {
                this.constants[constant] = (expressionCompiler_1.compileExpression(this.expandExpression(node.expression.clone()), { indicies: {}, errors: this.errors })).eval({});
            }
            catch (error) {
                this.errors.push(new error_1.default(node.textPos, error));
            }
        }
    }
    compileAlgEquation(node) {
        //throw new Error("Not implemented");
        let currentState = this.states[this.currentState];
        let variable = this.getSymbolString(node.left);
        if (currentState.equations.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Multiple equations for variable "${variable}" in state "${this.currentState}"`));
            return;
        }
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of time variable in state "${this.currentState}"`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}" in state "${this.currentState}"`));
            return;
        }
        if (!this.variables.hasOwnProperty(variable)) {
            this.variables[variable] = new VariableEntry(variable, true);
        }
        let equation = this.expandExpression(node.right.clone());
        if (expressionCompiler_1.hasDerivative(equation)) {
            this.errors.push(new error_1.default(node.textPos, `Right hand side expression for variable "${variable}" in state "${this.currentState}" contains derivatives`));
            return;
        }
        currentState.equations[variable] = new EquationEntry(equation, true);
    }
    compileDifEquation(node) {
        //throw new Error("Not implemented");
        let currentState = this.states[this.currentState];
        let variable = this.getSymbolString(node.left.id);
        if (currentState.equations.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Multiple equations for variable "${variable}" in state "${this.currentState}"`));
            return;
        }
        if (variable == "t") {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of time variable in state "${this.currentState}"`));
            return;
        }
        if (this.constants.hasOwnProperty(variable)) {
            this.errors.push(new error_1.default(node.textPos, `Invalid use of constant "${variable}" in state "${this.currentState}"`));
            return;
        }
        if (this.variables.hasOwnProperty(variable)) {
            this.variables[variable].isAlgebraic = false;
        }
        else {
            this.variables[variable] = new VariableEntry(variable, false);
        }
        let equation = this.expandExpression(node.right.clone());
        if (expressionCompiler_1.hasDerivative(equation)) {
            this.errors.push(new error_1.default(node.textPos, `Right hand side expression for variable "${variable}" in state "${this.currentState}" contains derivatives`));
            return;
        }
        currentState.equations[variable] = new EquationEntry(equation, false);
    }
    compileExplicitEquation(node) {
        //throw new Error("Not implemented");
        if (node.left instanceof astNode_1.VarIdentifierNode) {
            this.compileAlgEquation(node);
        }
        else if (node.left instanceof astNode_1.DerivativeNode) {
            this.compileDifEquation(node);
        }
        else {
            this.errors.push(new error_1.default(node.textPos, "Equation should be in explicit form"));
        }
    }
    compileImplicitEquation(node) {
        //throw new Error("Not implemented");
        let currentState = this.states[this.currentState];
        let label = (node.label != null ? this.getSymbolString(node.label) : (Object.keys(currentState.equations).length + 1));
        if (currentState.equations.hasOwnProperty(label)) {
            this.errors.push(new error_1.default(node.textPos, `Redeclaration of equation "${label}"`));
        }
        else {
            let equation = new astNode_1.SubtractionNode(node.left, node.right);
            equation = this.expandExpression(equation.clone()); //TODO add variables to variablesTable and remove validate
            currentState.equations[label] = new EquationEntry(equation, !expressionCompiler_1.hasDerivative(equation));
        }
    }
    compileState(node) {
        if (this.currentState != "initial") {
            this.errors.push(new error_1.default(node.textPos, `Invalid state definition`));
            return;
        }
        if (this.states.hasOwnProperty(node.id)) {
            this.errors.push(new error_1.default(node.textPos, `Redeclaration of state "${node.id}"`));
            return;
        }
        this.currentState = node.id;
        let state = new State();
        state.isTerminal = node.isTerminal;
        let self = this;
        this.states[node.id] = state;
        node.statements.forEach(function (item) {
            self.compileStatement(item);
        });
        node.stateTransitions.forEach(function (item) {
            state.transitions.push(new Transition(item.prevStates, self.expandBoolExpression(item.condition)));
        });
        this.currentState = "initial";
    }
    compileSetter(node) {
        if (this.currentState == "initial") {
            this.errors.push(new error_1.default(node.textPos, `Setter definition shouldn't exist in initial state.`));
            return;
        }
        let setters = this.states[this.currentState].setters;
        let id = this.getSymbolString(node.id);
        if (setters.hasOwnProperty(id)) {
            this.errors.push(new error_1.default(node.textPos, `Setter redefenition for variable "${id} in state "${this.currentState}""`));
        }
        setters[id] = this.expandExpression(node.expression.clone());
    }
    compileStatement(statement) {
        switch (statement.type) {
            case astNode_1.NodeType._InitialCondition: {
                this.compileInitialCondition(statement);
                break;
            }
            case astNode_1.NodeType._MacroDefinition: {
                this.compileMacroDefinition(statement);
                break;
            }
            case astNode_1.NodeType._ConstantStatement: {
                this.compileConstantStatement(statement);
                break;
            }
            case astNode_1.NodeType._Equation: {
                if (this.isExplicit)
                    this.compileExplicitEquation(statement);
                else
                    this.compileImplicitEquation(statement);
                break;
            }
            case astNode_1.NodeType._State: {
                this.compileState(statement);
                break;
            }
            case astNode_1.NodeType._Setter: {
                this.compileSetter(statement);
                break;
            }
            case astNode_1.NodeType._Loop: {
                this.compileLoop(statement);
                break;
            }
            default:
                this.errors.push(new error_1.default(statement.textPos, `Unexpected statement type at compileStatement()`));
        }
    }
}
exports.HybridSystemCompiler = HybridSystemCompiler;


/***/ }),

/***/ "./src/compiler/visitor.ts":
/*!*********************************!*\
  !*** ./src/compiler/visitor.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const odeGrammarVisitor_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarVisitor.js */ "./src/grammar/antlrOutput/odeGrammarVisitor.js"));
const odeGrammarParser_js_1 = __importDefault(__webpack_require__(/*! ../grammar/antlrOutput/odeGrammarParser.js */ "./src/grammar/antlrOutput/odeGrammarParser.js"));
const astNode_1 = __webpack_require__(/*! ./astNode */ "./src/compiler/astNode.ts");
class Visitor extends odeGrammarVisitor_js_1.default.odeGrammarVisitor {
    constructor() {
        super();
        this.statements = [];
    }
    startDAE(ctx, errorListener) {
        this.errorListener = errorListener;
        this.visitDae(ctx);
        return new astNode_1.SystemDefinition(this.statements);
    }
    startHybrid(ctx, errorListener) {
        this.errorListener = errorListener;
        this.visitHybrid(ctx);
        return new astNode_1.SystemDefinition(this.statements);
    }
    startExpression(ctx, errorListener) {
        this.errorListener = errorListener;
        return this.visitExpression(ctx);
    }
    visitMacroStatement(ctx) {
        let args = [];
        if (ctx.macroArguments + undefined) {
            let macroArgs = ctx.macroArguments();
            if (macroArgs != undefined) {
                macroArgs.ID().forEach(function (item) {
                    args.push(item.getText());
                });
            }
        }
        return new astNode_1.MacroStatementNode(this.visitVarIdentifier(ctx.id), args, this.visitExpression(ctx.exp))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    /* visitDaeStatement(ctx:any):StatementNode{
         return (this as unknown as ParseTreeVisitor).visit(ctx) as StatementNode;
     }*/
    visitDaeStatement(ctx) {
        return this.visit(ctx.children[0]);
    }
    visitDae(ctx) {
        ctx.daeStatement().forEach(function (item) {
            this.statements.push(this.visit(item));
        }, this);
    }
    visitStateStatement(ctx) {
        return this.visit(ctx.children[0]);
    }
    visitBoolExpression(ctx) {
        return this.visit(ctx);
    }
    visitExpression(ctx) {
        return this.visit(ctx);
    }
    visitHybridStatement(ctx) {
        return this.visit(ctx.children[0]);
    }
    visitLoopStatement(ctx) {
        return this.visit(ctx.children[0]);
    }
    visitHybrid(ctx) {
        ctx.hybridStatement().forEach(function (item) {
            this.statements.push(this.visitHybridStatement(item));
        }, this);
    }
    visitIndex(ctx) {
        return this.visitExpression(ctx.exp);
    }
    visitVarIdentifier(ctx) {
        let id = ctx.id.text;
        let indicies;
        indicies = ctx.index != undefined ? ctx.index().map(function (item) {
            return this.visitIndex(item);
        }, this) : [];
        return new astNode_1.VarIdentifierNode(id, indicies)
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitEBoolBinaryOperator(ctx) {
        let op = null;
        switch (ctx.op.type) {
            case odeGrammarParser_js_1.default.odeGrammarParser.L:
                op = new astNode_1.BoolLNode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.LE:
                op = new astNode_1.BoolLENode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.G:
                op = new astNode_1.BoolGNode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.GE:
                op = new astNode_1.BoolGENode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.E:
                op = new astNode_1.BoolENode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.NE:
                op = new astNode_1.BoolNENode(this.visitExpression(ctx.leftexp), this.visitExpression(ctx.rightexp));
                break;
            default:
                this.errorListener.add(new astNode_1.TextPosition(ctx.op.line, ctx.op.column, ctx.start.start, ctx.stop.stop), "Unknown binary operator");
                return null;
        }
        return op.setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitBBoolBinaryOperator(ctx) {
        let op = null;
        switch (ctx.op.type) {
            case odeGrammarParser_js_1.default.odeGrammarParser.AND:
                op = new astNode_1.BoolAndNode(this.visitBoolExpression(ctx.left), this.visitBoolExpression(ctx.right));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.OR:
                op = new astNode_1.BoolOrNode(this.visitBoolExpression(ctx.left), this.visitBoolExpression(ctx.right));
                break;
            default:
                this.errorListener.add(new astNode_1.TextPosition(ctx.op.line, ctx.op.column, ctx.start.start, ctx.stop.stop), "Unknown binary operator");
                return null;
        }
        return op.setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitBracketBoolExpression(ctx) {
        return this.visitBoolExpression(ctx.boolExpression());
    }
    visitBoolUnaryOperator(ctx) {
        return new astNode_1.BoolNegationNode(this.visitBoolExpression(ctx.boolExpression()))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitBracketExpression(ctx) {
        return this.visitExpression(ctx.expression());
    }
    visitStateTransition(ctx) {
        let prevStates = [];
        ctx.ID().forEach(function (item) {
            prevStates.push(item.getText());
        });
        return new astNode_1.TransitionNode(prevStates, this.visitBoolExpression(ctx.condition))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitStateDef(ctx) {
        let statements = [];
        let self = this;
        if (ctx.stateStatement != undefined)
            ctx.stateStatement().forEach(function (item) {
                statements.push(self.visitStateStatement(item));
            });
        let transitions = [];
        ctx.stateTransition().forEach(function (item) {
            transitions.push(self.visitStateTransition(item));
        });
        return new astNode_1.StateNode(ctx.name.text, ctx.terminal != undefined, transitions, statements)
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitSetter(ctx) {
        return new astNode_1.SetterNode(this.visitVarIdentifier(ctx.variable), this.visitExpression(ctx.exp))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitEquation(ctx) {
        return new astNode_1.EquationNode(ctx.label == undefined ? null : this.visitVarIdentifier(ctx.label), this.visitExpression(ctx.left), this.visitExpression(ctx.right))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitInitialCondition(ctx) {
        return new astNode_1.InitialConditionNode(this.visitVarIdentifier(ctx.variable), this.visitExpression(ctx.exp))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitNumber(ctx) {
        return new astNode_1.ConstantNode(parseFloat(ctx.getText()))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitConstantStatement(ctx) {
        return new astNode_1.ConstantStatementNode(this.visitVarIdentifier(ctx.constant), this.visitExpression(ctx.exp))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitLoopBounds(ctx) {
        return new astNode_1.Bounds(parseInt(ctx.lbound.text), parseInt(ctx.rbound.text));
    }
    visitLoop(ctx) {
        let bounds = [];
        let statements = [];
        ctx.loopBounds().forEach(function (item) {
            bounds.push(this.visitLoopBounds(item));
        }, this);
        if (ctx.loopBody().loopStatement != undefined)
            ctx.loopBody().loopStatement().forEach(function (item) {
                statements.push(this.visitLoopStatement(item));
            }, this);
        return new astNode_1.LoopStatementNode(ctx.iterator.text, bounds, statements)
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitMacroExpression(ctx) {
        let args;
        args = ctx.expression != undefined ? ctx.expression().map(function (item) {
            return this.visitExpression(item);
        }, this) : [];
        return new astNode_1.MacroExpressionNode(this.visitVarIdentifier(ctx.id), args)
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitConstantExpression(ctx) {
        return this.visitNumber(ctx.value);
    }
    visitSummationExpression(ctx) {
        return new astNode_1.SumExpressionNode(ctx.iterator.text, this.visitLoopBounds(ctx.bounds), this.visitExpression(ctx.summationExp))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitTernaryOperatorExpression(ctx) {
        return new astNode_1.TernaryOperatorNode(this.visitBoolExpression(ctx.condition), this.visitExpression(ctx.first), this.visitExpression(ctx.second))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitBoolConstant(ctx) {
        return new astNode_1.BoolConstantNode(ctx.value.text == "true")
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    /*visitDerivativeExpression(ctx:any){
        return new DerivativeNode(this.visitVarIdentifier(ctx.id));
    }*/
    visitVariableExpression(ctx) {
        let ident = this.visitVarIdentifier(ctx.id);
        if (ctx.der != undefined)
            return new astNode_1.DerivativeNode(ident)
                .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
        return this.visitVarIdentifier(ctx.id);
    }
    visitUnaryOperatorExpression(ctx) {
        switch (ctx.op.type) {
            case odeGrammarParser_js_1.default.odeGrammarParser.PLUS:
                return this.visitExpression(ctx.expression());
            case odeGrammarParser_js_1.default.odeGrammarParser.MINUS:
                return new astNode_1.NegationNode(this.visitExpression(ctx.expression()))
                    .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
            default:
                this.errorListener.add(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop), "Unknown unary operator");
                return null;
        }
    }
    visitBinaryOperatorExpression(ctx) {
        let op;
        switch (ctx.op.type) {
            case odeGrammarParser_js_1.default.odeGrammarParser.DIVISION:
                op = new astNode_1.DivisionNode(this.visitExpression(ctx.left), this.visitExpression(ctx.right));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.ASTERISK:
                op = new astNode_1.MultiplicationNode(this.visitExpression(ctx.left), this.visitExpression(ctx.right));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.PLUS:
                op = new astNode_1.AdditionNode(this.visitExpression(ctx.left), this.visitExpression(ctx.right));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.MINUS:
                op = new astNode_1.SubtractionNode(this.visitExpression(ctx.left), this.visitExpression(ctx.right));
                break;
            case odeGrammarParser_js_1.default.odeGrammarParser.CARET:
                op = new astNode_1.FunctionNode("pow", [this.visitExpression(ctx.left), this.visitExpression(ctx.right)]);
                break;
            default:
                this.errorListener.add(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop), "Unknown binary operator");
                return null;
        }
        return op
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitFunctionDerivative(ctx) {
        return new astNode_1.DerivativeNode(this.visitVarIdentifier(ctx.id))
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitFunctionExpression(ctx) {
        var args = this.visitFunctionArguments(ctx.functionArguments());
        return new astNode_1.FunctionNode(ctx.func.text, args)
            .setTextPos(new astNode_1.TextPosition(ctx.start.line, ctx.start.column, ctx.start.start, ctx.stop.stop));
    }
    visitFunctionArguments(ctx) {
        var args = [];
        if (ctx.expression != undefined)
            ctx.expression().forEach(function (item) {
                args.push(this.visit(item));
            }, this);
        return args;
    }
}
exports.default = Visitor;


/***/ }),

/***/ "./src/curveSimplification/douglasPeuckerNSimplification.ts":
/*!******************************************************************!*\
  !*** ./src/curveSimplification/douglasPeuckerNSimplification.ts ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DouglasPeuckerNSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class PriorityQueue {
    constructor() {
        this.items = [];
    }
    insert(item, priority) {
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].priority < priority) {
                this.items.splice(i, 0, { value: item, priority: priority });
                return;
            }
        }
        this.items.push({ value: item, priority: priority });
    }
    dequeueu() {
        return this.items.shift().value;
        //return this.items[0].value;
    }
    length() {
        return this.items.length;
    }
}
class Edge {
    constructor(start, end, point) {
        this.start = start;
        this.end = end;
        this.point = point;
    }
}
class DouglasPeuckerNSimplification {
    constructor(maxPoints) {
        this.maxPoints = maxPoints;
    }
    process(start, end, points, queue) {
        let maxDist = 0;
        let index = start;
        for (let i = start + 1; i < end; i++) {
            let distance = daeVector_1.DAEVector.distanceLinePoint(points[start], points[end], points[i]);
            if (distance > maxDist) {
                maxDist = distance;
                index = i;
            }
        }
        if (index != start)
            queue.insert(new Edge(start, end, index), maxDist);
    }
    simplify(points) {
        if (points.length <= this.maxPoints) {
            return points.slice();
        }
        let queue = new PriorityQueue();
        let choosenPoints = [];
        choosenPoints.push(0);
        choosenPoints.push(points.length - 1);
        let start = 0;
        let end = points.length - 1;
        this.process(start, end, points, queue);
        while (choosenPoints.length < this.maxPoints && queue.length() > 0) {
            let edge = queue.dequeueu();
            choosenPoints.push(edge.point);
            start = edge.start;
            end = edge.point;
            this.process(start, end, points, queue);
            start = edge.point;
            end = edge.end;
            this.process(start, end, points, queue);
        }
        choosenPoints.sort((a, b) => a - b);
        let result = choosenPoints.map(function (index) {
            return points[index];
        });
        return result;
    }
}
exports.DouglasPeuckerNSimplification = DouglasPeuckerNSimplification;


/***/ }),

/***/ "./src/curveSimplification/douglasPeuckerSimplification.ts":
/*!*****************************************************************!*\
  !*** ./src/curveSimplification/douglasPeuckerSimplification.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DouglasPeuckerSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class DouglasPeuckerSimplification {
    constructor(epsilon) {
        this.epsilon = epsilon;
    }
    simplify(points) {
        return this.run(points, 0, points.length - 1);
    }
    run(points, start, end) {
        let maxDist = 0.0;
        let index = start + 1;
        let first = points[start];
        let last = points[end];
        for (let i = start + 1; i < end; i++) {
            let dist = daeVector_1.DAEVector.distanceLinePoint(first, last, points[i]);
            if (dist >= maxDist) {
                index = i;
                maxDist = dist;
            }
        }
        if (maxDist > this.epsilon) {
            let res1 = this.run(points, start, index);
            let res2 = this.run(points, index, end);
            res1.pop();
            return res1.concat(res2);
        }
        else {
            return [first, last];
        }
    }
}
exports.DouglasPeuckerSimplification = DouglasPeuckerSimplification;


/***/ }),

/***/ "./src/curveSimplification/langSimplification.ts":
/*!*******************************************************!*\
  !*** ./src/curveSimplification/langSimplification.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LangSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class LangSimplification {
    constructor(tolerance, lookahead) {
        this.tolerance = tolerance;
        this.lookahead = lookahead;
    }
    simplify(points) {
        let result = [];
        result.push(points[0]);
        let current = 0;
        while (current < points.length - 1) {
            let end = Math.min(current + this.lookahead, points.length - 1);
            let _end = end;
            for (let i = current + 1; i < _end; i++) {
                if (daeVector_1.DAEVector.distanceLinePoint(points[current], points[_end], points[i]) > this.tolerance) {
                    i = current;
                    _end -= 1;
                    continue;
                }
                result.push(points[_end]);
                current = _end;
                break;
            }
            if (current + 1 < _end) {
                result.push(points[end]);
                current = end;
            }
        }
        return result;
    }
}
exports.LangSimplification = LangSimplification;


/***/ }),

/***/ "./src/curveSimplification/nthPointSimplification.ts":
/*!***********************************************************!*\
  !*** ./src/curveSimplification/nthPointSimplification.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NthPointSimplification = void 0;
class NthPointSimplification {
    constructor(maxPoints) {
        this.maxPoints = maxPoints;
    }
    simplify(points) {
        if (points.length <= this.maxPoints)
            return points.slice();
        let result = [];
        result.push(points[0]);
        let delta = (points.length - 1) / (this.maxPoints - 1);
        for (let i = delta, j = 2; i < points.length && j < this.maxPoints; i += delta, j++) {
            result.push(points[Math.round(i)]);
        }
        result.push(points[points.length - 1]);
        return result;
    }
}
exports.NthPointSimplification = NthPointSimplification;


/***/ }),

/***/ "./src/curveSimplification/opheimSimplification.ts":
/*!*********************************************************!*\
  !*** ./src/curveSimplification/opheimSimplification.ts ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OpheimSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class OpheimSimplification {
    constructor(minTolerance, maxTolerance) {
        this.minTolerance = minTolerance;
        this.maxTolerance = maxTolerance;
    }
    simplify(points) {
        let result = [];
        result.push(points[0]);
        let current = 0;
        while (true) {
            let i = current + 1;
            if (daeVector_1.DAEVector.distance(points[current], points[i]) < this.minTolerance) {
                for (let j = i + 1; j <= points.length - 1; j++) {
                    if (daeVector_1.DAEVector.distance(points[current], points[j]) < this.maxTolerance) {
                        i = j - 1;
                    }
                }
                if (i >= points.length - 1)
                    break;
            }
            let j = i + 1;
            for (; j < points.length - 1; j++) {
                let perpDist = daeVector_1.DAEVector.distanceLinePoint(points[current], points[i], points[j]);
                if (perpDist > this.minTolerance) {
                    result.push(points[j]);
                    current = j;
                    break;
                }
                if (daeVector_1.DAEVector.distance(points[current], points[j]) > this.maxTolerance) {
                    result.push(points[j]);
                    current = j;
                    break;
                }
            }
            if (j == points.length - 1)
                break;
        }
        result.push(points[points.length - 1]);
        return result;
    }
}
exports.OpheimSimplification = OpheimSimplification;


/***/ }),

/***/ "./src/curveSimplification/perpendicularDistanceSimplification.ts":
/*!************************************************************************!*\
  !*** ./src/curveSimplification/perpendicularDistanceSimplification.ts ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PerpendicularDistanceSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class PerpendicularDistanceSimplification {
    constructor(tolerance) {
        this.tolerance = tolerance;
    }
    simplify(points) {
        while (true) {
            let result = this.run(points);
            if (result.length == points.length)
                return result;
            points = result;
        }
    }
    run(points) {
        if (points.length <= 2)
            return points.slice();
        let result = [];
        result.push(points[0]);
        for (let i = 0; i < points.length - 2;) {
            if (daeVector_1.DAEVector.distanceLinePoint(points[i], points[i + 2], points[i + 1]) < this.tolerance) {
                result.push(points[i + 2]);
                i += 2;
            }
            else {
                result.push(points[i + 1]);
                i++;
            }
        }
        result.push(points[points.length - 1]);
        return result;
    }
}
exports.PerpendicularDistanceSimplification = PerpendicularDistanceSimplification;


/***/ }),

/***/ "./src/curveSimplification/radialDistanceSimplification.ts":
/*!*****************************************************************!*\
  !*** ./src/curveSimplification/radialDistanceSimplification.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RadialDistanceSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class RadialDistanceSimplification {
    constructor(tolerance) {
        this.tolerance = tolerance;
    }
    simplify(points) {
        let result = [];
        let current = points[0];
        result.push(points[0]);
        for (let i = 1; i < points.length - 1; i++) {
            if (daeVector_1.DAEVector.distanceSqr(points[i], current) > this.tolerance * this.tolerance) {
                current = points[i];
                result.push(points[i]);
            }
        }
        result.push(points[points.length - 1]);
        return result;
    }
}
exports.RadialDistanceSimplification = RadialDistanceSimplification;


/***/ }),

/***/ "./src/curveSimplification/reumannWitkamSimplification.ts":
/*!****************************************************************!*\
  !*** ./src/curveSimplification/reumannWitkamSimplification.ts ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ReumannWitkamSimplification = void 0;
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
class ReumannWitkamSimplification {
    constructor(tolerance) {
        this.tolerance = tolerance;
    }
    simplify(points) {
        let result = [];
        result.push(points[0]);
        let current = 1;
        for (let i = 1; i < points.length - 1; i++) {
            if (daeVector_1.DAEVector.distanceLinePoint(result[result.length - 1], points[current], points[i]) > this.tolerance) {
                result.push(points[i - 1]);
                current = i;
            }
        }
        result.push(points[points.length - 1]);
        return result;
    }
}
exports.ReumannWitkamSimplification = ReumannWitkamSimplification;


/***/ }),

/***/ "./src/dae/adaptiveStep.ts":
/*!*********************************!*\
  !*** ./src/dae/adaptiveStep.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.AdaptiveStepNewton = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
class AdaptiveStepNewton {
    constructor(gamma, minStep) {
        this.gamma = gamma;
        this.minStep = minStep;
    }
    findStepIDAE(x, z, t, solver, system) {
        let step = 10e8;
        let state = system.getCurrentState();
        let links = state.getLinks();
        links.forEach((link) => {
            let dxdt = solver.solve_dx(x, z, t, state);
            let dzdt = solver.solve_dzdt(dxdt, x, z, t, state);
            let denom = vector_1.vector.dot(link.dpdx(x, z, t), dxdt) + vector_1.vector.dot(link.dpdz(x, z, t), dzdt) + link.dpdt(x, z, t);
            let h = -this.gamma * link.p(x, z, t) / denom;
            step = (h < 0 || isNaN(h) ? step : Math.min(step, h));
        });
        return Math.max(step, this.minStep);
    }
    findStepEDAE(x, z, t, system) {
        let step = 10e8;
        let state = system.getCurrentState();
        let links = state.getLinks();
        links.forEach((link) => {
            let dxdt = state.f(x, z, t);
            let dzdt = state.dgdt(x, t).addSelf(state.dgdx(x, t).multVec(dxdt));
            let denom = vector_1.vector.dot(link.dpdx(x, z, t), dxdt) + vector_1.vector.dot(link.dpdz(x, z, t), dzdt) + link.dpdt(x, z, t);
            let h = -this.gamma * link.p(x, z, t) / denom;
            step = (h < 0 || isNaN(h) ? step : Math.min(step, h));
        });
        return Math.max(step, this.minStep);
    }
}
exports.AdaptiveStepNewton = AdaptiveStepNewton;


/***/ }),

/***/ "./src/dae/customEDAEHybridState.ts":
/*!******************************************!*\
  !*** ./src/dae/customEDAEHybridState.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomEDAEHybridState = void 0;
const edaeHybridSystem_1 = __webpack_require__(/*! ./edaeHybridSystem */ "./src/dae/edaeHybridSystem.ts");
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../math/matrix */ "./src/math/matrix.ts");
class CustomEDAEHybridState extends edaeHybridSystem_1.EDAEHybridState {
    init(_f, _g, _dfdx, _dfdz, _dgdx, _dgdt) {
        this._f = _f;
        this._g = _g;
        this._dfdx = _dfdx;
        this._dfdz = _dfdz;
        this._dgdx = _dgdx;
        this._dgdt = _dgdt;
        return this;
    }
    pushLink(link) {
        this.links.push(link);
    }
    f(x, z, t) {
        let result = vector_1.vector.empty(this.length_x());
        let args = x.data.concat(z.data, [t]);
        this._f.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    g(x, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat([t]);
        this._g.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    dfdx(x, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(z.data, [t]);
        //for each row
        this._dfdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfdz(x, z, t) {
        let result = matrix_1.matrix.empty(this.length_x(), this.length_z());
        let args = x.data.concat(z.data, [t]);
        //for each row
        this._dfdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdx(x, t) {
        let result = matrix_1.matrix.empty(this.length_z(), this.length_x());
        let args = x.data.concat([t]);
        //for each row
        this._dgdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdt(x, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat([t]);
        this._dgdt.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    length_x() {
        return this._f.length;
    }
    length_z() {
        return this._g.length;
    }
}
exports.CustomEDAEHybridState = CustomEDAEHybridState;


/***/ }),

/***/ "./src/dae/customEDAESystem.ts":
/*!*************************************!*\
  !*** ./src/dae/customEDAESystem.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomEDAESystem = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../math/matrix */ "./src/math/matrix.ts");
class CustomEDAESystem {
    constructor(_f, _g, _dfdx, _dfdz, _dgdx) {
        this._f = _f;
        this._g = _g;
        this._dfdx = _dfdx;
        this._dfdz = _dfdz;
        this._dgdx = _dgdx;
    }
    length_x() {
        return this._f.length;
    }
    length_z() {
        return this._g.length;
    }
    f(x, z, t) {
        let result = vector_1.vector.empty(this.length_x());
        let args = x.data.concat(z.data, [t]);
        this._f.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    g(x, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat([t]);
        this._g.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    dfdx(x, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(z.data, [t]);
        //for each row
        this._dfdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfdz(x, z, t) {
        let result = matrix_1.matrix.empty(this.length_x(), this.length_z());
        let args = x.data.concat(z.data, [t]);
        //for each row
        this._dfdz.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdx(x, t) {
        let result = matrix_1.matrix.empty(this.length_z(), this.length_x());
        let args = x.data.concat([t]);
        //for each row
        this._dgdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
}
exports.CustomEDAESystem = CustomEDAESystem;


/***/ }),

/***/ "./src/dae/customHybridStateLink.ts":
/*!******************************************!*\
  !*** ./src/dae/customHybridStateLink.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomHybridStateLink = exports.Setter = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
class Setter {
    constructor(index, expression) {
        this.index = index;
        this.expression = expression;
    }
}
exports.Setter = Setter;
class CustomHybridStateLink {
    constructor(newState, setters, _p, _dpdx, _dpdz, _dpdt) {
        this.newState = newState;
        this.setters = setters;
        this._p = _p;
        this._dpdx = _dpdx;
        this._dpdz = _dpdz;
        this._dpdt = _dpdt;
    }
    getNewState() {
        return this.newState;
    }
    pr(x, z, t) {
        let value = this.p(x, z, t);
        return value < 0 ? true : false;
    }
    p(x, z, t) {
        let args = x.data.concat(z.data, [t]);
        return this._p.execute(args);
    }
    dpdt(x, z, t) {
        let args = x.data.concat(z.data, [t]);
        return this._dpdt.execute(args);
    }
    setConditions(x, z, t) {
        let result = x.clone();
        let args = x.data.concat(z.data, [t]);
        this.setters.forEach(function (item) {
            result.set(item.expression.execute(args), item.index);
        });
        return result;
    }
    dpdz(x, z, t) {
        let result = vector_1.vector.empty(z.length());
        let args = x.data.concat(z.data, [t]);
        this._dpdz.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    dpdx(x, z, t) {
        let result = vector_1.vector.empty(x.length());
        let args = x.data.concat(z.data, [t]);
        this._dpdx.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
}
exports.CustomHybridStateLink = CustomHybridStateLink;


/***/ }),

/***/ "./src/dae/customIDAEHybridState.ts":
/*!******************************************!*\
  !*** ./src/dae/customIDAEHybridState.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomIDAEHybridState = void 0;
const idaeHybridSystem_1 = __webpack_require__(/*! ./idaeHybridSystem */ "./src/dae/idaeHybridSystem.ts");
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../math/matrix */ "./src/math/matrix.ts");
class CustomIDAEHybridState extends idaeHybridSystem_1.IDAEHybridState {
    init(_f, _g, _dfdx, _dfddx, _dfdz, _dgdx, _dgdz, _dgdt) {
        this._f = _f;
        this._g = _g;
        this._dfdx = _dfdx;
        this._dfddx = _dfddx;
        this._dfdz = _dfdz;
        this._dgdx = _dgdx;
        this._dgdz = _dgdz;
        this._dgdt = _dgdt;
        return this;
    }
    pushLink(link) {
        this.links.push(link);
    }
    f(x, dx, z, t) {
        let result = vector_1.vector.empty(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        this._f.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    g(x, z, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat(z.data, [t]);
        this._g.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    dfdx(x, dx, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfddx(x, dx, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfddx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfdz(x, dx, z, t) {
        let result = matrix_1.matrix.empty(this.length_x(), this.length_z());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfdz.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdz(x, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_z());
        let args = x.data.concat(z.data, [t]);
        this._dgdz.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdx(x, z, t) {
        let result = matrix_1.matrix.empty(this.length_z(), this.length_x());
        let args = x.data.concat(z.data, [t]);
        this._dgdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdt(x, z, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat(z.data, [t]);
        this._dgdt.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    length_x() {
        return this._f.length;
    }
    length_z() {
        return this._g.length;
    }
}
exports.CustomIDAEHybridState = CustomIDAEHybridState;


/***/ }),

/***/ "./src/dae/customIDAESystem.ts":
/*!*************************************!*\
  !*** ./src/dae/customIDAESystem.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomIDAESystem = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../math/matrix */ "./src/math/matrix.ts");
class CustomIDAESystem {
    constructor(_f, _g, _dfdx, _dfddx, _dfdz, _dgdx, _dgdz) {
        this._f = _f;
        this._g = _g;
        this._dfdx = _dfdx;
        this._dfddx = _dfddx;
        this._dfdz = _dfdz;
        this._dgdx = _dgdx;
        this._dgdz = _dgdz;
    }
    length_x() {
        return this._f.length;
    }
    length_z() {
        return this._g.length;
    }
    f(x, dx, z, t) {
        let result = vector_1.vector.empty(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        this._f.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    g(x, z, t) {
        let result = vector_1.vector.empty(this.length_z());
        let args = x.data.concat(z.data, [t]);
        this._g.forEach(function (item, i) {
            result.set(item.execute(args), i);
        });
        return result;
    }
    dfdx(x, dx, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfddx(x, dx, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_x());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfddx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dfdz(x, dx, z, t) {
        let result = matrix_1.matrix.empty(this.length_x(), this.length_z());
        let args = x.data.concat(dx.data, z.data, [t]);
        //for each row
        this._dfdz.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdz(x, z, t) {
        let result = matrix_1.matrix.emptySquare(this.length_z());
        let args = x.data.concat(z.data, [t]);
        this._dgdz.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
    dgdx(x, z, t) {
        let result = matrix_1.matrix.empty(this.length_z(), this.length_x());
        let args = x.data.concat(z.data, [t]);
        this._dgdx.forEach(function (row, j) {
            //for each cell in row
            row.forEach(function (item, i) {
                result.set(item.execute(args), j, i);
            });
        });
        return result;
    }
}
exports.CustomIDAESystem = CustomIDAESystem;


/***/ }),

/***/ "./src/dae/daeVector.ts":
/*!******************************!*\
  !*** ./src/dae/daeVector.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.DAEVector = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
class DAEVector {
    constructor(x, z, t) {
        this.x = x;
        this.z = z;
        this.t = t;
    }
    lengthSqr() {
        return this.t * this.t + this.x.norm2Sqr() + this.z.norm2Sqr();
    }
    length() {
        return Math.sqrt(this.t * this.t + this.x.norm2Sqr() + this.z.norm2Sqr());
    }
    static distance(a, b) {
        return Math.sqrt(Math.pow(a.t - b.t, 2) + vector_1.vector.sub(a.x, b.x).norm2Sqr() + vector_1.vector.sub(a.z, b.z).norm2Sqr());
    }
    static distanceSqr(a, b) {
        return Math.pow(a.t - b.t, 2) + vector_1.vector.sub(a.x, b.x).norm2Sqr() + vector_1.vector.sub(a.z, b.z).norm2Sqr();
    }
    static dot(a, b) {
        return a.t * b.t + vector_1.vector.dot(a.x, b.x) + vector_1.vector.dot(a.z, b.z);
    }
    static sub(a, b) {
        return new DAEVector(vector_1.vector.sub(a.x, b.x), vector_1.vector.sub(a.z, b.z), a.t - b.t);
    }
    static distanceLinePoint(p1, p2, point) {
        let a = DAEVector.distanceSqr(point, p1); //dist from p to p1
        let b = DAEVector.dot(DAEVector.sub(point, p1), DAEVector.sub(p2, p1));
        let c = DAEVector.distanceSqr(p1, p2);
        return Math.sqrt(a - b * b / c);
    }
}
exports.DAEVector = DAEVector;


/***/ }),

/***/ "./src/dae/edaeHybridSolver.ts":
/*!*************************************!*\
  !*** ./src/dae/edaeHybridSolver.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAEHybridSolver = void 0;
const daeVector_1 = __webpack_require__(/*! ./daeVector */ "./src/dae/daeVector.ts");
const hybridSolution_1 = __webpack_require__(/*! ./hybridSolution */ "./src/dae/hybridSolution.ts");
const maxFloats = 2097152;
class EDAEHybridSolver {
    constructor(eventDetector, adaptiveStepStrategy) {
        this.eventDetector = eventDetector;
        this.adaptiveStepStrategy = adaptiveStepStrategy;
    }
    solve(x0, t0, t1, solver, system) {
        let solutionValues = [];
        let states = [];
        let stateSwitches = [];
        let t = t0;
        let x = x0;
        let z = system.getCurrentState().g(x, t);
        let oldValues = new daeVector_1.DAEVector(x, z, t);
        solutionValues.push(oldValues);
        states.push(system.getCurrentStateIndex());
        stateSwitches.push(t0);
        while (oldValues.t < t1) {
            //calculate new step size
            let currentStep = solver.getStep();
            let isStepChanged = false;
            if (this.adaptiveStepStrategy != null) {
                let h = this.adaptiveStepStrategy.findStepEDAE(oldValues.x, oldValues.z, oldValues.t, system);
                if (h > 0 && h < solver.getStep()) {
                    solver.setStep(h);
                    isStepChanged = true;
                }
            }
            //calculate variable values at t_{n+1}, t_{n+1} = t_n + h
            let curValues = solver.makeStep(oldValues.x, oldValues.z, oldValues.t, system.getCurrentState());
            //check for state change in the interval [t_n,t_n+h]
            if (this.eventDetector.checkEventEDAE(oldValues, curValues, solver, system)) {
                states.push(system.getCurrentStateIndex());
                stateSwitches.push(curValues.t);
                //check for terminal state
                if (system.isTerminal()) {
                    break;
                }
                //reset multistep method
                solver.setStep(currentStep);
            }
            else if (isStepChanged)
                solver.setStep(currentStep);
            oldValues = curValues;
            solutionValues.push(oldValues);
            if (states.length * 2 + solutionValues.length * (system.getCurrentState().length_x() + system.getCurrentState().length_z() + 1) > maxFloats) {
                console.info(`Solution was terminated prematurely due to memory limit`);
                break;
            }
        }
        return new hybridSolution_1.HybridSolution(solutionValues, states, stateSwitches);
    }
}
exports.EDAEHybridSolver = EDAEHybridSolver;


/***/ }),

/***/ "./src/dae/edaeHybridSystem.ts":
/*!*************************************!*\
  !*** ./src/dae/edaeHybridSystem.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAEHybridSystem = exports.EDAEHybridState = void 0;
class EDAEHybridState {
    constructor(name, links, terminal) {
        this.name = name;
        this.links = links;
        this.terminal = terminal;
    }
    isTerminal() {
        return this.terminal;
    }
    getLinks() {
        return this.links;
    }
    getName() {
        return this.name;
    }
}
exports.EDAEHybridState = EDAEHybridState;
class EDAEHybridSystem {
    constructor(states) {
        this.states = states;
        this.currentState = 0;
    }
    setCurrentState(state) {
        this.currentState = state;
    }
    getCurrentStateIndex() {
        return this.currentState;
    }
    getCurrentState() {
        return this.states[this.currentState];
    }
    isTerminal() {
        return this.states[this.currentState].isTerminal();
    }
}
exports.EDAEHybridSystem = EDAEHybridSystem;


/***/ }),

/***/ "./src/dae/edaeSolver.ts":
/*!*******************************!*\
  !*** ./src/dae/edaeSolver.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAESolver = void 0;
class EDAESolver {
    constructor(step) {
        this.step = step;
    }
    setStep(value) {
        this.step = value;
    }
    getStep() {
        return this.step;
    }
}
exports.EDAESolver = EDAESolver;


/***/ }),

/***/ "./src/dae/eventDetection.ts":
/*!***********************************!*\
  !*** ./src/dae/eventDetection.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventDetectionComplex = exports.EventDetectionSimple = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
class EventDetectionSimple {
    /**
     * Event detection for implicit dae hybrid system
     * @param oldValues values at t
     * @param curValues values at t+h, used to store initial values in case of state change
     * @param solver implicit dae solver
     * @param system hybrid system
     * @returns true when state has changed
     */
    checkEventIDAE(oldValues, curValues, solver, system) {
        let value = 10e8;
        let index = -1;
        let state = system.getCurrentState();
        let links = state.getLinks();
        links.forEach((link, id) => {
            let p = link.p(curValues.x, curValues.z, curValues.t);
            if (p >= 0 && p < value) {
                value = p;
                index = id;
            }
        });
        if (index != -1) {
            curValues.x = links[index].setConditions(curValues.x, curValues.z, curValues.t);
            system.setCurrentState(links[index].getNewState());
            return true;
        }
        return false;
    }
    /**
     * Event detection for explicit dae hybrid system
     * @param oldValues values at t
     * @param curValues values at t+h, used to store initial values in case of state change
     * @param solver explicit dae solver
     * @param system hybrid system
     * @returns true when state has changed
     */
    checkEventEDAE(oldValues, curValues, solver, system) {
        let value = 10e8;
        let index = -1;
        let state = system.getCurrentState();
        let links = state.getLinks();
        links.forEach((link, id) => {
            let p = link.p(curValues.x, curValues.z, curValues.t);
            if (p >= 0 && p < value) {
                value = p;
                index = id;
            }
        });
        if (index != -1) {
            curValues.x = links[index].setConditions(curValues.x, curValues.z, curValues.t);
            system.setCurrentState(links[index].getNewState());
            return true;
        }
        return false;
    }
}
exports.EventDetectionSimple = EventDetectionSimple;
/**
 * Event detection on time step interval with newton method for cases, when signs of event condition function doesn't change and bisection method
 * for cases with change of sign
 */
class EventDetectionComplex {
    constructor(newtonIterations = 30, relTol = 1e-6, absTol = 1e-5, alpha = 0.95, bisectionIterations = 30, timeAbsTol = 1e-4, timeRelTol = 1e-4) {
        this.newtonIterations = 30;
        this.relTol = 1e-6;
        this.absTol = 1e-5;
        this.alpha = 0.95;
        this.bisectionIterations = 30;
        this.timeAbsTol = 1e-4;
        this.timeRelTol = 1e-4;
        this.newtonIterations = newtonIterations;
        this.relTol = relTol;
        this.absTol = absTol;
        this.alpha = alpha;
        this.bisectionIterations = bisectionIterations;
        this.timeAbsTol = timeAbsTol;
        this.timeRelTol = timeRelTol;
    }
    /**
     * Event detection for implicit dae hybrid system
     * @param oldValues values at t
     * @param curValues values at t+h, used to store initial values in case of state change
     * @param solver implicit dae solver
     * @param system hybrid system
     * @returns true when state has changed
     */
    checkEventIDAE(oldValues, curValues, solver, system) {
        let time = 10e8;
        let index = -1;
        let state = system.getCurrentState();
        let links = state.getLinks();
        let step = curValues.t - oldValues.t;
        let dx = vector_1.vector.sub(curValues.x, oldValues.x).scaleSelf(1 / step);
        let dz = vector_1.vector.sub(curValues.z, oldValues.z).scaleSelf(1 / step);
        //assume that x and z are linear in interval [oldT,curT]
        links.forEach((link, id) => {
            let p0 = link.p(oldValues.x, oldValues.z, oldValues.t);
            let p1 = link.p(curValues.x, curValues.z, curValues.t);
            if (p0 >= 0 && oldValues.t < time) {
                time = oldValues.t;
                index = id;
                return;
            }
            else if (p1 >= 0 && curValues.t < time) {
                time = curValues.t;
                index = id;
            }
            let _p0 = Math.min(Math.abs(p1), Math.abs(p0));
            let p = p0;
            let t = oldValues.t;
            let x = oldValues.x;
            let z = oldValues.z;
            let flag = false;
            //Newton method for root finding
            for (let i = 0; i < this.newtonIterations; i++) {
                let dpdt = vector_1.vector.dot(link.dpdx(x, z, t), dx) +
                    vector_1.vector.dot(link.dpdz(x, z, t), dz) + link.dpdt(x, z, t);
                p = Math.max(Math.abs(p), this.absTol) * Math.sign(p);
                let dt = -this.alpha * p / dpdt;
                //dt = Math.max(this.timeAbsTol,Math.abs(dt))*Math.sign(dt);
                t += dt;
                if (t < oldValues.t || t > curValues.t)
                    break;
                x = vector_1.vector.mix(oldValues.x, curValues.x, (t - oldValues.t) / step);
                z = vector_1.vector.mix(oldValues.z, curValues.z, (t - oldValues.t) / step);
                p = link.p(x, z, t);
                if (p >= 0 && Math.abs(p) < _p0 * this.relTol + this.absTol) {
                    if (t < time) {
                        time = t;
                        index = id;
                    }
                    return;
                }
            }
            //bisection
            {
                if (p1 >= 0 && p0 <= 0) {
                    let t1 = curValues.t;
                    let t0 = oldValues.t;
                    for (let i = 0; i < this.bisectionIterations; i++) {
                        let t = (t1 + t0) / 2;
                        let x = vector_1.vector.mix(oldValues.x, curValues.x, (t - oldValues.t) / step);
                        let z = vector_1.vector.mix(oldValues.z, curValues.z, (t - oldValues.t) / step);
                        let p = link.p(x, z, t);
                        let dt = 0;
                        if (p >= 0) {
                            p1 = p;
                            t1 = t;
                            dt = t - t0;
                            if (p < _p0 * this.relTol + this.absTol && dt < this.timeAbsTol + step * this.timeRelTol && t < time) {
                                time = t;
                                index = id;
                                break;
                            }
                        }
                        else {
                            p0 = p;
                            t0 = t;
                            dt = t1 - t;
                        }
                    }
                }
            }
            //TODO add false position from matlab article
        });
        if (index != -1) {
            let x = vector_1.vector.mix(oldValues.x, curValues.x, (time - oldValues.t) / step);
            let z = vector_1.vector.mix(oldValues.z, curValues.z, (time - oldValues.t) / step);
            z = solver.solve_z(x, z, time, state);
            curValues.x = links[index].setConditions(x, z, time);
            curValues.t = time;
            curValues.z = solver.solve_z(curValues.x, z, curValues.t, state);
            system.setCurrentState(links[index].getNewState());
            //curValues.z = z;
            return true;
        }
        return false;
    }
    /**
     * Event detection for explicit dae hybrid system
     * @param oldValues values at t
     * @param curValues values at t+h, used to store initial values in case of state change
     * @param solver explicit dae solver
     * @param system hybrid system
     * @returns true when state has changed
     */
    checkEventEDAE(oldValues, curValues, solver, system) {
        let time = 10e8;
        let index = -1;
        let state = system.getCurrentState();
        let links = state.getLinks();
        let step = curValues.t - oldValues.t;
        let dx = vector_1.vector.sub(curValues.x, oldValues.x).scaleSelf(1 / step);
        let dz = vector_1.vector.sub(curValues.z, oldValues.z).scaleSelf(1 / step);
        //assume that x and z are linear in interval [oldT,curT]
        links.forEach((link, id) => {
            let p0 = link.p(oldValues.x, oldValues.z, oldValues.t);
            let p1 = link.p(curValues.x, curValues.z, curValues.t);
            if (p0 >= 0 && oldValues.t < time) {
                time = oldValues.t;
                index = id;
                return;
            }
            else if (p1 >= 0 && curValues.t < time) {
                time = curValues.t;
                index = id;
            }
            let _p0 = Math.min(Math.abs(p1), Math.abs(p0));
            let p = p0;
            let t = oldValues.t;
            let x = oldValues.x;
            let z = oldValues.z;
            let flag = false;
            //newton
            for (let i = 0; i < this.newtonIterations; i++) {
                let dpdt = vector_1.vector.dot(link.dpdx(x, z, t), dx) +
                    vector_1.vector.dot(link.dpdz(x, z, t), dz) + link.dpdt(x, z, t);
                p = Math.max(Math.abs(p), this.absTol) * Math.sign(p);
                let dt = -this.alpha * p / dpdt;
                //dt = Math.max(this.timeAbsTol,Math.abs(dt))*Math.sign(dt);
                t += dt;
                if (t < oldValues.t || t > curValues.t)
                    break;
                x = vector_1.vector.mix(oldValues.x, curValues.x, (t - oldValues.t) / step);
                z = vector_1.vector.mix(oldValues.z, curValues.z, (t - oldValues.t) / step);
                p = link.p(x, z, t);
                if (p >= 0 && Math.abs(p) < _p0 * this.relTol + this.absTol) {
                    if (t < time) {
                        time = t;
                        index = id;
                    }
                    return;
                }
            }
            //bisection
            {
                if (p1 >= 0 && p0 <= 0) {
                    let t1 = curValues.t;
                    let t0 = oldValues.t;
                    for (let i = 0; i < this.bisectionIterations; i++) {
                        let t = (t1 + t0) / 2;
                        let x = vector_1.vector.mix(oldValues.x, curValues.x, (t - oldValues.t) / step);
                        let z = vector_1.vector.mix(oldValues.z, curValues.z, (t - oldValues.t) / step);
                        let p = link.p(x, z, t);
                        let dt = 0;
                        if (p >= 0) {
                            p1 = p;
                            t1 = t;
                            dt = t - t0;
                            if (p < _p0 * this.relTol + this.absTol && dt < this.timeAbsTol + step * this.timeRelTol && t < time) {
                                time = t;
                                index = id;
                                break;
                            }
                        }
                        else {
                            p0 = p;
                            t0 = t;
                            dt = t1 - t;
                        }
                    }
                }
            }
            //TODO add false position from matlab article
        });
        if (index != -1) {
            let x = vector_1.vector.mix(oldValues.x, curValues.x, (time - oldValues.t) / step);
            //let z = vector.mix(oldValues.z,curValues.z,(time-oldValues.t)/step);
            let z = state.g(x, time);
            curValues.x = links[index].setConditions(x, z, time);
            curValues.t = time;
            curValues.z = state.g(curValues.x, curValues.t);
            system.setCurrentState(links[index].getNewState());
            //curValues.z = z;
            return true;
        }
        return false;
    }
}
exports.EventDetectionComplex = EventDetectionComplex;


/***/ }),

/***/ "./src/dae/hybridSolution.ts":
/*!***********************************!*\
  !*** ./src/dae/hybridSolution.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HybridSolution = void 0;
/*export abstract class HybridState{
    name:string;
    links:HybridStateLink[];
    terminal:boolean;
    abstract f(x:vector,z:vector,t:number):vector;
    abstract g(x:vector,z:vector,t:number):vector;
    abstract dfdx(x:vector,z:vector,t:number):matrix;
    abstract dfdz(x:vector,z:vector,t:number):matrix;
}*/
class HybridSolution {
    constructor(values, states, stateSwitches) {
        this.values = values;
        this.states = states;
    }
}
exports.HybridSolution = HybridSolution;


/***/ }),

/***/ "./src/dae/idaeHybridSolver.ts":
/*!*************************************!*\
  !*** ./src/dae/idaeHybridSolver.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAEHybridSolver = void 0;
const hybridSolution_1 = __webpack_require__(/*! ./hybridSolution */ "./src/dae/hybridSolution.ts");
const daeVector_1 = __webpack_require__(/*! ./daeVector */ "./src/dae/daeVector.ts");
const maxFloats = 2097152;
//TODO: test this solver
class IDAEHybridSolver {
    constructor(eventDetector, adaptiveStepStrategy) {
        this.eventDetector = eventDetector;
        this.adaptiveStepStrategy = adaptiveStepStrategy;
    }
    solve(x0, z0, t0, t1, solver, system) {
        let solutionValues = [];
        let states = [];
        let stateSwitches = [];
        let t = t0;
        let x = x0;
        let z = solver.solve_z(x, z0, t, system.getCurrentState());
        let oldValues = new daeVector_1.DAEVector(x, z, t);
        solutionValues.push(oldValues);
        states.push(system.getCurrentStateIndex());
        stateSwitches.push(t0);
        while (oldValues.t < t1) {
            //find step
            let currentStep = solver.getStep();
            let isStepChanged = false;
            if (this.adaptiveStepStrategy != null) {
                let h = this.adaptiveStepStrategy.findStepIDAE(oldValues.x, oldValues.z, oldValues.t, solver, system);
                if (h > 0 && h < solver.getStep()) {
                    solver.setStep(h);
                    isStepChanged = true;
                }
            }
            //get values
            let curValues = solver.makeStep(oldValues.x, oldValues.z, oldValues.t, system.getCurrentState());
            //check for state change in the interval [t,t+h]
            if (this.eventDetector.checkEventIDAE(oldValues, curValues, solver, system)) {
                states.push(system.getCurrentStateIndex());
                stateSwitches.push(curValues.t);
                if (system.isTerminal()) {
                    break;
                }
                //reset multistep method
                solver.setStep(currentStep);
            }
            else if (isStepChanged)
                solver.setStep(currentStep);
            oldValues = curValues;
            solutionValues.push(oldValues);
            if (states.length * 2 + solutionValues.length * (system.getCurrentState().length_x() + system.getCurrentState().length_z() + 1) > maxFloats) {
                console.info(`Solution was terminated prematurely due to memory limit`);
                break;
            }
        }
        return new hybridSolution_1.HybridSolution(solutionValues, states, stateSwitches);
    }
}
exports.IDAEHybridSolver = IDAEHybridSolver;


/***/ }),

/***/ "./src/dae/idaeHybridSystem.ts":
/*!*************************************!*\
  !*** ./src/dae/idaeHybridSystem.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAEHybridSystem = exports.IDAEHybridState = void 0;
class IDAEHybridState {
    constructor(name, links, terminal) {
        this.name = name;
        this.links = links;
        this.terminal = terminal;
    }
    isTerminal() {
        return this.terminal;
    }
    getLinks() {
        return this.links;
    }
    getName() {
        return this.name;
    }
}
exports.IDAEHybridState = IDAEHybridState;
class IDAEHybridSystem {
    constructor(states) {
        this.states = states;
        this.currentState = 0;
    }
    getCurrentStateIndex() {
        return this.currentState;
    }
    getCurrentState() {
        return this.states[this.currentState];
    }
    isTerminal() {
        return this.states[this.currentState].isTerminal();
    }
    setCurrentState(state) {
        this.currentState = state;
    }
}
exports.IDAEHybridSystem = IDAEHybridSystem;


/***/ }),

/***/ "./src/dae/idaeSolver.ts":
/*!*******************************!*\
  !*** ./src/dae/idaeSolver.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAESolver = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const gauss_1 = __webpack_require__(/*! ../math/gauss */ "./src/math/gauss.ts");
class IDAESolver {
    constructor(step, newtonSolver) {
        this.step = step;
        this.systemSolver = newtonSolver;
    }
    setStep(value) {
        this.step = value;
    }
    getStep() {
        return this.step;
    }
    solve_z(x, z, t, system) {
        if (system.length_z() == 0)
            return z;
        //solve g(x_{n+1},z_{n+1},t_{n+1}) = 0 for z_{n+1} 
        return this.systemSolver.solve((zNew) => {
            return system.g(x, zNew, t);
        }, (zNew) => {
            return system.dgdz(x, zNew, t);
        }, system.length_z(), z.clone());
        /*let zNew = z.clone();
        let F: vector = system.g(x, zNew, t);
        let f0norm: number = F.norm2();
        for (let i = 0; i < this.systemSolver.getIterations(); i++) {
            let J: matrix;
            J = system.dgdz(x, zNew, t);
            let fnorm = F.norm2();
            let dz = gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
            zNew.addSelf(dz);
            F = system.g(x, zNew, t);
            if (fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                return zNew;
            }
        }
        throw "divergence at solve_z";*/
    }
    solve_dx(x, z, t, system) {
        if (system.length_x() == 0)
            return new vector_1.vector([]);
        //solve f(x,dx,z,t) = 0
        return this.systemSolver.solve((dx) => {
            return system.f(x, dx, z, t);
        }, (dx) => {
            return system.dfddx(x, dx, z, t);
        }, system.length_x());
        /*
        let dx = vector.empty(system.length_x());
        let F: vector = system.f(x, dx, z, t);
        let f0norm: number = F.norm2();
        for (let i = 0; i < this.systemSolver.getIterations(); i++) {
            let J: matrix;
            J = system.dfddx(x, dx, z, t);
            let fnorm = F.norm2();
            let _dx = gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
            dx.addSelf(_dx);
            F = system.f(x, dx, z, t);
            if (fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                return dx;
            }
        }
        throw "divergence at solve_dx";*/
    }
    solve_dzdt(dx, x, z, t, state) {
        if (state.length_z() == 0)
            return z;
        let A = state.dgdz(x, z, t);
        let b;
        if (state.length_x() != 0)
            b = state.dgdx(x, z, t).multVec(dx).addSelf(state.dgdt(x, z, t)).scaleSelf(-1);
        else
            b = state.dgdt(x, z, t).scaleSelf(-1);
        //solve linear system
        //dg/dz dz/dt = -dg/dx x' - dg/dt
        let dzdt = gauss_1.gauss.solve(A, b);
        return dzdt;
    }
}
exports.IDAESolver = IDAESolver;


/***/ }),

/***/ "./src/dae/solvers/edae/adams-bashforth.ts":
/*!*************************************************!*\
  !*** ./src/dae/solvers/edae/adams-bashforth.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_AB6 = exports.EDAE_AB5 = exports.EDAE_AB4 = exports.EDAE_AB3 = exports.EDAE_AB2 = void 0;
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const rk_1 = __webpack_require__(/*! ../edae/rk */ "./src/dae/solvers/edae/rk.ts");
class EDAE_ADAMS_BASHFORTH extends edaeSolver_1.EDAESolver {
    constructor(step, b, solver, stages) {
        super(step);
        this.b = b;
        this.solver = solver;
        this.stages = stages;
        this.prevValues = [];
    }
    setStep(value) {
        super.setStep(value);
        this.prevValues = [];
    }
    makeStep(x, z, t, system) {
        this.prevValues.splice(0, 0, system.f(x, z, t));
        if (this.prevValues.length != this.stages) {
            let result = this.solver.makeStep(x, z, t, system);
            return result;
        }
        let tNew = t + this.step;
        let xNew = x.clone();
        for (let i = 0; i < this.stages; i++) {
            xNew.addSelf(vector_1.vector.scale(this.prevValues[i], this.step * this.b[i]));
        }
        let zNew = system.g(xNew, tNew);
        this.prevValues.splice(this.prevValues.length - 1, 1);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
class EDAE_AB2 extends EDAE_ADAMS_BASHFORTH {
    constructor(step) {
        super(step, [3 / 2, -1 / 2], new rk_1.EDAE_RK4(step), 2);
    }
}
exports.EDAE_AB2 = EDAE_AB2;
class EDAE_AB3 extends EDAE_ADAMS_BASHFORTH {
    constructor(step) {
        super(step, [23 / 12, -4 / 3, 5 / 12], new rk_1.EDAE_RK4(step), 3);
    }
}
exports.EDAE_AB3 = EDAE_AB3;
class EDAE_AB4 extends EDAE_ADAMS_BASHFORTH {
    constructor(step) {
        super(step, [55 / 24, -59 / 24, 37 / 24, -3 / 8], new rk_1.EDAE_RK4(step), 4);
    }
}
exports.EDAE_AB4 = EDAE_AB4;
class EDAE_AB5 extends EDAE_ADAMS_BASHFORTH {
    constructor(step) {
        super(step, [1901 / 720, -1387 / 360, 109 / 30, -637 / 360, 251 / 720], new rk_1.EDAE_RK6(step), 5);
    }
}
exports.EDAE_AB5 = EDAE_AB5;
class EDAE_AB6 extends EDAE_ADAMS_BASHFORTH {
    constructor(step) {
        super(step, [4277 / 1440, -2641 / 480, 4991 / 720, -3649 / 720, 959 / 480, -95 / 288], new rk_1.EDAE_RK6(step), 6);
    }
}
exports.EDAE_AB6 = EDAE_AB6;


/***/ }),

/***/ "./src/dae/solvers/edae/algebraicSolver.ts":
/*!*************************************************!*\
  !*** ./src/dae/solvers/edae/algebraicSolver.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_AlgebraicSolver = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
/**
 * solver for z = g(t)
 */
class EDAE_AlgebraicSolver extends edaeSolver_1.EDAESolver {
    makeStep(x, z, t, system) {
        let xNew = x;
        let tNew = t + this.step;
        let zNew = system.g(xNew, tNew);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.EDAE_AlgebraicSolver = EDAE_AlgebraicSolver;


/***/ }),

/***/ "./src/dae/solvers/edae/euler.ts":
/*!***************************************!*\
  !*** ./src/dae/solvers/edae/euler.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_IEuler = exports.EDAE_EEuler = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/**
 * forward euler for explicit dae with index one
 */
class EDAE_EEuler extends edaeSolver_1.EDAESolver {
    makeStep(x, z, t, system) {
        let xNew = system.f(x, z, t).scaleSelf(this.step).addSelf(x);
        let tNew = t + this.step;
        let zNew = system.g(xNew, tNew);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.EDAE_EEuler = EDAE_EEuler;
/**
 * backward euler method for explicit dae with index one
 */
class EDAE_IEuler extends edaeSolver_1.EDAESolver {
    constructor(step, stepSolver) {
        super(step);
        this.stepSolver = stepSolver;
    }
    /*
    F = x_{n+1} - x_n - hf(x_{n+1},g(x_{n+1},t_{n+1}),t_{n+1}) = 0
    dFi/dx_{n+1}j = \delta_ij - h*df/dx - h*df/dz*dg/dx
    */
    makeStep(x, z, t, system) {
        let xNew = x.clone();
        let tNew = t + this.step;
        let zNew = system.g(xNew, tNew);
        let F = system.f(xNew, zNew, tNew).scaleSelf(-this.step).addSelf(xNew).subSelf(x);
        let f0norm = F.norm2();
        for (let i = 0; i < this.stepSolver.getIterations(); i++) {
            let J = matrix_1.matrix.identity(system.length_x());
            J.subSelf(system.dfdx(xNew, zNew, tNew).addSelf(matrix_1.matrix.mult(system.dfdz(xNew, zNew, tNew), system.dgdx(xNew, tNew))).scaleSelf(this.step));
            let dx = gauss_1.gauss.solve(J, F.scaleSelf(-this.stepSolver.getAlpha()));
            xNew.addSelf(dx);
            zNew = system.g(xNew, tNew);
            F = system.f(xNew, zNew, tNew).scaleSelf(-this.step).addSelf(xNew).subSelf(x);
            let fnorm = F.norm2();
            if (i >= this.stepSolver.getMinIterations() && fnorm < this.stepSolver.getAbsTol() + this.stepSolver.getRelTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, zNew, tNew);
            }
        }
        throw new Error("Divergence of newton method");
    }
}
exports.EDAE_IEuler = EDAE_IEuler;


/***/ }),

/***/ "./src/dae/solvers/edae/midpoint.ts":
/*!******************************************!*\
  !*** ./src/dae/solvers/edae/midpoint.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_IMidpoint = exports.EDAE_EMidpoint = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/*
explicit
    x_{n+1} = x_n + h f(x_n+0.5h*f(x_n,t_n),t_n + 0.5*h)
    {
        1.  k_1 = f(x_n,z_n,t_n)
        explicit Nx
        2.  x_{n+1} = x_n + h*f(x_n + 0.5*h * k_1,g(x_n + 0.5 *h* k_1,t_n + 0.5*h),t_n + 0.5*h)
        explicit Nx
        3.  z_{n+1} = g(x_{n+1},t_{n+1})
        explicit Nz
    }
implicit
    x_{n+1}=x_n + h f(0.5*(x_n+x_{n+1}),t_n+0.5*h)
    {
        1.  x_{n+1} - x_n - h*f(0.5*(x_n+x_{n+1}),0.5*(z_n+z_{n+1}),t_n+0.5*h) = 0
            z_{n+1} - g(x_{n+1},t_{n+1}) = 0
        implicit Nx + Nz

        OR

        1. x_{n+1} - x_n - h * f(0.5*(x_n+x_{n+1}),0.5*(z_n + g(x_{n+1],t_{n+1})),t_n + 0.5*j)=0
        implicit Nx
        2. z_{n+1} = g(x_{n+1},t_{n+1})
        explicit Nz
    }
*/
/**
 * explicit midpoint method for explicit dae with index one
 */
class EDAE_EMidpoint extends edaeSolver_1.EDAESolver {
    constructor(step) {
        super(step);
    }
    makeStep(x, z, t, system) {
        let k = system.f(x, z, t).scaleSelf(this.step * 0.5).addSelf(x);
        let kz = system.g(k, t + 0.5 * this.step);
        let xNew = system.f(k, kz, t + 0.5 * this.step).scaleSelf(this.step).addSelf(x);
        let tNew = t + this.step;
        let zNew = system.g(xNew, tNew);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.EDAE_EMidpoint = EDAE_EMidpoint;
/**
 * implicit midpoint method for explicit dae with index one
 */
class EDAE_IMidpoint extends edaeSolver_1.EDAESolver {
    constructor(step, stepSolver) {
        super(step);
        this.stepSolver = stepSolver;
    }
    /*
        x_{n+1} - x_n - h * f(0.5*(x_n+x_{n+1}),0.5*(z_n + g(x_{n+1],t_{n+1})),t_n + 0.5*j)=0
        dF_i/dx_{n+1}_j = \delta_ij - 0.5*h * df/dx - 0.5*h*df/dz * dg/dx(x_{n+1],t_{n+1})
     */
    makeStep(x, z, t, system) {
        let xNew = x.clone().addSelf(vector_1.vector.scale(system.f(x, z, t), this.step)); //better approximation for xNew
        let tNew = t + this.step;
        let xHalf = vector_1.vector.add(x, xNew).scaleSelf(0.5);
        let zHalf = system.g(xNew, tNew).addSelf(z).scaleSelf(0.5);
        let F = system.f(xHalf, zHalf, t + 0.5 * this.step).scale(-this.step).addSelf(xNew).subSelf(x);
        let f0norm = F.norm2();
        for (let i = 0; i < this.stepSolver.getIterations(); i++) {
            let J = matrix_1.matrix.identity(system.length_x());
            J.subSelf(system.dfdx(xHalf, zHalf, t + 0.5 * this.step).addSelf(matrix_1.matrix.mult(system.dfdz(xHalf, zHalf, t + 0.5 * this.step), system.dgdx(xNew, tNew))).scaleSelf(0.5 * this.step));
            let dx = gauss_1.gauss.solve(J, F.scale(-this.stepSolver.getAlpha()));
            xNew.addSelf(dx);
            xHalf = vector_1.vector.add(x, xNew).scaleSelf(0.5);
            zHalf = system.g(xNew, tNew).addSelf(z).scaleSelf(0.5);
            F = system.f(xHalf, zHalf, t + 0.5 * this.step).scale(-this.step).addSelf(xNew).subSelf(x);
            let fnorm = F.norm2();
            if (i >= this.stepSolver.getMinIterations() && fnorm <= this.stepSolver.getAbsTol() + this.stepSolver.getRelTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, system.g(xNew, tNew), tNew);
            }
        }
        throw new Error("Divergence");
    }
}
exports.EDAE_IMidpoint = EDAE_IMidpoint;


/***/ }),

/***/ "./src/dae/solvers/edae/rk.ts":
/*!************************************!*\
  !*** ./src/dae/solvers/edae/rk.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_LOBATTOIIIC4 = exports.EDAE_LOBATTOIIIC2 = exports.EDAE_LOBATTOIIIB4 = exports.EDAE_LOBATTOIIIB2 = exports.EDAE_LOBATTOIIIA4 = exports.EDAE_LOBATTOIIIA2 = exports.EDAE_GAUSSLEGENDRE6 = exports.EDAE_GAUSSLEGENDRE4 = exports.EDAE_RADAUIIA5 = exports.EDAE_RADAUIIA3 = exports.EDAE_RADAUIA5 = exports.EDAE_MidpointEuler = exports.EDAE_HeunEuler = exports.EDAE_BS23 = exports.EDAE_DOPRI5 = exports.EDAE_RK8 = exports.EDAE_RK6_2 = exports.EDAE_RK6 = exports.EDAE_RK4_RALSTON = exports.EDAE_RK4_2 = exports.EDAE_RK4 = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/**
 * explicit rk methods for explicit dae of index 1
 */
class EDAE_ERK extends edaeSolver_1.EDAESolver {
    constructor(step, a, b, c) {
        super(step);
        this.a = a;
        this.b = b;
        this.c = c;
    }
    makeStep(x, z, t, system) {
        let k = [];
        for (let i = 0; i < this.c.length; i++) {
            let _x = x.clone();
            for (let j = 0; j < i; j++) {
                _x.add(vector_1.vector.scale(k[j], this.step * this.a[i - 1][j]));
            }
            let _t = t + this.c[i] * this.step;
            k.push(system.f(_x, system.g(_x, _t), _t));
        }
        let xNew = x.clone();
        for (let i = 0; i < this.b.length; i++) {
            xNew.add(k[i].scaleSelf(this.step * this.b[i]));
        }
        let tNew = t + this.step;
        return new daeVector_1.DAEVector(xNew, system.g(xNew, tNew), tNew);
    }
}
/**
 * explicit rk methods with adaptive step for explicit dae of index 1
 */
class EDAE_ERKA extends EDAE_ERK {
    constructor(step, maxStep, errorOrder, errorTolerance, a, b, c, _b) {
        super(step, a, b, c);
        this._b = _b;
        this.errorOrder = errorOrder;
        this.errorTolerance = errorTolerance;
        this.minStep = step;
        this.maxStep = maxStep;
    }
    makeStep(x, z, t, system) {
        while (true) {
            let k = [];
            for (let i = 0; i < this.c.length; i++) {
                let _x = x.clone();
                for (let j = 0; j < i; j++) {
                    _x.add(vector_1.vector.scale(k[j], this.step * this.a[i - 1][j]));
                }
                let _t = t + this.c[i] * this.step;
                k.push(system.f(_x, system.g(_x, _t), _t));
            }
            let difference = vector_1.vector.empty(x.length());
            for (let i = 0; i < this._b.length; i++) {
                difference.addSelf(vector_1.vector.scale(k[i], this._b[i] - this.b[i]));
            }
            let difNorm = difference.norm2();
            var stepOpt = Math.pow(this.errorTolerance * 0.5 / difNorm, 1 / this.errorOrder) * this.step;
            if (isNaN(stepOpt)) {
                stepOpt = this.minStep;
            }
            stepOpt = Math.min(Math.max(this.minStep, stepOpt), this.maxStep);
            if (stepOpt * 2 < this.step) {
                this.step = stepOpt;
                continue;
            }
            this.step = stepOpt;
            let xNew = x.clone();
            let tNew = t + this.step;
            for (let i = 0; i < this.b.length; i++) {
                xNew.add(vector_1.vector.scale(k[i], this.step * this.b[i]));
            }
            return new daeVector_1.DAEVector(xNew, system.g(xNew, tNew), tNew);
        }
    }
}
/**
 * implicit rk methods for explicit dae of index 1
 */
class EDAE_IRK extends edaeSolver_1.EDAESolver {
    constructor(step, stepSolver, a, b, c, stages) {
        super(step);
        this.a = a;
        this.b = b;
        this.c = c;
        this.stepSolver = stepSolver;
        this.stages = stages;
    }
    /*  USE LATEX, LUKE
        k_i = f(x_n + h * sum_{j=1}^{S} k_j * a_ij, g(x_n + h * sum_{j=1}^{S} k_j * a_ij, t_n + h * c_i), t_n + h * c_i)

        F_i = k_i - f(x_n + h * sum k_j * aij, g(x_n + h * sum_{j=1}^{S} k_j * a_ij, t_n + h * c_i), t_n + h * c_i) = 0

        dF_il/dk_jm = \delta_il_jm - df_l/dx_m * h * a_ij - df_l/dz dg_l/dx_m * h * a_ij

        memory layout:
                  j->
        |-------------------|
        | dF0/dk0 | dF0/dk1 |
    i   |---------|---------|
    |   | dF1/dk0 | dF1/dk1 |
    v   |-------------------|
     */
    function(k, x, z, t, system) {
        let F = vector_1.vector.empty(system.length_x() * this.stages);
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(k[j], this.a[i][j] * this.step));
            let _z = system.g(_x, _t);
            F.addSubVector(k[i], i * system.length_x());
            F.subSubVector(system.f(_x, _z, _t), i * system.length_x());
        }
        return F;
    }
    jacobiMatrix(k, x, z, t, system) {
        let J = matrix_1.matrix.identity(this.stages * system.length_x());
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(k[j], this.a[i][j] * this.step));
            let _z = system.g(_x, _t);
            let dfdx = system.dfdx(_x, _z, _t);
            let dfdz = system.dfdz(_x, _z, _t);
            let dgdx = system.dgdx(_x, _t);
            let value = matrix_1.matrix.mult(dfdz, dgdx).addSelf(dfdx);
            for (let j = 0; j < this.stages; j++) {
                J.subSubMatrix(value.scaleSelf(this.step * this.a[i][j]), i * system.length_x(), j * system.length_x());
            }
        }
        return J;
    }
    makeStep(x, z, t, system) {
        let k = [];
        for (let i = 0; i < this.stages; i++) {
            k.push(vector_1.vector.empty(system.length_x()));
        }
        let F = this.function(k, x, z, t, system);
        let f0norm = F.norm2();
        for (let it = 0; it < this.stepSolver.getIterations(); it++) {
            let J = this.jacobiMatrix(k, x, z, t, system);
            let dk = gauss_1.gauss.solve(J, F.scaleSelf(-this.stepSolver.getAlpha()));
            for (let i = 0; i < this.stages; i++) {
                k[i].addSelf(dk.getSubVector(i * system.length_x(), system.length_x()));
            }
            F = this.function(k, x, z, t, system);
            let fnorm = F.norm2();
            if (it >= this.stepSolver.getMinIterations() && fnorm < this.stepSolver.getAbsTol() + this.stepSolver.getRelTol() * f0norm) {
                let xNew = x.clone();
                for (let j = 0; j < this.stages; j++) {
                    xNew.addSelf(k[j].scaleSelf(this.step * this.b[j]));
                }
                let tNew = t + this.step;
                return new daeVector_1.DAEVector(xNew, system.g(xNew, tNew), tNew);
            }
        }
        throw new Error("Divergence");
    }
}
/**
 * implicit rk methods with adaptive step for explicit dae of index 1
 */
class EDAE_IRKA extends EDAE_IRK {
    constructor(step, maxStep, errorOrder, errorTolerance, stepSolver, a, b, c, _b, stages) {
        super(step, stepSolver, a, b, c, stages);
        this._b = _b;
        this.errorOrder = errorOrder;
        this.errorTolerance = errorTolerance;
        this.minStep = step;
        this.maxStep = maxStep;
    }
    function(k, x, z, t, system) {
        let F = vector_1.vector.empty(system.length_x() * this.stages);
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(k[j], this.a[i][j] * this.step));
            let _z = system.g(_x, _t);
            F.addSubVector(k[i], i * system.length_x());
            F.subSubVector(system.f(_x, _z, _t), i * system.length_x());
        }
        return F;
    }
    jacobiMatrix(k, x, z, t, system) {
        let J = matrix_1.matrix.identity(this.stages * system.length_x());
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(k[j], this.a[i][j] * this.step));
            let _z = system.g(_x, _t);
            let dfdx = system.dfdx(_x, _z, _t);
            let dfdz = system.dfdz(_x, _z, _t);
            let dgdx = system.dgdx(_x, _t);
            let value = matrix_1.matrix.mult(dfdz, dgdx).addSelf(dfdx);
            for (let j = 0; j < this.stages; j++) {
                J.subSubMatrix(value.scaleSelf(this.step * this.a[i][j]), i * system.length_x(), j * system.length_x());
            }
        }
        return J;
    }
    makeStep(x, z, t, system) {
        while (true) {
            let shouldThrow = true;
            let k = [];
            for (let i = 0; i < this.stages; i++) {
                k.push(vector_1.vector.empty(system.length_x()));
            }
            let F = this.function(k, x, z, t, system);
            let f0norm = F.norm2();
            for (let it = 0; it < this.stepSolver.getIterations(); it++) {
                let J = this.jacobiMatrix(k, x, z, t, system);
                let dk = gauss_1.gauss.solve(J, F.scaleSelf(-this.stepSolver.getAlpha()));
                for (let i = 0; i < this.stages; i++) {
                    k[i].addSelf(dk.getSubVector(i * system.length_x(), system.length_x()));
                }
                F = this.function(k, x, z, t, system);
                let fnorm = F.norm2();
                if (it >= this.stepSolver.getMinIterations() && fnorm < this.stepSolver.getAbsTol() + this.stepSolver.getRelTol() * f0norm) {
                    let difference = vector_1.vector.empty(x.length());
                    for (let i = 0; i < this._b.length; i++) {
                        difference.addSelf(vector_1.vector.scale(k[i], this._b[i] - this.b[i]));
                    }
                    let difNorm = difference.norm2();
                    var stepOpt = Math.pow(this.errorTolerance * 0.5 / difNorm, 1 / this.errorOrder) * this.step;
                    if (isNaN(stepOpt)) {
                        stepOpt = this.minStep;
                    }
                    stepOpt = Math.min(Math.max(this.minStep, stepOpt), this.maxStep);
                    if (stepOpt * 2 < this.step) {
                        this.step = stepOpt;
                        shouldThrow = false;
                        break;
                    }
                    this.step = stepOpt;
                    let xNew = x.clone();
                    let tNew = t + this.step;
                    for (let j = 0; j < this.stages; j++) {
                        xNew.addSelf(k[j].scaleSelf(this.step * this.b[j]));
                    }
                    return new daeVector_1.DAEVector(xNew, system.g(xNew, tNew), tNew);
                }
            }
            if (shouldThrow)
                throw new Error("Divergence");
        }
    }
}
/**
 * classic RK4
 */
class EDAE_RK4 extends EDAE_ERK {
    constructor(step) {
        super(step, [
            [0.5],
            [0, 0.5],
            [0, 0, 1]
        ], [1 / 6, 1 / 3, 1 / 3, 1 / 6], [0, 0.5, 0.5, 1]);
    }
}
exports.EDAE_RK4 = EDAE_RK4;
class EDAE_RK4_2 extends EDAE_ERK {
    constructor(step) {
        super(step, [
            [1 / 3],
            [-1 / 3, 1],
            [1, -1, 1]
        ], [1 / 8, 3 / 8, 3 / 8, 1 / 8], [0, 1 / 3, 2 / 3, 1]);
    }
}
exports.EDAE_RK4_2 = EDAE_RK4_2;
class EDAE_RK4_RALSTON extends EDAE_ERK {
    constructor(step) {
        super(step, [
            [0.4],
            [0.29697761, 0.15875964],
            [0.2181004, -3.05096516, 3.83286476]
        ], [0.17476028, -0.55148066, 1.20553560, 0.17118478], [0, 0.4, 0.45573725, 1]);
    }
}
exports.EDAE_RK4_RALSTON = EDAE_RK4_RALSTON;
class EDAE_RK6 extends EDAE_ERK {
    constructor(step) {
        super(step, [
            [2 / 5],
            [0, 4 / 5],
            [169 / 1458, 110 / 729, -65 / 1458],
            [-44 / 675, -88 / 135, 76 / 351, 336 / 325],
            [21 / 106, 0, -105 / 689, -324 / 689, 45 / 106],
            [-2517 / 4864, -55 / 38, 10615 / 31616, 567 / 7904, 7245 / 4864, 2597 / 2432]
        ], [0, 0, 1375 / 4992, 6561 / 20384, 3375 / 12544, 53 / 768, 19 / 294], [0, 2 / 5, 4 / 5, 2 / 9, 8 / 15, 0, 1]);
    }
}
exports.EDAE_RK6 = EDAE_RK6;
class EDAE_RK6_2 extends EDAE_ERK {
    constructor(step) {
        super(step, [
            [1 / 3],
            [0, 2 / 3],
            [1 / 12, 1 / 3, -1 / 12],
            [25 / 48, -55 / 24, 35 / 48, 15 / 8],
            [3 / 20, -11 / 24, -1 / 8, 1 / 2, 1 / 10],
            [-261 / 260, 33 / 13, 43 / 156, -118 / 39, 32 / 195, 80 / 39]
        ], [13 / 200, 0, 11 / 40, 11 / 40, 4 / 25, 4 / 25, 13 / 200], [0, 1 / 3, 2 / 3, 1 / 3, 5 / 6, 1 / 6, 1]);
    }
}
exports.EDAE_RK6_2 = EDAE_RK6_2;
class EDAE_RK8 extends EDAE_ERK {
    constructor(step) {
        var root21 = Math.sqrt(21);
        super(step, [
            [1 / 2],
            [1 / 4, 1 / 4],
            [1 / 7, (-7 - 3 * root21) / 98, 0, (21 + 5 * root21) / 49],
            [(11 + root21) / 84, 0, (18 + 4 * root21) / 63, (21 - root21) / 252],
            [(5 + root21) / 48, 0, (9 + root21) / 36, (-231 + 14 * root21) / 360, (63 - 7 * root21) / 80],
            [(10 - root21) / 42, 0, (-432 + 92 * root21) / 315, (633 - 145 * root21) / 90, (-503 + 115 * root21) / 70, (63 - 13 * root21) / 35],
            [1 / 14, 0, 0, 0, (14 - 3 * root21) / 126, (13 - 3 * root21) / 63, 1 / 9],
            [1 / 32, 0, 0, 0, (91 - 21 * root21) / 576, 11 / 72, (-385 - 75 * root21) / 1152, (63 + 13 * root21) / 128],
            [1 / 14, 0, 0, 0, 1 / 9, (-733 - 147 * root21) / 2205, (515 + 111 * root21) / 504, (-51 - 11 * root21) / 56, (132 + 28 * root21) / 245],
            [0, 0, 0, 0, (-42 + 7 * root21) / 18, (-18 + 28 * root21) / 45, (-273 - 53 * root21) / 72, (301 + 53 * root21) / 72, (28 - 28 * root21) / 45, (49 - 7 * root21) / 18]
        ], [1 / 20, 0, 0, 0, 0, 0, 0, 49 / 180, 16 / 45, 49 / 180, 1 / 20], [0, 1 / 2, 1 / 2, (7 + root21) / 14, (7 + root21) / 14, 1 / 2, (7 - root21) / 14,
            (7 - root21) / 14, 1 / 2, (7 + root21) / 14, 1]);
    }
}
exports.EDAE_RK8 = EDAE_RK8;
class EDAE_DOPRI5 extends EDAE_ERKA {
    constructor(step, maxStep, errorTolerance) {
        super(step, maxStep, 5, errorTolerance, [
            [1 / 5],
            [3 / 40, 9 / 40],
            [44 / 45, -56 / 15, 32 / 9],
            [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],
            [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],
            [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]
        ], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0], [0, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1], [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40]);
    }
}
exports.EDAE_DOPRI5 = EDAE_DOPRI5;
/**
 * BogackiShampine23
 */
class EDAE_BS23 extends EDAE_ERKA {
    constructor(step, maxStep, errorTolerance) {
        super(step, maxStep, 3, errorTolerance, [
            [1 / 2],
            [0, 3 / 4],
            [2 / 9, 1 / 3, 4 / 9]
        ], [2 / 9, 1 / 3, 4 / 9, 0], [0, 0.5, 0.75, 1], [7 / 24, 1 / 4, 1 / 3, 1 / 8]);
    }
}
exports.EDAE_BS23 = EDAE_BS23;
/**
 *
 */
class EDAE_HeunEuler extends EDAE_ERKA {
    constructor(step, maxStep, errorTolerance) {
        super(step, maxStep, 2, errorTolerance, [
            [1]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0]);
    }
}
exports.EDAE_HeunEuler = EDAE_HeunEuler;
class EDAE_MidpointEuler extends EDAE_ERKA {
    constructor(step, maxStep, errorTolerance) {
        super(step, maxStep, 2, errorTolerance, [
            [1 / 2]
        ], [0, 1], [0, 0.5], [1, 0]);
    }
}
exports.EDAE_MidpointEuler = EDAE_MidpointEuler;
class EDAE_RADAUIA5 extends EDAE_IRK {
    constructor(step, stepSolver) {
        let root6 = Math.sqrt(6);
        super(step, stepSolver, [
            [1 / 9, (-1 - root6) / 18, (-1 + root6) / 18],
            [1 / 9, (88 + 7 * root6) / 360, (88 - 43 * root6) / 360],
            [1 / 9, (88 + 43 * root6) / 360, (80 - 7 * root6) / 360]
        ], [1 / 9, (16 + root6) / 36, (16 - root6) / 36], [0, (6 - root6) / 10, (6 + root6) / 10], 3);
    }
}
exports.EDAE_RADAUIA5 = EDAE_RADAUIA5;
class EDAE_RADAUIIA3 extends EDAE_IRK {
    constructor(step, stepSolver) {
        let root6 = Math.sqrt(6);
        super(step, stepSolver, [
            [5 / 12, -1 / 12],
            [3 / 4, 1 / 4]
        ], [3 / 4, 1 / 4], [1 / 3, 1], 2);
    }
}
exports.EDAE_RADAUIIA3 = EDAE_RADAUIIA3;
class EDAE_RADAUIIA5 extends EDAE_IRK {
    constructor(step, stepSolver) {
        let root6 = Math.sqrt(6);
        super(step, stepSolver, [
            [11 / 45 - 7 * root6 / 360, 37 / 225 - 169 * root6 / 1800, -2 / 225 + root6 / 75],
            [37 / 225 + 169 * root6 / 1800, 11 / 45 + 7 * root6 / 360, -2 / 225 - root6 / 75],
            [4 / 9 - root6 / 36, 4 / 9 + root6 / 36, 1 / 9]
        ], [4 / 9 - root6 / 36, 4 / 9 + root6 / 36, 1 / 9], [2 / 5 - root6 / 10, 2 / 5 + root6 / 10, 1], 3);
    }
}
exports.EDAE_RADAUIIA5 = EDAE_RADAUIIA5;
/**
 * Embedded gauss-legendre 4th order
 */
class EDAE_GAUSSLEGENDRE4 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        let sqrt3 = Math.sqrt(3);
        super(step, maxStep, 4, errorTolerance, stepSolver, [
            [1 / 4, 1 / 4 - sqrt3 / 6],
            [1 / 4 + sqrt3 / 6, 1 / 4]
        ], [0.5, 0.5], [(3 - sqrt3) / 6, (3 + sqrt3) / 6], [(1 + sqrt3) / 2, (1 - sqrt3) / 2], 2);
    }
}
exports.EDAE_GAUSSLEGENDRE4 = EDAE_GAUSSLEGENDRE4;
/**
 * Embedded gauss-legendre 6th order
 */
class EDAE_GAUSSLEGENDRE6 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        let sqrt15 = Math.sqrt(15);
        super(step, maxStep, 6, errorTolerance, stepSolver, [
            [5 / 36, 2 / 9 - sqrt15 / 15, 5 / 36 - sqrt15 / 30],
            [5 / 36 + sqrt15 / 24, 2 / 9, 5 / 36, -sqrt15 / 24],
            [5 / 36 + sqrt15 / 30, 2 / 9 + sqrt15 / 15, 5 / 36]
        ], [5 / 18, 4 / 9, 5 / 18], [0.5 - sqrt15 / 10, 0.5, 0.5 + sqrt15 / 10], [-5 / 6, 8 / 3, -5 / 6], 3);
    }
}
exports.EDAE_GAUSSLEGENDRE6 = EDAE_GAUSSLEGENDRE6;
class EDAE_LOBATTOIIIA2 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 2, errorTolerance, stepSolver, [
            [0, 0],
            [1 / 2, 1 / 2]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0], 2);
    }
}
exports.EDAE_LOBATTOIIIA2 = EDAE_LOBATTOIIIA2;
class EDAE_LOBATTOIIIA4 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 4, errorTolerance, stepSolver, [
            [0, 0, 0],
            [5 / 24, 1 / 3, -1 / 24],
            [1 / 6, 2 / 3, 1 / 36]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.EDAE_LOBATTOIIIA4 = EDAE_LOBATTOIIIA4;
class EDAE_LOBATTOIIIB2 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 2, errorTolerance, stepSolver, [
            [1 / 2, 0],
            [1 / 2, 0]
        ], [1 / 2, 1 / 2], [1 / 2, 1 / 2], [1, 0], 2);
    }
}
exports.EDAE_LOBATTOIIIB2 = EDAE_LOBATTOIIIB2;
class EDAE_LOBATTOIIIB4 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 4, errorTolerance, stepSolver, [
            [1 / 6, -1 / 6, 0],
            [1 / 6, 1 / 3, 0],
            [1 / 6, 5 / 6, 0]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.EDAE_LOBATTOIIIB4 = EDAE_LOBATTOIIIB4;
class EDAE_LOBATTOIIIC2 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 2, errorTolerance, stepSolver, [
            [1 / 2, -1 / 2],
            [1 / 2, 1 / 2]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0], 2);
    }
}
exports.EDAE_LOBATTOIIIC2 = EDAE_LOBATTOIIIC2;
class EDAE_LOBATTOIIIC4 extends EDAE_IRKA {
    constructor(step, maxStep, errorTolerance, stepSolver) {
        super(step, maxStep, 4, errorTolerance, stepSolver, [
            [1 / 6, -1 / 3, 1 / 6],
            [1 / 6, 5 / 12, -1 / 12],
            [1 / 6, 2 / 3, 1 / 6]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.EDAE_LOBATTOIIIC4 = EDAE_LOBATTOIIIC4;


/***/ }),

/***/ "./src/dae/solvers/edae/trapezoidal.ts":
/*!*********************************************!*\
  !*** ./src/dae/solvers/edae/trapezoidal.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EDAE_ITrapezoidal = exports.EDAE_ETrapezoidal = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const edaeSolver_1 = __webpack_require__(/*! ../../edaeSolver */ "./src/dae/edaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/*
explicit
    x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_n+hf(x_n,t_n),t_{n+1}))
    {
        1.  k_1 = f(x_n,z_n,t_n)
        explicit Nx
        2.  k_2 = f(x_n + h*k_1,g(x_n + h*k_1,t_{n+1}),t_{n+1})
        explicit Nx
        3.  x_{n+1} = x_n + 0.5*h(k_1 + k_2)
        explicit Nx
        4.  z_{n+1} = g(x_{n+1},t_{n+1})
        explicit Nz
    }
implicit
    x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_{n+1},t_{n+1}))
    {
        1.  k_1 = f(x_n,z_n,t_n)
        explicit Nx
        2.  x_{n+1} - x_n - 0.5*h(k_1+f(x_{n+1},g(x_{n+1},t_{n+1}),t_{n+1})) = 0
        implicit Nx
        3.  z_{n+1} = g(x_{n+1},t_{n+1})
        explicit Nz
    }
*/
/**
 * explicit trapezoidal method for explicit dae with index one
 */
class EDAE_ETrapezoidal extends edaeSolver_1.EDAESolver {
    constructor(step) {
        super(step);
    }
    makeStep(x, z, t, system) {
        let tNew = t + this.step;
        let k_1 = system.f(x, z, t).scaleSelf(this.step);
        let _x = vector_1.vector.add(x, k_1);
        let k_2 = system.f(_x, system.g(_x, tNew), tNew).scaleSelf(this.step);
        let xNew = k_1.addSelf(k_2).scaleSelf(0.5).addSelf(x);
        let zNew = system.g(xNew, tNew);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.EDAE_ETrapezoidal = EDAE_ETrapezoidal;
/**
 * implicit trapezoidal method for explicit dae with index one
 */
class EDAE_ITrapezoidal extends edaeSolver_1.EDAESolver {
    constructor(step, stepSolver) {
        super(step);
        this.stepSolver = stepSolver;
    }
    /*
        x_{n+1} - x_n - 0.5* h * (k_1+f(x_{n+1},g(x_{n+1},t_{n+1}),t_{n+1})) = 0
        dF_i/dx_{n+1}_j = \delta_ij - 0.5*h * df/dx - 0.5*h*df/dz * dg/dx(x_{n+1],t_{n+1})
     */
    makeStep(x, z, t, system) {
        let k_1 = system.f(x, z, t);
        let xNew = x.clone().addSelf(vector_1.vector.scale(k_1, this.step)); //better approximation for xNew
        let tNew = t + this.step;
        let zNew = system.g(xNew, tNew);
        let F = system.f(xNew, zNew, tNew).addSelf(k_1).scaleSelf(-0.5 * this.step).addSelf(xNew).subSelf(x);
        let f0norm = F.norm2();
        for (let i = 0; i < this.stepSolver.getIterations(); i++) {
            let J = matrix_1.matrix.identity(system.length_x());
            J.subSelf(system.dfdx(xNew, zNew, tNew).addSelf(matrix_1.matrix.mult(system.dfdz(xNew, zNew, tNew), system.dgdx(xNew, tNew))).scaleSelf(0.5 * this.step));
            let dx = gauss_1.gauss.solve(J, F.scaleSelf(-this.stepSolver.getAlpha()));
            xNew.addSelf(dx);
            zNew = system.g(xNew, tNew);
            F = system.f(xNew, zNew, tNew).addSelf(k_1).scaleSelf(-0.5 * this.step).addSelf(xNew).subSelf(x);
            let fnorm = F.norm2();
            if (i >= this.stepSolver.getMinIterations() && fnorm < this.stepSolver.getAbsTol() + this.stepSolver.getRelTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, zNew, tNew);
            }
        }
        throw new Error("Divergence");
    }
}
exports.EDAE_ITrapezoidal = EDAE_ITrapezoidal;


/***/ }),

/***/ "./src/dae/solvers/idae/adams-bashforth.ts":
/*!*************************************************!*\
  !*** ./src/dae/solvers/idae/adams-bashforth.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_AB6 = exports.IDAE_AB5 = exports.IDAE_AB4 = exports.IDAE_AB3 = exports.IDAE_AB2 = void 0;
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const rk_1 = __webpack_require__(/*! ../idae/rk */ "./src/dae/solvers/idae/rk.ts");
class IDAE_ADAMS_BASHFORTH extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver, b, solver, stages) {
        super(step, systemSolver);
        this.b = b;
        this.solver = solver;
        this.stages = stages;
        this.prevValues = [];
    }
    setStep(value) {
        super.setStep(value);
        this.prevValues = [];
    }
    makeStep(x, z, t, system) {
        this.prevValues.splice(0, 0, this.solve_dx(x, z, t, system));
        if (this.prevValues.length != this.stages) {
            let result = this.solver.makeStep(x, z, t, system);
            return result;
        }
        let tNew = t + this.step;
        let xNew = x.clone();
        for (let i = 0; i < this.stages; i++) {
            xNew.addSelf(vector_1.vector.scale(this.prevValues[i], this.step * this.b[i]));
        }
        let zNew = this.solve_z(xNew, z, tNew, system);
        this.prevValues.splice(this.prevValues.length - 1, 1);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
class IDAE_AB2 extends IDAE_ADAMS_BASHFORTH {
    constructor(step, systemSolver) {
        super(step, systemSolver, [3 / 2, -1 / 2], new rk_1.IDAE_RK4(step, systemSolver), 2);
    }
}
exports.IDAE_AB2 = IDAE_AB2;
class IDAE_AB3 extends IDAE_ADAMS_BASHFORTH {
    constructor(step, systemSolver) {
        super(step, systemSolver, [23 / 12, -4 / 3, 5 / 12], new rk_1.IDAE_RK4(step, systemSolver), 3);
    }
}
exports.IDAE_AB3 = IDAE_AB3;
class IDAE_AB4 extends IDAE_ADAMS_BASHFORTH {
    constructor(step, systemSolver) {
        super(step, systemSolver, [55 / 24, -59 / 24, 37 / 24, -3 / 8], new rk_1.IDAE_RK4(step, systemSolver), 4);
    }
}
exports.IDAE_AB4 = IDAE_AB4;
class IDAE_AB5 extends IDAE_ADAMS_BASHFORTH {
    constructor(step, systemSolver) {
        super(step, systemSolver, [1901 / 720, -1387 / 360, 109 / 30, -637 / 360, 251 / 720], new rk_1.IDAE_RK6(step, systemSolver), 5);
    }
}
exports.IDAE_AB5 = IDAE_AB5;
class IDAE_AB6 extends IDAE_ADAMS_BASHFORTH {
    constructor(step, systemSolver) {
        super(step, systemSolver, [4277 / 1440, -2641 / 480, 4991 / 720, -3649 / 720, 959 / 480, -95 / 288], new rk_1.IDAE_RK6(step, systemSolver), 6);
    }
}
exports.IDAE_AB6 = IDAE_AB6;


/***/ }),

/***/ "./src/dae/solvers/idae/algebraicSolver.ts":
/*!*************************************************!*\
  !*** ./src/dae/solvers/idae/algebraicSolver.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_AlgebraicSolver = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
/**
 * solver for purely algebraic system g(z,t) = 0
 */
class IDAE_AlgebraicSolver extends idaeSolver_1.IDAESolver {
    makeStep(x, z, t, system) {
        let xNew = x;
        let tNew = t + this.step;
        let zNew = this.solve_z(x, z, tNew, system);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.IDAE_AlgebraicSolver = IDAE_AlgebraicSolver;


/***/ }),

/***/ "./src/dae/solvers/idae/euler.ts":
/*!***************************************!*\
  !*** ./src/dae/solvers/idae/euler.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_IEuler = exports.IDAE_EEuler = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
class IDAE_EEuler extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver) {
        super(step, systemSolver);
    }
    solve_x(x, z, t, system) {
        return this.systemSolver.solve((xNew) => {
            let derx = vector_1.vector.sub(xNew, x).scale(1 / this.step);
            return system.f(x, derx, z, t).scaleSelf(this.step);
        }, (xNew) => {
            let derx = vector_1.vector.sub(xNew, x).scale(1 / this.step);
            return system.dfddx(x, derx, z, t);
        }, x.length(), x);
        /*//solve for x_{n+1}
        let xNew = x.clone();
        let F:vector;
        let derx = vector.empty(x.length());
        F = system.f(x,derx,z,t).scaleSelf(-this.step * this.alpha);
        let f0norm = F.norm2();
        for(let i=0;i<this.newtonIterations;i++){
            let J:matrix;
            J = system.dfddx(x,derx,z,t);
            let dx = gauss.solve(J,F);
            xNew.addSelf(dx);

            derx = vector.sub(xNew,x).scale(1/this.step);
            F = system.f(x,derx,z,t).scaleSelf(-this.step * this.alpha);
            let fnorm = F.norm2()/this.step;
            if(fnorm<this.fAbsTol+this.fRelTol*f0norm){
                return xNew;
            }
        }
        throw new Error("divergence at solve_x");*/
    }
    /*private solve_z(x:vector,z:vector,t:number,system:IDAESystem){
        //solve g(x_{n+1}, z_{n+1}, t_{n+1}) = 0 for z_{n+1}
        let zNew = z.clone();
        for(let i=0;i<this.newtonIterations;i++){
            let J:matrix;
            J = system.dgdz(x, zNew, t);
            let F:vector;
            F = system.g(x,zNew,t).scaleSelf(this.alpha);
            let dz = gauss.solve(J, F);
            zNew.addSelf(dz);
            if(F.norm2()<this.fAbsTol){
                return zNew;
            }
        }
        throw "divergence at solve_z";
    }*/
    makeStep(x, z, t, system) {
        let xNew = this.solve_x(x, z, t, system);
        let tNew = t + this.step;
        let zNew = this.solve_z(xNew, z, tNew, system);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.IDAE_EEuler = IDAE_EEuler;
/*
df/dx_{n+1} = df/dx + df/ddx * 1/h
df/dz_{n+1} = df/dz
dg/dx_{n+1} = dg/dx
dg/dz_{n+1} = dg/dz
F = {
    f(x_{n+1},(x_{n+1}-x_{n})/h, z_{n+1},t_{n+1}) = 0
    g(x_{n+1}, z_{n+1}, t_{n+1}) = 0
}
OR
df/dx_{n+1} = df/dx * h + df/ddx
df/dz_{n+1} = df/dz * h
dg/dx_{n+1} = dg/dx * h
dg/dz_{n+1} = dg/dz * h
F = {
    f(x_{n+1},(x_{n+1}-x_{n})/h, z_{n+1}, t_{n+1}) * h = 0
    g(x_{n+1},z_{n+1}, t_{n+1}) * h = 0
}
*/
class IDAE_IEuler extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver) {
        super(step, systemSolver);
    }
    makeStep(x, z, t, system) {
        /*let xz0 = vector.concat([x,z]);
        let tNew = t + this.step;
        let xzNew = this.stepSolver.solve((xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let derx = vector.sub(xNew,x).scale(1/this.step);
            let F:vector = vector.empty(system.length_x()+system.length_z());
            F.addSubVector(system.f(xNew,derx,zNew,tNew),0);
            F.addSubVector(system.g(xNew,zNew,tNew),system.length_x());
            return F;
        }, (xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let J:matrix;
            J = matrix.emptySquare(x.length()+z.length());
            //scale both part of (J dx = -F) by step
            J.addSubMatrix(system.dfdx(xNew,derx,zNew,tNew).addSelf(system.dfddx(xNew,derx,zNew,tNew).scaleSelf(1/this.step)),0,0);
            J.addSubMatrix(system.dfdz(xNew,derx,zNew,tNew),0,x.length());
            J.addSubMatrix(system.dgdx(xNew,zNew,tNew),x.length(),0);
            J.addSubMatrix(system.dgdz(xNew,zNew,tNew),x.length(),x.length());
            return J;
        }, system.length_x()+system.length_z(), xz0);
        return new DAEVector(xzNew.getSubVector(0,system.length_x()),xzNew.getSubVector(system.length_x(),system.length_z()),tNew);*/
        let xNew = x.clone();
        let zNew = z.clone();
        let tNew = t + this.step;
        let derx = vector_1.vector.empty(x.length());
        let F;
        F = vector_1.vector.empty(x.length() + z.length());
        F.addSubVector(system.f(xNew, derx, zNew, tNew), 0);
        F.addSubVector(system.g(xNew, zNew, tNew), x.length());
        let f0norm = F.norm2();
        ;
        for (let i = 0; i < this.systemSolver.getIterations(); i++) {
            let J;
            J = matrix_1.matrix.emptySquare(x.length() + z.length());
            //scale both part of (J dx = -F) by step
            J.addSubMatrix(system.dfdx(xNew, derx, zNew, tNew).addSelf(system.dfddx(xNew, derx, zNew, tNew).scaleSelf(1 / this.step)), 0, 0);
            J.addSubMatrix(system.dfdz(xNew, derx, zNew, tNew), 0, x.length());
            J.addSubMatrix(system.dgdx(xNew, zNew, tNew), x.length(), 0);
            J.addSubMatrix(system.dgdz(xNew, zNew, tNew), x.length(), x.length());
            let dxz = gauss_1.gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
            xNew.addSelf(dxz.getSubVector(0, x.length()));
            zNew.addSelf(dxz.getSubVector(x.length(), z.length()));
            derx = vector_1.vector.sub(xNew, x).scale(1 / this.step);
            F = vector_1.vector.empty(x.length() + z.length());
            F.addSubVector(system.f(xNew, derx, zNew, tNew), 0);
            F.addSubVector(system.g(xNew, zNew, tNew), x.length());
            let fnorm = F.norm2();
            if (i >= this.systemSolver.getMinIterations() && fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, zNew, tNew);
            }
        }
        throw new Error("Divergence");
    }
}
exports.IDAE_IEuler = IDAE_IEuler;


/***/ }),

/***/ "./src/dae/solvers/idae/midpoint.ts":
/*!******************************************!*\
  !*** ./src/dae/solvers/idae/midpoint.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_IMidpoint = exports.IDAE_EMidpoint = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/*
explicit
    x_{n+1} = x_n + h f(x_n+0.5h*f(x_n, t_n), t_n + 0.5*h)
    {
        1.  f(x_n, k_1, z_n, t_n) = 0
        implicit Nx
        2.  g(x_n + 0.5 * h * k_1, z^1_n, t_n+0.5*h) = 0
        implicit Nz
        3.  f(x_n + 0.5 * h * k_1, k_2, z^1_n, t_n+0.5*h) = 0
        implicit Nx
        4.  x_{n+1} = x_n + h*k_2
        explicit Nx
        5.  g(x_{n+1}, z_{n+1}, t_{n+1}) = 0
        implicit Nz
    }
implicit
    x_{n+1}=x_n + h f(0.5*(x_n+x_{n+1}),t_n+0.5*h)
    {
        1.  f(0.5*(x_{n}+x_{n+1}), (x_{n+1} - x_n)/h, 0.5*(z_{n}+z_{n+1}), t_n + 0.5*h) = 0
            g(x_{n+1}, z_{n+1}, t_{n+1}) = 0
        implicit Nx + Nz
    }
*/
/**
 * explicit midpoint method for implicit dae with index one
 */
class IDAE_EMidpoint extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver) {
        super(step, systemSolver);
    }
    makeStep(x, z, t, system) {
        let x1 = this.solve_dx(x, z, t, system).scaleSelf(0.5 * this.step).addSelf(x);
        let z1 = this.solve_z(x1, z, t + 0.5 * this.step, system);
        let tNew = t + this.step;
        let xNew = this.solve_dx(x1, z1, t + 0.5 * this.step, system).scaleSelf(this.step).addSelf(x);
        let zNew = this.solve_z(xNew, z1, tNew, system);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
        /*x_{n+1} = x_n + h f(x_n+0.5h*f(x_n, t_n), t_n + 0.5*h)
        {
            1.  f(x_n, k_1, z_n, t_n) = 0
            implicit Nx
            2.  g(x_n + 0.5 * h * k_1, z^1_n, t_n+0.5*h) = 0
            implicit Nz
            3.  f(x_n + 0.5 * h * k_1, k_2, z^1_n, t_n+0.5*h) = 0
            implicit Nx
            4.  x_{n+1} = x_n + h*k_2
            explicit Nx
            5.  g(x_{n+1}, z_{n+1}, t_{n+1}) = 0
            implicit Nz
        }*/
    }
}
exports.IDAE_EMidpoint = IDAE_EMidpoint;
/**
 * implicit midpoint method for implicit dae with index one
 */
/*
Fx = f(0.5*(x_{n}+x_{n+1}), (x_{n+1} - x_n)/h, 0.5*(z_{n}+z_{n+1}), t_n + 0.5*h) = 0
Fz = g(x_{n+1}, z_{n+1}, t_{n+1}) = 0
dFx/dx_{n+1} = 0.5*df/dx + df/ddx *1/h
dFx/dz_{n+1} = 0.5*df/dz
dFz/dx_{n+1} = dg/dx
dFz/dz_{n+1} = dg/dz
*/
class IDAE_IMidpoint extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver) {
        super(step, systemSolver);
    }
    makeStep(x, z, t, system) {
        /*let xz0 = vector.concat([x,z]);
        let tHalf = t + this.step*0.5;
        let tNew = t + this.step;
        let xzNew = this.stepSolver.solve((xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let dx = vector.sub(xNew,x).scale(1/this.step);
            let xHalf = vector.add(x,xNew).scaleSelf(0.5);
            let zHalf = vector.add(z,zNew).scaleSelf(0.5);

            let F = vector.empty(x.length()+z.length());
            F.addSubVector(system.f(xHalf,dx,zHalf,tHalf),0);
            F.addSubVector(system.g(xNew,zNew,tNew),x.length());
            return F;
        },(xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let dx = vector.sub(xNew,x).scale(1/this.step);
            let xHalf = vector.add(x,xNew).scaleSelf(0.5);
            let zHalf = vector.add(z,zNew).scaleSelf(0.5);

            let J:matrix = matrix.emptySquare(x.length()+z.length());
            J.addSubMatrix(system.dfdx(xHalf,dx,zHalf,tHalf).scaleSelf(0.5).addSelf(system.dfddx(xHalf,dx,zHalf,tHalf).scaleSelf(1/this.step)),0,0);
            J.addSubMatrix(system.dfdz(xHalf,dx,zHalf,tHalf).scaleSelf(0.5),0,x.length());
            J.addSubMatrix(system.dgdx(xNew,zNew,tNew),x.length(),0);
            J.addSubMatrix(system.dgdz(xNew,zNew,tNew),x.length(),x.length());
            return J;
        },system.length_x()+system.length_z(),xz0);

        return new DAEVector(xzNew.getSubVector(0,system.length_x()),xzNew.getSubVector(system.length_x(),system.length_z()),tNew);*/
        let tNew = t + this.step;
        let xNew = x.clone();
        let zNew = z.clone();
        let tHalf = t + 0.5 * this.step;
        let F = vector_1.vector.empty(x.length() + z.length());
        let dx = vector_1.vector.empty(x.length());
        let xHalf = vector_1.vector.add(x, xNew).scaleSelf(0.5);
        let zHalf = vector_1.vector.add(z, zNew).scaleSelf(0.5);
        F.addSubVector(system.f(xHalf, dx, zHalf, tHalf), 0);
        F.addSubVector(system.g(xNew, zNew, tNew), x.length());
        let f0norm = F.norm2();
        for (let i = 0; i < this.systemSolver.getIterations(); i++) {
            let J = matrix_1.matrix.emptySquare(x.length() + z.length());
            J.addSubMatrix(system.dfdx(xHalf, dx, zHalf, tHalf).scaleSelf(0.5).addSelf(system.dfddx(xHalf, dx, zHalf, tHalf).scaleSelf(1 / this.step)), 0, 0);
            J.addSubMatrix(system.dfdz(xHalf, dx, zHalf, tHalf).scaleSelf(0.5), 0, x.length());
            J.addSubMatrix(system.dgdx(xNew, zNew, tNew), x.length(), 0);
            J.addSubMatrix(system.dgdz(xNew, zNew, tNew), x.length(), x.length());
            let dxz = gauss_1.gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
            xNew.addSelf(dxz.getSubVector(0, x.length()));
            zNew.addSelf(dxz.getSubVector(x.length(), z.length()));
            dx = vector_1.vector.sub(xNew, x).scale(1 / this.step);
            xHalf = vector_1.vector.add(x, xNew).scaleSelf(0.5);
            zHalf = vector_1.vector.add(z, zNew).scaleSelf(0.5);
            F = vector_1.vector.empty(x.length() + z.length());
            F.addSubVector(system.f(xHalf, dx, zHalf, tHalf), 0);
            F.addSubVector(system.g(xNew, zNew, tNew), x.length());
            let fnorm = F.norm2();
            if (i >= this.systemSolver.getMinIterations() && fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, zNew, tNew);
            }
        }
        throw new Error("Divergence");
    }
}
exports.IDAE_IMidpoint = IDAE_IMidpoint;


/***/ }),

/***/ "./src/dae/solvers/idae/rk.ts":
/*!************************************!*\
  !*** ./src/dae/solvers/idae/rk.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_LOBATTOIIIC4 = exports.IDAE_LOBATTOIIIC2 = exports.IDAE_LOBATTOIIIB4 = exports.IDAE_LOBATTOIIIB2 = exports.IDAE_LOBATTOIIIA4 = exports.IDAE_LOBATTOIIIA2 = exports.IDAE_GAUSSLEGENDRE6 = exports.IDAE_GAUSSLEGENDRE4 = exports.IDAE_RADAUIIA5 = exports.IDAE_RADAUIIA3 = exports.IDAE_RADAUIA5 = exports.IDAE_MidpointEuler = exports.IDAE_HeunEuler = exports.IDAE_BS23 = exports.IDAE_DOPRI5 = exports.IDAE_RK8 = exports.IDAE_RK6_2 = exports.IDAE_RK6 = exports.IDAE_RK4_RALSTON = exports.IDAE_RK4_2 = exports.IDAE_RK4 = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/**
 * explicit rk methods for implicit dae of index 1
 */
class IDAE_ERK extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver, a, b, c) {
        super(step, systemSolver);
        this.a = a;
        this.b = b;
        this.c = c;
    }
    makeStep(x, z, t, system) {
        let k = [];
        let _z = z;
        for (let i = 0; i < this.c.length; i++) {
            let _x = x.clone();
            for (let j = 0; j < i; j++) {
                _x.add(vector_1.vector.scale(k[j], this.step * this.a[i - 1][j]));
            }
            let _t = t + this.c[i] * this.step;
            _z = this.solve_z(_x, _z, _t, system);
            k.push(this.solve_dx(_x, _z, _t, system));
        }
        let xNew = x.clone();
        for (let i = 0; i < this.b.length; i++) {
            xNew.add(k[i].scaleSelf(this.step * this.b[i]));
        }
        let tNew = t + this.step;
        let zNew = this.solve_z(xNew, _z, tNew, system);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
/**
 * explicit rk methods with adaptive step for implicit dae of index 1
 */
class IDAE_ERKA extends IDAE_ERK {
    constructor(step, maxStep, errorOrder, errorTolerance, systemSolver, a, b, c, _b) {
        super(step, systemSolver, a, b, c);
        this._b = _b;
        this.errorOrder = errorOrder;
        this.errorTolerance = errorTolerance;
        this.minStep = step;
        this.maxStep = maxStep;
    }
    makeStep(x, z, t, system) {
        while (true) {
            let k = [];
            let _z = z;
            for (let i = 0; i < this.c.length; i++) {
                let _x = x.clone();
                for (let j = 0; j < i; j++) {
                    _x.add(vector_1.vector.scale(k[j], this.step * this.a[i - 1][j]));
                }
                let _t = t + this.c[i] * this.step;
                _z = this.solve_z(_x, _z, _t, system);
                k.push(this.solve_dx(_x, _z, _t, system));
            }
            let difference = vector_1.vector.empty(x.length());
            for (let i = 0; i < this._b.length; i++) {
                difference.addSelf(vector_1.vector.scale(k[i], this._b[i] - this.b[i]));
            }
            let difNorm = difference.norm2();
            var stepOpt = Math.pow(this.errorTolerance * 0.5 / difNorm, 1 / this.errorOrder) * this.step;
            if (isNaN(stepOpt)) {
                stepOpt = this.minStep;
            }
            stepOpt = Math.min(Math.max(this.minStep, stepOpt), this.maxStep);
            if (stepOpt * 2 < this.step) {
                this.step = stepOpt;
                continue;
            }
            this.step = stepOpt;
            let xNew = x.clone();
            let tNew = t + this.step;
            for (let i = 0; i < this.b.length; i++) {
                xNew.add(vector_1.vector.scale(k[i], this.step * this.b[i]));
            }
            let zNew = this.solve_z(xNew, _z, tNew, system);
            return new daeVector_1.DAEVector(xNew, zNew, tNew);
        }
    }
}
/**
 * implicit rk methods for explicit dae of index 1
 */
class IDAE_IRK extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver, a, b, c, stages) {
        super(step, systemSolver);
        this.a = a;
        this.b = b;
        this.c = c;
        this.stages = stages;
    }
    /*  I KNEW UR FATHER, LUKE, I CUTTED HIS LEGS AND LEFT HIM IN LAVA, HE WAS A GOOD FRIEND
        {
            F_{xi}: f(x_n + h * sum_{j=1}^{S} k_j * a_ij, k_i, k_{zi}, t_n + h * c_i) = 0
            F_{gi}: g(x_n + h * sum_{j=1}^{S} k_j * a_ij, k_{zi}, t_n + h * c_i) = 0
        }
        S * (N_x + N_z)
        dF_{xil}/dk_jm = \delta_ij * df/ddx + df/dx * h * a_ij;
        dF_{xil}/dk_zj = \delta_ij * df/dz;
        dF_{gi}/dk_jm = dg/dx * h * a_ij;
        dF_{gi}/dk_zj = \delta_ij * dg/dz;

        memory layout:
                  j->
        |-----------------------------------------------------|
        | dFx0/dk0 | dFx0/dkz0     | dFx0/dk1 | dFx0/dkz1 = 0 |
    i   |----------|---------------|----------|---------------|
    |   | dFg0/dk0 | dFg0/dkz0     | dFg0/dk1 | dFg0/dkz1 = 0 |
    v   |----------|---------------|----------|---------------|
        | dFx1/dk0 | dFx1/dkz0 = 0 | dFx1/dk1 | dFx1/dkz1     |
        |----------|---------------|----------|---------------|
        | dFg1/dk0 | dFg1/dkz0 = 0 | dFg1/dk1 | dFg1/dkz1     |
        |-----------------------------------------------------|
     */
    function(kx, kz, x, z, t, system) {
        let length = system.length_x() + system.length_z();
        let F = vector_1.vector.empty(this.stages * length);
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(kx[j], this.a[i][j] * this.step));
            F.addSubVector(system.f(_x, kx[i], kz[i], _t), i * length);
            F.subSubVector(system.g(_x, kz[i], _t), i * length + system.length_x());
        }
        return F;
    }
    jacobiMatrix(kx, kz, x, z, t, system) {
        let length = system.length_x() + system.length_z();
        let J = matrix_1.matrix.emptySquare(this.stages * length);
        for (let i = 0; i < this.stages; i++) {
            let _t = t + this.c[i] * this.step;
            let _x = x.clone();
            for (let j = 0; j < this.stages; j++)
                _x.addSelf(vector_1.vector.scale(kx[j], this.a[i][j] * this.step));
            let dfdx = system.dfdx(_x, kx[i], kz[i], _t);
            let dfddx = system.dfddx(_x, kx[i], kz[i], _t);
            let dfdz = system.dfdz(_x, kx[i], kz[i], _t);
            let dgdx = system.dgdx(_x, kz[i], _t);
            let dgdz = system.dgdz(_x, kz[i], _t);
            J.addSubMatrix(dfddx, i * length, i * length);
            J.addSubMatrix(dfdz, i * length, i * length + system.length_x());
            J.addSubMatrix(dgdz, i * length + system.length_x(), i * length + system.length_x());
            for (let j = 0; j < this.stages; j++) {
                J.subSubMatrix(dfdx.scaleSelf(this.step * this.a[i][j]), i * length, j * length);
                J.subSubMatrix(dgdx.scaleSelf(this.step * this.a[i][j]), i * length + system.length_x(), j * length);
            }
        }
        return J;
    }
    makeStep(x, z, t, system) {
        let length = system.length_x() + system.length_z();
        let kx = [];
        let kz = [];
        for (let i = 0; i < this.stages; i++) {
            kx.push(vector_1.vector.empty(system.length_x()));
            kz.push(z.clone());
        }
        let F = this.function(kx, kz, x, z, t, system);
        let f0norm = F.norm2();
        for (let it = 0; it < this.systemSolver.getIterations(); it++) {
            let J = this.jacobiMatrix(kx, kz, x, z, t, system);
            let dk = gauss_1.gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
            for (let i = 0; i < this.stages; i++) {
                kx[i].addSelf(dk.getSubVector(i * length, system.length_x()));
                kz[i].addSelf(dk.getSubVector(i * length + system.length_x(), system.length_z()));
            }
            F = this.function(kx, kz, x, z, t, system);
            let fnorm = F.norm2();
            if (it >= this.systemSolver.getMinIterations() && fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                let xNew = x.clone();
                for (let j = 0; j < this.stages; j++) {
                    xNew.addSelf(kx[j].scaleSelf(this.step * this.b[j]));
                }
                let tNew = t + this.step;
                return new daeVector_1.DAEVector(xNew, this.solve_z(xNew, kz[this.stages - 1], tNew, system), tNew);
            }
        }
        throw new Error("Divergence");
    }
}
/**
 * implicit rk methods with adaptive step for implicit dae of index 1
 */
class IDAE_IRKA extends IDAE_IRK {
    constructor(step, maxStep, errorOrder, errorTolerance, systemSolver, a, b, c, _b, stages) {
        super(step, systemSolver, a, b, c, stages);
        this._b = _b;
        this.errorOrder = errorOrder;
        this.errorTolerance = errorTolerance;
        this.minStep = step;
        this.maxStep = maxStep;
    }
    makeStep(x, z, t, system) {
        //throw new Error("Method not implemented.");
        while (true) {
            let shouldThrow = true;
            let length = system.length_x() + system.length_z();
            let kx = [];
            let kz = [];
            for (let i = 0; i < this.stages; i++) {
                kx.push(vector_1.vector.empty(system.length_x()));
                kz.push(z.clone());
            }
            let F = this.function(kx, kz, x, z, t, system);
            let f0norm = F.norm2();
            for (let it = 0; it < this.systemSolver.getIterations(); it++) {
                let J = this.jacobiMatrix(kx, kz, x, z, t, system);
                let dk = gauss_1.gauss.solve(J, F.scaleSelf(-this.systemSolver.getAlpha()));
                for (let i = 0; i < this.stages; i++) {
                    kx[i].addSelf(dk.getSubVector(i * length, system.length_x()));
                    kz[i].addSelf(dk.getSubVector(i * length + system.length_x(), system.length_z()));
                }
                F = this.function(kx, kz, x, z, t, system);
                let fnorm = F.norm2();
                if (it >= this.systemSolver.getMinIterations() && fnorm < this.systemSolver.getAbsTol() + this.systemSolver.getRelTol() * f0norm) {
                    let difference = vector_1.vector.empty(x.length());
                    for (let i = 0; i < this._b.length; i++) {
                        difference.addSelf(vector_1.vector.scale(kx[i], this._b[i] - this.b[i]));
                    }
                    let difNorm = difference.norm2();
                    var stepOpt = Math.pow(this.errorTolerance * 0.5 / difNorm, 1 / this.errorOrder) * this.step;
                    if (isNaN(stepOpt)) {
                        stepOpt = this.minStep;
                    }
                    stepOpt = Math.min(Math.max(this.minStep, stepOpt), this.maxStep);
                    if (stepOpt * 2 < this.step) {
                        this.step = stepOpt;
                        shouldThrow = false;
                        break;
                    }
                    this.step = stepOpt;
                    let xNew = x.clone();
                    let tNew = t + this.step;
                    for (let j = 0; j < this.stages; j++) {
                        xNew.addSelf(kx[j].scaleSelf(this.step * this.b[j]));
                    }
                    return new daeVector_1.DAEVector(xNew, this.solve_z(xNew, kz[this.stages - 1], tNew, system), tNew);
                }
            }
            if (shouldThrow)
                throw new Error("Divergence");
        }
    }
}
/**
 * classic RK4
 */
class IDAE_RK4 extends IDAE_ERK {
    constructor(step, systemSolver) {
        super(step, systemSolver, [
            [0.5],
            [0, 0.5],
            [0, 0, 1]
        ], [1 / 6, 1 / 3, 1 / 3, 1 / 6], [0, 0.5, 0.5, 1]);
    }
}
exports.IDAE_RK4 = IDAE_RK4;
class IDAE_RK4_2 extends IDAE_ERK {
    constructor(step, systemSolver) {
        super(step, systemSolver, [
            [1 / 3],
            [-1 / 3, 1],
            [1, -1, 1]
        ], [1 / 8, 3 / 8, 3 / 8, 1 / 8], [0, 1 / 3, 2 / 3, 1]);
    }
}
exports.IDAE_RK4_2 = IDAE_RK4_2;
class IDAE_RK4_RALSTON extends IDAE_ERK {
    constructor(step, systemSolver) {
        super(step, systemSolver, [
            [0.4],
            [0.29697761, 0.15875964],
            [0.2181004, -3.05096516, 3.83286476]
        ], [0.17476028, -0.55148066, 1.20553560, 0.17118478], [0, 0.4, 0.45573725, 1]);
    }
}
exports.IDAE_RK4_RALSTON = IDAE_RK4_RALSTON;
class IDAE_RK6 extends IDAE_ERK {
    constructor(step, systemSolver) {
        super(step, systemSolver, [
            [2 / 5],
            [0, 4 / 5],
            [169 / 1458, 110 / 729, -65 / 1458],
            [-44 / 675, -88 / 135, 76 / 351, 336 / 325],
            [21 / 106, 0, -105 / 689, -324 / 689, 45 / 106],
            [-2517 / 4864, -55 / 38, 10615 / 31616, 567 / 7904, 7245 / 4864, 2597 / 2432]
        ], [0, 0, 1375 / 4992, 6561 / 20384, 3375 / 12544, 53 / 768, 19 / 294], [0, 2 / 5, 4 / 5, 2 / 9, 8 / 15, 0, 1]);
    }
}
exports.IDAE_RK6 = IDAE_RK6;
class IDAE_RK6_2 extends IDAE_ERK {
    constructor(step, systemSolver) {
        super(step, systemSolver, [
            [1 / 3],
            [0, 2 / 3],
            [1 / 12, 1 / 3, -1 / 12],
            [25 / 48, -55 / 24, 35 / 48, 15 / 8],
            [3 / 20, -11 / 24, -1 / 8, 1 / 2, 1 / 10],
            [-261 / 260, 33 / 13, 43 / 156, -118 / 39, 32 / 195, 80 / 39]
        ], [13 / 200, 0, 11 / 40, 11 / 40, 4 / 25, 4 / 25, 13 / 200], [0, 1 / 3, 2 / 3, 1 / 3, 5 / 6, 1 / 6, 1]);
    }
}
exports.IDAE_RK6_2 = IDAE_RK6_2;
class IDAE_RK8 extends IDAE_ERK {
    constructor(step, systemSolver) {
        var root21 = Math.sqrt(21);
        super(step, systemSolver, [
            [1 / 2],
            [1 / 4, 1 / 4],
            [1 / 7, (-7 - 3 * root21) / 98, 0, (21 + 5 * root21) / 49],
            [(11 + root21) / 84, 0, (18 + 4 * root21) / 63, (21 - root21) / 252],
            [(5 + root21) / 48, 0, (9 + root21) / 36, (-231 + 14 * root21) / 360, (63 - 7 * root21) / 80],
            [(10 - root21) / 42, 0, (-432 + 92 * root21) / 315, (633 - 145 * root21) / 90, (-503 + 115 * root21) / 70, (63 - 13 * root21) / 35],
            [1 / 14, 0, 0, 0, (14 - 3 * root21) / 126, (13 - 3 * root21) / 63, 1 / 9],
            [1 / 32, 0, 0, 0, (91 - 21 * root21) / 576, 11 / 72, (-385 - 75 * root21) / 1152, (63 + 13 * root21) / 128],
            [1 / 14, 0, 0, 0, 1 / 9, (-733 - 147 * root21) / 2205, (515 + 111 * root21) / 504, (-51 - 11 * root21) / 56, (132 + 28 * root21) / 245],
            [0, 0, 0, 0, (-42 + 7 * root21) / 18, (-18 + 28 * root21) / 45, (-273 - 53 * root21) / 72, (301 + 53 * root21) / 72, (28 - 28 * root21) / 45, (49 - 7 * root21) / 18]
        ], [1 / 20, 0, 0, 0, 0, 0, 0, 49 / 180, 16 / 45, 49 / 180, 1 / 20], [0, 1 / 2, 1 / 2, (7 + root21) / 14, (7 + root21) / 14, 1 / 2, (7 - root21) / 14,
            (7 - root21) / 14, 1 / 2, (7 + root21) / 14, 1]);
    }
}
exports.IDAE_RK8 = IDAE_RK8;
class IDAE_DOPRI5 extends IDAE_ERKA {
    constructor(step, maxStep, systemSolver, errorTolerance) {
        super(step, maxStep, 5, errorTolerance, systemSolver, [
            [1 / 5],
            [3 / 40, 9 / 40],
            [44 / 45, -56 / 15, 32 / 9],
            [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],
            [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],
            [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]
        ], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0], [0, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1], [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40]);
    }
}
exports.IDAE_DOPRI5 = IDAE_DOPRI5;
/**
 * BogackiShampine23
 */
class IDAE_BS23 extends IDAE_ERKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 3, errorTolerance, systemSolver, [
            [1 / 2],
            [0, 3 / 4],
            [2 / 9, 1 / 3, 4 / 9]
        ], [2 / 9, 1 / 3, 4 / 9, 0], [0, 0.5, 0.75, 1], [7 / 24, 1 / 4, 1 / 3, 1 / 8]);
    }
}
exports.IDAE_BS23 = IDAE_BS23;
class IDAE_HeunEuler extends IDAE_ERKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 2, errorTolerance, systemSolver, [
            [1]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0]);
    }
}
exports.IDAE_HeunEuler = IDAE_HeunEuler;
class IDAE_MidpointEuler extends IDAE_ERKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 2, errorTolerance, systemSolver, [
            [1 / 2]
        ], [0, 1], [0, 0.5], [1, 0]);
    }
}
exports.IDAE_MidpointEuler = IDAE_MidpointEuler;
class IDAE_RADAUIA5 extends IDAE_IRK {
    constructor(step, systemSolver) {
        let root6 = Math.sqrt(6);
        super(step, systemSolver, [
            [1 / 9, (-1 - root6) / 18, (-1 + root6) / 18],
            [1 / 9, (88 + 7 * root6) / 360, (88 - 43 * root6) / 360],
            [1 / 9, (88 + 43 * root6) / 360, (80 - 7 * root6) / 360]
        ], [1 / 9, (16 + root6) / 36, (16 - root6) / 36], [0, (6 - root6) / 10, (6 + root6) / 10], 3);
    }
}
exports.IDAE_RADAUIA5 = IDAE_RADAUIA5;
class IDAE_RADAUIIA3 extends IDAE_IRK {
    constructor(step, systemSolver) {
        let root6 = Math.sqrt(6);
        super(step, systemSolver, [
            [5 / 12, -1 / 12],
            [3 / 4, 1 / 4]
        ], [3 / 4, 1 / 4], [1 / 3, 1], 2);
    }
}
exports.IDAE_RADAUIIA3 = IDAE_RADAUIIA3;
class IDAE_RADAUIIA5 extends IDAE_IRK {
    constructor(step, systemSolver) {
        let root6 = Math.sqrt(6);
        super(step, systemSolver, [
            [11 / 45 - 7 * root6 / 360, 37 / 225 - 169 * root6 / 1800, -2 / 225 + root6 / 75],
            [37 / 225 + 169 * root6 / 1800, 11 / 45 + 7 * root6 / 360, -2 / 225 - root6 / 75],
            [4 / 9 - root6 / 36, 4 / 9 + root6 / 36, 1 / 9]
        ], [4 / 9 - root6 / 36, 4 / 9 + root6 / 36, 1 / 9], [2 / 5 - root6 / 10, 2 / 5 + root6 / 10, 1], 3);
    }
}
exports.IDAE_RADAUIIA5 = IDAE_RADAUIIA5;
/**
 * Embedded gauss-legendre 4th order
 */
class IDAE_GAUSSLEGENDRE4 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        let sqrt3 = Math.sqrt(3);
        super(step, maxStep, 4, errorTolerance, systemSolver, [
            [1 / 4, 1 / 4 - sqrt3 / 6],
            [1 / 4 + sqrt3 / 6, 1 / 4]
        ], [0.5, 0.5], [(3 - sqrt3) / 6, (3 + sqrt3) / 6], [(1 + sqrt3) / 2, (1 - sqrt3) / 2], 2);
    }
}
exports.IDAE_GAUSSLEGENDRE4 = IDAE_GAUSSLEGENDRE4;
/**
 * Embedded gauss-legendre 6th order
 */
class IDAE_GAUSSLEGENDRE6 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        let sqrt15 = Math.sqrt(15);
        super(step, maxStep, 6, errorTolerance, systemSolver, [
            [5 / 36, 2 / 9 - sqrt15 / 15, 5 / 36 - sqrt15 / 30],
            [5 / 36 + sqrt15 / 24, 2 / 9, 5 / 36, -sqrt15 / 24],
            [5 / 36 + sqrt15 / 30, 2 / 9 + sqrt15 / 15, 5 / 36]
        ], [5 / 18, 4 / 9, 5 / 18], [0.5 - sqrt15 / 10, 0.5, 0.5 + sqrt15 / 10], [-5 / 6, 8 / 3, -5 / 6], 3);
    }
}
exports.IDAE_GAUSSLEGENDRE6 = IDAE_GAUSSLEGENDRE6;
class IDAE_LOBATTOIIIA2 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 2, errorTolerance, systemSolver, [
            [0, 0],
            [1 / 2, 1 / 2]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0], 2);
    }
}
exports.IDAE_LOBATTOIIIA2 = IDAE_LOBATTOIIIA2;
class IDAE_LOBATTOIIIA4 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 4, errorTolerance, systemSolver, [
            [0, 0, 0],
            [5 / 24, 1 / 3, -1 / 24],
            [1 / 6, 2 / 3, 1 / 36]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.IDAE_LOBATTOIIIA4 = IDAE_LOBATTOIIIA4;
class IDAE_LOBATTOIIIB2 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 2, errorTolerance, systemSolver, [
            [1 / 2, 0],
            [1 / 2, 0]
        ], [1 / 2, 1 / 2], [1 / 2, 1 / 2], [1, 0], 2);
    }
}
exports.IDAE_LOBATTOIIIB2 = IDAE_LOBATTOIIIB2;
class IDAE_LOBATTOIIIB4 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 4, errorTolerance, systemSolver, [
            [1 / 6, -1 / 6, 0],
            [1 / 6, 1 / 3, 0],
            [1 / 6, 5 / 6, 0]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.IDAE_LOBATTOIIIB4 = IDAE_LOBATTOIIIB4;
class IDAE_LOBATTOIIIC2 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 2, errorTolerance, systemSolver, [
            [1 / 2, -1 / 2],
            [1 / 2, 1 / 2]
        ], [1 / 2, 1 / 2], [0, 1], [1, 0], 2);
    }
}
exports.IDAE_LOBATTOIIIC2 = IDAE_LOBATTOIIIC2;
class IDAE_LOBATTOIIIC4 extends IDAE_IRKA {
    constructor(step, maxStep, errorTolerance, systemSolver) {
        super(step, maxStep, 4, errorTolerance, systemSolver, [
            [1 / 6, -1 / 3, 1 / 6],
            [1 / 6, 5 / 12, -1 / 12],
            [1 / 6, 2 / 3, 1 / 6]
        ], [1 / 6, 2 / 3, 1 / 6], [0, 0.5, 1], [-1 / 2, 2, -1 / 2], 3);
    }
}
exports.IDAE_LOBATTOIIIC4 = IDAE_LOBATTOIIIC4;


/***/ }),

/***/ "./src/dae/solvers/idae/trapezoidal.ts":
/*!*********************************************!*\
  !*** ./src/dae/solvers/idae/trapezoidal.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.IDAE_ITrapezoidal = exports.IDAE_ETrapezoidal = void 0;
const daeVector_1 = __webpack_require__(/*! ../../daeVector */ "./src/dae/daeVector.ts");
const idaeSolver_1 = __webpack_require__(/*! ../../idaeSolver */ "./src/dae/idaeSolver.ts");
const vector_1 = __webpack_require__(/*! ../../../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../../../math/matrix */ "./src/math/matrix.ts");
const gauss_1 = __webpack_require__(/*! ../../../math/gauss */ "./src/math/gauss.ts");
/*
explicit
    x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_n+hf(x_n,t_n),t_{n+1}))
    {
        1.  f(x_n,k_1,z_n,t_n) = 0
        implicit Nx
        2.  g(x_n+hk_1,z^1_n,t_{n+1}) = 0
        implicit Nz
        3.  f(x_n+hk_1,k_2,z^1_n,t_{n+1}) = 0
        implicit Nx
        4.  x_{n+1} = x_n + 0.5*h(k_1 + k_2)
        explicit Nx
        5.  g(x_{n+1},z_{n+1},t_{n+1}) = 0
        implicit Nz
    }
implicit
    x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_{n+1}.t_{n+1}))
    {
        1.  f(x_n,k_1,z_n,t_n) = 0
        implicit Nx
        2.  g(x_{n+1},z_{n+1},t_{n+1}) = 0
            f(x_{n+1},(x_{n+1}-x_n)/(2h)-k_1,z_{n+1},t_{n+1}) = 0
        implicit Nx + Nz system
    }
*/
/**
 * explicit trapezoidal method for implicit dae with index one
 */
class IDAE_ETrapezoidal extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver) {
        super(step, systemSolver);
    }
    makeStep(x, z, t, system) {
        //1.    f(x_n,k_1,z_n,t_n) = 0
        let x1 = this.solve_dx(x, z, t, system).scaleSelf(this.step).addSelf(x);
        let tNew = t + this.step;
        //2.    g(x_n+hk_1,z^1_n,t_{n+1}) = 0
        let z1 = this.solve_z(x1, z, tNew, system);
        //3.    f(x_n+hk_1,k_2,z^1_n,t_{n+1}) = 0
        let x2 = this.solve_dx(x1, z1, tNew, system).scaleSelf(this.step).addSelf(x);
        //4.    x_{n+1} = x_n + 0.5*h(k_1 + k_2)
        let xNew = x1.addSelf(x2).scaleSelf(0.5);
        //5.    g(x_{n+1},z_{n+1},t_{n+1}) = 0
        let zNew = this.solve_z(xNew, z1, tNew, system);
        return new daeVector_1.DAEVector(xNew, zNew, tNew);
    }
}
exports.IDAE_ETrapezoidal = IDAE_ETrapezoidal;
/**
 * implicit trapezoidal method for implicit dae with index one
 */
class IDAE_ITrapezoidal extends idaeSolver_1.IDAESolver {
    constructor(step, systemSolver, stepSolver) {
        super(step, systemSolver);
        this.stepSolver = stepSolver;
    }
    /*x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_{n+1}.t_{n+1}))
    {
        1.  f(x_n,k_1,z_n,t_n) = 0
        implicit Nx
        2.  Fx = f(x_{n+1},(x_{n+1}-x_n)*2/h-k_1,z_{n+1},t_{n+1}) = 0
            Fz = g(x_{n+1},z_{n+1},t_{n+1}) = 0
        implicit Nx + Nz system
        dFx/dx_{n+1} = df/dx + df/ddx *2/h
        dFx/dz_{n+1} = df/dz
        dFz/dx_{n+1} = dg/dx
        dFz/dz_{n+1} = dg/dz
    }*/
    makeStep(x, z, t, system) {
        /*let k1 = this.solve_dx(x,z,t,system);
        let xz0 = vector.concat([x.clone().addSelf(vector.scale(k1,this.step)),z]);
        let tNew = t + this.step;
        let xzNew = this.stepSolver.solve((xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let dx = vector.sub(xNew,x).scale(2/this.step).sub(k1);

            let F:vector = vector.empty(x.length()+z.length());
            F.addSubVector(system.f(xNew,dx,zNew,tNew),0);
            F.addSubVector(system.g(xNew,zNew,tNew),x.length());
            return F;

        },(xzNew:vector)=>{
            let xNew = xzNew.getSubVector(0,system.length_x());
            let zNew = xzNew.getSubVector(system.length_x(),system.length_z());
            let dx = vector.sub(xNew,x).scale(2/this.step).sub(k1);

            let J:matrix = matrix.emptySquare(x.length()+z.length());
            J.addSubMatrix(system.dfdx(xNew,dx,zNew,tNew).addSelf(system.dfddx(xNew,dx,zNew,tNew).scaleSelf(2/this.step)),0,0);
            J.addSubMatrix(system.dfdz(xNew,dx,zNew,tNew),0,x.length());
            J.addSubMatrix(system.dgdx(xNew,zNew,tNew),x.length(),0);
            J.addSubMatrix(system.dgdz(xNew,zNew,tNew),x.length(),x.length());
            return J;
        },system.length_x() + system.length_z(), xz0);
        
        return new DAEVector(xzNew.getSubVector(0,system.length_x()),xzNew.getSubVector(system.length_x(),system.length_z()),tNew);*/
        /*x_{n+1} = x_n + 0.5*h(f(x_n,t_n)+f(x_{n+1}.t_{n+1}))
        {
            1.  f(x_n,k_1,z_n,t_n) = 0
            implicit Nx
            2.  Fx = f(x_{n+1},(x_{n+1}-x_n)*2/h-k_1,z_{n+1},t_{n+1}) = 0
                Fz = g(x_{n+1},z_{n+1},t_{n+1}) = 0
            implicit Nx + Nz system
            dFx/dx_{n+1} = df/dx + df/ddx *2/h
            dFx/dz_{n+1} = df/dz
            dFz/dx_{n+1} = dg/dx
            dFz/dz_{n+1} = dg/dz
        }*/
        //1.    f(x_n,k_1,z_n,t_n) = 0
        let k1 = this.solve_dx(x, z, t, system);
        let tNew = t + this.step;
        let xNew = x.clone().addSelf(vector_1.vector.scale(k1, this.step)); //better approximation for xNew
        let zNew = z.clone();
        let dx = vector_1.vector.sub(xNew, x).scaleSelf(2 / this.step).subSelf(k1);
        let F = vector_1.vector.empty(x.length() + z.length());
        F.addSubVector(system.f(xNew, dx, zNew, tNew), 0);
        F.addSubVector(system.g(xNew, zNew, tNew), x.length());
        let f0norm = F.norm2();
        for (let i = 0; i < this.stepSolver.getIterations(); i++) {
            let J = matrix_1.matrix.emptySquare(x.length() + z.length());
            J.addSubMatrix(system.dfdx(xNew, dx, zNew, tNew).addSelf(system.dfddx(xNew, dx, zNew, tNew).scaleSelf(2 / this.step)), 0, 0);
            J.addSubMatrix(system.dfdz(xNew, dx, zNew, tNew), 0, x.length());
            J.addSubMatrix(system.dgdx(xNew, zNew, tNew), x.length(), 0);
            J.addSubMatrix(system.dgdz(xNew, zNew, tNew), x.length(), x.length());
            let dxz = gauss_1.gauss.solve(J, F.scaleSelf(-this.stepSolver.getAlpha()));
            xNew.addSelf(dxz.getSubVector(0, x.length()));
            zNew.addSelf(dxz.getSubVector(x.length(), z.length()));
            dx = vector_1.vector.sub(xNew, x).scaleSelf(2 / this.step).subSelf(k1);
            F = vector_1.vector.empty(x.length() + z.length());
            F.addSubVector(system.f(xNew, dx, zNew, tNew), 0);
            F.addSubVector(system.g(xNew, zNew, tNew), x.length());
            let fnorm = F.norm2();
            if (i >= this.stepSolver.getMinIterations() && fnorm < this.stepSolver.getRelTol() + this.stepSolver.getAbsTol() * f0norm) {
                return new daeVector_1.DAEVector(xNew, zNew, tNew);
            }
        }
        throw new Error("Divergence");
    }
}
exports.IDAE_ITrapezoidal = IDAE_ITrapezoidal;


/***/ }),

/***/ "./src/examples.ts":
/*!*************************!*\
  !*** ./src/examples.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.examples = void 0;
exports.examples = {
    dae: {
        //https://www.mathworks.com/help/matlab/math/solve-differential-algebraic-equations-daes.html
        "robertson-problem": {
            name: "Robertson problem",
            text: `
//https://www.mathworks.com/help/matlab/math/solve-differential-algebraic-equations-daes.html
//Robertson problem

x1(t0) = 1;
x2(t0) = 0;
x1'=-0.04*x1+10^4*x2*x3;
x2'=0.04-1e4*x2*x3-3e7*x2^2;
x3 = 1 - x1 - x2;`
        },
        "weissinger": {
            name: "Weissinger implicit DE",
            text: `
//Weissinger implicit dif. eq.
//t0 = 1

x(t0) = sqrt(3/2);
t * x^2*der(x)^3 - x^3*der(x)^2 + t*(t^2+1)*der(x)-t*t*x = 0;
z = sqrt(t*t+0.5);  //exact solution`
        },
        "stiff-equation": {
            name: "Stiff equation",
            text: `//stiff equation

constant x0 = 0;
constant a = -21;
constant c1 = x0 + 1/(a + 1);

x' = a*x+exp(-t);
z = c1 * exp(a*t) - exp(-t)/(a+1);//analytical solution
x(t0) = x0;`
        },
        "lorenz-system": {
            name: "Lorenz system",
            text: `
//Lorenz system

constant sigma = 10;
constant rho=28;
constant beta=8/3;

x(t0) = 1;
y(t0) = 1;
z(t0) = 1;

x' = sigma* (y-x);
y' = x * (rho - z) - y;
z' = x*z-beta*z;`
        },
        "dalquist-equation": {
            name: "Dalquist equation",
            text: `
//Dalquist equation
//t0 = 0, t1 = 2

constant a = 2;
constant x0 = 1;
constant t0 = 0;

x(t0) = x0;
x' = a * x;
z = x0*exp(a*x-a*t0);//analytic solution
`
        },
        "van-der-pol-oscillator": {
            name: "Van der Pol oscillator",
            text: `
//Van der Pol oscillator

constant mu = 20;
constant a = 0;
constant omega = 1;

x1(t0) = 1;
x2(t0) = 0;

x1' = x2;
x2' = mu*(1-x1*x1)*x2-x1 + a*sin(omega*t);`
        },
        "implicid van-der-pol": {
            name: "Implicit Van der Pol oscillator",
            text: `
//Van der Pol oscillator

constant mu = 20;
constant a = 0;
constant omega = 1;

x1(t0) = 1;
x2(t0) = 0;

x1' - x2 =0;
x2' = mu*(1-x1*x1)*x2-x1 + a*sin(omega*t);
`
        },
        "airy-equation": {
            name: "Airy equation",
            text: `
//Airy equation
//x''-tx=0
//t0 = -15

x2(t0)=0.0;
x1(t0)=0.255;

x2'= t*x1;
x1'= x2;`
        },
        "lotka-volterra": {
            name: "Lotka-Volterra equations",
            text: `
//prey hunter LotkaVolterra

constant alpha = 1.1;
constant beta = 0.4;
constant delta = 0.1;
constant gamma = 0.4;

x(t0) = 10;
y(t0) = 10;

x' = x*alpha-beta*x*y;
y' = delta*x*y - gamma*y;`
        },
        "logistic-equation": {
            name: "Logistic differential equation",
            text: `
//Logistic differential equation
constant k = 1;
constant a = 1;

x(t0) = 0.5;

x' = k*x*(a-x);`
        },
        "double-pendulum": {
            name: "Double pendulum",
            text: `//double pendulum

constant m = 1;
constant r = 1;
constant g = 9.82;

p1(t0) = 0;
p2(t0) = 0;
theta1(t0) = 1.5;
theta2(t0) = 3.;

macro dtheta1() 6/(m*r^2)*(2*p1 - 3*cos(theta1 - theta2)*p2)/(16-9*cos(theta1 - theta2)^2);
macro dtheta2() 6/(m*r^2)*(8*p2 - 3*cos(theta1 - theta2)*p1)/(16-9*cos(theta1 - theta2)^2);

der(theta1) =#dtheta1() ;
der(theta2) = #dtheta2();
der(p1) = -0.5*m*(r^2)*(#dtheta1()*#dtheta2()*sin(theta1-theta2)+3*g/r*sin(theta1));
der(p2) = -0.5*m*(r^2)*(-#dtheta1()*#dtheta2()*sin(theta1-theta2)+g/r*sin(theta2));

x1 =r*sin(theta1);
y1 = -r*cos(theta1);
x2 = r*sin(theta1) + r*sin(theta2);
y2 = -r*cos(theta1) - r*cos(theta2);
`
        },
        "mathieu": {
            name: "Mathieu's differential equation",
            text: `//Methieu's differential equation

constant q = 1;
constant a = 2;

y(t0) = 0;
dyt(t0) = 0;

dyt' = y*(2*q*cos(2*t)-a);
y' = dyt;

`
        },
        "linear-system": {
            name: "Linear system",
            text: `//Linear system
/*
x_i' = sum_j x_j * a_{ij} + t * b_i
*/

macro a[1][1]()  1;
macro  a[1][2]() -1;
macro a[1][3]()  -2;

macro a[2][1]() -3;
macro a[2][2]() -1;
macro a[2][3]() -0.2;

macro a[3][1]() 0.12;
macro a[3][2]() 0.15;
macro a[3][3]() 3;

macro b[1]() 1;
macro b[2]() -0.13;
macro b[3]() 0.5;

x[1](t0) = 1;
x[2](t0) = -0.3;
x[3](t0) = 0.0;

for(i in [1:3]){
        der(x[i]) = sum(j in [1:3]){ x[j]*#a[i][j]() }+#b[i]()*t;
}
`
        },
        "pendulum": {
            name: "Pendulum",
            text: `//penduluum
//t = [0,0.5]

constant m = 1;
constant r = 1;
constant g = 9.8;
constant angle = pi()/6;

x1(t0) = r*sin(angle);
y1(t0) = -r*cos(angle);
x2(t0) = 0;
y2(t0) = 0;
T(t0) = 0.0;
x3(t0) = 0.0;
y3(t0) = 0.0;

y1' = y2;
y2' = y3;
m*x3 = T*x1/r;
m*y3 = T*y1/r - g;
x1^2 + y1^2 = r^2;
x1*x2 + y1*y2 = 0;
x2^2 + y2^2+ x1*x3 + y3*y1 = 0;`
        },
        "orbit": {
            name: "An Arenstorf orbit",
            text: `
//period is 17.0652165601579625588917206249
constant m1 = 0.012277471;
constant m2 = 1 - m1;

x1' = x2;
x2' = x1 + 2*y2 - m2*(x1+m1)/D1-m1*(x1-m2)/D2;
y1' = y2;
y2' = y1 - 2*x2 - m2*y1/D1-m1*y1/D2;

D1 = ((x1 + m1)^2 + y1^2)^1.5;
D2 = ((x1 - m2)^2 + y1^2)^1.5;
x1(t0) = 0.994;
x2(t0) = 0;
y1(t0) = 0;
y2(t0) = -2.00158510637908252240537862224;
`
        },
        "oregonator": {
            name: "Oregonator",
            text: `
//t = [0,400]
constant a1 = 77.27;
constant a2 = 8.375e-5;
constant a3 = 0.161;

x1' = a1 * x2 + a1 * x1 - a1 * a2 * x1^2 - a1 * x1 * x2;
x2' = (-x2 + x1*x2 + x3) / a1;
x3' = a3 * (x1 - x3);

x1(t0) = 400;
x2(t0) = 1;
x3(t0) = 400;
`
        },
        "brusselator": {
            name: "Brusselator",
            text: `
//t = [0,30]
x1(t0) = 1.5;
x2(t0) = 3;

x1' = 1 + x1^2 * x2 - 4*x1;
x2' = 3*x1 - x1^2 * x2;
`
        }
    },
    hybrid: {
        "jumping-ball": {
            name: "Jumping ball",
            text: `
//Jumping ball
constant m = 1;
constant g = 9.82;
constant k = 1;

x(t0) = 1;
v(t0) = 0;

v' = -m*g;
x' = v;

state jump{
        set v = -v*k;
} from initial, jump on(v<0 and x<0);

terminal state end{
}from initial, jump on(abs(v)=0 and abs(x)=0);`
        },
        "jumping-ball-spring": {
            name: "Jumping ball on a spring",
            text: `//Jumping ball on a spring
constant m = 1;
constant g = 9.82;
constant k = 1;
constant k_spring = 0.1;
constant h0;

x(t0) = 1;
v(t0) = 0;

v' = -m*g - k_spring*(x - h0);
x' = v;

state jump{
        set v = -v*k;
} from initial, jump on(v<0 and x<0);

terminal state end{
}from initial, jump on(abs(v)=0 and abs(x)=0);
`
        },
        "two-masses": {
            name: "Two masses",
            text: `
//Two masses
constant k1 = n1 = m1 = m2 = 1, k2 = n2 = 2;

x1(t0) = 0;
x2(t0) = 3;
st(t0) = 0;

state separate{
        x1' = v1;
        v1' = k1*(n1-x1)/m1;
        x2' = v2;
        v2' = k2*(n2-x2)/m2;
        set st = 10;
        a1 = k1*(n1 - x1)/m1;
        a2 = k2*(n2 - x2)/m2;
} from initial, together on(st<);

state together{
        set st = 10;
        set v1 = (m1 * v1 + m2*v2)/(m1 + m2);
        set v2 = v1;
        v1' = (k1*n1+k2*n2-x1*(k1+k2))/(m1+m2);
        v2' = (k1*n1+k2*n2-x2*(k1+k2))/(m1+m2);
        x1' = v1;
        x2' = v2;
        a1 = (k1*n1 + k2*n2-x1*(k1+k2))/(m1+m2);
        a2 = (k1*n1 + k2*n2-x2*(k1+k2))/(m1+m2);
} from initial, separate on(x1>x2&&v1>v2);`
        },
        "abs-equation": {
            name: "Abs value differential equation",
            text: `
//abs value
//t = [0,40]
x(t0) = 1;

x' = -abs(x);
z = exp(-t);//analytic solution

state zero{
	set x = abs(x);
} from initial, zero on(x<0);`
        },
        "knee-problem": {
            name: "Knee problem",
            text: `
//knee problem
//t = [0,2]

constant epsilon = 1e-6;

x(t0) = 1;
z = {t<1?1 - x:0};
epsilon*x' = (1 - t)*x - x^2;

state zero on(x<0){
	set x = abs(x);
} from initial on(x<0), zero on(x<0);`
        },
        "falling-body": {
            name: "Falling body",
            text: `
//falling body
//x'' = -1 + x'^2

x1(t0) = 1;
x2(t0) = 0;

eq_1:x1' = x2;
eq_2:x2' = -1 + x2^2;

terminal state zero{
        eq_1:x1' = 0;
        eq_2:x2' = 0;
} from initial on(x<=0);`
        }
    }
};


/***/ }),

/***/ "./src/grammar/antlrOutput/odeGrammarLexer.js":
/*!****************************************************!*\
  !*** ./src/grammar/antlrOutput/odeGrammarLexer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated from e:\projects\SolversJS\src\grammar\odeGrammar.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = __webpack_require__(/*! antlr4/index */ "./node_modules/antlr4/index.js");



var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u00024\u018e\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004",
    "\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t",
    "\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004",
    "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010",
    "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013",
    "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017",
    "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a",
    "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e",
    "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#",
    "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004",
    "*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u0004",
    "1\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u0003\u0002\u0003",
    "\u0002\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003",
    "\u0005\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003",
    "\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\b\u0003\b\u0003\b\u0003",
    "\t\u0003\t\u0003\t\u0003\t\u0003\t\u0003\n\u0003\n\u0003\n\u0003\n\u0003",
    "\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003\u000b\u0003",
    "\u000b\u0003\u000b\u0003\u000b\u0003\f\u0003\f\u0003\f\u0003\f\u0003",
    "\f\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\r\u0003\u000e\u0003",
    "\u000e\u0003\u000e\u0003\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0003",
    "\u000f\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0003",
    "\u0010\u0003\u0010\u0003\u0010\u0003\u0011\u0003\u0011\u0003\u0011\u0003",
    "\u0011\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0013\u0003\u0013\u0003",
    "\u0013\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003",
    "\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0005\u0017\u00d1\n\u0017\u0003\u0018\u0003\u0018\u0003\u0018",
    "\u0003\u0018\u0003\u0018\u0005\u0018\u00d8\n\u0018\u0003\u0019\u0003",
    "\u0019\u0003\u0019\u0003\u0019\u0005\u0019\u00de\n\u0019\u0003\u001a",
    "\u0003\u001a\u0003\u001b\u0003\u001b\u0003\u001c\u0006\u001c\u00e5\n",
    "\u001c\r\u001c\u000e\u001c\u00e6\u0003\u001c\u0003\u001c\u0007\u001c",
    "\u00eb\n\u001c\f\u001c\u000e\u001c\u00ee\u000b\u001c\u0003\u001c\u0003",
    "\u001c\u0005\u001c\u00f2\n\u001c\u0003\u001c\u0006\u001c\u00f5\n\u001c",
    "\r\u001c\u000e\u001c\u00f6\u0005\u001c\u00f9\n\u001c\u0003\u001c\u0003",
    "\u001c\u0006\u001c\u00fd\n\u001c\r\u001c\u000e\u001c\u00fe\u0003\u001c",
    "\u0003\u001c\u0005\u001c\u0103\n\u001c\u0003\u001c\u0006\u001c\u0106",
    "\n\u001c\r\u001c\u000e\u001c\u0107\u0005\u001c\u010a\n\u001c\u0003\u001c",
    "\u0006\u001c\u010d\n\u001c\r\u001c\u000e\u001c\u010e\u0003\u001c\u0003",
    "\u001c\u0005\u001c\u0113\n\u001c\u0003\u001c\u0006\u001c\u0116\n\u001c",
    "\r\u001c\u000e\u001c\u0117\u0005\u001c\u011a\n\u001c\u0003\u001d\u0006",
    "\u001d\u011d\n\u001d\r\u001d\u000e\u001d\u011e\u0003\u001e\u0007\u001e",
    "\u0122\n\u001e\f\u001e\u000e\u001e\u0125\u000b\u001e\u0003\u001e\u0003",
    "\u001e\u0005\u001e\u0129\n\u001e\u0003\u001e\u0007\u001e\u012c\n\u001e",
    "\f\u001e\u000e\u001e\u012f\u000b\u001e\u0003\u001f\u0003\u001f\u0003",
    " \u0003 \u0003!\u0003!\u0003\"\u0003\"\u0003#\u0003#\u0003$\u0003$\u0003",
    "%\u0003%\u0003&\u0003&\u0003\'\u0003\'\u0003(\u0003(\u0003)\u0003)\u0003",
    "*\u0003*\u0003*\u0003+\u0003+\u0003+\u0003,\u0003,\u0003,\u0003-\u0003",
    "-\u0003.\u0003.\u0003/\u0003/\u00030\u00030\u00031\u00031\u00032\u0003",
    "2\u00033\u00033\u00034\u00054\u015f\n4\u00034\u00034\u00064\u0163\n",
    "4\r4\u000e4\u0164\u00034\u00034\u00035\u00065\u016a\n5\r5\u000e5\u016b",
    "\u00035\u00035\u00036\u00036\u00036\u00036\u00076\u0174\n6\f6\u000e",
    "6\u0177\u000b6\u00036\u00056\u017a\n6\u00036\u00036\u00056\u017e\n6",
    "\u00036\u00036\u00036\u00036\u00076\u0184\n6\f6\u000e6\u0187\u000b6",
    "\u00036\u00036\u00056\u018b\n6\u00036\u00036\u0003\u0185\u00027\u0003",
    "\u0003\u0005\u0002\u0007\u0002\t\u0002\u000b\u0004\r\u0005\u000f\u0006",
    "\u0011\u0007\u0013\b\u0015\t\u0017\n\u0019\u000b\u001b\f\u001d\r\u001f",
    "\u000e!\u000f#\u0010%\u0011\'\u0012)\u0013+\u0014-\u0015/\u00161\u0017",
    "3\u00185\u00197\u001a9\u001b;\u001c=\u001d?\u001eA\u001fC E!G\"I#K$",
    "M%O&Q\'S(U)W*Y+[,]-_.a/c0e1g2i3k4\u0003\u0002\u000b\u0003\u0002c|\u0003",
    "\u0002C\\\u0003\u00022;\u0004\u0002GGgg\u0004\u0002--//\u0003\u0002",
    "aa\u0006\u00022;C\\aac|\u0004\u0002\u000b\u000b\"\"\u0004\u0002\f\f",
    "\u000f\u000f\u0002\u01a8\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u000b",
    "\u0003\u0002\u0002\u0002\u0002\r\u0003\u0002\u0002\u0002\u0002\u000f",
    "\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002\u0002\u0013",
    "\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002\u0002\u0017",
    "\u0003\u0002\u0002\u0002\u0002\u0019\u0003\u0002\u0002\u0002\u0002\u001b",
    "\u0003\u0002\u0002\u0002\u0002\u001d\u0003\u0002\u0002\u0002\u0002\u001f",
    "\u0003\u0002\u0002\u0002\u0002!\u0003\u0002\u0002\u0002\u0002#\u0003",
    "\u0002\u0002\u0002\u0002%\u0003\u0002\u0002\u0002\u0002\'\u0003\u0002",
    "\u0002\u0002\u0002)\u0003\u0002\u0002\u0002\u0002+\u0003\u0002\u0002",
    "\u0002\u0002-\u0003\u0002\u0002\u0002\u0002/\u0003\u0002\u0002\u0002",
    "\u00021\u0003\u0002\u0002\u0002\u00023\u0003\u0002\u0002\u0002\u0002",
    "5\u0003\u0002\u0002\u0002\u00027\u0003\u0002\u0002\u0002\u00029\u0003",
    "\u0002\u0002\u0002\u0002;\u0003\u0002\u0002\u0002\u0002=\u0003\u0002",
    "\u0002\u0002\u0002?\u0003\u0002\u0002\u0002\u0002A\u0003\u0002\u0002",
    "\u0002\u0002C\u0003\u0002\u0002\u0002\u0002E\u0003\u0002\u0002\u0002",
    "\u0002G\u0003\u0002\u0002\u0002\u0002I\u0003\u0002\u0002\u0002\u0002",
    "K\u0003\u0002\u0002\u0002\u0002M\u0003\u0002\u0002\u0002\u0002O\u0003",
    "\u0002\u0002\u0002\u0002Q\u0003\u0002\u0002\u0002\u0002S\u0003\u0002",
    "\u0002\u0002\u0002U\u0003\u0002\u0002\u0002\u0002W\u0003\u0002\u0002",
    "\u0002\u0002Y\u0003\u0002\u0002\u0002\u0002[\u0003\u0002\u0002\u0002",
    "\u0002]\u0003\u0002\u0002\u0002\u0002_\u0003\u0002\u0002\u0002\u0002",
    "a\u0003\u0002\u0002\u0002\u0002c\u0003\u0002\u0002\u0002\u0002e\u0003",
    "\u0002\u0002\u0002\u0002g\u0003\u0002\u0002\u0002\u0002i\u0003\u0002",
    "\u0002\u0002\u0002k\u0003\u0002\u0002\u0002\u0003m\u0003\u0002\u0002",
    "\u0002\u0005o\u0003\u0002\u0002\u0002\u0007q\u0003\u0002\u0002\u0002",
    "\ts\u0003\u0002\u0002\u0002\u000bu\u0003\u0002\u0002\u0002\rz\u0003",
    "\u0002\u0002\u0002\u000f~\u0003\u0002\u0002\u0002\u0011\u0081\u0003",
    "\u0002\u0002\u0002\u0013\u0086\u0003\u0002\u0002\u0002\u0015\u008a\u0003",
    "\u0002\u0002\u0002\u0017\u0093\u0003\u0002\u0002\u0002\u0019\u0098\u0003",
    "\u0002\u0002\u0002\u001b\u009e\u0003\u0002\u0002\u0002\u001d\u00a2\u0003",
    "\u0002\u0002\u0002\u001f\u00a8\u0003\u0002\u0002\u0002!\u00ae\u0003",
    "\u0002\u0002\u0002#\u00b2\u0003\u0002\u0002\u0002%\u00b5\u0003\u0002",
    "\u0002\u0002\'\u00b8\u0003\u0002\u0002\u0002)\u00bd\u0003\u0002\u0002",
    "\u0002+\u00c3\u0003\u0002\u0002\u0002-\u00d0\u0003\u0002\u0002\u0002",
    "/\u00d7\u0003\u0002\u0002\u00021\u00dd\u0003\u0002\u0002\u00023\u00df",
    "\u0003\u0002\u0002\u00025\u00e1\u0003\u0002\u0002\u00027\u0119\u0003",
    "\u0002\u0002\u00029\u011c\u0003\u0002\u0002\u0002;\u0123\u0003\u0002",
    "\u0002\u0002=\u0130\u0003\u0002\u0002\u0002?\u0132\u0003\u0002\u0002",
    "\u0002A\u0134\u0003\u0002\u0002\u0002C\u0136\u0003\u0002\u0002\u0002",
    "E\u0138\u0003\u0002\u0002\u0002G\u013a\u0003\u0002\u0002\u0002I\u013c",
    "\u0003\u0002\u0002\u0002K\u013e\u0003\u0002\u0002\u0002M\u0140\u0003",
    "\u0002\u0002\u0002O\u0142\u0003\u0002\u0002\u0002Q\u0144\u0003\u0002",
    "\u0002\u0002S\u0146\u0003\u0002\u0002\u0002U\u0149\u0003\u0002\u0002",
    "\u0002W\u014c\u0003\u0002\u0002\u0002Y\u014f\u0003\u0002\u0002\u0002",
    "[\u0151\u0003\u0002\u0002\u0002]\u0153\u0003\u0002\u0002\u0002_\u0155",
    "\u0003\u0002\u0002\u0002a\u0157\u0003\u0002\u0002\u0002c\u0159\u0003",
    "\u0002\u0002\u0002e\u015b\u0003\u0002\u0002\u0002g\u0162\u0003\u0002",
    "\u0002\u0002i\u0169\u0003\u0002\u0002\u0002k\u018a\u0003\u0002\u0002",
    "\u0002mn\u0007%\u0002\u0002n\u0004\u0003\u0002\u0002\u0002op\t\u0002",
    "\u0002\u0002p\u0006\u0003\u0002\u0002\u0002qr\t\u0003\u0002\u0002r\b",
    "\u0003\u0002\u0002\u0002st\t\u0004\u0002\u0002t\n\u0003\u0002\u0002",
    "\u0002uv\u0007*\u0002\u0002vw\u0007v\u0002\u0002wx\u00072\u0002\u0002",
    "xy\u0007+\u0002\u0002y\f\u0003\u0002\u0002\u0002z{\u0007u\u0002\u0002",
    "{|\u0007g\u0002\u0002|}\u0007v\u0002\u0002}\u000e\u0003\u0002\u0002",
    "\u0002~\u007f\u0007q\u0002\u0002\u007f\u0080\u0007p\u0002\u0002\u0080",
    "\u0010\u0003\u0002\u0002\u0002\u0081\u0082\u0007h\u0002\u0002\u0082",
    "\u0083\u0007t\u0002\u0002\u0083\u0084\u0007q\u0002\u0002\u0084\u0085",
    "\u0007o\u0002\u0002\u0085\u0012\u0003\u0002\u0002\u0002\u0086\u0087",
    "\u0007f\u0002\u0002\u0087\u0088\u0007g\u0002\u0002\u0088\u0089\u0007",
    "t\u0002\u0002\u0089\u0014\u0003\u0002\u0002\u0002\u008a\u008b\u0007",
    "v\u0002\u0002\u008b\u008c\u0007g\u0002\u0002\u008c\u008d\u0007t\u0002",
    "\u0002\u008d\u008e\u0007o\u0002\u0002\u008e\u008f\u0007k\u0002\u0002",
    "\u008f\u0090\u0007p\u0002\u0002\u0090\u0091\u0007c\u0002\u0002\u0091",
    "\u0092\u0007n\u0002\u0002\u0092\u0016\u0003\u0002\u0002\u0002\u0093",
    "\u0094\u0007v\u0002\u0002\u0094\u0095\u0007t\u0002\u0002\u0095\u0096",
    "\u0007w\u0002\u0002\u0096\u0097\u0007g\u0002\u0002\u0097\u0018\u0003",
    "\u0002\u0002\u0002\u0098\u0099\u0007h\u0002\u0002\u0099\u009a\u0007",
    "c\u0002\u0002\u009a\u009b\u0007n\u0002\u0002\u009b\u009c\u0007u\u0002",
    "\u0002\u009c\u009d\u0007g\u0002\u0002\u009d\u001a\u0003\u0002\u0002",
    "\u0002\u009e\u009f\u0007u\u0002\u0002\u009f\u00a0\u0007w\u0002\u0002",
    "\u00a0\u00a1\u0007o\u0002\u0002\u00a1\u001c\u0003\u0002\u0002\u0002",
    "\u00a2\u00a3\u0007o\u0002\u0002\u00a3\u00a4\u0007c\u0002\u0002\u00a4",
    "\u00a5\u0007e\u0002\u0002\u00a5\u00a6\u0007t\u0002\u0002\u00a6\u00a7",
    "\u0007q\u0002\u0002\u00a7\u001e\u0003\u0002\u0002\u0002\u00a8\u00a9",
    "\u0007u\u0002\u0002\u00a9\u00aa\u0007v\u0002\u0002\u00aa\u00ab\u0007",
    "c\u0002\u0002\u00ab\u00ac\u0007v\u0002\u0002\u00ac\u00ad\u0007g\u0002",
    "\u0002\u00ad \u0003\u0002\u0002\u0002\u00ae\u00af\u0007h\u0002\u0002",
    "\u00af\u00b0\u0007q\u0002\u0002\u00b0\u00b1\u0007t\u0002\u0002\u00b1",
    "\"\u0003\u0002\u0002\u0002\u00b2\u00b3\u0007k\u0002\u0002\u00b3\u00b4",
    "\u0007p\u0002\u0002\u00b4$\u0003\u0002\u0002\u0002\u00b5\u00b6\u0007",
    "k\u0002\u0002\u00b6\u00b7\u0007h\u0002\u0002\u00b7&\u0003\u0002\u0002",
    "\u0002\u00b8\u00b9\u0007g\u0002\u0002\u00b9\u00ba\u0007n\u0002\u0002",
    "\u00ba\u00bb\u0007u\u0002\u0002\u00bb\u00bc\u0007g\u0002\u0002\u00bc",
    "(\u0003\u0002\u0002\u0002\u00bd\u00be\u0007n\u0002\u0002\u00be\u00bf",
    "\u0007q\u0002\u0002\u00bf\u00c0\u0007e\u0002\u0002\u00c0\u00c1\u0007",
    "c\u0002\u0002\u00c1\u00c2\u0007n\u0002\u0002\u00c2*\u0003\u0002\u0002",
    "\u0002\u00c3\u00c4\u0007e\u0002\u0002\u00c4\u00c5\u0007q\u0002\u0002",
    "\u00c5\u00c6\u0007p\u0002\u0002\u00c6\u00c7\u0007u\u0002\u0002\u00c7",
    "\u00c8\u0007v\u0002\u0002\u00c8\u00c9\u0007c\u0002\u0002\u00c9\u00ca",
    "\u0007p\u0002\u0002\u00ca\u00cb\u0007v\u0002\u0002\u00cb,\u0003\u0002",
    "\u0002\u0002\u00cc\u00cd\u0007~\u0002\u0002\u00cd\u00d1\u0007~\u0002",
    "\u0002\u00ce\u00cf\u0007q\u0002\u0002\u00cf\u00d1\u0007t\u0002\u0002",
    "\u00d0\u00cc\u0003\u0002\u0002\u0002\u00d0\u00ce\u0003\u0002\u0002\u0002",
    "\u00d1.\u0003\u0002\u0002\u0002\u00d2\u00d3\u0007(\u0002\u0002\u00d3",
    "\u00d8\u0007(\u0002\u0002\u00d4\u00d5\u0007c\u0002\u0002\u00d5\u00d6",
    "\u0007p\u0002\u0002\u00d6\u00d8\u0007f\u0002\u0002\u00d7\u00d2\u0003",
    "\u0002\u0002\u0002\u00d7\u00d4\u0003\u0002\u0002\u0002\u00d80\u0003",
    "\u0002\u0002\u0002\u00d9\u00de\u0007#\u0002\u0002\u00da\u00db\u0007",
    "p\u0002\u0002\u00db\u00dc\u0007q\u0002\u0002\u00dc\u00de\u0007v\u0002",
    "\u0002\u00dd\u00d9\u0003\u0002\u0002\u0002\u00dd\u00da\u0003\u0002\u0002",
    "\u0002\u00de2\u0003\u0002\u0002\u0002\u00df\u00e0\u0007]\u0002\u0002",
    "\u00e04\u0003\u0002\u0002\u0002\u00e1\u00e2\u0007_\u0002\u0002\u00e2",
    "6\u0003\u0002\u0002\u0002\u00e3\u00e5\u0005\t\u0005\u0002\u00e4\u00e3",
    "\u0003\u0002\u0002\u0002\u00e5\u00e6\u0003\u0002\u0002\u0002\u00e6\u00e4",
    "\u0003\u0002\u0002\u0002\u00e6\u00e7\u0003\u0002\u0002\u0002\u00e7\u00e8",
    "\u0003\u0002\u0002\u0002\u00e8\u00ec\u0005I%\u0002\u00e9\u00eb\u0005",
    "\t\u0005\u0002\u00ea\u00e9\u0003\u0002\u0002\u0002\u00eb\u00ee\u0003",
    "\u0002\u0002\u0002\u00ec\u00ea\u0003\u0002\u0002\u0002\u00ec\u00ed\u0003",
    "\u0002\u0002\u0002\u00ed\u00f8\u0003\u0002\u0002\u0002\u00ee\u00ec\u0003",
    "\u0002\u0002\u0002\u00ef\u00f1\t\u0005\u0002\u0002\u00f0\u00f2\t\u0006",
    "\u0002\u0002\u00f1\u00f0\u0003\u0002\u0002\u0002\u00f1\u00f2\u0003\u0002",
    "\u0002\u0002\u00f2\u00f4\u0003\u0002\u0002\u0002\u00f3\u00f5\u0005\t",
    "\u0005\u0002\u00f4\u00f3\u0003\u0002\u0002\u0002\u00f5\u00f6\u0003\u0002",
    "\u0002\u0002\u00f6\u00f4\u0003\u0002\u0002\u0002\u00f6\u00f7\u0003\u0002",
    "\u0002\u0002\u00f7\u00f9\u0003\u0002\u0002\u0002\u00f8\u00ef\u0003\u0002",
    "\u0002\u0002\u00f8\u00f9\u0003\u0002\u0002\u0002\u00f9\u011a\u0003\u0002",
    "\u0002\u0002\u00fa\u00fc\u0005I%\u0002\u00fb\u00fd\u0005\t\u0005\u0002",
    "\u00fc\u00fb\u0003\u0002\u0002\u0002\u00fd\u00fe\u0003\u0002\u0002\u0002",
    "\u00fe\u00fc\u0003\u0002\u0002\u0002\u00fe\u00ff\u0003\u0002\u0002\u0002",
    "\u00ff\u0109\u0003\u0002\u0002\u0002\u0100\u0102\t\u0005\u0002\u0002",
    "\u0101\u0103\t\u0006\u0002\u0002\u0102\u0101\u0003\u0002\u0002\u0002",
    "\u0102\u0103\u0003\u0002\u0002\u0002\u0103\u0105\u0003\u0002\u0002\u0002",
    "\u0104\u0106\u0005\t\u0005\u0002\u0105\u0104\u0003\u0002\u0002\u0002",
    "\u0106\u0107\u0003\u0002\u0002\u0002\u0107\u0105\u0003\u0002\u0002\u0002",
    "\u0107\u0108\u0003\u0002\u0002\u0002\u0108\u010a\u0003\u0002\u0002\u0002",
    "\u0109\u0100\u0003\u0002\u0002\u0002\u0109\u010a\u0003\u0002\u0002\u0002",
    "\u010a\u011a\u0003\u0002\u0002\u0002\u010b\u010d\u0005\t\u0005\u0002",
    "\u010c\u010b\u0003\u0002\u0002\u0002\u010d\u010e\u0003\u0002\u0002\u0002",
    "\u010e\u010c\u0003\u0002\u0002\u0002\u010e\u010f\u0003\u0002\u0002\u0002",
    "\u010f\u0110\u0003\u0002\u0002\u0002\u0110\u0112\t\u0005\u0002\u0002",
    "\u0111\u0113\t\u0006\u0002\u0002\u0112\u0111\u0003\u0002\u0002\u0002",
    "\u0112\u0113\u0003\u0002\u0002\u0002\u0113\u0115\u0003\u0002\u0002\u0002",
    "\u0114\u0116\u0005\t\u0005\u0002\u0115\u0114\u0003\u0002\u0002\u0002",
    "\u0116\u0117\u0003\u0002\u0002\u0002\u0117\u0115\u0003\u0002\u0002\u0002",
    "\u0117\u0118\u0003\u0002\u0002\u0002\u0118\u011a\u0003\u0002\u0002\u0002",
    "\u0119\u00e4\u0003\u0002\u0002\u0002\u0119\u00fa\u0003\u0002\u0002\u0002",
    "\u0119\u010c\u0003\u0002\u0002\u0002\u011a8\u0003\u0002\u0002\u0002",
    "\u011b\u011d\u0005\t\u0005\u0002\u011c\u011b\u0003\u0002\u0002\u0002",
    "\u011d\u011e\u0003\u0002\u0002\u0002\u011e\u011c\u0003\u0002\u0002\u0002",
    "\u011e\u011f\u0003\u0002\u0002\u0002\u011f:\u0003\u0002\u0002\u0002",
    "\u0120\u0122\t\u0007\u0002\u0002\u0121\u0120\u0003\u0002\u0002\u0002",
    "\u0122\u0125\u0003\u0002\u0002\u0002\u0123\u0121\u0003\u0002\u0002\u0002",
    "\u0123\u0124\u0003\u0002\u0002\u0002\u0124\u0128\u0003\u0002\u0002\u0002",
    "\u0125\u0123\u0003\u0002\u0002\u0002\u0126\u0129\u0005\u0005\u0003\u0002",
    "\u0127\u0129\u0005\u0007\u0004\u0002\u0128\u0126\u0003\u0002\u0002\u0002",
    "\u0128\u0127\u0003\u0002\u0002\u0002\u0129\u012d\u0003\u0002\u0002\u0002",
    "\u012a\u012c\t\b\u0002\u0002\u012b\u012a\u0003\u0002\u0002\u0002\u012c",
    "\u012f\u0003\u0002\u0002\u0002\u012d\u012b\u0003\u0002\u0002\u0002\u012d",
    "\u012e\u0003\u0002\u0002\u0002\u012e<\u0003\u0002\u0002\u0002\u012f",
    "\u012d\u0003\u0002\u0002\u0002\u0130\u0131\u0007-\u0002\u0002\u0131",
    ">\u0003\u0002\u0002\u0002\u0132\u0133\u0007/\u0002\u0002\u0133@\u0003",
    "\u0002\u0002\u0002\u0134\u0135\u0007,\u0002\u0002\u0135B\u0003\u0002",
    "\u0002\u0002\u0136\u0137\u00071\u0002\u0002\u0137D\u0003\u0002\u0002",
    "\u0002\u0138\u0139\u0007*\u0002\u0002\u0139F\u0003\u0002\u0002\u0002",
    "\u013a\u013b\u0007+\u0002\u0002\u013bH\u0003\u0002\u0002\u0002\u013c",
    "\u013d\u00070\u0002\u0002\u013dJ\u0003\u0002\u0002\u0002\u013e\u013f",
    "\u0007.\u0002\u0002\u013fL\u0003\u0002\u0002\u0002\u0140\u0141\u0007",
    "`\u0002\u0002\u0141N\u0003\u0002\u0002\u0002\u0142\u0143\u0007>\u0002",
    "\u0002\u0143P\u0003\u0002\u0002\u0002\u0144\u0145\u0007@\u0002\u0002",
    "\u0145R\u0003\u0002\u0002\u0002\u0146\u0147\u0007>\u0002\u0002\u0147",
    "\u0148\u0007?\u0002\u0002\u0148T\u0003\u0002\u0002\u0002\u0149\u014a",
    "\u0007@\u0002\u0002\u014a\u014b\u0007?\u0002\u0002\u014bV\u0003\u0002",
    "\u0002\u0002\u014c\u014d\u0007#\u0002\u0002\u014d\u014e\u0007?\u0002",
    "\u0002\u014eX\u0003\u0002\u0002\u0002\u014f\u0150\u0007?\u0002\u0002",
    "\u0150Z\u0003\u0002\u0002\u0002\u0151\u0152\u0007=\u0002\u0002\u0152",
    "\\\u0003\u0002\u0002\u0002\u0153\u0154\u0007<\u0002\u0002\u0154^\u0003",
    "\u0002\u0002\u0002\u0155\u0156\u0007}\u0002\u0002\u0156`\u0003\u0002",
    "\u0002\u0002\u0157\u0158\u0007\u007f\u0002\u0002\u0158b\u0003\u0002",
    "\u0002\u0002\u0159\u015a\u0007)\u0002\u0002\u015ad\u0003\u0002\u0002",
    "\u0002\u015b\u015c\u0007A\u0002\u0002\u015cf\u0003\u0002\u0002\u0002",
    "\u015d\u015f\u0007\u000f\u0002\u0002\u015e\u015d\u0003\u0002\u0002\u0002",
    "\u015e\u015f\u0003\u0002\u0002\u0002\u015f\u0160\u0003\u0002\u0002\u0002",
    "\u0160\u0163\u0007\f\u0002\u0002\u0161\u0163\u0007\u000f\u0002\u0002",
    "\u0162\u015e\u0003\u0002\u0002\u0002\u0162\u0161\u0003\u0002\u0002\u0002",
    "\u0163\u0164\u0003\u0002\u0002\u0002\u0164\u0162\u0003\u0002\u0002\u0002",
    "\u0164\u0165\u0003\u0002\u0002\u0002\u0165\u0166\u0003\u0002\u0002\u0002",
    "\u0166\u0167\b4\u0002\u0002\u0167h\u0003\u0002\u0002\u0002\u0168\u016a",
    "\t\t\u0002\u0002\u0169\u0168\u0003\u0002\u0002\u0002\u016a\u016b\u0003",
    "\u0002\u0002\u0002\u016b\u0169\u0003\u0002\u0002\u0002\u016b\u016c\u0003",
    "\u0002\u0002\u0002\u016c\u016d\u0003\u0002\u0002\u0002\u016d\u016e\b",
    "5\u0002\u0002\u016ej\u0003\u0002\u0002\u0002\u016f\u0170\u00071\u0002",
    "\u0002\u0170\u0171\u00071\u0002\u0002\u0171\u0175\u0003\u0002\u0002",
    "\u0002\u0172\u0174\n\n\u0002\u0002\u0173\u0172\u0003\u0002\u0002\u0002",
    "\u0174\u0177\u0003\u0002\u0002\u0002\u0175\u0173\u0003\u0002\u0002\u0002",
    "\u0175\u0176\u0003\u0002\u0002\u0002\u0176\u017d\u0003\u0002\u0002\u0002",
    "\u0177\u0175\u0003\u0002\u0002\u0002\u0178\u017a\u0007\u000f\u0002\u0002",
    "\u0179\u0178\u0003\u0002\u0002\u0002\u0179\u017a\u0003\u0002\u0002\u0002",
    "\u017a\u017b\u0003\u0002\u0002\u0002\u017b\u017e\u0007\f\u0002\u0002",
    "\u017c\u017e\u0007t\u0002\u0002\u017d\u0179\u0003\u0002\u0002\u0002",
    "\u017d\u017c\u0003\u0002\u0002\u0002\u017e\u018b\u0003\u0002\u0002\u0002",
    "\u017f\u0180\u00071\u0002\u0002\u0180\u0181\u0007,\u0002\u0002\u0181",
    "\u0185\u0003\u0002\u0002\u0002\u0182\u0184\u000b\u0002\u0002\u0002\u0183",
    "\u0182\u0003\u0002\u0002\u0002\u0184\u0187\u0003\u0002\u0002\u0002\u0185",
    "\u0186\u0003\u0002\u0002\u0002\u0185\u0183\u0003\u0002\u0002\u0002\u0186",
    "\u0188\u0003\u0002\u0002\u0002\u0187\u0185\u0003\u0002\u0002\u0002\u0188",
    "\u0189\u0007,\u0002\u0002\u0189\u018b\u00071\u0002\u0002\u018a\u016f",
    "\u0003\u0002\u0002\u0002\u018a\u017f\u0003\u0002\u0002\u0002\u018b\u018c",
    "\u0003\u0002\u0002\u0002\u018c\u018d\b6\u0002\u0002\u018dl\u0003\u0002",
    "\u0002\u0002 \u0002\u00d0\u00d7\u00dd\u00e6\u00ec\u00f1\u00f6\u00f8",
    "\u00fe\u0102\u0107\u0109\u010e\u0112\u0117\u0119\u011e\u0123\u0128\u012d",
    "\u015e\u0162\u0164\u016b\u0175\u0179\u017d\u0185\u018a\u0003\b\u0002",
    "\u0002"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

function odeGrammarLexer(input) {
	antlr4.Lexer.call(this, input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
    return this;
}

odeGrammarLexer.prototype = Object.create(antlr4.Lexer.prototype);
odeGrammarLexer.prototype.constructor = odeGrammarLexer;

Object.defineProperty(odeGrammarLexer.prototype, "atn", {
        get : function() {
                return atn;
        }
});

odeGrammarLexer.EOF = antlr4.Token.EOF;
odeGrammarLexer.T__0 = 1;
odeGrammarLexer.T0 = 2;
odeGrammarLexer.SET = 3;
odeGrammarLexer.ON = 4;
odeGrammarLexer.FROM = 5;
odeGrammarLexer.DER = 6;
odeGrammarLexer.TERMINAL = 7;
odeGrammarLexer.TRUE = 8;
odeGrammarLexer.FALSE = 9;
odeGrammarLexer.SUM = 10;
odeGrammarLexer.MACRO = 11;
odeGrammarLexer.STATE = 12;
odeGrammarLexer.FOR = 13;
odeGrammarLexer.IN = 14;
odeGrammarLexer.IF = 15;
odeGrammarLexer.ELSE = 16;
odeGrammarLexer.LOCAL = 17;
odeGrammarLexer.CONSTANT = 18;
odeGrammarLexer.OR = 19;
odeGrammarLexer.AND = 20;
odeGrammarLexer.NOT = 21;
odeGrammarLexer.LSQR = 22;
odeGrammarLexer.RSQR = 23;
odeGrammarLexer.FLOAT = 24;
odeGrammarLexer.INT = 25;
odeGrammarLexer.ID = 26;
odeGrammarLexer.PLUS = 27;
odeGrammarLexer.MINUS = 28;
odeGrammarLexer.ASTERISK = 29;
odeGrammarLexer.DIVISION = 30;
odeGrammarLexer.LPAREN = 31;
odeGrammarLexer.RPAREN = 32;
odeGrammarLexer.DOT = 33;
odeGrammarLexer.COMMA = 34;
odeGrammarLexer.CARET = 35;
odeGrammarLexer.L = 36;
odeGrammarLexer.G = 37;
odeGrammarLexer.LE = 38;
odeGrammarLexer.GE = 39;
odeGrammarLexer.NE = 40;
odeGrammarLexer.E = 41;
odeGrammarLexer.SEMICOLON = 42;
odeGrammarLexer.COLON = 43;
odeGrammarLexer.LCRL = 44;
odeGrammarLexer.RCRL = 45;
odeGrammarLexer.APOSTROPHE = 46;
odeGrammarLexer.QUESTIONMARK = 47;
odeGrammarLexer.NEWLINE = 48;
odeGrammarLexer.WHITESPACE = 49;
odeGrammarLexer.COMMENT = 50;

odeGrammarLexer.prototype.channelNames = [ "DEFAULT_TOKEN_CHANNEL", "HIDDEN" ];

odeGrammarLexer.prototype.modeNames = [ "DEFAULT_MODE" ];

odeGrammarLexer.prototype.literalNames = [ null, "'#'", "'(t0)'", "'set'", 
                                           "'on'", "'from'", "'der'", "'terminal'", 
                                           "'true'", "'false'", "'sum'", 
                                           "'macro'", "'state'", "'for'", 
                                           "'in'", "'if'", "'else'", "'local'", 
                                           "'constant'", null, null, null, 
                                           "'['", "']'", null, null, null, 
                                           "'+'", "'-'", "'*'", "'/'", "'('", 
                                           "')'", "'.'", "','", "'^'", "'<'", 
                                           "'>'", "'<='", "'>='", "'!='", 
                                           "'='", "';'", "':'", "'{'", "'}'", 
                                           "'''", "'?'" ];

odeGrammarLexer.prototype.symbolicNames = [ null, null, "T0", "SET", "ON", 
                                            "FROM", "DER", "TERMINAL", "TRUE", 
                                            "FALSE", "SUM", "MACRO", "STATE", 
                                            "FOR", "IN", "IF", "ELSE", "LOCAL", 
                                            "CONSTANT", "OR", "AND", "NOT", 
                                            "LSQR", "RSQR", "FLOAT", "INT", 
                                            "ID", "PLUS", "MINUS", "ASTERISK", 
                                            "DIVISION", "LPAREN", "RPAREN", 
                                            "DOT", "COMMA", "CARET", "L", 
                                            "G", "LE", "GE", "NE", "E", 
                                            "SEMICOLON", "COLON", "LCRL", 
                                            "RCRL", "APOSTROPHE", "QUESTIONMARK", 
                                            "NEWLINE", "WHITESPACE", "COMMENT" ];

odeGrammarLexer.prototype.ruleNames = [ "T__0", "LOWERCASE", "UPPERCASE", 
                                        "DIGIT", "T0", "SET", "ON", "FROM", 
                                        "DER", "TERMINAL", "TRUE", "FALSE", 
                                        "SUM", "MACRO", "STATE", "FOR", 
                                        "IN", "IF", "ELSE", "LOCAL", "CONSTANT", 
                                        "OR", "AND", "NOT", "LSQR", "RSQR", 
                                        "FLOAT", "INT", "ID", "PLUS", "MINUS", 
                                        "ASTERISK", "DIVISION", "LPAREN", 
                                        "RPAREN", "DOT", "COMMA", "CARET", 
                                        "L", "G", "LE", "GE", "NE", "E", 
                                        "SEMICOLON", "COLON", "LCRL", "RCRL", 
                                        "APOSTROPHE", "QUESTIONMARK", "NEWLINE", 
                                        "WHITESPACE", "COMMENT" ];

odeGrammarLexer.prototype.grammarFileName = "odeGrammar.g4";


exports.odeGrammarLexer = odeGrammarLexer;



/***/ }),

/***/ "./src/grammar/antlrOutput/odeGrammarParser.js":
/*!*****************************************************!*\
  !*** ./src/grammar/antlrOutput/odeGrammarParser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated from e:\projects\SolversJS\src\grammar\odeGrammar.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = __webpack_require__(/*! antlr4/index */ "./node_modules/antlr4/index.js");
var odeGrammarVisitor = __webpack_require__(/*! ./odeGrammarVisitor */ "./src/grammar/antlrOutput/odeGrammarVisitor.js").odeGrammarVisitor;

var grammarFileName = "odeGrammar.g4";


var serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964",
    "\u00034\u0146\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004\t",
    "\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007\u0004",
    "\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f\u0004",
    "\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010\u0004",
    "\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013\u0004\u0014\t",
    "\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017\t\u0017\u0004",
    "\u0018\t\u0018\u0003\u0002\u0007\u00022\n\u0002\f\u0002\u000e\u0002",
    "5\u000b\u0002\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003",
    "\u0003\u0005\u0003<\n\u0003\u0003\u0004\u0007\u0004?\n\u0004\f\u0004",
    "\u000e\u0004B\u000b\u0004\u0003\u0005\u0003\u0005\u0003\u0006\u0003",
    "\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0005\u0006L",
    "\n\u0006\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\b\u0003",
    "\b\u0007\bT\n\b\f\b\u000e\bW\u000b\b\u0003\t\u0003\t\u0003\t\u0003\t",
    "\u0003\t\u0003\t\u0005\t_\n\t\u0003\n\u0003\n\u0007\nc\n\n\f\n\u000e",
    "\nf\u000b\n\u0003\n\u0003\n\u0003\u000b\u0003\u000b\u0003\u000b\u0003",
    "\u000b\u0003\u000b\u0003\u000b\u0005\u000bp\n\u000b\u0003\u000b\u0003",
    "\u000b\u0003\u000b\u0003\f\u0003\f\u0003\f\u0007\fx\n\f\f\f\u000e\f",
    "{\u000b\f\u0003\f\u0005\f~\n\f\u0003\r\u0003\r\u0003\r\u0003\r\u0003",
    "\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0003\u000e\u0006",
    "\u000e\u008a\n\u000e\r\u000e\u000e\u000e\u008b\u0003\u000e\u0003\u000e",
    "\u0003\u000e\u0003\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0005\u000f",
    "\u0095\n\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0003",
    "\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003\u0010\u0003",
    "\u0010\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0003",
    "\u0011\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003\u0012\u0003",
    "\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005",
    "\u0013\u00b3\n\u0013\u0003\u0014\u0005\u0014\u00b6\n\u0014\u0003\u0014",
    "\u0003\u0014\u0003\u0014\u0003\u0014\u0007\u0014\u00bc\n\u0014\f\u0014",
    "\u000e\u0014\u00bf\u000b\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0003",
    "\u0014\u0003\u0014\u0007\u0014\u00c6\n\u0014\f\u0014\u000e\u0014\u00c9",
    "\u000b\u0014\u0003\u0015\u0003\u0015\u0003\u0015\u0007\u0015\u00ce\n",
    "\u0015\f\u0015\u000e\u0015\u00d1\u000b\u0015\u0003\u0015\u0003\u0015",
    "\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0016",
    "\u0003\u0016\u0005\u0016\u00e8\n\u0016\u0003\u0016\u0003\u0016\u0003",
    "\u0016\u0003\u0016\u0003\u0016\u0003\u0016\u0007\u0016\u00f0\n\u0016",
    "\f\u0016\u000e\u0016\u00f3\u000b\u0016\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0005\u0017\u0108",
    "\n\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017",
    "\u0007\u0017\u010f\n\u0017\f\u0017\u000e\u0017\u0112\u000b\u0017\u0003",
    "\u0017\u0005\u0017\u0115\n\u0017\u0003\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017",
    "\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0005\u0017",
    "\u012b\n\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003",
    "\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0003\u0017\u0007\u0017\u0136",
    "\n\u0017\f\u0017\u000e\u0017\u0139\u000b\u0017\u0003\u0018\u0003\u0018",
    "\u0003\u0018\u0007\u0018\u013e\n\u0018\f\u0018\u000e\u0018\u0141\u000b",
    "\u0018\u0003\u0018\u0005\u0018\u0144\n\u0018\u0003\u0018\u0002\u0004",
    "*,\u0019\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018",
    "\u001a\u001c\u001e \"$&(*,.\u0002\b\u0003\u0002\u001a\u001b\u0003\u0002",
    "&)\u0003\u0002*+\u0003\u0002\n\u000b\u0003\u0002\u001d\u001e\u0003\u0002",
    "\u001f \u0002\u0163\u00023\u0003\u0002\u0002\u0002\u0004;\u0003\u0002",
    "\u0002\u0002\u0006@\u0003\u0002\u0002\u0002\bC\u0003\u0002\u0002\u0002",
    "\nK\u0003\u0002\u0002\u0002\fM\u0003\u0002\u0002\u0002\u000eQ\u0003",
    "\u0002\u0002\u0002\u0010^\u0003\u0002\u0002\u0002\u0012`\u0003\u0002",
    "\u0002\u0002\u0014i\u0003\u0002\u0002\u0002\u0016}\u0003\u0002\u0002",
    "\u0002\u0018\u007f\u0003\u0002\u0002\u0002\u001a\u0083\u0003\u0002\u0002",
    "\u0002\u001c\u0094\u0003\u0002\u0002\u0002\u001e\u009b\u0003\u0002\u0002",
    "\u0002 \u00a1\u0003\u0002\u0002\u0002\"\u00a7\u0003\u0002\u0002\u0002",
    "$\u00b2\u0003\u0002\u0002\u0002&\u00b5\u0003\u0002\u0002\u0002(\u00ca",
    "\u0003\u0002\u0002\u0002*\u00e7\u0003\u0002\u0002\u0002,\u012a\u0003",
    "\u0002\u0002\u0002.\u0143\u0003\u0002\u0002\u000202\u0005\u0004\u0003",
    "\u000210\u0003\u0002\u0002\u000225\u0003\u0002\u0002\u000231\u0003\u0002",
    "\u0002\u000234\u0003\u0002\u0002\u00024\u0003\u0003\u0002\u0002\u0002",
    "53\u0003\u0002\u0002\u00026<\u0005\u001c\u000f\u00027<\u0005 \u0011",
    "\u00028<\u0005\"\u0012\u00029<\u0005\u0014\u000b\u0002:<\u0005\u001a",
    "\u000e\u0002;6\u0003\u0002\u0002\u0002;7\u0003\u0002\u0002\u0002;8\u0003",
    "\u0002\u0002\u0002;9\u0003\u0002\u0002\u0002;:\u0003\u0002\u0002\u0002",
    "<\u0005\u0003\u0002\u0002\u0002=?\u0005\n\u0006\u0002>=\u0003\u0002",
    "\u0002\u0002?B\u0003\u0002\u0002\u0002@>\u0003\u0002\u0002\u0002@A\u0003",
    "\u0002\u0002\u0002A\u0007\u0003\u0002\u0002\u0002B@\u0003\u0002\u0002",
    "\u0002CD\t\u0002\u0002\u0002D\t\u0003\u0002\u0002\u0002EL\u0005\u001c",
    "\u000f\u0002FL\u0005 \u0011\u0002GL\u0005\"\u0012\u0002HL\u0005\u0014",
    "\u000b\u0002IL\u0005\u001a\u000e\u0002JL\u0005&\u0014\u0002KE\u0003",
    "\u0002\u0002\u0002KF\u0003\u0002\u0002\u0002KG\u0003\u0002\u0002\u0002",
    "KH\u0003\u0002\u0002\u0002KI\u0003\u0002\u0002\u0002KJ\u0003\u0002\u0002",
    "\u0002L\u000b\u0003\u0002\u0002\u0002MN\u0007\u0018\u0002\u0002NO\u0005",
    ",\u0017\u0002OP\u0007\u0019\u0002\u0002P\r\u0003\u0002\u0002\u0002Q",
    "U\u0007\u001c\u0002\u0002RT\u0005\f\u0007\u0002SR\u0003\u0002\u0002",
    "\u0002TW\u0003\u0002\u0002\u0002US\u0003\u0002\u0002\u0002UV\u0003\u0002",
    "\u0002\u0002V\u000f\u0003\u0002\u0002\u0002WU\u0003\u0002\u0002\u0002",
    "X_\u0005\u001c\u000f\u0002Y_\u0005 \u0011\u0002Z_\u0005\u0014\u000b",
    "\u0002[_\u0005\"\u0012\u0002\\_\u0005\u001e\u0010\u0002]_\u0005\u001a",
    "\u000e\u0002^X\u0003\u0002\u0002\u0002^Y\u0003\u0002\u0002\u0002^Z\u0003",
    "\u0002\u0002\u0002^[\u0003\u0002\u0002\u0002^\\\u0003\u0002\u0002\u0002",
    "^]\u0003\u0002\u0002\u0002_\u0011\u0003\u0002\u0002\u0002`d\u0007.\u0002",
    "\u0002ac\u0005\u0010\t\u0002ba\u0003\u0002\u0002\u0002cf\u0003\u0002",
    "\u0002\u0002db\u0003\u0002\u0002\u0002de\u0003\u0002\u0002\u0002eg\u0003",
    "\u0002\u0002\u0002fd\u0003\u0002\u0002\u0002gh\u0007/\u0002\u0002h\u0013",
    "\u0003\u0002\u0002\u0002ij\u0007\r\u0002\u0002jo\u0005\u000e\b\u0002",
    "kl\u0007!\u0002\u0002lm\u0005\u0016\f\u0002mn\u0007\"\u0002\u0002np",
    "\u0003\u0002\u0002\u0002ok\u0003\u0002\u0002\u0002op\u0003\u0002\u0002",
    "\u0002pq\u0003\u0002\u0002\u0002qr\u0005,\u0017\u0002rs\u0007,\u0002",
    "\u0002s\u0015\u0003\u0002\u0002\u0002ty\u0007\u001c\u0002\u0002uv\u0007",
    "$\u0002\u0002vx\u0007\u001c\u0002\u0002wu\u0003\u0002\u0002\u0002x{",
    "\u0003\u0002\u0002\u0002yw\u0003\u0002\u0002\u0002yz\u0003\u0002\u0002",
    "\u0002z~\u0003\u0002\u0002\u0002{y\u0003\u0002\u0002\u0002|~\u0003\u0002",
    "\u0002\u0002}t\u0003\u0002\u0002\u0002}|\u0003\u0002\u0002\u0002~\u0017",
    "\u0003\u0002\u0002\u0002\u007f\u0080\u0007\u001b\u0002\u0002\u0080\u0081",
    "\u0007-\u0002\u0002\u0081\u0082\u0007\u001b\u0002\u0002\u0082\u0019",
    "\u0003\u0002\u0002\u0002\u0083\u0084\u0007\u000f\u0002\u0002\u0084\u0085",
    "\u0007!\u0002\u0002\u0085\u0086\u0007\u001c\u0002\u0002\u0086\u0087",
    "\u0007\u0010\u0002\u0002\u0087\u0089\u0007\u0018\u0002\u0002\u0088\u008a",
    "\u0005\u0018\r\u0002\u0089\u0088\u0003\u0002\u0002\u0002\u008a\u008b",
    "\u0003\u0002\u0002\u0002\u008b\u0089\u0003\u0002\u0002\u0002\u008b\u008c",
    "\u0003\u0002\u0002\u0002\u008c\u008d\u0003\u0002\u0002\u0002\u008d\u008e",
    "\u0007\u0019\u0002\u0002\u008e\u008f\u0007\"\u0002\u0002\u008f\u0090",
    "\u0005\u0012\n\u0002\u0090\u001b\u0003\u0002\u0002\u0002\u0091\u0092",
    "\u0005\u000e\b\u0002\u0092\u0093\u0007-\u0002\u0002\u0093\u0095\u0003",
    "\u0002\u0002\u0002\u0094\u0091\u0003\u0002\u0002\u0002\u0094\u0095\u0003",
    "\u0002\u0002\u0002\u0095\u0096\u0003\u0002\u0002\u0002\u0096\u0097\u0005",
    ",\u0017\u0002\u0097\u0098\u0007+\u0002\u0002\u0098\u0099\u0005,\u0017",
    "\u0002\u0099\u009a\u0007,\u0002\u0002\u009a\u001d\u0003\u0002\u0002",
    "\u0002\u009b\u009c\u0007\u0005\u0002\u0002\u009c\u009d\u0005\u000e\b",
    "\u0002\u009d\u009e\u0007+\u0002\u0002\u009e\u009f\u0005,\u0017\u0002",
    "\u009f\u00a0\u0007,\u0002\u0002\u00a0\u001f\u0003\u0002\u0002\u0002",
    "\u00a1\u00a2\u0005\u000e\b\u0002\u00a2\u00a3\u0007\u0004\u0002\u0002",
    "\u00a3\u00a4\u0007+\u0002\u0002\u00a4\u00a5\u0005,\u0017\u0002\u00a5",
    "\u00a6\u0007,\u0002\u0002\u00a6!\u0003\u0002\u0002\u0002\u00a7\u00a8",
    "\u0007\u0014\u0002\u0002\u00a8\u00a9\u0005\u000e\b\u0002\u00a9\u00aa",
    "\u0007+\u0002\u0002\u00aa\u00ab\u0005,\u0017\u0002\u00ab\u00ac\u0007",
    ",\u0002\u0002\u00ac#\u0003\u0002\u0002\u0002\u00ad\u00b3\u0005\u001c",
    "\u000f\u0002\u00ae\u00b3\u0005\u001e\u0010\u0002\u00af\u00b3\u0005\u001a",
    "\u000e\u0002\u00b0\u00b3\u0005\u0014\u000b\u0002\u00b1\u00b3\u0005\"",
    "\u0012\u0002\u00b2\u00ad\u0003\u0002\u0002\u0002\u00b2\u00ae\u0003\u0002",
    "\u0002\u0002\u00b2\u00af\u0003\u0002\u0002\u0002\u00b2\u00b0\u0003\u0002",
    "\u0002\u0002\u00b2\u00b1\u0003\u0002\u0002\u0002\u00b3%\u0003\u0002",
    "\u0002\u0002\u00b4\u00b6\u0007\t\u0002\u0002\u00b5\u00b4\u0003\u0002",
    "\u0002\u0002\u00b5\u00b6\u0003\u0002\u0002\u0002\u00b6\u00b7\u0003\u0002",
    "\u0002\u0002\u00b7\u00b8\u0007\u000e\u0002\u0002\u00b8\u00b9\u0007\u001c",
    "\u0002\u0002\u00b9\u00bd\u0007.\u0002\u0002\u00ba\u00bc\u0005$\u0013",
    "\u0002\u00bb\u00ba\u0003\u0002\u0002\u0002\u00bc\u00bf\u0003\u0002\u0002",
    "\u0002\u00bd\u00bb\u0003\u0002\u0002\u0002\u00bd\u00be\u0003\u0002\u0002",
    "\u0002\u00be\u00c0\u0003\u0002\u0002\u0002\u00bf\u00bd\u0003\u0002\u0002",
    "\u0002\u00c0\u00c1\u0007/\u0002\u0002\u00c1\u00c2\u0007\u0007\u0002",
    "\u0002\u00c2\u00c7\u0005(\u0015\u0002\u00c3\u00c4\u0007$\u0002\u0002",
    "\u00c4\u00c6\u0005(\u0015\u0002\u00c5\u00c3\u0003\u0002\u0002\u0002",
    "\u00c6\u00c9\u0003\u0002\u0002\u0002\u00c7\u00c5\u0003\u0002\u0002\u0002",
    "\u00c7\u00c8\u0003\u0002\u0002\u0002\u00c8\'\u0003\u0002\u0002\u0002",
    "\u00c9\u00c7\u0003\u0002\u0002\u0002\u00ca\u00cf\u0007\u001c\u0002\u0002",
    "\u00cb\u00cc\u0007$\u0002\u0002\u00cc\u00ce\u0007\u001c\u0002\u0002",
    "\u00cd\u00cb\u0003\u0002\u0002\u0002\u00ce\u00d1\u0003\u0002\u0002\u0002",
    "\u00cf\u00cd\u0003\u0002\u0002\u0002\u00cf\u00d0\u0003\u0002\u0002\u0002",
    "\u00d0\u00d2\u0003\u0002\u0002\u0002\u00d1\u00cf\u0003\u0002\u0002\u0002",
    "\u00d2\u00d3\u0007\u0006\u0002\u0002\u00d3\u00d4\u0007!\u0002\u0002",
    "\u00d4\u00d5\u0005*\u0016\u0002\u00d5\u00d6\u0007\"\u0002\u0002\u00d6",
    ")\u0003\u0002\u0002\u0002\u00d7\u00d8\b\u0016\u0001\u0002\u00d8\u00d9",
    "\u0007!\u0002\u0002\u00d9\u00da\u0005*\u0016\u0002\u00da\u00db\u0007",
    "\"\u0002\u0002\u00db\u00e8\u0003\u0002\u0002\u0002\u00dc\u00dd\u0007",
    "\u0017\u0002\u0002\u00dd\u00e8\u0005*\u0016\b\u00de\u00df\u0005,\u0017",
    "\u0002\u00df\u00e0\t\u0003\u0002\u0002\u00e0\u00e1\u0005,\u0017\u0002",
    "\u00e1\u00e8\u0003\u0002\u0002\u0002\u00e2\u00e3\u0005,\u0017\u0002",
    "\u00e3\u00e4\t\u0004\u0002\u0002\u00e4\u00e5\u0005,\u0017\u0002\u00e5",
    "\u00e8\u0003\u0002\u0002\u0002\u00e6\u00e8\t\u0005\u0002\u0002\u00e7",
    "\u00d7\u0003\u0002\u0002\u0002\u00e7\u00dc\u0003\u0002\u0002\u0002\u00e7",
    "\u00de\u0003\u0002\u0002\u0002\u00e7\u00e2\u0003\u0002\u0002\u0002\u00e7",
    "\u00e6\u0003\u0002\u0002\u0002\u00e8\u00f1\u0003\u0002\u0002\u0002\u00e9",
    "\u00ea\f\u0005\u0002\u0002\u00ea\u00eb\u0007\u0016\u0002\u0002\u00eb",
    "\u00f0\u0005*\u0016\u0006\u00ec\u00ed\f\u0004\u0002\u0002\u00ed\u00ee",
    "\u0007\u0015\u0002\u0002\u00ee\u00f0\u0005*\u0016\u0005\u00ef\u00e9",
    "\u0003\u0002\u0002\u0002\u00ef\u00ec\u0003\u0002\u0002\u0002\u00f0\u00f3",
    "\u0003\u0002\u0002\u0002\u00f1\u00ef\u0003\u0002\u0002\u0002\u00f1\u00f2",
    "\u0003\u0002\u0002\u0002\u00f2+\u0003\u0002\u0002\u0002\u00f3\u00f1",
    "\u0003\u0002\u0002\u0002\u00f4\u00f5\b\u0017\u0001\u0002\u00f5\u00f6",
    "\u0007!\u0002\u0002\u00f6\u00f7\u0005,\u0017\u0002\u00f7\u00f8\u0007",
    "\"\u0002\u0002\u00f8\u012b\u0003\u0002\u0002\u0002\u00f9\u00fa\u0007",
    "\b\u0002\u0002\u00fa\u00fb\u0007!\u0002\u0002\u00fb\u00fc\u0005\u000e",
    "\b\u0002\u00fc\u00fd\u0007\"\u0002\u0002\u00fd\u012b\u0003\u0002\u0002",
    "\u0002\u00fe\u00ff\u0007\u001c\u0002\u0002\u00ff\u0100\u0007!\u0002",
    "\u0002\u0100\u0101\u0005.\u0018\u0002\u0101\u0102\u0007\"\u0002\u0002",
    "\u0102\u012b\u0003\u0002\u0002\u0002\u0103\u0104\t\u0006\u0002\u0002",
    "\u0104\u012b\u0005,\u0017\n\u0105\u0107\u0005\u000e\b\u0002\u0106\u0108",
    "\u00070\u0002\u0002\u0107\u0106\u0003\u0002\u0002\u0002\u0107\u0108",
    "\u0003\u0002\u0002\u0002\u0108\u012b\u0003\u0002\u0002\u0002\u0109\u012b",
    "\u0005\b\u0005\u0002\u010a\u010b\u0007\u0003\u0002\u0002\u010b\u0114",
    "\u0005\u000e\b\u0002\u010c\u0110\u0007!\u0002\u0002\u010d\u010f\u0005",
    ",\u0017\u0002\u010e\u010d\u0003\u0002\u0002\u0002\u010f\u0112\u0003",
    "\u0002\u0002\u0002\u0110\u010e\u0003\u0002\u0002\u0002\u0110\u0111\u0003",
    "\u0002\u0002\u0002\u0111\u0113\u0003\u0002\u0002\u0002\u0112\u0110\u0003",
    "\u0002\u0002\u0002\u0113\u0115\u0007\"\u0002\u0002\u0114\u010c\u0003",
    "\u0002\u0002\u0002\u0114\u0115\u0003\u0002\u0002\u0002\u0115\u012b\u0003",
    "\u0002\u0002\u0002\u0116\u0117\u0007\f\u0002\u0002\u0117\u0118\u0007",
    "!\u0002\u0002\u0118\u0119\u0007\u001c\u0002\u0002\u0119\u011a\u0007",
    "\u0010\u0002\u0002\u011a\u011b\u0007\u0018\u0002\u0002\u011b\u011c\u0005",
    "\u0018\r\u0002\u011c\u011d\u0007\u0019\u0002\u0002\u011d\u011e\u0007",
    "\"\u0002\u0002\u011e\u011f\u0007.\u0002\u0002\u011f\u0120\u0005,\u0017",
    "\u0002\u0120\u0121\u0007/\u0002\u0002\u0121\u012b\u0003\u0002\u0002",
    "\u0002\u0122\u0123\u0007.\u0002\u0002\u0123\u0124\u0005*\u0016\u0002",
    "\u0124\u0125\u00071\u0002\u0002\u0125\u0126\u0005,\u0017\u0002\u0126",
    "\u0127\u0007-\u0002\u0002\u0127\u0128\u0005,\u0017\u0002\u0128\u0129",
    "\u0007/\u0002\u0002\u0129\u012b\u0003\u0002\u0002\u0002\u012a\u00f4",
    "\u0003\u0002\u0002\u0002\u012a\u00f9\u0003\u0002\u0002\u0002\u012a\u00fe",
    "\u0003\u0002\u0002\u0002\u012a\u0103\u0003\u0002\u0002\u0002\u012a\u0105",
    "\u0003\u0002\u0002\u0002\u012a\u0109\u0003\u0002\u0002\u0002\u012a\u010a",
    "\u0003\u0002\u0002\u0002\u012a\u0116\u0003\u0002\u0002\u0002\u012a\u0122",
    "\u0003\u0002\u0002\u0002\u012b\u0137\u0003\u0002\u0002\u0002\u012c\u012d",
    "\f\u000b\u0002\u0002\u012d\u012e\u0007%\u0002\u0002\u012e\u0136\u0005",
    ",\u0017\u000b\u012f\u0130\f\t\u0002\u0002\u0130\u0131\t\u0007\u0002",
    "\u0002\u0131\u0136\u0005,\u0017\n\u0132\u0133\f\b\u0002\u0002\u0133",
    "\u0134\t\u0006\u0002\u0002\u0134\u0136\u0005,\u0017\t\u0135\u012c\u0003",
    "\u0002\u0002\u0002\u0135\u012f\u0003\u0002\u0002\u0002\u0135\u0132\u0003",
    "\u0002\u0002\u0002\u0136\u0139\u0003\u0002\u0002\u0002\u0137\u0135\u0003",
    "\u0002\u0002\u0002\u0137\u0138\u0003\u0002\u0002\u0002\u0138-\u0003",
    "\u0002\u0002\u0002\u0139\u0137\u0003\u0002\u0002\u0002\u013a\u013f\u0005",
    ",\u0017\u0002\u013b\u013c\u0007$\u0002\u0002\u013c\u013e\u0005,\u0017",
    "\u0002\u013d\u013b\u0003\u0002\u0002\u0002\u013e\u0141\u0003\u0002\u0002",
    "\u0002\u013f\u013d\u0003\u0002\u0002\u0002\u013f\u0140\u0003\u0002\u0002",
    "\u0002\u0140\u0144\u0003\u0002\u0002\u0002\u0141\u013f\u0003\u0002\u0002",
    "\u0002\u0142\u0144\u0003\u0002\u0002\u0002\u0143\u013a\u0003\u0002\u0002",
    "\u0002\u0143\u0142\u0003\u0002\u0002\u0002\u0144/\u0003\u0002\u0002",
    "\u0002\u001e3;@KU^doy}\u008b\u0094\u00b2\u00b5\u00bd\u00c7\u00cf\u00e7",
    "\u00ef\u00f1\u0107\u0110\u0114\u012a\u0135\u0137\u013f\u0143"].join("");


var atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);

var decisionsToDFA = atn.decisionToState.map( function(ds, index) { return new antlr4.dfa.DFA(ds, index); });

var sharedContextCache = new antlr4.PredictionContextCache();

var literalNames = [ null, "'#'", "'(t0)'", "'set'", "'on'", "'from'", "'der'", 
                     "'terminal'", "'true'", "'false'", "'sum'", "'macro'", 
                     "'state'", "'for'", "'in'", "'if'", "'else'", "'local'", 
                     "'constant'", null, null, null, "'['", "']'", null, 
                     null, null, "'+'", "'-'", "'*'", "'/'", "'('", "')'", 
                     "'.'", "','", "'^'", "'<'", "'>'", "'<='", "'>='", 
                     "'!='", "'='", "';'", "':'", "'{'", "'}'", "'''", "'?'" ];

var symbolicNames = [ null, null, "T0", "SET", "ON", "FROM", "DER", "TERMINAL", 
                      "TRUE", "FALSE", "SUM", "MACRO", "STATE", "FOR", "IN", 
                      "IF", "ELSE", "LOCAL", "CONSTANT", "OR", "AND", "NOT", 
                      "LSQR", "RSQR", "FLOAT", "INT", "ID", "PLUS", "MINUS", 
                      "ASTERISK", "DIVISION", "LPAREN", "RPAREN", "DOT", 
                      "COMMA", "CARET", "L", "G", "LE", "GE", "NE", "E", 
                      "SEMICOLON", "COLON", "LCRL", "RCRL", "APOSTROPHE", 
                      "QUESTIONMARK", "NEWLINE", "WHITESPACE", "COMMENT" ];

var ruleNames =  [ "dae", "daeStatement", "hybrid", "number", "hybridStatement", 
                   "index", "varIdentifier", "loopStatement", "loopBody", 
                   "macroStatement", "macroArguments", "loopBounds", "loop", 
                   "equation", "setter", "initialCondition", "constantStatement", 
                   "stateStatement", "stateDef", "stateTransition", "boolExpression", 
                   "expression", "functionArguments" ];

function odeGrammarParser (input) {
	antlr4.Parser.call(this, input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = ruleNames;
    this.literalNames = literalNames;
    this.symbolicNames = symbolicNames;
    return this;
}

odeGrammarParser.prototype = Object.create(antlr4.Parser.prototype);
odeGrammarParser.prototype.constructor = odeGrammarParser;

Object.defineProperty(odeGrammarParser.prototype, "atn", {
	get : function() {
		return atn;
	}
});

odeGrammarParser.EOF = antlr4.Token.EOF;
odeGrammarParser.T__0 = 1;
odeGrammarParser.T0 = 2;
odeGrammarParser.SET = 3;
odeGrammarParser.ON = 4;
odeGrammarParser.FROM = 5;
odeGrammarParser.DER = 6;
odeGrammarParser.TERMINAL = 7;
odeGrammarParser.TRUE = 8;
odeGrammarParser.FALSE = 9;
odeGrammarParser.SUM = 10;
odeGrammarParser.MACRO = 11;
odeGrammarParser.STATE = 12;
odeGrammarParser.FOR = 13;
odeGrammarParser.IN = 14;
odeGrammarParser.IF = 15;
odeGrammarParser.ELSE = 16;
odeGrammarParser.LOCAL = 17;
odeGrammarParser.CONSTANT = 18;
odeGrammarParser.OR = 19;
odeGrammarParser.AND = 20;
odeGrammarParser.NOT = 21;
odeGrammarParser.LSQR = 22;
odeGrammarParser.RSQR = 23;
odeGrammarParser.FLOAT = 24;
odeGrammarParser.INT = 25;
odeGrammarParser.ID = 26;
odeGrammarParser.PLUS = 27;
odeGrammarParser.MINUS = 28;
odeGrammarParser.ASTERISK = 29;
odeGrammarParser.DIVISION = 30;
odeGrammarParser.LPAREN = 31;
odeGrammarParser.RPAREN = 32;
odeGrammarParser.DOT = 33;
odeGrammarParser.COMMA = 34;
odeGrammarParser.CARET = 35;
odeGrammarParser.L = 36;
odeGrammarParser.G = 37;
odeGrammarParser.LE = 38;
odeGrammarParser.GE = 39;
odeGrammarParser.NE = 40;
odeGrammarParser.E = 41;
odeGrammarParser.SEMICOLON = 42;
odeGrammarParser.COLON = 43;
odeGrammarParser.LCRL = 44;
odeGrammarParser.RCRL = 45;
odeGrammarParser.APOSTROPHE = 46;
odeGrammarParser.QUESTIONMARK = 47;
odeGrammarParser.NEWLINE = 48;
odeGrammarParser.WHITESPACE = 49;
odeGrammarParser.COMMENT = 50;

odeGrammarParser.RULE_dae = 0;
odeGrammarParser.RULE_daeStatement = 1;
odeGrammarParser.RULE_hybrid = 2;
odeGrammarParser.RULE_number = 3;
odeGrammarParser.RULE_hybridStatement = 4;
odeGrammarParser.RULE_index = 5;
odeGrammarParser.RULE_varIdentifier = 6;
odeGrammarParser.RULE_loopStatement = 7;
odeGrammarParser.RULE_loopBody = 8;
odeGrammarParser.RULE_macroStatement = 9;
odeGrammarParser.RULE_macroArguments = 10;
odeGrammarParser.RULE_loopBounds = 11;
odeGrammarParser.RULE_loop = 12;
odeGrammarParser.RULE_equation = 13;
odeGrammarParser.RULE_setter = 14;
odeGrammarParser.RULE_initialCondition = 15;
odeGrammarParser.RULE_constantStatement = 16;
odeGrammarParser.RULE_stateStatement = 17;
odeGrammarParser.RULE_stateDef = 18;
odeGrammarParser.RULE_stateTransition = 19;
odeGrammarParser.RULE_boolExpression = 20;
odeGrammarParser.RULE_expression = 21;
odeGrammarParser.RULE_functionArguments = 22;


function DaeContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_dae;
    return this;
}

DaeContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DaeContext.prototype.constructor = DaeContext;

DaeContext.prototype.daeStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(DaeStatementContext);
    } else {
        return this.getTypedRuleContext(DaeStatementContext,i);
    }
};

DaeContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitDae(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.DaeContext = DaeContext;

odeGrammarParser.prototype.dae = function() {

    var localctx = new DaeContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, odeGrammarParser.RULE_dae);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 49;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << odeGrammarParser.T__0) | (1 << odeGrammarParser.DER) | (1 << odeGrammarParser.SUM) | (1 << odeGrammarParser.MACRO) | (1 << odeGrammarParser.FOR) | (1 << odeGrammarParser.CONSTANT) | (1 << odeGrammarParser.FLOAT) | (1 << odeGrammarParser.INT) | (1 << odeGrammarParser.ID) | (1 << odeGrammarParser.PLUS) | (1 << odeGrammarParser.MINUS) | (1 << odeGrammarParser.LPAREN))) !== 0) || _la===odeGrammarParser.LCRL) {
            this.state = 46;
            this.daeStatement();
            this.state = 51;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function DaeStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_daeStatement;
    return this;
}

DaeStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
DaeStatementContext.prototype.constructor = DaeStatementContext;

DaeStatementContext.prototype.equation = function() {
    return this.getTypedRuleContext(EquationContext,0);
};

DaeStatementContext.prototype.initialCondition = function() {
    return this.getTypedRuleContext(InitialConditionContext,0);
};

DaeStatementContext.prototype.constantStatement = function() {
    return this.getTypedRuleContext(ConstantStatementContext,0);
};

DaeStatementContext.prototype.macroStatement = function() {
    return this.getTypedRuleContext(MacroStatementContext,0);
};

DaeStatementContext.prototype.loop = function() {
    return this.getTypedRuleContext(LoopContext,0);
};

DaeStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitDaeStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.DaeStatementContext = DaeStatementContext;

odeGrammarParser.prototype.daeStatement = function() {

    var localctx = new DaeStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 2, odeGrammarParser.RULE_daeStatement);
    try {
        this.state = 57;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,1,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 52;
            this.equation();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 53;
            this.initialCondition();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 54;
            this.constantStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 55;
            this.macroStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 56;
            this.loop();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HybridContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_hybrid;
    return this;
}

HybridContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HybridContext.prototype.constructor = HybridContext;

HybridContext.prototype.hybridStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(HybridStatementContext);
    } else {
        return this.getTypedRuleContext(HybridStatementContext,i);
    }
};

HybridContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitHybrid(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.HybridContext = HybridContext;

odeGrammarParser.prototype.hybrid = function() {

    var localctx = new HybridContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, odeGrammarParser.RULE_hybrid);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 62;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << odeGrammarParser.T__0) | (1 << odeGrammarParser.DER) | (1 << odeGrammarParser.TERMINAL) | (1 << odeGrammarParser.SUM) | (1 << odeGrammarParser.MACRO) | (1 << odeGrammarParser.STATE) | (1 << odeGrammarParser.FOR) | (1 << odeGrammarParser.CONSTANT) | (1 << odeGrammarParser.FLOAT) | (1 << odeGrammarParser.INT) | (1 << odeGrammarParser.ID) | (1 << odeGrammarParser.PLUS) | (1 << odeGrammarParser.MINUS) | (1 << odeGrammarParser.LPAREN))) !== 0) || _la===odeGrammarParser.LCRL) {
            this.state = 59;
            this.hybridStatement();
            this.state = 64;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function NumberContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_number;
    this.value = null; // Token
    return this;
}

NumberContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
NumberContext.prototype.constructor = NumberContext;

NumberContext.prototype.FLOAT = function() {
    return this.getToken(odeGrammarParser.FLOAT, 0);
};

NumberContext.prototype.INT = function() {
    return this.getToken(odeGrammarParser.INT, 0);
};

NumberContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitNumber(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.NumberContext = NumberContext;

odeGrammarParser.prototype.number = function() {

    var localctx = new NumberContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, odeGrammarParser.RULE_number);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 65;
        localctx.value = this._input.LT(1);
        _la = this._input.LA(1);
        if(!(_la===odeGrammarParser.FLOAT || _la===odeGrammarParser.INT)) {
            localctx.value = this._errHandler.recoverInline(this);
        }
        else {
        	this._errHandler.reportMatch(this);
            this.consume();
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function HybridStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_hybridStatement;
    return this;
}

HybridStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
HybridStatementContext.prototype.constructor = HybridStatementContext;

HybridStatementContext.prototype.equation = function() {
    return this.getTypedRuleContext(EquationContext,0);
};

HybridStatementContext.prototype.initialCondition = function() {
    return this.getTypedRuleContext(InitialConditionContext,0);
};

HybridStatementContext.prototype.constantStatement = function() {
    return this.getTypedRuleContext(ConstantStatementContext,0);
};

HybridStatementContext.prototype.macroStatement = function() {
    return this.getTypedRuleContext(MacroStatementContext,0);
};

HybridStatementContext.prototype.loop = function() {
    return this.getTypedRuleContext(LoopContext,0);
};

HybridStatementContext.prototype.stateDef = function() {
    return this.getTypedRuleContext(StateDefContext,0);
};

HybridStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitHybridStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.HybridStatementContext = HybridStatementContext;

odeGrammarParser.prototype.hybridStatement = function() {

    var localctx = new HybridStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, odeGrammarParser.RULE_hybridStatement);
    try {
        this.state = 73;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,3,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 67;
            this.equation();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 68;
            this.initialCondition();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 69;
            this.constantStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 70;
            this.macroStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 71;
            this.loop();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 72;
            this.stateDef();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function IndexContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_index;
    this.exp = null; // ExpressionContext
    return this;
}

IndexContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
IndexContext.prototype.constructor = IndexContext;

IndexContext.prototype.LSQR = function() {
    return this.getToken(odeGrammarParser.LSQR, 0);
};

IndexContext.prototype.RSQR = function() {
    return this.getToken(odeGrammarParser.RSQR, 0);
};

IndexContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

IndexContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitIndex(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.IndexContext = IndexContext;

odeGrammarParser.prototype.index = function() {

    var localctx = new IndexContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, odeGrammarParser.RULE_index);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 75;
        this.match(odeGrammarParser.LSQR);
        this.state = 76;
        localctx.exp = this.expression(0);
        this.state = 77;
        this.match(odeGrammarParser.RSQR);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function VarIdentifierContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_varIdentifier;
    this.id = null; // Token
    return this;
}

VarIdentifierContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
VarIdentifierContext.prototype.constructor = VarIdentifierContext;

VarIdentifierContext.prototype.ID = function() {
    return this.getToken(odeGrammarParser.ID, 0);
};

VarIdentifierContext.prototype.index = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(IndexContext);
    } else {
        return this.getTypedRuleContext(IndexContext,i);
    }
};

VarIdentifierContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitVarIdentifier(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.VarIdentifierContext = VarIdentifierContext;

odeGrammarParser.prototype.varIdentifier = function() {

    var localctx = new VarIdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, odeGrammarParser.RULE_varIdentifier);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 79;
        localctx.id = this.match(odeGrammarParser.ID);
        this.state = 83;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,4,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                this.state = 80;
                this.index(); 
            }
            this.state = 85;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,4,this._ctx);
        }

    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function LoopStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_loopStatement;
    return this;
}

LoopStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LoopStatementContext.prototype.constructor = LoopStatementContext;

LoopStatementContext.prototype.equation = function() {
    return this.getTypedRuleContext(EquationContext,0);
};

LoopStatementContext.prototype.initialCondition = function() {
    return this.getTypedRuleContext(InitialConditionContext,0);
};

LoopStatementContext.prototype.macroStatement = function() {
    return this.getTypedRuleContext(MacroStatementContext,0);
};

LoopStatementContext.prototype.constantStatement = function() {
    return this.getTypedRuleContext(ConstantStatementContext,0);
};

LoopStatementContext.prototype.setter = function() {
    return this.getTypedRuleContext(SetterContext,0);
};

LoopStatementContext.prototype.loop = function() {
    return this.getTypedRuleContext(LoopContext,0);
};

LoopStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitLoopStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.LoopStatementContext = LoopStatementContext;

odeGrammarParser.prototype.loopStatement = function() {

    var localctx = new LoopStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, odeGrammarParser.RULE_loopStatement);
    try {
        this.state = 92;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,5,this._ctx);
        switch(la_) {
        case 1:
            this.enterOuterAlt(localctx, 1);
            this.state = 86;
            this.equation();
            break;

        case 2:
            this.enterOuterAlt(localctx, 2);
            this.state = 87;
            this.initialCondition();
            break;

        case 3:
            this.enterOuterAlt(localctx, 3);
            this.state = 88;
            this.macroStatement();
            break;

        case 4:
            this.enterOuterAlt(localctx, 4);
            this.state = 89;
            this.constantStatement();
            break;

        case 5:
            this.enterOuterAlt(localctx, 5);
            this.state = 90;
            this.setter();
            break;

        case 6:
            this.enterOuterAlt(localctx, 6);
            this.state = 91;
            this.loop();
            break;

        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function LoopBodyContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_loopBody;
    return this;
}

LoopBodyContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LoopBodyContext.prototype.constructor = LoopBodyContext;

LoopBodyContext.prototype.LCRL = function() {
    return this.getToken(odeGrammarParser.LCRL, 0);
};

LoopBodyContext.prototype.RCRL = function() {
    return this.getToken(odeGrammarParser.RCRL, 0);
};

LoopBodyContext.prototype.loopStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LoopStatementContext);
    } else {
        return this.getTypedRuleContext(LoopStatementContext,i);
    }
};

LoopBodyContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitLoopBody(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.LoopBodyContext = LoopBodyContext;

odeGrammarParser.prototype.loopBody = function() {

    var localctx = new LoopBodyContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, odeGrammarParser.RULE_loopBody);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 94;
        this.match(odeGrammarParser.LCRL);
        this.state = 98;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << odeGrammarParser.T__0) | (1 << odeGrammarParser.SET) | (1 << odeGrammarParser.DER) | (1 << odeGrammarParser.SUM) | (1 << odeGrammarParser.MACRO) | (1 << odeGrammarParser.FOR) | (1 << odeGrammarParser.CONSTANT) | (1 << odeGrammarParser.FLOAT) | (1 << odeGrammarParser.INT) | (1 << odeGrammarParser.ID) | (1 << odeGrammarParser.PLUS) | (1 << odeGrammarParser.MINUS) | (1 << odeGrammarParser.LPAREN))) !== 0) || _la===odeGrammarParser.LCRL) {
            this.state = 95;
            this.loopStatement();
            this.state = 100;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 101;
        this.match(odeGrammarParser.RCRL);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function MacroStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_macroStatement;
    this.id = null; // VarIdentifierContext
    this.exp = null; // ExpressionContext
    return this;
}

MacroStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MacroStatementContext.prototype.constructor = MacroStatementContext;

MacroStatementContext.prototype.MACRO = function() {
    return this.getToken(odeGrammarParser.MACRO, 0);
};

MacroStatementContext.prototype.SEMICOLON = function() {
    return this.getToken(odeGrammarParser.SEMICOLON, 0);
};

MacroStatementContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

MacroStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

MacroStatementContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

MacroStatementContext.prototype.macroArguments = function() {
    return this.getTypedRuleContext(MacroArgumentsContext,0);
};

MacroStatementContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

MacroStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitMacroStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.MacroStatementContext = MacroStatementContext;

odeGrammarParser.prototype.macroStatement = function() {

    var localctx = new MacroStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, odeGrammarParser.RULE_macroStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 103;
        this.match(odeGrammarParser.MACRO);
        this.state = 104;
        localctx.id = this.varIdentifier();
        this.state = 109;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,7,this._ctx);
        if(la_===1) {
            this.state = 105;
            this.match(odeGrammarParser.LPAREN);
            this.state = 106;
            this.macroArguments();
            this.state = 107;
            this.match(odeGrammarParser.RPAREN);

        }
        this.state = 111;
        localctx.exp = this.expression(0);
        this.state = 112;
        this.match(odeGrammarParser.SEMICOLON);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function MacroArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_macroArguments;
    return this;
}

MacroArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
MacroArgumentsContext.prototype.constructor = MacroArgumentsContext;

MacroArgumentsContext.prototype.ID = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.ID);
    } else {
        return this.getToken(odeGrammarParser.ID, i);
    }
};


MacroArgumentsContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.COMMA);
    } else {
        return this.getToken(odeGrammarParser.COMMA, i);
    }
};


MacroArgumentsContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitMacroArguments(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.MacroArgumentsContext = MacroArgumentsContext;

odeGrammarParser.prototype.macroArguments = function() {

    var localctx = new MacroArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, odeGrammarParser.RULE_macroArguments);
    var _la = 0; // Token type
    try {
        this.state = 123;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case odeGrammarParser.ID:
            this.enterOuterAlt(localctx, 1);
            this.state = 114;
            this.match(odeGrammarParser.ID);
            this.state = 119;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===odeGrammarParser.COMMA) {
                this.state = 115;
                this.match(odeGrammarParser.COMMA);
                this.state = 116;
                this.match(odeGrammarParser.ID);
                this.state = 121;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;
        case odeGrammarParser.RPAREN:
            this.enterOuterAlt(localctx, 2);

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function LoopBoundsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_loopBounds;
    this.lbound = null; // Token
    this.rbound = null; // Token
    return this;
}

LoopBoundsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LoopBoundsContext.prototype.constructor = LoopBoundsContext;

LoopBoundsContext.prototype.COLON = function() {
    return this.getToken(odeGrammarParser.COLON, 0);
};

LoopBoundsContext.prototype.INT = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.INT);
    } else {
        return this.getToken(odeGrammarParser.INT, i);
    }
};


LoopBoundsContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitLoopBounds(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.LoopBoundsContext = LoopBoundsContext;

odeGrammarParser.prototype.loopBounds = function() {

    var localctx = new LoopBoundsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, odeGrammarParser.RULE_loopBounds);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 125;
        localctx.lbound = this.match(odeGrammarParser.INT);
        this.state = 126;
        this.match(odeGrammarParser.COLON);
        this.state = 127;
        localctx.rbound = this.match(odeGrammarParser.INT);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function LoopContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_loop;
    this.iterator = null; // Token
    return this;
}

LoopContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
LoopContext.prototype.constructor = LoopContext;

LoopContext.prototype.FOR = function() {
    return this.getToken(odeGrammarParser.FOR, 0);
};

LoopContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

LoopContext.prototype.IN = function() {
    return this.getToken(odeGrammarParser.IN, 0);
};

LoopContext.prototype.LSQR = function() {
    return this.getToken(odeGrammarParser.LSQR, 0);
};

LoopContext.prototype.RSQR = function() {
    return this.getToken(odeGrammarParser.RSQR, 0);
};

LoopContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

LoopContext.prototype.loopBody = function() {
    return this.getTypedRuleContext(LoopBodyContext,0);
};

LoopContext.prototype.ID = function() {
    return this.getToken(odeGrammarParser.ID, 0);
};

LoopContext.prototype.loopBounds = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(LoopBoundsContext);
    } else {
        return this.getTypedRuleContext(LoopBoundsContext,i);
    }
};

LoopContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitLoop(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.LoopContext = LoopContext;

odeGrammarParser.prototype.loop = function() {

    var localctx = new LoopContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, odeGrammarParser.RULE_loop);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 129;
        this.match(odeGrammarParser.FOR);
        this.state = 130;
        this.match(odeGrammarParser.LPAREN);
        this.state = 131;
        localctx.iterator = this.match(odeGrammarParser.ID);
        this.state = 132;
        this.match(odeGrammarParser.IN);
        this.state = 133;
        this.match(odeGrammarParser.LSQR);
        this.state = 135; 
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        do {
            this.state = 134;
            this.loopBounds();
            this.state = 137; 
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        } while(_la===odeGrammarParser.INT);
        this.state = 139;
        this.match(odeGrammarParser.RSQR);
        this.state = 140;
        this.match(odeGrammarParser.RPAREN);
        this.state = 141;
        this.loopBody();
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function EquationContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_equation;
    this.label = null; // VarIdentifierContext
    this.left = null; // ExpressionContext
    this.right = null; // ExpressionContext
    return this;
}

EquationContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
EquationContext.prototype.constructor = EquationContext;

EquationContext.prototype.E = function() {
    return this.getToken(odeGrammarParser.E, 0);
};

EquationContext.prototype.SEMICOLON = function() {
    return this.getToken(odeGrammarParser.SEMICOLON, 0);
};

EquationContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

EquationContext.prototype.COLON = function() {
    return this.getToken(odeGrammarParser.COLON, 0);
};

EquationContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

EquationContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitEquation(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.EquationContext = EquationContext;

odeGrammarParser.prototype.equation = function() {

    var localctx = new EquationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, odeGrammarParser.RULE_equation);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 146;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,11,this._ctx);
        if(la_===1) {
            this.state = 143;
            localctx.label = this.varIdentifier();
            this.state = 144;
            this.match(odeGrammarParser.COLON);

        }
        this.state = 148;
        localctx.left = this.expression(0);
        this.state = 149;
        this.match(odeGrammarParser.E);
        this.state = 150;
        localctx.right = this.expression(0);
        this.state = 151;
        this.match(odeGrammarParser.SEMICOLON);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function SetterContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_setter;
    this.variable = null; // VarIdentifierContext
    this.exp = null; // ExpressionContext
    return this;
}

SetterContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
SetterContext.prototype.constructor = SetterContext;

SetterContext.prototype.SET = function() {
    return this.getToken(odeGrammarParser.SET, 0);
};

SetterContext.prototype.E = function() {
    return this.getToken(odeGrammarParser.E, 0);
};

SetterContext.prototype.SEMICOLON = function() {
    return this.getToken(odeGrammarParser.SEMICOLON, 0);
};

SetterContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

SetterContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

SetterContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitSetter(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.SetterContext = SetterContext;

odeGrammarParser.prototype.setter = function() {

    var localctx = new SetterContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, odeGrammarParser.RULE_setter);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 153;
        this.match(odeGrammarParser.SET);
        this.state = 154;
        localctx.variable = this.varIdentifier();
        this.state = 155;
        this.match(odeGrammarParser.E);
        this.state = 156;
        localctx.exp = this.expression(0);
        this.state = 157;
        this.match(odeGrammarParser.SEMICOLON);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function InitialConditionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_initialCondition;
    this.variable = null; // VarIdentifierContext
    this.exp = null; // ExpressionContext
    return this;
}

InitialConditionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
InitialConditionContext.prototype.constructor = InitialConditionContext;

InitialConditionContext.prototype.T0 = function() {
    return this.getToken(odeGrammarParser.T0, 0);
};

InitialConditionContext.prototype.E = function() {
    return this.getToken(odeGrammarParser.E, 0);
};

InitialConditionContext.prototype.SEMICOLON = function() {
    return this.getToken(odeGrammarParser.SEMICOLON, 0);
};

InitialConditionContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

InitialConditionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

InitialConditionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitInitialCondition(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.InitialConditionContext = InitialConditionContext;

odeGrammarParser.prototype.initialCondition = function() {

    var localctx = new InitialConditionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 30, odeGrammarParser.RULE_initialCondition);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 159;
        localctx.variable = this.varIdentifier();
        this.state = 160;
        this.match(odeGrammarParser.T0);
        this.state = 161;
        this.match(odeGrammarParser.E);
        this.state = 162;
        localctx.exp = this.expression(0);
        this.state = 163;
        this.match(odeGrammarParser.SEMICOLON);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function ConstantStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_constantStatement;
    this.constant = null; // VarIdentifierContext
    this.exp = null; // ExpressionContext
    return this;
}

ConstantStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ConstantStatementContext.prototype.constructor = ConstantStatementContext;

ConstantStatementContext.prototype.CONSTANT = function() {
    return this.getToken(odeGrammarParser.CONSTANT, 0);
};

ConstantStatementContext.prototype.E = function() {
    return this.getToken(odeGrammarParser.E, 0);
};

ConstantStatementContext.prototype.SEMICOLON = function() {
    return this.getToken(odeGrammarParser.SEMICOLON, 0);
};

ConstantStatementContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

ConstantStatementContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

ConstantStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitConstantStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.ConstantStatementContext = ConstantStatementContext;

odeGrammarParser.prototype.constantStatement = function() {

    var localctx = new ConstantStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 32, odeGrammarParser.RULE_constantStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 165;
        this.match(odeGrammarParser.CONSTANT);
        this.state = 166;
        localctx.constant = this.varIdentifier();
        this.state = 167;
        this.match(odeGrammarParser.E);
        this.state = 168;
        localctx.exp = this.expression(0);
        this.state = 169;
        this.match(odeGrammarParser.SEMICOLON);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StateStatementContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_stateStatement;
    return this;
}

StateStatementContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StateStatementContext.prototype.constructor = StateStatementContext;

StateStatementContext.prototype.equation = function() {
    return this.getTypedRuleContext(EquationContext,0);
};

StateStatementContext.prototype.setter = function() {
    return this.getTypedRuleContext(SetterContext,0);
};

StateStatementContext.prototype.loop = function() {
    return this.getTypedRuleContext(LoopContext,0);
};

StateStatementContext.prototype.macroStatement = function() {
    return this.getTypedRuleContext(MacroStatementContext,0);
};

StateStatementContext.prototype.constantStatement = function() {
    return this.getTypedRuleContext(ConstantStatementContext,0);
};

StateStatementContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitStateStatement(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.StateStatementContext = StateStatementContext;

odeGrammarParser.prototype.stateStatement = function() {

    var localctx = new StateStatementContext(this, this._ctx, this.state);
    this.enterRule(localctx, 34, odeGrammarParser.RULE_stateStatement);
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 176;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case odeGrammarParser.T__0:
        case odeGrammarParser.DER:
        case odeGrammarParser.SUM:
        case odeGrammarParser.FLOAT:
        case odeGrammarParser.INT:
        case odeGrammarParser.ID:
        case odeGrammarParser.PLUS:
        case odeGrammarParser.MINUS:
        case odeGrammarParser.LPAREN:
        case odeGrammarParser.LCRL:
            this.state = 171;
            this.equation();
            break;
        case odeGrammarParser.SET:
            this.state = 172;
            this.setter();
            break;
        case odeGrammarParser.FOR:
            this.state = 173;
            this.loop();
            break;
        case odeGrammarParser.MACRO:
            this.state = 174;
            this.macroStatement();
            break;
        case odeGrammarParser.CONSTANT:
            this.state = 175;
            this.constantStatement();
            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StateDefContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_stateDef;
    this.name = null; // Token
    return this;
}

StateDefContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StateDefContext.prototype.constructor = StateDefContext;

StateDefContext.prototype.STATE = function() {
    return this.getToken(odeGrammarParser.STATE, 0);
};

StateDefContext.prototype.LCRL = function() {
    return this.getToken(odeGrammarParser.LCRL, 0);
};

StateDefContext.prototype.RCRL = function() {
    return this.getToken(odeGrammarParser.RCRL, 0);
};

StateDefContext.prototype.FROM = function() {
    return this.getToken(odeGrammarParser.FROM, 0);
};

StateDefContext.prototype.stateTransition = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StateTransitionContext);
    } else {
        return this.getTypedRuleContext(StateTransitionContext,i);
    }
};

StateDefContext.prototype.ID = function() {
    return this.getToken(odeGrammarParser.ID, 0);
};

StateDefContext.prototype.TERMINAL = function() {
    return this.getToken(odeGrammarParser.TERMINAL, 0);
};

StateDefContext.prototype.stateStatement = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(StateStatementContext);
    } else {
        return this.getTypedRuleContext(StateStatementContext,i);
    }
};

StateDefContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.COMMA);
    } else {
        return this.getToken(odeGrammarParser.COMMA, i);
    }
};


StateDefContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitStateDef(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.StateDefContext = StateDefContext;

odeGrammarParser.prototype.stateDef = function() {

    var localctx = new StateDefContext(this, this._ctx, this.state);
    this.enterRule(localctx, 36, odeGrammarParser.RULE_stateDef);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 179;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        if(_la===odeGrammarParser.TERMINAL) {
            this.state = 178;
            this.match(odeGrammarParser.TERMINAL);
        }

        this.state = 181;
        this.match(odeGrammarParser.STATE);
        this.state = 182;
        localctx.name = this.match(odeGrammarParser.ID);
        this.state = 183;
        this.match(odeGrammarParser.LCRL);
        this.state = 187;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << odeGrammarParser.T__0) | (1 << odeGrammarParser.SET) | (1 << odeGrammarParser.DER) | (1 << odeGrammarParser.SUM) | (1 << odeGrammarParser.MACRO) | (1 << odeGrammarParser.FOR) | (1 << odeGrammarParser.CONSTANT) | (1 << odeGrammarParser.FLOAT) | (1 << odeGrammarParser.INT) | (1 << odeGrammarParser.ID) | (1 << odeGrammarParser.PLUS) | (1 << odeGrammarParser.MINUS) | (1 << odeGrammarParser.LPAREN))) !== 0) || _la===odeGrammarParser.LCRL) {
            this.state = 184;
            this.stateStatement();
            this.state = 189;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 190;
        this.match(odeGrammarParser.RCRL);
        this.state = 191;
        this.match(odeGrammarParser.FROM);
        this.state = 192;
        this.stateTransition();
        this.state = 197;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===odeGrammarParser.COMMA) {
            this.state = 193;
            this.match(odeGrammarParser.COMMA);
            this.state = 194;
            this.stateTransition();
            this.state = 199;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function StateTransitionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_stateTransition;
    this.condition = null; // BoolExpressionContext
    return this;
}

StateTransitionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
StateTransitionContext.prototype.constructor = StateTransitionContext;

StateTransitionContext.prototype.ID = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.ID);
    } else {
        return this.getToken(odeGrammarParser.ID, i);
    }
};


StateTransitionContext.prototype.ON = function() {
    return this.getToken(odeGrammarParser.ON, 0);
};

StateTransitionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

StateTransitionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

StateTransitionContext.prototype.boolExpression = function() {
    return this.getTypedRuleContext(BoolExpressionContext,0);
};

StateTransitionContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.COMMA);
    } else {
        return this.getToken(odeGrammarParser.COMMA, i);
    }
};


StateTransitionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitStateTransition(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.StateTransitionContext = StateTransitionContext;

odeGrammarParser.prototype.stateTransition = function() {

    var localctx = new StateTransitionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 38, odeGrammarParser.RULE_stateTransition);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 200;
        this.match(odeGrammarParser.ID);
        this.state = 205;
        this._errHandler.sync(this);
        _la = this._input.LA(1);
        while(_la===odeGrammarParser.COMMA) {
            this.state = 201;
            this.match(odeGrammarParser.COMMA);
            this.state = 202;
            this.match(odeGrammarParser.ID);
            this.state = 207;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
        }
        this.state = 208;
        this.match(odeGrammarParser.ON);
        this.state = 209;
        this.match(odeGrammarParser.LPAREN);
        this.state = 210;
        localctx.condition = this.boolExpression(0);
        this.state = 211;
        this.match(odeGrammarParser.RPAREN);
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


function BoolExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_boolExpression;
    return this;
}

BoolExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
BoolExpressionContext.prototype.constructor = BoolExpressionContext;


 
BoolExpressionContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};

function BoolConstantContext(parser, ctx) {
	BoolExpressionContext.call(this, parser);
    this.value = null; // Token;
    BoolExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BoolConstantContext.prototype = Object.create(BoolExpressionContext.prototype);
BoolConstantContext.prototype.constructor = BoolConstantContext;

odeGrammarParser.BoolConstantContext = BoolConstantContext;

BoolConstantContext.prototype.TRUE = function() {
    return this.getToken(odeGrammarParser.TRUE, 0);
};

BoolConstantContext.prototype.FALSE = function() {
    return this.getToken(odeGrammarParser.FALSE, 0);
};
BoolConstantContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBoolConstant(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function BoolUnaryOperatorContext(parser, ctx) {
	BoolExpressionContext.call(this, parser);
    this.op = null; // Token;
    BoolExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BoolUnaryOperatorContext.prototype = Object.create(BoolExpressionContext.prototype);
BoolUnaryOperatorContext.prototype.constructor = BoolUnaryOperatorContext;

odeGrammarParser.BoolUnaryOperatorContext = BoolUnaryOperatorContext;

BoolUnaryOperatorContext.prototype.boolExpression = function() {
    return this.getTypedRuleContext(BoolExpressionContext,0);
};

BoolUnaryOperatorContext.prototype.NOT = function() {
    return this.getToken(odeGrammarParser.NOT, 0);
};
BoolUnaryOperatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBoolUnaryOperator(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function BracketBoolExpressionContext(parser, ctx) {
	BoolExpressionContext.call(this, parser);
    BoolExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BracketBoolExpressionContext.prototype = Object.create(BoolExpressionContext.prototype);
BracketBoolExpressionContext.prototype.constructor = BracketBoolExpressionContext;

odeGrammarParser.BracketBoolExpressionContext = BracketBoolExpressionContext;

BracketBoolExpressionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

BracketBoolExpressionContext.prototype.boolExpression = function() {
    return this.getTypedRuleContext(BoolExpressionContext,0);
};

BracketBoolExpressionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};
BracketBoolExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBracketBoolExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function BBoolBinaryOperatorContext(parser, ctx) {
	BoolExpressionContext.call(this, parser);
    this.left = null; // BoolExpressionContext;
    this.op = null; // Token;
    this.right = null; // BoolExpressionContext;
    BoolExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BBoolBinaryOperatorContext.prototype = Object.create(BoolExpressionContext.prototype);
BBoolBinaryOperatorContext.prototype.constructor = BBoolBinaryOperatorContext;

odeGrammarParser.BBoolBinaryOperatorContext = BBoolBinaryOperatorContext;

BBoolBinaryOperatorContext.prototype.boolExpression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(BoolExpressionContext);
    } else {
        return this.getTypedRuleContext(BoolExpressionContext,i);
    }
};

BBoolBinaryOperatorContext.prototype.AND = function() {
    return this.getToken(odeGrammarParser.AND, 0);
};

BBoolBinaryOperatorContext.prototype.OR = function() {
    return this.getToken(odeGrammarParser.OR, 0);
};
BBoolBinaryOperatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBBoolBinaryOperator(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function EBoolBinaryOperatorContext(parser, ctx) {
	BoolExpressionContext.call(this, parser);
    this.leftexp = null; // ExpressionContext;
    this.op = null; // Token;
    this.rightexp = null; // ExpressionContext;
    BoolExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

EBoolBinaryOperatorContext.prototype = Object.create(BoolExpressionContext.prototype);
EBoolBinaryOperatorContext.prototype.constructor = EBoolBinaryOperatorContext;

odeGrammarParser.EBoolBinaryOperatorContext = EBoolBinaryOperatorContext;

EBoolBinaryOperatorContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

EBoolBinaryOperatorContext.prototype.L = function() {
    return this.getToken(odeGrammarParser.L, 0);
};

EBoolBinaryOperatorContext.prototype.LE = function() {
    return this.getToken(odeGrammarParser.LE, 0);
};

EBoolBinaryOperatorContext.prototype.G = function() {
    return this.getToken(odeGrammarParser.G, 0);
};

EBoolBinaryOperatorContext.prototype.GE = function() {
    return this.getToken(odeGrammarParser.GE, 0);
};

EBoolBinaryOperatorContext.prototype.E = function() {
    return this.getToken(odeGrammarParser.E, 0);
};

EBoolBinaryOperatorContext.prototype.NE = function() {
    return this.getToken(odeGrammarParser.NE, 0);
};
EBoolBinaryOperatorContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitEBoolBinaryOperator(this);
    } else {
        return visitor.visitChildren(this);
    }
};



odeGrammarParser.prototype.boolExpression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new BoolExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 40;
    this.enterRecursionRule(localctx, 40, odeGrammarParser.RULE_boolExpression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 229;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,17,this._ctx);
        switch(la_) {
        case 1:
            localctx = new BracketBoolExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;

            this.state = 214;
            this.match(odeGrammarParser.LPAREN);
            this.state = 215;
            this.boolExpression(0);
            this.state = 216;
            this.match(odeGrammarParser.RPAREN);
            break;

        case 2:
            localctx = new BoolUnaryOperatorContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 218;
            localctx.op = this.match(odeGrammarParser.NOT);
            this.state = 219;
            this.boolExpression(6);
            break;

        case 3:
            localctx = new EBoolBinaryOperatorContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 220;
            localctx.leftexp = this.expression(0);
            this.state = 221;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(((((_la - 36)) & ~0x1f) == 0 && ((1 << (_la - 36)) & ((1 << (odeGrammarParser.L - 36)) | (1 << (odeGrammarParser.G - 36)) | (1 << (odeGrammarParser.LE - 36)) | (1 << (odeGrammarParser.GE - 36)))) !== 0))) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 222;
            localctx.rightexp = this.expression(0);
            break;

        case 4:
            localctx = new EBoolBinaryOperatorContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 224;
            localctx.leftexp = this.expression(0);
            this.state = 225;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===odeGrammarParser.NE || _la===odeGrammarParser.E)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 226;
            localctx.rightexp = this.expression(0);
            break;

        case 5:
            localctx = new BoolConstantContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 228;
            localctx.value = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===odeGrammarParser.TRUE || _la===odeGrammarParser.FALSE)) {
                localctx.value = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 239;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,19,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 237;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,18,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new BBoolBinaryOperatorContext(this, new BoolExpressionContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, odeGrammarParser.RULE_boolExpression);
                    this.state = 231;
                    if (!( this.precpred(this._ctx, 3))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
                    }
                    this.state = 232;
                    localctx.op = this.match(odeGrammarParser.AND);
                    this.state = 233;
                    localctx.right = this.boolExpression(4);
                    break;

                case 2:
                    localctx = new BBoolBinaryOperatorContext(this, new BoolExpressionContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, odeGrammarParser.RULE_boolExpression);
                    this.state = 234;
                    if (!( this.precpred(this._ctx, 2))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
                    }
                    this.state = 235;
                    localctx.op = this.match(odeGrammarParser.OR);
                    this.state = 236;
                    localctx.right = this.boolExpression(3);
                    break;

                } 
            }
            this.state = 241;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,19,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


function ExpressionContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_expression;
    return this;
}

ExpressionContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
ExpressionContext.prototype.constructor = ExpressionContext;


 
ExpressionContext.prototype.copyFrom = function(ctx) {
    antlr4.ParserRuleContext.prototype.copyFrom.call(this, ctx);
};

function BracketExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BracketExpressionContext.prototype = Object.create(ExpressionContext.prototype);
BracketExpressionContext.prototype.constructor = BracketExpressionContext;

odeGrammarParser.BracketExpressionContext = BracketExpressionContext;

BracketExpressionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

BracketExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

BracketExpressionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};
BracketExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBracketExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function MacroExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.id = null; // VarIdentifierContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

MacroExpressionContext.prototype = Object.create(ExpressionContext.prototype);
MacroExpressionContext.prototype.constructor = MacroExpressionContext;

odeGrammarParser.MacroExpressionContext = MacroExpressionContext;

MacroExpressionContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

MacroExpressionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

MacroExpressionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

MacroExpressionContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};
MacroExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitMacroExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function BinaryOperatorExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.left = null; // ExpressionContext;
    this.op = null; // Token;
    this.right = null; // ExpressionContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

BinaryOperatorExpressionContext.prototype = Object.create(ExpressionContext.prototype);
BinaryOperatorExpressionContext.prototype.constructor = BinaryOperatorExpressionContext;

odeGrammarParser.BinaryOperatorExpressionContext = BinaryOperatorExpressionContext;

BinaryOperatorExpressionContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

BinaryOperatorExpressionContext.prototype.CARET = function() {
    return this.getToken(odeGrammarParser.CARET, 0);
};

BinaryOperatorExpressionContext.prototype.DIVISION = function() {
    return this.getToken(odeGrammarParser.DIVISION, 0);
};

BinaryOperatorExpressionContext.prototype.ASTERISK = function() {
    return this.getToken(odeGrammarParser.ASTERISK, 0);
};

BinaryOperatorExpressionContext.prototype.PLUS = function() {
    return this.getToken(odeGrammarParser.PLUS, 0);
};

BinaryOperatorExpressionContext.prototype.MINUS = function() {
    return this.getToken(odeGrammarParser.MINUS, 0);
};
BinaryOperatorExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitBinaryOperatorExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function FunctionExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.func = null; // Token;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FunctionExpressionContext.prototype = Object.create(ExpressionContext.prototype);
FunctionExpressionContext.prototype.constructor = FunctionExpressionContext;

odeGrammarParser.FunctionExpressionContext = FunctionExpressionContext;

FunctionExpressionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

FunctionExpressionContext.prototype.functionArguments = function() {
    return this.getTypedRuleContext(FunctionArgumentsContext,0);
};

FunctionExpressionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

FunctionExpressionContext.prototype.ID = function() {
    return this.getToken(odeGrammarParser.ID, 0);
};
FunctionExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitFunctionExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function UnaryOperatorExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.op = null; // Token;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

UnaryOperatorExpressionContext.prototype = Object.create(ExpressionContext.prototype);
UnaryOperatorExpressionContext.prototype.constructor = UnaryOperatorExpressionContext;

odeGrammarParser.UnaryOperatorExpressionContext = UnaryOperatorExpressionContext;

UnaryOperatorExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};

UnaryOperatorExpressionContext.prototype.PLUS = function() {
    return this.getToken(odeGrammarParser.PLUS, 0);
};

UnaryOperatorExpressionContext.prototype.MINUS = function() {
    return this.getToken(odeGrammarParser.MINUS, 0);
};
UnaryOperatorExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitUnaryOperatorExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function ConstantExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.value = null; // NumberContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

ConstantExpressionContext.prototype = Object.create(ExpressionContext.prototype);
ConstantExpressionContext.prototype.constructor = ConstantExpressionContext;

odeGrammarParser.ConstantExpressionContext = ConstantExpressionContext;

ConstantExpressionContext.prototype.number = function() {
    return this.getTypedRuleContext(NumberContext,0);
};
ConstantExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitConstantExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function SummationExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.iterator = null; // Token;
    this.bounds = null; // LoopBoundsContext;
    this.summationExp = null; // ExpressionContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

SummationExpressionContext.prototype = Object.create(ExpressionContext.prototype);
SummationExpressionContext.prototype.constructor = SummationExpressionContext;

odeGrammarParser.SummationExpressionContext = SummationExpressionContext;

SummationExpressionContext.prototype.SUM = function() {
    return this.getToken(odeGrammarParser.SUM, 0);
};

SummationExpressionContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

SummationExpressionContext.prototype.IN = function() {
    return this.getToken(odeGrammarParser.IN, 0);
};

SummationExpressionContext.prototype.LSQR = function() {
    return this.getToken(odeGrammarParser.LSQR, 0);
};

SummationExpressionContext.prototype.RSQR = function() {
    return this.getToken(odeGrammarParser.RSQR, 0);
};

SummationExpressionContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

SummationExpressionContext.prototype.LCRL = function() {
    return this.getToken(odeGrammarParser.LCRL, 0);
};

SummationExpressionContext.prototype.RCRL = function() {
    return this.getToken(odeGrammarParser.RCRL, 0);
};

SummationExpressionContext.prototype.ID = function() {
    return this.getToken(odeGrammarParser.ID, 0);
};

SummationExpressionContext.prototype.loopBounds = function() {
    return this.getTypedRuleContext(LoopBoundsContext,0);
};

SummationExpressionContext.prototype.expression = function() {
    return this.getTypedRuleContext(ExpressionContext,0);
};
SummationExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitSummationExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function FunctionDerivativeContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.id = null; // VarIdentifierContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

FunctionDerivativeContext.prototype = Object.create(ExpressionContext.prototype);
FunctionDerivativeContext.prototype.constructor = FunctionDerivativeContext;

odeGrammarParser.FunctionDerivativeContext = FunctionDerivativeContext;

FunctionDerivativeContext.prototype.DER = function() {
    return this.getToken(odeGrammarParser.DER, 0);
};

FunctionDerivativeContext.prototype.LPAREN = function() {
    return this.getToken(odeGrammarParser.LPAREN, 0);
};

FunctionDerivativeContext.prototype.RPAREN = function() {
    return this.getToken(odeGrammarParser.RPAREN, 0);
};

FunctionDerivativeContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};
FunctionDerivativeContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitFunctionDerivative(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function VariableExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.id = null; // VarIdentifierContext;
    this.der = null; // Token;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

VariableExpressionContext.prototype = Object.create(ExpressionContext.prototype);
VariableExpressionContext.prototype.constructor = VariableExpressionContext;

odeGrammarParser.VariableExpressionContext = VariableExpressionContext;

VariableExpressionContext.prototype.varIdentifier = function() {
    return this.getTypedRuleContext(VarIdentifierContext,0);
};

VariableExpressionContext.prototype.APOSTROPHE = function() {
    return this.getToken(odeGrammarParser.APOSTROPHE, 0);
};
VariableExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitVariableExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};


function TernaryOperatorExpressionContext(parser, ctx) {
	ExpressionContext.call(this, parser);
    this.condition = null; // BoolExpressionContext;
    this.first = null; // ExpressionContext;
    this.second = null; // ExpressionContext;
    ExpressionContext.prototype.copyFrom.call(this, ctx);
    return this;
}

TernaryOperatorExpressionContext.prototype = Object.create(ExpressionContext.prototype);
TernaryOperatorExpressionContext.prototype.constructor = TernaryOperatorExpressionContext;

odeGrammarParser.TernaryOperatorExpressionContext = TernaryOperatorExpressionContext;

TernaryOperatorExpressionContext.prototype.LCRL = function() {
    return this.getToken(odeGrammarParser.LCRL, 0);
};

TernaryOperatorExpressionContext.prototype.QUESTIONMARK = function() {
    return this.getToken(odeGrammarParser.QUESTIONMARK, 0);
};

TernaryOperatorExpressionContext.prototype.COLON = function() {
    return this.getToken(odeGrammarParser.COLON, 0);
};

TernaryOperatorExpressionContext.prototype.RCRL = function() {
    return this.getToken(odeGrammarParser.RCRL, 0);
};

TernaryOperatorExpressionContext.prototype.boolExpression = function() {
    return this.getTypedRuleContext(BoolExpressionContext,0);
};

TernaryOperatorExpressionContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};
TernaryOperatorExpressionContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitTernaryOperatorExpression(this);
    } else {
        return visitor.visitChildren(this);
    }
};



odeGrammarParser.prototype.expression = function(_p) {
	if(_p===undefined) {
	    _p = 0;
	}
    var _parentctx = this._ctx;
    var _parentState = this.state;
    var localctx = new ExpressionContext(this, this._ctx, _parentState);
    var _prevctx = localctx;
    var _startState = 42;
    this.enterRecursionRule(localctx, 42, odeGrammarParser.RULE_expression, _p);
    var _la = 0; // Token type
    try {
        this.enterOuterAlt(localctx, 1);
        this.state = 296;
        this._errHandler.sync(this);
        var la_ = this._interp.adaptivePredict(this._input,23,this._ctx);
        switch(la_) {
        case 1:
            localctx = new BracketExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;

            this.state = 243;
            this.match(odeGrammarParser.LPAREN);
            this.state = 244;
            this.expression(0);
            this.state = 245;
            this.match(odeGrammarParser.RPAREN);
            break;

        case 2:
            localctx = new FunctionDerivativeContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 247;
            this.match(odeGrammarParser.DER);
            this.state = 248;
            this.match(odeGrammarParser.LPAREN);
            this.state = 249;
            localctx.id = this.varIdentifier();
            this.state = 250;
            this.match(odeGrammarParser.RPAREN);
            break;

        case 3:
            localctx = new FunctionExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 252;
            localctx.func = this.match(odeGrammarParser.ID);
            this.state = 253;
            this.match(odeGrammarParser.LPAREN);
            this.state = 254;
            this.functionArguments();
            this.state = 255;
            this.match(odeGrammarParser.RPAREN);
            break;

        case 4:
            localctx = new UnaryOperatorExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 257;
            localctx.op = this._input.LT(1);
            _la = this._input.LA(1);
            if(!(_la===odeGrammarParser.PLUS || _la===odeGrammarParser.MINUS)) {
                localctx.op = this._errHandler.recoverInline(this);
            }
            else {
            	this._errHandler.reportMatch(this);
                this.consume();
            }
            this.state = 258;
            this.expression(8);
            break;

        case 5:
            localctx = new VariableExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 259;
            localctx.id = this.varIdentifier();
            this.state = 261;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,20,this._ctx);
            if(la_===1) {
                this.state = 260;
                localctx.der = this.match(odeGrammarParser.APOSTROPHE);

            }
            break;

        case 6:
            localctx = new ConstantExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 263;
            localctx.value = this.number();
            break;

        case 7:
            localctx = new MacroExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 264;
            this.match(odeGrammarParser.T__0);
            this.state = 265;
            localctx.id = this.varIdentifier();
            this.state = 274;
            this._errHandler.sync(this);
            var la_ = this._interp.adaptivePredict(this._input,22,this._ctx);
            if(la_===1) {
                this.state = 266;
                this.match(odeGrammarParser.LPAREN);
                this.state = 270;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
                while((((_la) & ~0x1f) == 0 && ((1 << _la) & ((1 << odeGrammarParser.T__0) | (1 << odeGrammarParser.DER) | (1 << odeGrammarParser.SUM) | (1 << odeGrammarParser.FLOAT) | (1 << odeGrammarParser.INT) | (1 << odeGrammarParser.ID) | (1 << odeGrammarParser.PLUS) | (1 << odeGrammarParser.MINUS) | (1 << odeGrammarParser.LPAREN))) !== 0) || _la===odeGrammarParser.LCRL) {
                    this.state = 267;
                    this.expression(0);
                    this.state = 272;
                    this._errHandler.sync(this);
                    _la = this._input.LA(1);
                }
                this.state = 273;
                this.match(odeGrammarParser.RPAREN);

            }
            break;

        case 8:
            localctx = new SummationExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 276;
            this.match(odeGrammarParser.SUM);
            this.state = 277;
            this.match(odeGrammarParser.LPAREN);
            this.state = 278;
            localctx.iterator = this.match(odeGrammarParser.ID);
            this.state = 279;
            this.match(odeGrammarParser.IN);
            this.state = 280;
            this.match(odeGrammarParser.LSQR);
            this.state = 281;
            localctx.bounds = this.loopBounds();
            this.state = 282;
            this.match(odeGrammarParser.RSQR);
            this.state = 283;
            this.match(odeGrammarParser.RPAREN);
            this.state = 284;
            this.match(odeGrammarParser.LCRL);
            this.state = 285;
            localctx.summationExp = this.expression(0);
            this.state = 286;
            this.match(odeGrammarParser.RCRL);
            break;

        case 9:
            localctx = new TernaryOperatorExpressionContext(this, localctx);
            this._ctx = localctx;
            _prevctx = localctx;
            this.state = 288;
            this.match(odeGrammarParser.LCRL);
            this.state = 289;
            localctx.condition = this.boolExpression(0);
            this.state = 290;
            this.match(odeGrammarParser.QUESTIONMARK);
            this.state = 291;
            localctx.first = this.expression(0);
            this.state = 292;
            this.match(odeGrammarParser.COLON);
            this.state = 293;
            localctx.second = this.expression(0);
            this.state = 294;
            this.match(odeGrammarParser.RCRL);
            break;

        }
        this._ctx.stop = this._input.LT(-1);
        this.state = 309;
        this._errHandler.sync(this);
        var _alt = this._interp.adaptivePredict(this._input,25,this._ctx)
        while(_alt!=2 && _alt!=antlr4.atn.ATN.INVALID_ALT_NUMBER) {
            if(_alt===1) {
                if(this._parseListeners!==null) {
                    this.triggerExitRuleEvent();
                }
                _prevctx = localctx;
                this.state = 307;
                this._errHandler.sync(this);
                var la_ = this._interp.adaptivePredict(this._input,24,this._ctx);
                switch(la_) {
                case 1:
                    localctx = new BinaryOperatorExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, odeGrammarParser.RULE_expression);
                    this.state = 298;
                    if (!( this.precpred(this._ctx, 9))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
                    }
                    this.state = 299;
                    localctx.op = this.match(odeGrammarParser.CARET);
                    this.state = 300;
                    localctx.right = this.expression(9);
                    break;

                case 2:
                    localctx = new BinaryOperatorExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, odeGrammarParser.RULE_expression);
                    this.state = 301;
                    if (!( this.precpred(this._ctx, 7))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
                    }
                    this.state = 302;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===odeGrammarParser.ASTERISK || _la===odeGrammarParser.DIVISION)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 303;
                    localctx.right = this.expression(8);
                    break;

                case 3:
                    localctx = new BinaryOperatorExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
                    localctx.left = _prevctx;
                    this.pushNewRecursionContext(localctx, _startState, odeGrammarParser.RULE_expression);
                    this.state = 304;
                    if (!( this.precpred(this._ctx, 6))) {
                        throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
                    }
                    this.state = 305;
                    localctx.op = this._input.LT(1);
                    _la = this._input.LA(1);
                    if(!(_la===odeGrammarParser.PLUS || _la===odeGrammarParser.MINUS)) {
                        localctx.op = this._errHandler.recoverInline(this);
                    }
                    else {
                    	this._errHandler.reportMatch(this);
                        this.consume();
                    }
                    this.state = 306;
                    localctx.right = this.expression(7);
                    break;

                } 
            }
            this.state = 311;
            this._errHandler.sync(this);
            _alt = this._interp.adaptivePredict(this._input,25,this._ctx);
        }

    } catch( error) {
        if(error instanceof antlr4.error.RecognitionException) {
	        localctx.exception = error;
	        this._errHandler.reportError(this, error);
	        this._errHandler.recover(this, error);
	    } else {
	    	throw error;
	    }
    } finally {
        this.unrollRecursionContexts(_parentctx)
    }
    return localctx;
};


function FunctionArgumentsContext(parser, parent, invokingState) {
	if(parent===undefined) {
	    parent = null;
	}
	if(invokingState===undefined || invokingState===null) {
		invokingState = -1;
	}
	antlr4.ParserRuleContext.call(this, parent, invokingState);
    this.parser = parser;
    this.ruleIndex = odeGrammarParser.RULE_functionArguments;
    return this;
}

FunctionArgumentsContext.prototype = Object.create(antlr4.ParserRuleContext.prototype);
FunctionArgumentsContext.prototype.constructor = FunctionArgumentsContext;

FunctionArgumentsContext.prototype.expression = function(i) {
    if(i===undefined) {
        i = null;
    }
    if(i===null) {
        return this.getTypedRuleContexts(ExpressionContext);
    } else {
        return this.getTypedRuleContext(ExpressionContext,i);
    }
};

FunctionArgumentsContext.prototype.COMMA = function(i) {
	if(i===undefined) {
		i = null;
	}
    if(i===null) {
        return this.getTokens(odeGrammarParser.COMMA);
    } else {
        return this.getToken(odeGrammarParser.COMMA, i);
    }
};


FunctionArgumentsContext.prototype.accept = function(visitor) {
    if ( visitor instanceof odeGrammarVisitor ) {
        return visitor.visitFunctionArguments(this);
    } else {
        return visitor.visitChildren(this);
    }
};




odeGrammarParser.FunctionArgumentsContext = FunctionArgumentsContext;

odeGrammarParser.prototype.functionArguments = function() {

    var localctx = new FunctionArgumentsContext(this, this._ctx, this.state);
    this.enterRule(localctx, 44, odeGrammarParser.RULE_functionArguments);
    var _la = 0; // Token type
    try {
        this.state = 321;
        this._errHandler.sync(this);
        switch(this._input.LA(1)) {
        case odeGrammarParser.T__0:
        case odeGrammarParser.DER:
        case odeGrammarParser.SUM:
        case odeGrammarParser.FLOAT:
        case odeGrammarParser.INT:
        case odeGrammarParser.ID:
        case odeGrammarParser.PLUS:
        case odeGrammarParser.MINUS:
        case odeGrammarParser.LPAREN:
        case odeGrammarParser.LCRL:
            this.enterOuterAlt(localctx, 1);
            this.state = 312;
            this.expression(0);
            this.state = 317;
            this._errHandler.sync(this);
            _la = this._input.LA(1);
            while(_la===odeGrammarParser.COMMA) {
                this.state = 313;
                this.match(odeGrammarParser.COMMA);
                this.state = 314;
                this.expression(0);
                this.state = 319;
                this._errHandler.sync(this);
                _la = this._input.LA(1);
            }
            break;
        case odeGrammarParser.RPAREN:
            this.enterOuterAlt(localctx, 2);

            break;
        default:
            throw new antlr4.error.NoViableAltException(this);
        }
    } catch (re) {
    	if(re instanceof antlr4.error.RecognitionException) {
	        localctx.exception = re;
	        this._errHandler.reportError(this, re);
	        this._errHandler.recover(this, re);
	    } else {
	    	throw re;
	    }
    } finally {
        this.exitRule();
    }
    return localctx;
};


odeGrammarParser.prototype.sempred = function(localctx, ruleIndex, predIndex) {
	switch(ruleIndex) {
	case 20:
			return this.boolExpression_sempred(localctx, predIndex);
	case 21:
			return this.expression_sempred(localctx, predIndex);
    default:
        throw "No predicate with index:" + ruleIndex;
   }
};

odeGrammarParser.prototype.boolExpression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 0:
			return this.precpred(this._ctx, 3);
		case 1:
			return this.precpred(this._ctx, 2);
		default:
			throw "No predicate with index:" + predIndex;
	}
};

odeGrammarParser.prototype.expression_sempred = function(localctx, predIndex) {
	switch(predIndex) {
		case 2:
			return this.precpred(this._ctx, 9);
		case 3:
			return this.precpred(this._ctx, 7);
		case 4:
			return this.precpred(this._ctx, 6);
		default:
			throw "No predicate with index:" + predIndex;
	}
};


exports.odeGrammarParser = odeGrammarParser;


/***/ }),

/***/ "./src/grammar/antlrOutput/odeGrammarVisitor.js":
/*!******************************************************!*\
  !*** ./src/grammar/antlrOutput/odeGrammarVisitor.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Generated from e:\projects\SolversJS\src\grammar\odeGrammar.g4 by ANTLR 4.8
// jshint ignore: start
var antlr4 = __webpack_require__(/*! antlr4/index */ "./node_modules/antlr4/index.js");

// This class defines a complete generic visitor for a parse tree produced by odeGrammarParser.

function odeGrammarVisitor() {
	antlr4.tree.ParseTreeVisitor.call(this);
	return this;
}

odeGrammarVisitor.prototype = Object.create(antlr4.tree.ParseTreeVisitor.prototype);
odeGrammarVisitor.prototype.constructor = odeGrammarVisitor;

// Visit a parse tree produced by odeGrammarParser#dae.
odeGrammarVisitor.prototype.visitDae = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#daeStatement.
odeGrammarVisitor.prototype.visitDaeStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#hybrid.
odeGrammarVisitor.prototype.visitHybrid = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#number.
odeGrammarVisitor.prototype.visitNumber = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#hybridStatement.
odeGrammarVisitor.prototype.visitHybridStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#index.
odeGrammarVisitor.prototype.visitIndex = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#varIdentifier.
odeGrammarVisitor.prototype.visitVarIdentifier = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#loopStatement.
odeGrammarVisitor.prototype.visitLoopStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#loopBody.
odeGrammarVisitor.prototype.visitLoopBody = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#macroStatement.
odeGrammarVisitor.prototype.visitMacroStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#macroArguments.
odeGrammarVisitor.prototype.visitMacroArguments = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#loopBounds.
odeGrammarVisitor.prototype.visitLoopBounds = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#loop.
odeGrammarVisitor.prototype.visitLoop = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#equation.
odeGrammarVisitor.prototype.visitEquation = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#setter.
odeGrammarVisitor.prototype.visitSetter = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#initialCondition.
odeGrammarVisitor.prototype.visitInitialCondition = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#constantStatement.
odeGrammarVisitor.prototype.visitConstantStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#stateStatement.
odeGrammarVisitor.prototype.visitStateStatement = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#stateDef.
odeGrammarVisitor.prototype.visitStateDef = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#stateTransition.
odeGrammarVisitor.prototype.visitStateTransition = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BoolConstant.
odeGrammarVisitor.prototype.visitBoolConstant = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BoolUnaryOperator.
odeGrammarVisitor.prototype.visitBoolUnaryOperator = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BracketBoolExpression.
odeGrammarVisitor.prototype.visitBracketBoolExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BBoolBinaryOperator.
odeGrammarVisitor.prototype.visitBBoolBinaryOperator = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#EBoolBinaryOperator.
odeGrammarVisitor.prototype.visitEBoolBinaryOperator = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BracketExpression.
odeGrammarVisitor.prototype.visitBracketExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#MacroExpression.
odeGrammarVisitor.prototype.visitMacroExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#BinaryOperatorExpression.
odeGrammarVisitor.prototype.visitBinaryOperatorExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#FunctionExpression.
odeGrammarVisitor.prototype.visitFunctionExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#UnaryOperatorExpression.
odeGrammarVisitor.prototype.visitUnaryOperatorExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#ConstantExpression.
odeGrammarVisitor.prototype.visitConstantExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#SummationExpression.
odeGrammarVisitor.prototype.visitSummationExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#FunctionDerivative.
odeGrammarVisitor.prototype.visitFunctionDerivative = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#VariableExpression.
odeGrammarVisitor.prototype.visitVariableExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#TernaryOperatorExpression.
odeGrammarVisitor.prototype.visitTernaryOperatorExpression = function(ctx) {
  return this.visitChildren(ctx);
};


// Visit a parse tree produced by odeGrammarParser#functionArguments.
odeGrammarVisitor.prototype.visitFunctionArguments = function(ctx) {
  return this.visitChildren(ctx);
};



exports.odeGrammarVisitor = odeGrammarVisitor;

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ui_1 = __webpack_require__(/*! ./ui */ "./src/ui.ts");
const jquery_1 = __importDefault(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
ui_1.ui.init();
(function () {
    var data = [];
    var layout = {
        title: 'Result',
        width: jquery_1.default("#plot-area").width(),
        height: jquery_1.default("#plot-area").height(),
        paper_bgcolor: 'rgba(245,245,245,1)',
        plot_bgcolor: 'rgba(245,245,245,1)'
    };
    //@ts-ignore
    Plotly.newPlot('plot-area', data, layout, { responsive: true });
})();
window.onresize = function () {
    if (ui_1.ui.isResultsTab) {
        //@ts-ignore
        Plotly.relayout('plot-area', {
            width: jquery_1.default("#plot-area").width(),
            height: jquery_1.default("#plot-area").height()
        });
        //console.log($("#plot-area").width());
    }
};
ui_1.ui.openTab("run");
ui_1.ui.addLogMessage("Start");
ui_1.ui.loadDaeExample("stiff-equation");
ui_1.ui.showDebug();


/***/ }),

/***/ "./src/math/gauss.ts":
/*!***************************!*\
  !*** ./src/math/gauss.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.gauss = void 0;
const vector_1 = __webpack_require__(/*! ./vector */ "./src/math/vector.ts");
class gauss {
    /**
     * gauss method for linear equations with rows sorting
     */
    static solve(A, b) {
        var rang = b.length();
        var x = vector_1.vector.empty(rang);
        let epsilon = 0.001;
        var indexes = new Array(rang);
        for (var i = 0; i < rang; i++) {
            indexes[i] = i;
        }
        for (var l = 0; l < rang; l++) {
            var max = l;
            for (var i = l + 1; i < rang; i++) {
                if (Math.abs(A.get(indexes[i], l)) > Math.abs(A.get(indexes[max], l)))
                    max = i;
            }
            if (max != l) {
                var temp = indexes[l];
                indexes[l] = indexes[max];
                indexes[max] = temp;
            }
            if (Math.abs(A.get(indexes[l], l)) < epsilon) {
                for (var i = 0; i < rang; i++)
                    x.set(0.0, i);
                return x;
            }
            for (var i = l + 1; i < rang; i++)
                A.set(A.get(indexes[l], i) / A.get(indexes[l], l), indexes[l], i);
            b.set(b.get(indexes[l]) / A.get(indexes[l], l), indexes[l]);
            A.set(1, indexes[l], l);
            for (var i = l + 1; i < rang; i++) {
                for (var k = l + 1; k < rang; k++)
                    A.set(A.get(indexes[i], k) - A.get(indexes[i], l) * A.get(indexes[l], k), indexes[i], k);
                b.set(b.get(indexes[i]) - A.get(indexes[i], l) * b.get(indexes[l]), indexes[i]);
                A.set(0, indexes[i], l);
            }
        }
        x.set(b.get(indexes[rang - 1]), rang - 1);
        for (var i = rang - 2; i > -1; i--) {
            var k = 0.;
            for (var j = i + 1; j < rang; j++) {
                k = k + A.get(indexes[i], j) * x.get(j);
            }
            x.set(b.get(indexes[i]) - k, i);
        }
        return x;
    }
}
exports.gauss = gauss;


/***/ }),

/***/ "./src/math/matrix.ts":
/*!****************************!*\
  !*** ./src/math/matrix.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.matrix = void 0;
const vector_1 = __webpack_require__(/*! ./vector */ "./src/math/vector.ts");
class matrix {
    constructor(data, columns, rows) {
        this.data = data;
        this.width = columns;
        this.height = rows;
    }
    multVec(dx) {
        let result = vector_1.vector.empty(this.height);
        for (let i = 0; i < this.height; i++) {
            let v = 0;
            for (let j = 0; j < this.width; j++) {
                v += this.get(j, i) * dx.get(j);
            }
            result.set(v, i);
        }
        return result;
    }
    /**
    * creates empty identity matrix
    */
    static identity(size) {
        let data;
        (data = []).length = size * size;
        data.fill(0);
        for (let i = 0; i < size; i++) {
            data[i + i * size] = 1;
        }
        return new matrix(data, size, size);
    }
    /**
    * creates empty square matrix
    */
    static emptySquare(size) {
        let data;
        (data = []).length = size * size;
        data.fill(0);
        return new matrix(data, size, size);
    }
    /**
    * creates empty rectangular matrix
    */
    static empty(rows, columns) {
        let data;
        (data = []).length = rows * columns;
        data.fill(0);
        return new matrix(data, columns, rows);
    }
    static add(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] + b.data[i]);
        return new matrix(result, a.width, a.height);
    }
    static sub(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] - b.data[i]);
        return new matrix(result, a.width, a.height);
    }
    static scale(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] * b);
        return new matrix(result, a.width, a.height);
    }
    /**
     * matrix multiplication
     * @param a matrix with (width = w_a, height = h_a)
     * @param b matrix with (width = w_b, height = w_a)
     * @returns matrix with (width = w_b, height = h_a)
     */
    static mult(a, b) {
        let result = matrix.empty(a.height, b.width);
        //for each cell in the result
        for (let j = 0; j < a.height; j++) {
            for (let i = 0; i < b.width; i++) {
                let value = 0;
                for (let k = 0; k < a.width; k++) {
                    value += a.get(j, k) * b.get(k, i);
                }
                result.set(value, j, i);
            }
        }
        return result;
    }
    /**
    * get value
    * @param row row
    * @param column column
    */
    get(row, column) {
        return this.data[row * this.width + column];
    }
    /**
    * set value
    * @param value value
    * @param row row
    * @param column column
    */
    set(value, row, column) {
        this.data[row * this.width + column] = value;
    }
    /**
    * multiply matrix by scalar and store result in dest
    * @param b scalar
    * @param dest destination matrix
    * @return result
    */
    scale(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] * b;
        return this;
    }
    add(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] + b.data[i];
        return this;
    }
    sub(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] - b.data[i];
        return this;
    }
    scaleSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] *= b;
        return this;
    }
    addSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] += b.data[i];
        return this;
    }
    subSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] -= b.data[i];
        return this;
    }
    addSubMatrix(b, rowOffset, columnOffset) {
        for (let j = 0; j < b.height; j++) {
            for (let i = 0; i < b.width; i++) {
                let value = this.get(j + rowOffset, i + columnOffset) + b.get(j, i);
                this.set(value, j + rowOffset, i + columnOffset);
            }
        }
        return this;
    }
    subSubMatrix(b, rowOffset, columnOffset) {
        for (let j = 0; j < b.height; j++) {
            for (let i = 0; i < b.width; i++) {
                let value = this.get(j + rowOffset, i + columnOffset) - b.get(j, i);
                this.set(value, j + rowOffset, i + columnOffset);
            }
        }
        return this;
    }
}
exports.matrix = matrix;


/***/ }),

/***/ "./src/math/newton.ts":
/*!****************************!*\
  !*** ./src/math/newton.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NewtonSolver = void 0;
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const gauss_1 = __webpack_require__(/*! ../math/gauss */ "./src/math/gauss.ts");
class NewtonSolver {
    constructor(iterations, fAbsTol, fRelTol, alpha, minIterations = 0) {
        this.minIterations = 0;
        this.iterations = iterations;
        this.fAbsTol = fAbsTol;
        this.fRelTol = fRelTol;
        this.alpha = alpha;
        this.minIterations = minIterations;
    }
    getMinIterations() {
        return this.minIterations;
    }
    getIterations() {
        return this.iterations;
    }
    getAbsTol() {
        return this.fAbsTol;
    }
    getRelTol() {
        return this.fRelTol;
    }
    getAlpha() {
        return this.alpha;
    }
    setMinIterations(value) {
        this.minIterations = value;
    }
    setIterations(value) {
        this.iterations = value;
    }
    setAbsTol(value) {
        this.fAbsTol = value;
    }
    setRelTol(value) {
        this.fRelTol = value;
    }
    setAlpha(value) {
        this.alpha = value;
    }
    solve(F, J, length, x0) {
        let x;
        if (x0 == undefined)
            x = vector_1.vector.empty(length);
        else
            x = x0.clone();
        let f = F(x);
        let f0Norm = f.norm2();
        for (let i = 0; i < this.iterations; i++) {
            let j = J(x);
            let dx = gauss_1.gauss.solve(j, f.scaleSelf(-this.alpha));
            x.addSelf(dx);
            f = F(x);
            if (i >= this.minIterations && f.norm2() < this.fAbsTol + this.fRelTol * f0Norm) {
                return x;
            }
        }
        throw new Error("Divergence of newton method");
    }
    solveSystem(system, x0) {
        let x;
        if (x0 == undefined)
            x = vector_1.vector.empty(system.length());
        else
            x = x0.clone();
        let F = system.F(x);
        let f0Norm = F.norm2();
        for (let i = 0; i < this.iterations; i++) {
            let J = system.J(x);
            let dx = gauss_1.gauss.solve(J, F.scaleSelf(-this.alpha));
            x.addSelf(dx);
            F = system.F(x);
            if (i >= this.minIterations && F.norm2() < this.fAbsTol + this.fRelTol * f0Norm) {
                return x;
            }
        }
        throw new Error("Divergence of newton method");
    }
}
exports.NewtonSolver = NewtonSolver;


/***/ }),

/***/ "./src/math/vector.ts":
/*!****************************!*\
  !*** ./src/math/vector.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.vector = void 0;
const matrix_1 = __webpack_require__(/*! ./matrix */ "./src/math/matrix.ts");
function lerp(a, b, t) {
    return a * (1 - t) + b * t;
}
class vector {
    constructor(data) {
        this.data = data;
    }
    static outer(a, b) {
        let result = matrix_1.matrix.empty(a.length(), b.length());
        for (let j = 0; j < a.length(); j++) {
            for (let i = 0; i < b.length(); i++) {
                result.set(a.get(j) * b.get(i), j, i);
            }
        }
        return result;
    }
    static concat(vectors) {
        let data = [];
        vectors.forEach(function (item) {
            data = data.concat(item.data);
        });
        return new vector(data);
    }
    static dot(a, b) {
        let result = 0;
        for (let i = 0; i < a.length(); i++) {
            result += a.data[i] * b.data[i];
        }
        return result;
    }
    /**
     * vector interpolation
     */
    static mix(a, b, t) {
        let result = a.clone();
        for (let i = 0; i < a.length(); i++) {
            result.data[i] = lerp(result.data[i], b.data[i], t);
        }
        return result;
    }
    static empty(length) {
        let data;
        (data = []).length = length;
        data.fill(0);
        return new vector(data);
    }
    static add(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] + b.data[i]);
        return new vector(result);
    }
    static sub(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] - b.data[i]);
        return new vector(result);
    }
    static scale(a, b) {
        let result = [];
        for (let i = 0; i < a.data.length; i++)
            result.push(a.data[i] * b);
        return new vector(result);
    }
    clone() {
        return new vector(this.data.slice());
    }
    addSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] += b.data[i];
        return this;
    }
    subSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] -= b.data[i];
        return this;
    }
    scaleSelf(b) {
        for (let i = 0; i < this.data.length; i++)
            this.data[i] *= b;
        return this;
    }
    get(i) {
        return this.data[i];
    }
    set(value, i) {
        this.data[i] = value;
    }
    length() {
        return this.data.length;
    }
    getSubVector(offset, length) {
        let resultData = new Array(length);
        for (let i = 0; i < length; i++)
            resultData[i] = this.data[offset + i];
        return new vector(resultData);
    }
    addSubVector(b, offset) {
        for (let i = 0; i < b.length(); i++)
            this.data[i + offset] += b.get(i);
        return this;
    }
    subSubVector(b, offset) {
        for (let i = 0; i < b.length(); i++)
            this.data[i + offset] -= b.get(i);
        return this;
    }
    add(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] + b.data[i];
        return dest;
    }
    sub(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] - b.data[i];
        return dest;
    }
    scale(b, dest) {
        if (dest == undefined) {
            dest = this;
        }
        for (let i = 0; i < this.data.length; i++)
            dest.data[i] = this.data[i] * b;
        return dest;
    }
    norm2() {
        let result = 0;
        for (let i = 0; i < this.data.length; i++)
            result += this.data[i] * this.data[i];
        return Math.sqrt(result);
    }
    norm2Sqr() {
        return vector.dot(this, this);
    }
}
exports.vector = vector;


/***/ }),

/***/ "./src/methods.ts":
/*!************************!*\
  !*** ./src/methods.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.methods = exports.UIParameters = void 0;
const euler_1 = __webpack_require__(/*! ./dae/solvers/edae/euler */ "./src/dae/solvers/edae/euler.ts");
const euler_2 = __webpack_require__(/*! ./dae/solvers/idae/euler */ "./src/dae/solvers/idae/euler.ts");
const rk_1 = __webpack_require__(/*! ./dae/solvers/edae/rk */ "./src/dae/solvers/edae/rk.ts");
const rk_2 = __webpack_require__(/*! ./dae/solvers/idae/rk */ "./src/dae/solvers/idae/rk.ts");
const midpoint_1 = __webpack_require__(/*! ./dae/solvers/idae/midpoint */ "./src/dae/solvers/idae/midpoint.ts");
const trapezoidal_1 = __webpack_require__(/*! ./dae/solvers/idae/trapezoidal */ "./src/dae/solvers/idae/trapezoidal.ts");
const midpoint_2 = __webpack_require__(/*! ./dae/solvers/edae/midpoint */ "./src/dae/solvers/edae/midpoint.ts");
const trapezoidal_2 = __webpack_require__(/*! ./dae/solvers/edae/trapezoidal */ "./src/dae/solvers/edae/trapezoidal.ts");
const algebraicSolver_1 = __webpack_require__(/*! ./dae/solvers/edae/algebraicSolver */ "./src/dae/solvers/edae/algebraicSolver.ts");
const algebraicSolver_2 = __webpack_require__(/*! ./dae/solvers/idae/algebraicSolver */ "./src/dae/solvers/idae/algebraicSolver.ts");
const newton_1 = __webpack_require__(/*! ./math/newton */ "./src/math/newton.ts");
class UIParameters {
}
exports.UIParameters = UIParameters;
class Method {
}
exports.methods = {
    edopri5: {
        name: "DOPRI5",
        autostep: true,
        implicit: false,
        edaeInit: function (p) {
            let s = p.solver.stepControl;
            return new rk_1.EDAE_DOPRI5(s.minStep, p.solver.step, s.errTol);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_DOPRI5(p.solver.stepControl.minStep, p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters), p.solver.stepControl.errTol);
        }
    },
    eeuler: {
        name: "Euler",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new euler_1.EDAE_EEuler(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new euler_2.IDAE_EEuler(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    emidpoint: {
        name: "Midpoint",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new midpoint_2.EDAE_EMidpoint(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new midpoint_1.IDAE_EMidpoint(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    etrapezoidal: {
        name: "Trapezoidal",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new trapezoidal_2.EDAE_ETrapezoidal(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new trapezoidal_1.IDAE_ETrapezoidal(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    erk4: {
        name: "Standart RK4",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK4(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK4(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    "erk4-2": {
        name: "Alt. RK4",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK4_2(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK4_2(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    "erk4-ralston": {
        name: "RK4 by Ralston",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK4_RALSTON(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK4_RALSTON(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    "ebs23": {
        name: "Bogacki Shampine 23 emb.",
        autostep: true,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_BS23(p.solver.stepControl.minStep, p.solver.step, p.solver.stepControl.errTol);
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_BS23(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    erk6: {
        name: "RK6",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK6(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK6(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    "erk6-2": {
        name: "Alt. RK6",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK6_2(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK6_2(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    erk8: {
        name: "RK8",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new rk_1.EDAE_RK8(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RK8(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    ealgebraic: {
        name: "Algebraic solver",
        autostep: false,
        implicit: false,
        edaeInit: function (p) {
            return new algebraicSolver_1.EDAE_AlgebraicSolver(p.solver.step);
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new algebraicSolver_2.IDAE_AlgebraicSolver(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    ieuler: {
        name: "Euler",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new euler_1.EDAE_IEuler(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new euler_2.IDAE_IEuler(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    imidpoint: {
        name: "Midpoint",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new midpoint_2.EDAE_IMidpoint(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new midpoint_1.IDAE_IMidpoint(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    itrapezoidal: {
        name: "Trapezoidal",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new trapezoidal_2.EDAE_ITrapezoidal(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            let s = p.solver.implicitSystemSolver;
            return new trapezoidal_1.IDAE_ITrapezoidal(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters), new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        }
    },
    iradauia5: {
        name: "RADAU IA5",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_RADAUIA5(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RADAUIA5(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    iradauiia3: {
        name: "RADAU IIA3",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_RADAUIIA3(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RADAUIIA3(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    iradauiia5: {
        name: "RADAU IIA5",
        autostep: false,
        implicit: true,
        edaeInit: function (p) {
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_RADAUIIA5(p.solver.step, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_RADAUIIA5(p.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobattoiiia2: {
        name: "LOBATTO IIIA2",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIA2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIA2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobattoiiia4: {
        name: "LOBATTO IIIA4",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIA4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIA4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobatoiiib2: {
        name: "LOBATTO IIIB2",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIB2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIB2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobattoiiib4: {
        name: "LOBATTO IIIB4",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIB4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIB4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobattoiiic2: {
        name: "LOBATTO IIIC2",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIC2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIC2(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    lobattoiiic4: {
        name: "LOBATTO IIIC4",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_LOBATTOIIIC4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_LOBATTOIIIC4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    gausslegendre4: {
        name: "GAUSS LEGENDRE 4",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_GAUSSLEGENDRE4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_GAUSSLEGENDRE4(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    gausslegendre6: {
        name: "GAUSS LEGENDRE 6",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            let i = p.solver.implicitStepSolver;
            return new rk_1.EDAE_GAUSSLEGENDRE6(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(i.iters, i.absTol, i.relTol, i.alpha, i.minIters));
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_GAUSSLEGENDRE6(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    iheunEuler: {
        name: "Heun Euler emb.",
        autostep: true,
        implicit: true,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            return new rk_1.EDAE_HeunEuler(c.minStep, p.solver.step, c.errTol);
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_HeunEuler(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    },
    imidpointEuler: {
        name: "Midpoint Euler emb.",
        autostep: true,
        implicit: false,
        edaeInit: function (p) {
            let c = p.solver.stepControl;
            return new rk_1.EDAE_MidpointEuler(c.minStep, p.solver.step, c.errTol);
        },
        idaeInit: function (p) {
            let c = p.solver.stepControl;
            let s = p.solver.implicitSystemSolver;
            return new rk_2.IDAE_MidpointEuler(c.minStep, p.solver.step, c.errTol, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
        }
    }
};


/***/ }),

/***/ "./src/test/test.ts":
/*!**************************!*\
  !*** ./src/test/test.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = exports.handleErrors = exports.plotExpression = void 0;
const adaptiveStep_1 = __webpack_require__(/*! ../dae/adaptiveStep */ "./src/dae/adaptiveStep.ts");
const eventDetection_1 = __webpack_require__(/*! ../dae/eventDetection */ "./src/dae/eventDetection.ts");
const daeVector_1 = __webpack_require__(/*! ../dae/daeVector */ "./src/dae/daeVector.ts");
const idaeHybridSystem_1 = __webpack_require__(/*! ../dae/idaeHybridSystem */ "./src/dae/idaeHybridSystem.ts");
const edaeHybridSystem_1 = __webpack_require__(/*! ../dae/edaeHybridSystem */ "./src/dae/edaeHybridSystem.ts");
const edaeHybridSolver_1 = __webpack_require__(/*! ../dae/edaeHybridSolver */ "./src/dae/edaeHybridSolver.ts");
const idaeHybridSolver_1 = __webpack_require__(/*! ../dae/idaeHybridSolver */ "./src/dae/idaeHybridSolver.ts");
const vector_1 = __webpack_require__(/*! ../math/vector */ "./src/math/vector.ts");
const matrix_1 = __webpack_require__(/*! ../math/matrix */ "./src/math/matrix.ts");
const euler_1 = __webpack_require__(/*! ../dae/solvers/idae/euler */ "./src/dae/solvers/idae/euler.ts");
const jquery_1 = __importDefault(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
const rk_1 = __webpack_require__(/*! ../dae/solvers/edae/rk */ "./src/dae/solvers/edae/rk.ts");
const rk_2 = __webpack_require__(/*! ../dae/solvers/idae/rk */ "./src/dae/solvers/idae/rk.ts");
const adams_bashforth_1 = __webpack_require__(/*! ../dae/solvers/edae/adams-bashforth */ "./src/dae/solvers/edae/adams-bashforth.ts");
const adams_bashforth_2 = __webpack_require__(/*! ../dae/solvers/idae/adams-bashforth */ "./src/dae/solvers/idae/adams-bashforth.ts");
const newton_1 = __webpack_require__(/*! ../math/newton */ "./src/math/newton.ts");
const ui_1 = __webpack_require__(/*! ../ui */ "./src/ui.ts");
const compiler_1 = __webpack_require__(/*! ../compiler/compiler */ "./src/compiler/compiler.ts");
const compilerError_1 = __webpack_require__(/*! ../compiler/compilerError */ "./src/compiler/compilerError.ts");
const hybridCompiler_1 = __webpack_require__(/*! ../compiler/hybridCompiler */ "./src/compiler/hybridCompiler.ts");
const astNode_1 = __webpack_require__(/*! ../compiler/astNode */ "./src/compiler/astNode.ts");
const douglasPeuckerSimplification_1 = __webpack_require__(/*! ../curveSimplification/douglasPeuckerSimplification */ "./src/curveSimplification/douglasPeuckerSimplification.ts");
const perpendicularDistanceSimplification_1 = __webpack_require__(/*! ../curveSimplification/perpendicularDistanceSimplification */ "./src/curveSimplification/perpendicularDistanceSimplification.ts");
const radialDistanceSimplification_1 = __webpack_require__(/*! ../curveSimplification/radialDistanceSimplification */ "./src/curveSimplification/radialDistanceSimplification.ts");
const langSimplification_1 = __webpack_require__(/*! ../curveSimplification/langSimplification */ "./src/curveSimplification/langSimplification.ts");
const reumannWitkamSimplification_1 = __webpack_require__(/*! ../curveSimplification/reumannWitkamSimplification */ "./src/curveSimplification/reumannWitkamSimplification.ts");
const opheimSimplification_1 = __webpack_require__(/*! ../curveSimplification/opheimSimplification */ "./src/curveSimplification/opheimSimplification.ts");
const douglasPeuckerNSimplification_1 = __webpack_require__(/*! ../curveSimplification/douglasPeuckerNSimplification */ "./src/curveSimplification/douglasPeuckerNSimplification.ts");
const nthPointSimplification_1 = __webpack_require__(/*! ../curveSimplification/nthPointSimplification */ "./src/curveSimplification/nthPointSimplification.ts");
function solveExplicit(x0, t0, t1, solver, system) {
    let solution = [];
    let z0 = system.g(x0, t0);
    let point = new daeVector_1.DAEVector(x0, z0, t0);
    solution.push(point);
    for (let t = t0; t <= t1; t = point.t) {
        point = solver.makeStep(point.x, point.z, point.t, system);
        solution.push(point);
    }
    return solution;
}
function solveImplicit(x0, z0, t0, t1, solver, system) {
    let solution = [];
    z0 = solver.solve_z(x0, z0, t0, system);
    let point = new daeVector_1.DAEVector(x0, z0, t0);
    solution.push(point);
    for (let t = t0; t <= t1; t = point.t) {
        point = solver.makeStep(point.x, point.z, point.t, system);
        solution.push(point);
    }
    return solution;
}
function plotExpression(t0, t1, dt, expression, label) {
    let trace = {
        x: [],
        y: [],
        type: "scattergl",
        mode: 'markers+lines',
        name: label
    };
    for (let t = t0; t <= t1; t += dt) {
        trace.x.push(t);
        trace.y.push(expression.execute([t]));
    }
    //@ts-ignore
    Plotly.addTraces('plot-area', [trace]);
}
exports.plotExpression = plotExpression;
function handleErrors(e) {
    if (e instanceof compilerError_1.CompilerError) {
        e.messages.forEach(function (item) {
            ui_1.ui.addLogMessage(item.print());
            ui_1.ui.addErrorMessage(item.message, item.textPos);
            console.log(item.print());
        });
    }
    else if (e instanceof Error) {
        ui_1.ui.addLogMessage(e.message);
        ui_1.ui.addErrorMessage(e.message, astNode_1.TextPosition.invalid());
        console.log(e.message);
    }
    else {
        ui_1.ui.addLogMessage("Exception: " + e);
        ui_1.ui.addErrorMessage("Exception: " + e, astNode_1.TextPosition.invalid());
    }
}
exports.handleErrors = handleErrors;
class Test {
    static testEDAESolvers(t0, t1, x0, solvers, system, xNames, zNames, label) {
        solvers.forEach(function (item) {
            ui_1.ui.addLogMessage(label + ": " + item.label);
            console.log(label + ": " + item.label);
            try {
                let values = solveExplicit(x0, t0, t1, item.method, system);
                Test.showOutput(values, xNames, zNames, label + " " + item.label);
            }
            catch (error) {
                console.log("Error during " + label + ": " + error);
                ui_1.ui.addLogMessage("Error during " + label + ": " + error);
            }
        });
    }
    static testIDAESolvers(t0, t1, x0, solvers, system, xNames, zNames, label) {
        solvers.forEach(function (item) {
            ui_1.ui.addLogMessage(label + ": " + item.label);
            console.log(label + ": " + item.label);
            try {
                let values = solveImplicit(x0, vector_1.vector.empty(system.length_z()), t0, t1, item.method, system);
                Test.showOutput(values, xNames, zNames, label + " " + item.label);
            }
            catch (error) {
                console.log("Error during " + label + ": " + error);
                ui_1.ui.addLogMessage("Error during " + label + ": " + error);
            }
        });
    }
    static showOutput(values, difVariables, algVariables, label) {
        let data = [];
        difVariables.forEach(function (item, index) {
            if (item == null)
                return;
            let trace = {
                x: [],
                y: [],
                type: "scattergl",
                mode: 'markers+lines',
                name: label + ": " + item
            };
            for (let i = 0; i < values.length; i++) {
                let valueVector = values[i];
                trace.y.push(valueVector.x.get(index));
                trace.x.push(valueVector.t);
            }
            data.push(trace);
        });
        algVariables.forEach(function (item, index) {
            if (item == null)
                return;
            let trace = {
                x: [],
                y: [],
                type: "scattergl",
                mode: 'markers+lines',
                name: label + ": " + item
            };
            for (let i = 0; i < values.length; i++) {
                let valueVector = values[i];
                trace.y.push(valueVector.z.get(index));
                trace.x.push(valueVector.t);
            }
            data.push(trace);
        });
        //@ts-ignore
        Plotly.addTraces('plot-area', data);
    }
    /*static serializeOutput(values:DAEVector[],states:number[],variableNamesX:string[],variableNamesZ:string[]):string{
        let result = "";
        variableNamesX.forEach(function(name, index){
            result.append(name);
            result.append(",");
        });
        variableNamesZ.forEach(function(name, index){
            result.append(name);
            result.append(",");
        });
        result.append("state");
        result.append(",");
        result.append("t");
        values.t.forEach(function(id){
                result.append("\n");
            variableNamesX.forEach(function(name,index){
                result.append(values.x[id].get(index));
                result.append(",");
            });
            variableNamesZ.forEach(function(name,index){
                result.append(values.z[id].get(index));
                result.append(",");
            });
            result.append(states[id]);
            result.append(",");
            result.append(values.t[id]);
        });
    }*/
    static initPlot() {
        var layout = {
            title: 'Result',
            type: "scattergl",
            width: jquery_1.default("#plot-area").width(),
            height: jquery_1.default("#plot-area").height(),
            paper_bgcolor: 'rgba(245,245,245,1)',
            plot_bgcolor: 'rgba(245,245,245,1)',
            nticks: 30
        };
        //@ts-ignore
        Plotly.newPlot('plot-area', [], layout, { responsive: true });
    }
    static runTests() {
        jquery_1.default("log").val("");
        ui_1.ui.addLogMessage("Run tests");
        //ui.clearLog();
        let EDAESolvers = [
            /*{method:new EDAE_EEuler(1e-3),label:"EEuler"},
            {method:new EDAE_IEuler(1e-3,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"IEuler"},
            {method:new EDAE_EMidpoint(1e-2),label:"EMidpoint"},
            {method:new EDAE_IMidpoint(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"IMidpoint"},
            {method:new EDAE_ETrapezoidal(1e-2),label:"ETrapezoidal"},
            {method:new EDAE_ITrapezoidal(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ITrapezoidal"},*/
            { method: new rk_1.EDAE_RK4(1e-2), label: "ERK4" },
            /*{method:new EDAE_RK4_2(1e-2),label:"ERK4_2"},
            {method:new EDAE_RK4_RALSTON(1e-2),label:"ERK4_Ralston"},
            {method:new EDAE_DOPRI5(1e-2,3e-2,1e-6),label:"EDOPRI5"},
            {method:new EDAE_BS23(1e-2,3e-2,1e-6),label:"EBS23"},
            {method:new EDAE_RK6(1e-2),label:"ERK6_1"},
            {method:new EDAE_RK6_2(1e-2),label:"ERK6_2"},
            {method:new EDAE_RK8(1e-2),label:"ERK8"},
            {method:new EDAE_RADAUIA5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"IRadau_IA5"},
            {method:new EDAE_RADAUIIA3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"IRadau_IIA3"},
            {method:new EDAE_RADAUIIA5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"IRadau_IIA5"},
            {method:new EDAE_LOBATTOIIIA2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILLobatto_IIIA2"},
            {method:new EDAE_LOBATTOIIIA4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILLobatto_IIIA4"},
            {method:new EDAE_LOBATTOIIIB2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILLobatto_IIIB2"},
            {method:new EDAE_LOBATTOIIIB4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILLobatto_IIIB4"},
            {method:new EDAE_LOBATTOIIIC2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILLobatto_IIIC2"},
            {method:new EDAE_LOBATTOIIIC4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95)),label:"ILobatto_IIIC4"},
            {method:new EDAE_GAUSSLEGENDRE4(1e-2,3e-2,1e-3,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IGaussLegender4"},
            {method:new EDAE_GAUSSLEGENDRE6(1e-2,3e-2,1e-3,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IGaussLegender6"},
            {method:new EDAE_HeunEuler(1e-2,3e-2,1e-4),label:"IHeunEuler"},
            {method:new EDAE_MidpointEuler(1e-2,3e-2,1e-4),label:"IMidpointEuler"},
            {method:new EDAE_BDF2(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF2"},
            {method:new EDAE_BDF3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF3"},
            {method:new EDAE_BDF4(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF4"},
            {method:new EDAE_BDF5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF5"},
            {method:new EDAE_BDF6(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF6"},
            {method:new EDAE_AM2(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6)),label:"IAM2"},
            {method:new EDAE_AM3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6)),label:"IAM3"},
            {method:new EDAE_AM4(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6)),label:"IAM4"},
            {method:new EDAE_AM5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6)),label:"IAM5"},
            {method:new EDAE_AM6(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6)),label:"IAM6"},*/
            { method: new adams_bashforth_1.EDAE_AB2(1e-2), label: "EAB2" },
            { method: new adams_bashforth_1.EDAE_AB3(1e-2), label: "EAB3" },
            { method: new adams_bashforth_1.EDAE_AB4(1e-2), label: "EAB4" },
            { method: new adams_bashforth_1.EDAE_AB5(1e-2), label: "EAB5" },
            { method: new adams_bashforth_1.EDAE_AB6(1e-2), label: "EAB6" }
        ];
        let IDAESolvers = [
            /*{method:new IDAE_EEuler(1e-3,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"EEuler"},
            {method:new IDAE_IEuler(1e-3, new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"IEuler"},
            {method:new IDAE_EMidpoint(1e-2,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"EMidpoint"},
            {method:new IDAE_IMidpoint(1e-2,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"IMidpoint"},
            {method:new IDAE_ETrapezoidal(1e-2,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"ETrapezoidal"},
            {method:new IDAE_ITrapezoidal(1e-2,new NewtonSolver(20,1e-5,1e-5,0.95,4), new NewtonSolver(20,1e-2,1e-3,0.95)),label:"ITrapezoidal"},*/
            { method: new rk_2.IDAE_RK4(1e-2, new newton_1.NewtonSolver(20, 1e-4, 1e-5, 0.95, 4)), label: "ERK4" },
            /*{method:new IDAE_RK4_2(1e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"ERK4_2"},
            {method:new IDAE_RK4_RALSTON(1e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"ERK4_Ralston"},
            {method:new IDAE_DOPRI5(1e-2,3e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4),1e-6),label:"EDOPRI5"},
            {method:new IDAE_BS23(1e-2,3e-2,1e-6,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"EBS23"},
            {method:new IDAE_RK6(1e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"ERK6_1"},
            {method:new IDAE_RK6_2(1e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"ERK6_2"},
            {method:new IDAE_RK8(1e-2,new NewtonSolver(20,1e-4,1e-5,0.95,4)),label:"ERK8"},
            {method:new IDAE_RADAUIA5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IRadau_IA5"},
            {method:new IDAE_RADAUIIA3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IRadau_IIA3"},
            {method:new IDAE_RADAUIIA5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IRadau_IIA5"},
            {method:new IDAE_LOBATTOIIIA2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILLobatto_IIIA2"},
            {method:new IDAE_LOBATTOIIIA4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILLobatto_IIIA4"},
            {method:new IDAE_LOBATTOIIIB2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILLobatto_IIIB2"},
            {method:new IDAE_LOBATTOIIIB4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILLobatto_IIIB4"},
            {method:new IDAE_LOBATTOIIIC2(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILLobatto_IIIC2"},
            {method:new IDAE_LOBATTOIIIC4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"ILobatto_IIIC4"},
            {method:new IDAE_GAUSSLEGENDRE4(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IGaussLegender4"},
            {method:new IDAE_GAUSSLEGENDRE6(1e-2,3e-2,1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IGaussLegender6"},
            {method:new IDAE_HeunEuler(1e-2,3e-2,1e-4,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"E_HeunEuler"},
            {method:new IDAE_MidpointEuler(1e-2,3e-2,1e-4,new NewtonSolver(20,1e-5,1e-5,0.95,4)),label:"E_MidpointEuler"},
            {method:new IDAE_BDF2(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF2"},
            {method:new IDAE_BDF3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF3"},
            {method:new IDAE_BDF4(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF4"},
            {method:new IDAE_BDF5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF5"},
            {method:new IDAE_BDF6(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IBDF6"},
            {method:new IDAE_AM2(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6),new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IAM2"},
            {method:new IDAE_AM3(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6),new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IAM3"},
            {method:new IDAE_AM4(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6),new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IAM4"},
            {method:new IDAE_AM5(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6),new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IAM5"},
            {method:new IDAE_AM6(1e-2,new NewtonSolver(20,1e-3,1e-4,0.95,6),new NewtonSolver(20,1e-3,1e-4,0.95,4)),label:"IAM6"},*/
            { method: new adams_bashforth_2.IDAE_AB2(1e-2, new newton_1.NewtonSolver(25, 1e-3, 1e-4, 0.95, 4)), label: "EAB2" },
            { method: new adams_bashforth_2.IDAE_AB3(1e-2, new newton_1.NewtonSolver(25, 1e-3, 1e-4, 0.95, 4)), label: "EAB3" },
            { method: new adams_bashforth_2.IDAE_AB4(1e-2, new newton_1.NewtonSolver(25, 1e-3, 1e-4, 0.95, 4)), label: "EAB4" },
            { method: new adams_bashforth_2.IDAE_AB5(1e-2, new newton_1.NewtonSolver(25, 1e-3, 1e-4, 0.95, 4)), label: "EAB5" },
            { method: new adams_bashforth_2.IDAE_AB6(1e-2, new newton_1.NewtonSolver(25, 1e-3, 1e-4, 0.95, 4)), label: "EAB6" }
        ];
        try {
            this.initPlot();
            this.testEDAECompiler();
            //this.testDalquist(EDAESolvers,IDAESolvers);//
            //this.testVanDerPol(EDAESolvers,IDAESolvers);//
            //this.testLorenz(EDAESolvers,IDAESolvers);//
            //this.testIDAE(EDAESolvers,IDAESolvers);//
            //this.testJumpingBall();//passed
            //this.testIDAEJumpingBall();
            //this.testAlgebraic();//Passed
        }
        catch (error) {
            console.log(error);
            ui_1.ui.addLogMessage(JSON.stringify(error));
            jquery_1.default("#log").val(JSON.stringify(error));
        }
    }
    static testDalquist(edaeSolvers, idaeSolvers) {
        function exponentAnalytical(x0, a, t0, t1, step) {
            let result = [];
            let c = x0 / Math.exp(a * t0);
            for (let t = t0; t <= t1 * 1.001; t += step) {
                result.push(new daeVector_1.DAEVector(new vector_1.vector([Math.exp(a * t) * c]), new vector_1.vector([]), t));
            }
            return result;
        }
        /**
        dx = ax
        */
        class DalquistProblem {
            constructor(a) {
                this.a = a;
            }
            f(x, z, t) {
                return new vector_1.vector([
                    this.a * x.get(0)
                ]);
            }
            g(z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, z, t) {
                return new matrix_1.matrix([this.a], 1, 1);
            }
            dfdz(x, z, t) {
                return new matrix_1.matrix([], 0, 1);
            }
            dgdx(x, t) {
                return new matrix_1.matrix([], 1, 0);
            }
            length_x() {
                return 1;
            }
            length_z() {
                return 0;
            }
        }
        let t0 = 0;
        let t1 = 1;
        let a = -2;
        let x0 = new vector_1.vector([1]);
        let ESystem = new DalquistProblem(a);
        /*let EDAEESolver = new EDAE_EEuler(0.01);
        let EDAEISolver = new EDAE_IEuler(0.01,20,0.025,0.95);
        let EDAEESolution = solveExplicit(new vector([1]),t0,t1,EDAEESolver,ESystem);
        let EDAEISolution = solveExplicit(new vector([1]),t0,t1,EDAEISolver,ESystem);
        Test.showOutput(EDAEESolution,["x"],[],"Exponent EDAEE");
        Test.showOutput(EDAEISolution,["x"],[],"Exponent EDAEI");*/
        /**
         * dx - ax = 0
         */
        class ImplicitDalquistProblem {
            constructor(a) {
                this.a = a;
            }
            f(x, dx, z, t) {
                return new vector_1.vector([
                    dx.get(0) - this.a * x.get(0)
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, dx, z, t) {
                return new matrix_1.matrix([-this.a], 1, 1);
            }
            dfddx(x, dx, z, t) {
                return new matrix_1.matrix([1], 1, 1);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 1);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 1, 0);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            length_x() {
                return 1;
            }
            length_z() {
                return 0;
            }
        }
        let ISystem = new ImplicitDalquistProblem(a);
        /*let IDAEESolver = new IDAE_EEuler(0.01,20,0.025,0.95);
        let IDAEISolver = new IDAE_IEuler(0.01,20,0.025,0.95);
        let IDAEESolution = solveImplicit(new vector([1]),t0,t1,IDAEESolver,ISystem);
        let IDAEISolution = solveImplicit(new vector([1]),t0,t1,IDAEISolver,ISystem);
        Test.showOutput(IDAEESolution,["x"],[],"Exponent IDAEE");
        Test.showOutput(IDAEISolution,["x"],[],"Exponent IDAEI");*/
        this.testEDAESolvers(t0, t1, x0, edaeSolvers, ESystem, ["x"], [], "EDAE");
        this.testIDAESolvers(t0, t1, x0, idaeSolvers, ISystem, ["x"], [], "IDAE");
        Test.showOutput(exponentAnalytical(x0.get(0), a, t0, t1, 0.01), ["x"], [], "Exponent analytical");
    }
    static testVanDerPol(edaeSolvers, idaeSolvers) {
        /*
            dx = y;
            dy = mu(1-x^2)y - x;
        */
        class EVanDerPol {
            constructor(parameter) {
                this.parameter = parameter;
            }
            f(x, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                return new vector_1.vector([
                    _y,
                    this.parameter * (1 - _x * _x) * _y - _x
                ]);
            }
            g(z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let result;
                result = matrix_1.matrix.emptySquare(2);
                result.set(0, 0, 0);
                result.set(1, 0, 1);
                result.set(-2 * this.parameter * _y * _x - 1, 1, 0);
                result.set(this.parameter * (1 - _x * _x), 1, 1);
                return result;
            }
            dfdz(x, z, t) {
                return new matrix_1.matrix([], 0, 2);
            }
            dgdx(x, t) {
                return new matrix_1.matrix([], 2, 0);
            }
            dgdz(x, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 0;
            }
        }
        /*
            dx - y = 0;
            dy - mu(1-x^2)y + x = 0;
        */
        class IVanDerPol {
            constructor(parameter) {
                this.parameter = parameter;
            }
            f(x, dx, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let _dx = dx.get(0);
                let _dy = dx.get(1);
                return new vector_1.vector([
                    _dx - _y,
                    _dy - this.parameter * (1 - _x * _x) * _y + _x
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, dx, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                return new matrix_1.matrix([
                    0, -1,
                    1 + 2 * this.parameter * _y * _x, -this.parameter * (1 - _x * _x)
                ], 2, 2);
            }
            dfddx(x, dx, z, t) {
                return new matrix_1.matrix([
                    1, 0,
                    0, 1
                ], 2, 2);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 2);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 2, 0);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 0;
            }
        }
        let t0 = 0;
        let t1 = 5;
        let x0 = new vector_1.vector([1, 1]);
        let ESystem = new EVanDerPol(20);
        this.testEDAESolvers(t0, t1, x0, edaeSolvers, ESystem, ["x", "x'"], [], "EDAE");
        let ISystem = new IVanDerPol(20);
        this.testIDAESolvers(t0, t1, x0, idaeSolvers, ISystem, ["x", "x'"], [], "IDAE");
        /*let EDAEESolver = new EDAE_EEuler(0.01);
        let EDAEISolver = new EDAE_IEuler(0.01,20,0.05,0.95);
        let EDAEESolution = solveExplicit(new vector([1,1]),t0,t1,EDAEESolver,ESystem);
        let EDAEISolution = solveExplicit(new vector([1,1]),t0,t1,EDAEISolver,ESystem);
        Test.showOutput(EDAEESolution,["x","x'"],[],"Van der pol EDAEE");
        Test.showOutput(EDAEISolution,["x","x'"],[],"Van der pol EDAEI");*/
    }
    static testWeissinger() {
        class IWeissinger {
            f(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new vector_1.vector([
                    t * Math.pow(_x * _dx, 2) * _dx - Math.pow(_x * _dx, 2) * _x + t * (t * t + 1) * _dx - t * t * _x
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new matrix_1.matrix([
                    2 * t * _x * Math.pow(_dx, 3) - 3 * Math.pow(_x * _dx, 2) - t * t
                ], 1, 1);
            }
            dfddx(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new matrix_1.matrix([
                    3 * t * Math.pow(_x * _dx, 2) - 2 * _dx * Math.pow(_x, 3) - t * (t * t + 1)
                ], 1, 1);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 1);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 1, 0);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            length_x() {
                return 1;
            }
            length_z() {
                return 0;
            }
        }
    }
    static testLorenz(edaeSolvers, idaeSolvers) {
        /*
            dx = s(y-x)
            dy = x(p-z) - y
            dz = xy - bz
        */
        class ELorenz {
            constructor(sigma, rho, beta) {
                this.sigma = sigma;
                this.rho = rho;
                this.beta = beta;
            }
            f(x, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let _z = x.get(2);
                return new vector_1.vector([
                    this.sigma * (_y - _x),
                    _x * (this.rho - _z) - _y,
                    _x * _y - this.beta * _z
                ]);
            }
            g(x, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let _z = x.get(2);
                return new matrix_1.matrix([
                    -this.sigma, this.sigma, 0,
                    this.rho - _z, -1, -_x,
                    _y, _x, -this.beta
                ], 3, 3);
            }
            dfdz(x, z, t) {
                return new matrix_1.matrix([], 0, 3);
            }
            dgdx(x, t) {
                return new matrix_1.matrix([], 3, 0);
            }
            length_x() {
                return 3;
            }
            length_z() {
                return 0;
            }
        }
        class ILorenz {
            constructor(sigma, rho, beta) {
                this.sigma = sigma;
                this.rho = rho;
                this.beta = beta;
            }
            f(x, dx, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let _z = x.get(2);
                let _dx = dx.get(0);
                let _dy = dx.get(1);
                let _dz = dx.get(2);
                return new vector_1.vector([
                    _dx - this.sigma * (_y - _x),
                    _dy - _x * (this.rho - _z) + _y,
                    _dz - _x * _y + this.beta * _z
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, dx, z, t) {
                let _x = x.get(0);
                let _y = x.get(1);
                let _z = x.get(2);
                return new matrix_1.matrix([
                    this.sigma, -this.sigma, 0,
                    -this.rho + _z, 1, _x,
                    -_y, -_x, this.beta
                ], 3, 3);
            }
            dfddx(x, dx, z, t) {
                return new matrix_1.matrix([
                    1, 0, 0,
                    0, 1, 0,
                    0, 0, 1
                ], 3, 3);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 3);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 3, 0);
            }
            length_x() {
                return 3;
            }
            length_z() {
                return 0;
            }
        }
        let t0 = 0;
        let t1 = 5;
        let x0 = new vector_1.vector([1, 1, 1]);
        let ESystem = new ELorenz(10, 28, 8 / 3);
        let ISystem = new ILorenz(10, 28, 8 / 3);
        this.testEDAESolvers(t0, t1, x0, edaeSolvers, ESystem, ["x", "y", "z"], [], "EDAE");
        this.testIDAESolvers(t0, t1, x0, idaeSolvers, ISystem, ["x", "y", "z"], [], "IDAE");
        /*let EDAEESolver = new EDAE_EEuler(0.02);
        let EDAEISolver = new EDAE_IEuler(0.02,20,0.05,0.95);
        let EDAEESolution = solveExplicit(new vector([1,1,1]),t0,t1,EDAEESolver,ESystem);
        let EDAEISolution = solveExplicit(new vector([1,1,1]),t0,t1,EDAEISolver,ESystem);
        Test.showOutput(EDAEESolution,["x","y","z"],[],"Lorenz EDAEE");
        Test.showOutput(EDAEISolution,["x","y","z"],[],"Lorenz EDAEI");*/
    }
    static testIDAE(edaeSolvers, idaeSolvers) {
        /**
            dx = y + z + t
            dy = x
            z = x + y
            dx-y-z-t=0
            dy-x=0
            z-x-y=0
        */
        class EDAEProblem {
            f(x, z, t) {
                return new vector_1.vector([
                    x.get(1) + z.get(0) + t,
                    x.get(0)
                ]);
            }
            g(x, t) {
                return new vector_1.vector([x.get(0) + x.get(1)]);
            }
            dfdx(x, z, t) {
                return new matrix_1.matrix([0, 1, 1, 0], 2, 2);
            }
            dfdz(x, z, t) {
                return new matrix_1.matrix([1, 0], 1, 2);
            }
            dgdx(x, t) {
                return new matrix_1.matrix([1, 1], 2, 1);
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 1;
            }
        }
        class IDAEProblem {
            f(x, dx, z, t) {
                return new vector_1.vector([
                    dx.get(0) - x.get(1) - z.get(0) - t,
                    dx.get(1) - x.get(0)
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([z.get(0) - x.get(0) - x.get(1)]);
            }
            dfdx(x, dx, z, t) {
                let result;
                result = matrix_1.matrix.emptySquare(2);
                result.set(0, 0, 0);
                result.set(-1, 0, 1);
                result.set(-1, 1, 0);
                result.set(0, 1, 1);
                return result;
            }
            dfdz(x, dx, z, t) {
                let result;
                result = matrix_1.matrix.empty(2, 1);
                result.set(-1, 0, 0);
                result.set(0, 1, 0);
                return result;
            }
            dfddx(x, dx, z, t) {
                let result;
                result = matrix_1.matrix.emptySquare(2);
                result.set(1, 0, 0);
                result.set(0, 0, 1);
                result.set(0, 1, 0);
                result.set(1, 1, 1);
                return result;
            }
            dgdx(x, z, t) {
                let result;
                result = matrix_1.matrix.empty(1, 2);
                result.set(-1, 0, 0);
                result.set(-1, 0, 1);
                return result;
            }
            dgdz(x, z, t) {
                let result;
                result = matrix_1.matrix.empty(1, 1);
                result.set(1, 0, 0);
                return result;
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 1;
            }
        }
        let t0 = 0;
        let t1 = 1;
        let x0 = new vector_1.vector([0, 0]);
        let ISystem = new IDAEProblem();
        let ESystem = new EDAEProblem();
        /*let IDAEESolver = new IDAE_EEuler(0.005,20,0.05,0.95);
        let IDAEISolver = new IDAE_IEuler(0.010,20,0.01,0.95);
        let IDAEESolution = solveImplicit(new vector([0,0]),t0,t1,IDAEESolver,ISystem);
        let IDAEISolution = solveImplicit(new vector([0,0]),t0,t1,IDAEISolver,ISystem);*/
        this.testEDAESolvers(t0, t1, x0, edaeSolvers, ESystem, ["x", "y"], ["z"], "EDAE");
        this.testIDAESolvers(t0, t1, x0, idaeSolvers, ISystem, ["x", "y"], ["z"], "IDAE");
        /*Test.showOutput(IDAEESolution,["x","y"],["z"],"IDAEE problem");
        Test.showOutput(IDAEISolution,["x","y"],["z"],"IDAEI problem");*/
    }
    static testIDAEJumpingBall() {
        function getAnaltyticJumpingBall(x0, v0, t1, dt, k) {
            let result = [];
            let point = new daeVector_1.DAEVector(new vector_1.vector([x0, v0]), new vector_1.vector([]), 0);
            result.push();
            let _v0 = v0;
            let _x0 = x0;
            let g = 10;
            let t = 0;
            while (t < t1) {
                //find time of next intersection with x axis
                let eventStep = (_v0 + Math.sqrt(_v0 * _v0 + 2 * _x0 * g)) / g;
                let tNext = t + eventStep;
                let vNext = Math.abs(_v0 - g * eventStep);
                if (eventStep <= 0.001)
                    break;
                for (let _dt = 0; t < tNext; t += dt, _dt += dt) {
                    if (t >= t1)
                        return result;
                    point = new daeVector_1.DAEVector(new vector_1.vector([
                        _x0 + _v0 * _dt - g * _dt * _dt / 2,
                        _v0 - g * _dt
                    ]), new vector_1.vector([]), t);
                    result.push(point);
                }
                t = tNext;
                _x0 = 0;
                _v0 = vNext * k;
                result.push(new daeVector_1.DAEVector(new vector_1.vector([_x0, _v0]), new vector_1.vector([]), t));
            }
            return result;
        }
        /*
            constant m = 1;
            v(t0) = 0;
            x(t0) = 1;
            position: x' - v = 0;
            velocity: v' + mg = 0;
            state jump on (v<=0&&x<=0){
                set v = -v;
            } from init, jump;
        */
        class JumpStateLink {
            constructor(stateNumber, k) {
                this.stateNumber = stateNumber;
                this.k = k;
            }
            getNewState() {
                return this.stateNumber;
            }
            pr(x, z, t) {
                return x.get(0) <= 0 && x.get(1) <= 0;
            }
            p(x, z, t) {
                return Math.min(-x.get(0), -x.get(1));
            }
            dpdt(x, z, t) {
                return 0;
            }
            dpdz(x, z, t) {
                return new vector_1.vector([]);
            }
            dpdx(x, z, t) {
                let _x = x.get(0);
                let _v = x.get(1);
                if (-_x < -_v) {
                    return new vector_1.vector([-1, 0]);
                }
                return new vector_1.vector([0, -1]);
            }
            setConditions(x, z, t) {
                return new vector_1.vector([x.get(0), -x.get(1) * this.k]);
            }
        }
        class IDAEJumpState extends idaeHybridSystem_1.IDAEHybridState {
            constructor(name, links, terminal, g) {
                super(name, links, terminal);
                this._g = g;
            }
            f(x, dx, z, t) {
                return new vector_1.vector([
                    dx.get(0) - x.get(1),
                    dx.get(1) + this._g
                ]);
            }
            g(x, z, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, dx, z, t) {
                return new matrix_1.matrix([0, -1, 0, 0], 2, 2);
            }
            dfddx(x, dx, z, t) {
                return new matrix_1.matrix([1, 0, 0, 1], 2, 2);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 2);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 2, 0);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            dgdt(x, z, t) {
                return new vector_1.vector([]);
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 0;
            }
        }
        class IDAEJumpingBall extends idaeHybridSystem_1.IDAEHybridSystem {
            constructor(g, k) {
                let link = new JumpStateLink(1, k);
                let init = new IDAEJumpState("init", [link], false, g);
                let jump = new IDAEJumpState("jump", [link], false, g);
                super([init, jump]);
                this.currentState = 0;
            }
        }
        let t1 = 23;
        let k = 0.8;
        let eventDetectorSimple = new eventDetection_1.EventDetectionSimple();
        let eventDetectorComplex = new eventDetection_1.EventDetectionComplex();
        let adaptiveStepStrategy = new adaptiveStep_1.AdaptiveStepNewton(0.95, 1e-5);
        let idaeHybridSolver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetectorComplex, adaptiveStepStrategy);
        let idaeSystem = new IDAEJumpingBall(10, k);
        let initialState = new vector_1.vector([10, 15]);
        let idaeSolution;
        //idaeSolution = idaeHybridSolver.solve(initialState,0,1,idaeiEulerSolver,idaeSystem,[]);
        //Test.showOutput(idaeSolution.values,["x","v"],[],"Jumping ball idae complex with step");
        idaeHybridSolver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetectorSimple, adaptiveStepStrategy);
        //idaeSolution = idaeHybridSolver.solve(initialState,0,1,idaeiEulerSolver,idaeSystem,[]);
        //Test.showOutput(idaeSolution.values,["x","v"],[],"Jumping ball idae simple with step");
        idaeHybridSolver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetectorComplex, null);
        //idaeSolution = idaeHybridSolver.solve(initialState,0,1,idaeiEulerSolver,idaeSystem,[]);
        //Test.showOutput(idaeSolution.values,["x","v"],[],"Jumping ball idae complex");
        idaeHybridSolver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetectorSimple, null);
        //idaeSolution = idaeHybridSolver.solve(initialState,0,1,idaeiEulerSolver,idaeSystem,[]);
        //Test.showOutput(idaeSolution.values,["x","v"],[],"Jumping ball idae simple");
        Test.showOutput(getAnaltyticJumpingBall(initialState.get(0), initialState.get(1), t1, 0.05, k), ["x"], [], "Jumping ball analytical");
    }
    static testJumpingBall() {
        function getAnaltyticJumpingBall(x0, v0, t1, dt, k) {
            let result = [];
            let point = new daeVector_1.DAEVector(new vector_1.vector([x0, v0]), new vector_1.vector([]), 0);
            result.push();
            let _v0 = v0;
            let _x0 = x0;
            let g = 10;
            let t = 0;
            while (t < t1) {
                //find time of next intersection with x axis
                let eventStep = (_v0 + Math.sqrt(_v0 * _v0 + 2 * _x0 * g)) / g;
                let tNext = t + eventStep;
                let vNext = Math.abs(_v0 - g * eventStep);
                if (eventStep <= 0.001)
                    break;
                for (let _dt = 0; t < tNext; t += dt, _dt += dt) {
                    if (t >= t1)
                        return result;
                    point = new daeVector_1.DAEVector(new vector_1.vector([
                        _x0 + _v0 * _dt - g * _dt * _dt / 2,
                        _v0 - g * _dt
                    ]), new vector_1.vector([]), t);
                    result.push(point);
                }
                t = tNext;
                _x0 = 0;
                _v0 = vNext * k;
                result.push(new daeVector_1.DAEVector(new vector_1.vector([_x0, _v0]), new vector_1.vector([]), t));
            }
            return result;
        }
        class JumpStateLink {
            constructor(stateNumber, k) {
                this.stateNumber = stateNumber;
                this.k = k;
            }
            getNewState() {
                return this.stateNumber;
            }
            pr(x, z, t) {
                return x.get(0) <= 0 && x.get(1) <= 0;
            }
            p(x, z, t) {
                return Math.min(-x.get(0), -x.get(1));
            }
            dpdt(x, z, t) {
                return 0;
            }
            dpdz(x, z, t) {
                return new vector_1.vector([]);
            }
            dpdx(x, z, t) {
                let _x = x.get(0);
                let _v = x.get(1);
                if (-_x < -_v) {
                    return new vector_1.vector([-1, 0]);
                }
                return new vector_1.vector([0, -1]);
            }
            setConditions(x, z, t) {
                return new vector_1.vector([x.get(0), -x.get(1) * this.k]);
            }
        }
        class EDAEJumpState extends edaeHybridSystem_1.EDAEHybridState {
            constructor(name, links, terminal, g) {
                super(name, links, terminal);
                this._g = g;
            }
            f(x, z, t) {
                let _x = x.get(0);
                let _v = x.get(1);
                return new vector_1.vector([_v, -this._g]);
            }
            g(x, t) {
                return new vector_1.vector([]);
            }
            dfdx(x, z, t) {
                return new matrix_1.matrix([
                    0, 1,
                    0, 0
                ], 2, 2);
            }
            dfdz(x, z, t) {
                return new matrix_1.matrix([], 0, 2);
            }
            dgdx(x, t) {
                return new matrix_1.matrix([], 2, 0);
            }
            dgdt(x, t) {
                return new vector_1.vector([]);
            }
            length_x() {
                return 2;
            }
            length_z() {
                return 0;
            }
        }
        /*
            constant m = 1;
            v(t0) = 0;
            x(t0) = 1;
            x' = v;
            v'= - mg;
            state jump on (v<=0&&x<=0){
                set v = -v;
            } from init, jump;
        */
        class EDAEJumpingBall extends edaeHybridSystem_1.EDAEHybridSystem {
            constructor(g, k) {
                let link = new JumpStateLink(1, k);
                let init = new EDAEJumpState("init", [link], false, g);
                let jump = new EDAEJumpState("jump", [link], false, g);
                super([init, jump]);
                this.currentState = 0;
                //this.states = [];
                //this.states = [{name:"init",links:[link],terminal:false},{name:"jump",links:[link],terminal:false}];
            }
        }
        let t1 = 23;
        let k = 0.8;
        let adaptiveStepStrategy = new adaptiveStep_1.AdaptiveStepNewton(0.95, 1e-5);
        let eventDetectorComplex = new eventDetection_1.EventDetectionComplex();
        let eventDetectorSimple = new eventDetection_1.EventDetectionSimple();
        let initialState = new vector_1.vector([10, 15]);
        let edaeeRK4Solver = new rk_1.EDAE_RK4(1e-2);
        let edaeHybridSolver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetectorComplex, adaptiveStepStrategy);
        let edaeSystem = new EDAEJumpingBall(10, k);
        let edaeSolution;
        edaeSolution = edaeHybridSolver.solve(initialState, 0, t1, edaeeRK4Solver, edaeSystem);
        Test.showOutput(edaeSolution.values, ["x", null], [], "Jumping ball edae complex with step");
        edaeHybridSolver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetectorSimple, adaptiveStepStrategy);
        edaeSolution = edaeHybridSolver.solve(initialState, 0, t1, edaeeRK4Solver, edaeSystem);
        Test.showOutput(edaeSolution.values, ["x", null], [], "Jumping ball edae simple with step");
        edaeHybridSolver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetectorComplex, null);
        edaeSolution = edaeHybridSolver.solve(initialState, 0, t1, edaeeRK4Solver, edaeSystem);
        Test.showOutput(edaeSolution.values, ["x", null], [], "Jumping ball edae complex");
        edaeHybridSolver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetectorSimple, null);
        edaeSolution = edaeHybridSolver.solve(initialState, 0, t1, edaeeRK4Solver, edaeSystem);
        Test.showOutput(edaeSolution.values, ["x", null], [], "Jumping ball edae simple");
        Test.showOutput(getAnaltyticJumpingBall(initialState.get(0), initialState.get(1), t1, 0.1, k), ["x"], [], "Jumping ball analytical");
    }
    static testAlgebraic() {
        class AlgebraicProblem {
            f(x, dx, z, t) {
                return new vector_1.vector([]);
            }
            g(x, z, t) {
                return new vector_1.vector([Math.sin(t + z.get(0)) - t * z.get(0)]);
            }
            dfddx(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            dfdx(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 0);
            }
            dfdz() {
                return new matrix_1.matrix([], 0, 1);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 1, 0);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([Math.cos(t + z.get(0)) - t], 1, 1);
            }
            length_x() {
                return 0;
            }
            length_z() {
                return 1;
            }
        }
        let t0 = 0.5;
        let t1 = 0.8;
        let idaeeEulerSolver = new euler_1.IDAE_EEuler(0.1, new newton_1.NewtonSolver(160, 0.05, 1e-4, 0.5));
        let idaeiEulerSolver = new euler_1.IDAE_IEuler(0.05, new newton_1.NewtonSolver(80, 0.05, 1e-4, 0.75));
        let system = new AlgebraicProblem();
        let IDAEESolution = solveImplicit(new vector_1.vector([]), vector_1.vector.empty(system.length_z()), t0, t1, idaeeEulerSolver, system);
        let IDAEISolution = solveImplicit(new vector_1.vector([]), vector_1.vector.empty(system.length_z()), t0, t1, idaeiEulerSolver, system);
        Test.showOutput(IDAEESolution, [], ["z"], "Algebraic problem IDAEE");
        Test.showOutput(IDAEISolution, [], ["z"], "Algebraic problem IDAEI");
    }
    static testEDAECompiler() {
        ui_1.ui.clearErrors();
        Test.initPlot();
        try {
            let parameters = ui_1.ui.getParameters();
            let text = jquery_1.default("#text-input").val();
            let compiler = new compiler_1.DAECompiler();
            let { system, x0, x, z } = compiler.compileExplicit(text);
            let solver = new rk_1.EDAE_RK4(parameters.solver.step);
            let t0 = parameters.solver.t0;
            let t1 = parameters.solver.t0 + parameters.solver.time;
            let solution = solveExplicit(x0, t0, t1, solver, system);
            Test.showOutput(solution, x, z, "Test edae compiler");
            ui_1.ui.openTab("results");
        }
        catch (e) {
            handleErrors(e);
            ui_1.ui.openTab("main");
            ui_1.ui.openTab("errors-tab");
        }
    }
    static testIDAECompiler() {
        ui_1.ui.clearErrors();
        Test.initPlot();
        try {
            let parameters = ui_1.ui.getParameters();
            let text = jquery_1.default("#text-input").val();
            let compiler = new compiler_1.DAECompiler();
            let { system, x0, x, z, z0 } = compiler.compileImplicit(text);
            let s = parameters.solver.implicitSystemSolver;
            let solver = new rk_2.IDAE_RK4(parameters.solver.step, new newton_1.NewtonSolver(s.iters, s.absTol, s.relTol, s.alpha, s.minIters));
            let t0 = parameters.solver.t0;
            let t1 = parameters.solver.t0 + parameters.solver.time;
            let solution = solveImplicit(x0, z0, t0, t1, solver, system);
            Test.showOutput(solution, x, z, "Test idae compiler");
            ui_1.ui.openTab("results");
        }
        catch (e) {
            handleErrors(e);
            ui_1.ui.openTab("main");
            ui_1.ui.openTab("errors-tab");
        }
    }
    static testExplicitHybridCompiler() {
        ui_1.ui.clearErrors();
        Test.initPlot();
        try {
            let text = jquery_1.default("#text-input").val();
            let compiler = new hybridCompiler_1.HybridSystemCompiler();
            let sysDef = compiler.compileExplicit(text);
            let parameters = ui_1.ui.getParameters();
            let eventDetection;
            if (parameters.eventDetection.zeroCrossing.enabled) {
                let params = parameters.eventDetection.zeroCrossing;
                eventDetection = new eventDetection_1.EventDetectionComplex(params.newtonIters, params.relTol, params.absTol, params.newtonAlpha, params.bisectIters, params.timeAbsTol, params.timeRelTol);
            }
            else {
                eventDetection = new eventDetection_1.EventDetectionSimple();
            }
            let adaptiveStepStrategy;
            if (parameters.eventDetection.adaptiveStep.enabled) {
            }
            else {
                adaptiveStepStrategy = null;
            }
            let t0 = parameters.solver.t0;
            let t1 = t0 + parameters.solver.time;
            let method = ui_1.ui.methods[parameters.solver.method].edaeInit(parameters);
            let solver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetection, adaptiveStepStrategy);
            let solution = solver.solve(sysDef.x0, t0, t1, method, sysDef.system);
            Test.showOutput(solution.values, sysDef.x, sysDef.z, "Test explicit hybrid compiler");
            //ui.plotSolution(solution,sysDef.x,sysDef.z);
            ui_1.ui.openTab("results");
        }
        catch (e) {
            handleErrors(e);
            ui_1.ui.openTab("main");
            ui_1.ui.openTab("errors-tab");
        }
    }
    static testSimplification() {
        ui_1.ui.clearErrors();
        Test.initPlot();
        let methods = [
            { alg: new douglasPeuckerSimplification_1.DouglasPeuckerSimplification(0.005), name: "douglasPeucker" },
            { alg: new perpendicularDistanceSimplification_1.PerpendicularDistanceSimplification(0.01), name: "perpDist" },
            //{alg:new MaxPointsSimplification(100),name:"maxPoints"},
            { alg: new radialDistanceSimplification_1.RadialDistanceSimplification(0.1), name: "radDist" },
            { alg: new langSimplification_1.LangSimplification(0.1, 4), name: "lang" },
            { alg: new reumannWitkamSimplification_1.ReumannWitkamSimplification(0.1), name: "reumannWitkam" },
            { alg: new opheimSimplification_1.OpheimSimplification(0.05, 0.1), name: "opheim" },
            { alg: new douglasPeuckerNSimplification_1.DouglasPeuckerNSimplification(100), name: "douglasPeuckerN" },
            { alg: new nthPointSimplification_1.NthPointSimplification(100), name: "Nth point simplification" }
        ];
        let data = [];
        for (let i = 0; i < 1000; i++) {
            let t = i * 0.01;
            let x = Math.cos(t * 6.0) * Math.exp(-2. * t);
            data.push(new daeVector_1.DAEVector(new vector_1.vector([x]), new vector_1.vector([]), t));
        }
        Test.showOutput(data, ["x"], [], "sin output");
        for (let i = 0; i < methods.length; i++) {
            let res = methods[i].alg.simplify(data);
            Test.showOutput(res, ["x"], [], methods[i].name);
            ui_1.ui.addLogMessage(`${methods[i].name}: ${res.length} points`);
        }
        ui_1.ui.openTab("results");
    }
    static testImplicitHybridCompiler() {
        ui_1.ui.clearErrors();
        Test.initPlot();
        try {
            let text = jquery_1.default("#text-input").val();
            let compiler = new hybridCompiler_1.HybridSystemCompiler();
            let sysDef = compiler.compileImplicit(text);
            let parameters = ui_1.ui.getParameters();
            let eventDetection;
            if (parameters.eventDetection.zeroCrossing.enabled) {
                let params = parameters.eventDetection.zeroCrossing;
                eventDetection = new eventDetection_1.EventDetectionComplex(params.newtonIters, params.relTol, params.absTol, params.newtonAlpha, params.bisectIters, params.timeAbsTol, params.timeRelTol);
            }
            else {
                eventDetection = new eventDetection_1.EventDetectionSimple();
            }
            let adaptiveStepStrategy;
            if (parameters.eventDetection.adaptiveStep.enabled) {
            }
            else {
                adaptiveStepStrategy = null;
            }
            let t0 = parameters.solver.t0;
            let t1 = t0 + parameters.solver.time;
            let method = ui_1.ui.methods[parameters.solver.method].idaeInit(parameters);
            let solver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetection, adaptiveStepStrategy);
            let solution = solver.solve(sysDef.x0, sysDef.z0, t0, t1, method, sysDef.system);
            Test.showOutput(solution.values, sysDef.x, sysDef.z, "Test explicit hybrid compiler");
            ui_1.ui.openTab("results");
        }
        catch (e) {
            if (e instanceof compilerError_1.CompilerError) {
                e.messages.forEach(function (item) {
                    ui_1.ui.addLogMessage(item.print());
                    console.log(item.print());
                });
            }
            else if (e instanceof Error) {
                ui_1.ui.addLogMessage(e.message);
                console.log(e.message);
            }
            else {
                ui_1.ui.addLogMessage("Exception: " + e);
            }
            ui_1.ui.openTab("main");
            ui_1.ui.openTab("errors-tab");
        }
    }
    static testWeissingerImplicit() {
        class IWeissinger {
            f(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new vector_1.vector([
                    t * Math.pow(_x, 2) * Math.pow(_dx, 3) -
                        Math.pow(_x, 3) * Math.pow(_dx, 2) +
                        t * (t * t + 1) * _dx - t * t * _x
                ]);
            }
            g(x, z, t) {
                let _z = z.get(0);
                return new vector_1.vector([_z - Math.sqrt(t * t + 0.5)]);
            }
            dfdx(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new matrix_1.matrix([
                    2 * t * _x * Math.pow(_dx, 3) - 3 * Math.pow(_x * _dx, 2) - t * t
                ], 1, 1);
            }
            dfddx(x, dx, z, t) {
                let _x = x.get(0);
                let _dx = dx.get(0);
                return new matrix_1.matrix([
                    3 * t * Math.pow(_x * _dx, 2) - 2 * Math.pow(_x, 3) * _dx + t * (t * t + 1)
                ], 1, 1);
            }
            dfdz(x, dx, z, t) {
                return new matrix_1.matrix([], 0, 1);
            }
            dgdz(x, z, t) {
                return new matrix_1.matrix([1], 1, 1);
            }
            dgdx(x, z, t) {
                return new matrix_1.matrix([], 1, 0);
            }
            length_x() {
                return 1;
            }
            length_z() {
                return 1;
            }
        }
        let t0 = 0;
        let t1 = 1;
        let system = new IWeissinger();
        let solver = new rk_2.IDAE_RK4(0.01, new newton_1.NewtonSolver(20, 1e-3, 1e-5, 0.95, 3));
        let solution = solveImplicit(new vector_1.vector([Math.sqrt(3 / 2)]), new vector_1.vector([0]), t0, t1, solver, system);
        Test.showOutput(solution, ["x"], ["z"], "Implicit weissinger");
    }
}
exports.Test = Test;


/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ui = void 0;
const examples_1 = __webpack_require__(/*! ./examples */ "./src/examples.ts");
const jquery_1 = __importDefault(__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
const test_1 = __webpack_require__(/*! ./test/test */ "./src/test/test.ts");
const edaeHybridSolver_1 = __webpack_require__(/*! ./dae/edaeHybridSolver */ "./src/dae/edaeHybridSolver.ts");
const idaeHybridSolver_1 = __webpack_require__(/*! ./dae/idaeHybridSolver */ "./src/dae/idaeHybridSolver.ts");
const hybridCompiler_1 = __webpack_require__(/*! ./compiler/hybridCompiler */ "./src/compiler/hybridCompiler.ts");
const compilerError_1 = __webpack_require__(/*! ./compiler/compilerError */ "./src/compiler/compilerError.ts");
const eventDetection_1 = __webpack_require__(/*! ./dae/eventDetection */ "./src/dae/eventDetection.ts");
const astNode_1 = __webpack_require__(/*! ./compiler/astNode */ "./src/compiler/astNode.ts");
const methods_1 = __webpack_require__(/*! ./methods */ "./src/methods.ts");
//tabs init
exports.ui = {
    isResultsTab: false,
    methods: methods_1.methods,
    showDebug: function () {
        jquery_1.default("#debug").css("display", "block");
    },
    hideDebug: function () {
        jquery_1.default("#debug").css("display", "none");
    },
    init: function () {
        //init debug
        jquery_1.default("#debug").append('<button class="button" id="debug-hide">Hide</button>');
        jquery_1.default("#debug-hide").click(exports.ui.hideDebug);
        jquery_1.default("#debug").append('<button class="button" id="edae-test">Test EDAE</button>');
        jquery_1.default("#debug").append('<button class="button" id="idae-test">Test IDAE</button>');
        jquery_1.default("#debug").append('<button class="button" id="e-hybrid-test">Test Explicit Hybrid</button>');
        jquery_1.default("#debug").append('<button class="button" id="i-hybrid-test">Test Implicit Hybrid</button>');
        jquery_1.default('#edae-test').click(test_1.Test.testEDAECompiler);
        jquery_1.default('#idae-test').click(test_1.Test.testIDAECompiler);
        jquery_1.default('#e-hybrid-test').click(test_1.Test.testExplicitHybridCompiler);
        jquery_1.default('#i-hybrid-test').click(test_1.Test.testImplicitHybridCompiler);
        jquery_1.default("#run-button").click(exports.ui.run);
        jquery_1.default("#export-button").click(exports.ui.run);
        jquery_1.default('*[data-role="tab"]').click(function (e) {
            exports.ui.openTab(jquery_1.default(e.target).data("tab"));
        });
        let examplesContainer = jquery_1.default('#examples-dae');
        Object.entries(examples_1.examples.dae).forEach(function ([key, value]) {
            examplesContainer.append(`<button id="${key}" class="example-button dae button">${value.name}</button`);
        });
        examplesContainer = jquery_1.default('#examples-hybrid');
        Object.entries(examples_1.examples.hybrid).forEach(function ([key, value]) {
            examplesContainer.append(`<button id="${key}" class="example-button hybrid button">${value.name}</button`);
        });
        jquery_1.default('.example-button.dae').click(function (e) {
            exports.ui.loadDaeExample(this.id);
        });
        jquery_1.default('.example-button.hybrid').click(function (e) {
            exports.ui.loadHybridExample(this.id);
        });
        let stepControl = jquery_1.default('#step-control');
        let stepSolver = jquery_1.default('#step-solver');
        let systemSolver = jquery_1.default('#system-solver');
        let adaptive = jquery_1.default('#adaptive');
        let zeroCrossing = jquery_1.default('#zero-crossing');
        let simplification = jquery_1.default('#simplification');
        let adaptiveGamma = jquery_1.default('#adaptive-gamma');
        let adaptiveMinStep = jquery_1.default('#adaptive-min-step');
        let zeroCrossingNewtonIterations = jquery_1.default('#newton-iterations-zero-crossing');
        let zeroCrossingNewtonAlphha = jquery_1.default('#alpha-zero-crossing');
        let zeroCrossingAbsTol = jquery_1.default('#abs-tol-zero-crossing');
        let zeroCrossingRelTol = jquery_1.default('#rel-tol-zero-crossing');
        let zeroCrossingBisectionIterations = jquery_1.default('#bisection-iterations-zero-crossing');
        let zeroCrossingTimeResAbsTol = jquery_1.default('#time-abs-tol-zero-crossing');
        let zeroCrossingTimeResRelTol = jquery_1.default('#time-rel-tol-zero-crossing');
        let simplificationMethod = jquery_1.default('#simplification-method');
        let simplificationPointsLimit = jquery_1.default('#simplification-limit');
        jquery_1.default('#dae-form').change(function () {
            if (jquery_1.default(this).val() == "explicit")
                systemSolver.attr("disabled", "disabled");
            else
                systemSolver.attr("disabled", null);
        });
        jquery_1.default('#dae-form').trigger("change");
        let explicitMethods = jquery_1.default("#explicitMethods");
        let implicitMethods = jquery_1.default("#implicitMethods");
        //init methods select element
        Object.entries(methods_1.methods).forEach(function ([key, item]) {
            let el = `<option value="${key}">${item.name}</option>`;
            if (item.implicit) {
                implicitMethods.append(el);
            }
            else {
                explicitMethods.append(el);
            }
        });
        jquery_1.default('#method').change(function () {
            if (methods_1.methods[jquery_1.default(this).val()].autostep == true)
                stepControl.attr("disabled", null);
            else
                stepControl.attr("disabled", "disabled");
            if (methods_1.methods[jquery_1.default(this).val()].implicit == true)
                stepSolver.attr("disabled", null);
            else
                stepSolver.attr("disabled", "disabled");
        });
        jquery_1.default('#method').trigger("change");
        jquery_1.default('#adaptive-step').change(function () {
            if (jquery_1.default(this).prop("checked")) {
                adaptive.attr("disabled", null);
            }
            else {
                adaptive.attr("disabled", "disabled");
            }
        });
        jquery_1.default('#adaptive-step').trigger("change");
        jquery_1.default('#zero-crossing-detection').change(function () {
            if (jquery_1.default(this).prop("checked")) {
                zeroCrossing.attr("disabled", null);
            }
            else {
                zeroCrossing.attr("disabled", "disabled");
            }
        });
        jquery_1.default('#zero-crossing-detection').trigger("change");
        jquery_1.default('#use-simplification').change(function () {
            if (jquery_1.default(this).prop("checked")) {
                simplification.attr("disabled", null);
            }
            else {
                simplification.attr("disabled", "disabled");
            }
        });
        jquery_1.default('#use-simplification').trigger("change");
    },
    getParameters: function () {
        return {
            solver: {
                daeForm: jquery_1.default("#dae-form").val(),
                method: jquery_1.default("#method").val(),
                step: parseFloat(jquery_1.default("#step").val()) * 1e-3,
                t0: parseFloat(jquery_1.default("#t0").val()),
                time: parseFloat(jquery_1.default("#time").val()),
                stepControl: {
                    minStep: parseFloat(jquery_1.default("#min-step").val()) * 1e-3,
                    errTol: parseFloat(jquery_1.default("#error-tolerance").val()) * 1e-3
                },
                implicitStepSolver: {
                    iters: parseFloat(jquery_1.default("#implicit-iterations").val()),
                    minIters: parseFloat(jquery_1.default("#implicit-min-iterations").val()),
                    absTol: parseFloat(jquery_1.default("#implicit-f-abs-tol").val()) * 1e-3,
                    relTol: parseFloat(jquery_1.default("#implicit-f-rel-tol").val()) * 1e-3,
                    alpha: parseFloat(jquery_1.default("#implicit-alpha").val())
                },
                implicitSystemSolver: {
                    iters: parseFloat(jquery_1.default("#idae-iterations").val()),
                    minIters: parseFloat(jquery_1.default("#idae-min-iterations").val()),
                    absTol: parseFloat(jquery_1.default("#idae-f-abs-tol").val()) * 1e-3,
                    relTol: parseFloat(jquery_1.default("#idae-f-rel-tol").val()) * 1e-3,
                    alpha: parseFloat(jquery_1.default("#idae-alpha").val())
                },
            },
            eventDetection: {
                borderTol: parseFloat(jquery_1.default("#zero-crossing-border-tol").val()) * 1e-3,
                adaptiveStep: {
                    enabled: jquery_1.default("#adaptive-step").val() == "on",
                    gamma: parseFloat(jquery_1.default("#adaptive-gamma").val()),
                    minStep: parseFloat(jquery_1.default("#adaptive-min-step").val()) * 1e-3,
                },
                zeroCrossing: {
                    enabled: jquery_1.default("#zero-crossing-detection").val() == "on",
                    newtonIters: parseInt(jquery_1.default("#newton-iterations-zero-crossing").val()),
                    newtonAlpha: parseFloat(jquery_1.default("#alpha-zero-crossing").val()),
                    absTol: parseFloat(jquery_1.default("#abs-tol-zero-crossing").val()) * 1e-3,
                    relTol: parseFloat(jquery_1.default("#rel-tol-zero-crossing").val()) * 1e-3,
                    bisectIters: parseInt(jquery_1.default("#bisection-iterations-zero-crossing").val()),
                    timeAbsTol: parseFloat(jquery_1.default("#time-abs-tol-zero-crossing").val()) * 1e-3,
                    timeRelTol: parseFloat(jquery_1.default("#time-rel-tol-zero-crossing").val()) * 1e-3
                }
            },
            simplification: {
                enabled: jquery_1.default("#use-simplification").val() == "on",
                method: jquery_1.default("#simplification-method").val(),
                maxPoints: parseInt(jquery_1.default("#simplification-limit").val()),
                tolerance: parseFloat(jquery_1.default("#simplification-tolerance").val())
            }
        };
    },
    openTab: function (tabId) {
        let target = jquery_1.default('[data-role="tab"][data-tab="' + tabId + '"]');
        let parentId = target.data("parent");
        let parent = jquery_1.default('#' + parentId);
        jquery_1.default('[data-role="tab-item"][data-parent="' + parentId + '"').removeClass("show");
        jquery_1.default('[data-role="tab"][data-parent="' + parentId + '"').removeClass("active");
        target.addClass("active");
        jquery_1.default('#' + tabId).addClass("show");
        if (tabId == "results") {
            exports.ui.isResultsTab = true;
            //@ts-ignore
            Plotly.relayout('plot-area', {
                width: jquery_1.default("#plot-area").width(),
                height: jquery_1.default("#plot-area").height()
            });
        }
        else {
            exports.ui.isResultsTab = false;
        }
    },
    loadDaeExample: function (exampleId) {
        jquery_1.default('#text-input').val(examples_1.examples.dae[exampleId].text);
    },
    loadHybridExample: function (exampleId) {
        jquery_1.default('#text-input').val(examples_1.examples.hybrid[exampleId].text);
    },
    clearLog: function () {
        jquery_1.default('#log-area').empty();
    },
    clearErrors: function () {
        jquery_1.default('#error-list').empty();
    },
    addErrorMessage: function (message, textPos) {
        jquery_1.default('#error-list').append(`<div class="errors-row${textPos.line == -1 ? "" : " clickable"}" data-line="${textPos.line}" data-column="${textPos.column}" data-start="${textPos.start}" data-stop="${textPos.stop}">
        <div class="errors-cell">${textPos.line == -1 ? "" : textPos.line}</div>
        <div class="errors-cell">${textPos.line == -1 ? "" : textPos.column}</div>
        <div class="errors-cell">${message}</div>
        </div>`);
        if (textPos.line != -1)
            jquery_1.default('#error-list').children().last().click(exports.ui.onClickErrorMessage);
    },
    setCursor(line, position) {
        let elem = jquery_1.default("#text-input")[0];
        let row = 1;
        let pos = 0;
        while (row < line) {
            let lineEnd = elem.value.indexOf("\n", pos);
            if (lineEnd == -1) {
                return;
            }
            row++;
            pos = lineEnd + 1;
        }
        let lineEnd = elem.value.indexOf("\n", pos);
        lineEnd = (lineEnd == -1 ? elem.value.length : lineEnd);
        pos = Math.min(lineEnd, pos + position);
        elem.focus();
        elem.setSelectionRange(pos, pos + 1);
    },
    onClickErrorMessage: function () {
        let line = parseInt(jquery_1.default(this).data("line"));
        let column = parseInt(jquery_1.default(this).data("column"));
        let start = parseInt(jquery_1.default(this).data("start"));
        let stop = parseInt(jquery_1.default(this).data("stop"));
        if (start == -1)
            exports.ui.setCursor(line, column);
        else {
            let elem = jquery_1.default("#text-input")[0];
            elem.focus();
            elem.setSelectionRange(start, stop);
        }
    },
    addLogMessage: function (message) {
        let logArea = jquery_1.default('#log-area');
        let childs = logArea.children();
        let i = 0;
        while (childs.length > 15 + i) {
            childs[i].remove();
            i++;
        }
        let date = new Date();
        const ss = String(date.getSeconds() + 1).padStart(2, '0');
        const hh = String(date.getHours()).padStart(2, '0');
        const mm = String(date.getMinutes()).padStart(2, '0');
        logArea.append(`<div class="log-message">[${hh}:${mm}:${ss}]: ${message}</div>`);
        var mydiv = jquery_1.default("#scroll");
        logArea.scrollTop(logArea.prop("scrollHeight"));
    },
    registerMethods: function (methods) {
        let explicit = jquery_1.default("#methods").append('<optgroup label="Explicit methods"></optgroup>');
        methods.explicit.forEach(function (item) {
            explicit.append(`<option value="${item.id}">${item.name}</option>`);
        });
        let implicit = jquery_1.default("#methods").append('<optgroup label="Implicit methods"></optgroup>');
        methods.implicit.forEach(function (item) {
            implicit.append(`<option value="${item.id}">${item.name}</option>`);
        });
    },
    plotSolution: function (solution, x, z) {
        let data = [];
        let t = [];
        let xTraces = [];
        let zTraces = [];
        data.push({ x: t, y: [], type: "scattergl", mode: 'markers+lines', name: "State",
            line: { shape: 'hv' }, });
        x.forEach(function (item) {
            xTraces.push({ x: t, y: [], type: "scattergl", mode: 'markers+lines', name: item });
        });
        z.forEach(function (item) {
            zTraces.push({ x: t, y: [], type: "scattergl", mode: 'markers+lines', name: item });
        });
        solution.values.forEach(function (value, index) {
            t.push(value.t);
            data[0].y.push(solution.states[index]);
            xTraces.forEach(function (item, id) {
                item.y.push(value.x.get(id));
            });
            zTraces.forEach(function (item, id) {
                item.y.push(value.z.get(id));
            });
        });
        xTraces.forEach(function (item) {
            data.push(xTraces);
        });
        zTraces.forEach(function (item) {
            data.push(zTraces);
        });
        //@ts-ignore
        Plotly.addTraces('plot-area', data);
    },
    plot: function (x, t, label) {
        let data = [];
        let trace = {
            x: t,
            y: x,
            type: "scattergl",
            mode: 'markers+lines',
            name: label
        };
        data.push(trace);
        //@ts-ignore
        Plotly.addTraces('plot-area', data);
    },
    export: function () {
    },
    run: function () {
        test_1.Test.testSimplification();
        //Test.runTests();
        return;
        throw new Error("Not implemented");
        exports.ui.clearErrors();
        let parameters = exports.ui.getParameters();
        let text = jquery_1.default("#text-input").val();
        try {
            let eventDetection;
            if (parameters.eventDetection.zeroCrossing.enabled) {
                let params = parameters.eventDetection.zeroCrossing;
                eventDetection = new eventDetection_1.EventDetectionComplex(params.newtonIters, params.relTol, params.absTol, params.newtonAlpha, params.bisectIters, params.timeAbsTol, params.timeRelTol);
            }
            else {
                eventDetection = new eventDetection_1.EventDetectionSimple();
            }
            let adaptiveStepStrategy;
            if (parameters.eventDetection.adaptiveStep.enabled) {
            }
            else {
                adaptiveStepStrategy = null;
            }
            let compiler = new hybridCompiler_1.HybridSystemCompiler();
            if (parameters.solver.daeForm == "explicit") {
                let sysDef = compiler.compileExplicit(text);
                let daeSolver = methods_1.methods[parameters.solver.method].edaeInit(parameters);
                let solver = new edaeHybridSolver_1.EDAEHybridSolver(eventDetection, adaptiveStepStrategy);
                let solution = solver.solve(sysDef.x0, parameters.solver.t0, parameters.solver.t0 + parameters.solver.time, daeSolver, sysDef.system);
                exports.ui.plotSolution(solution, sysDef.x, sysDef.z);
            }
            else {
                let sysDef = compiler.compileImplicit(text);
                let daeSolver = methods_1.methods[parameters.solver.method].idaeInit(parameters);
                let solver = new idaeHybridSolver_1.IDAEHybridSolver(eventDetection, adaptiveStepStrategy);
                let solution = solver.solve(sysDef.x0, sysDef.z0, parameters.solver.t0, parameters.solver.t0 + parameters.solver.time, daeSolver, sysDef.system);
                exports.ui.plotSolution(solution, sysDef.x, sysDef.z);
            }
        }
        catch (e) {
            if (e instanceof compilerError_1.CompilerError) {
                e.messages.forEach(function (item) {
                    exports.ui.addErrorMessage(item.message, item.textPos);
                    console.log(item.print());
                });
            }
            else if (e instanceof Error) {
                exports.ui.addErrorMessage(e.message, astNode_1.TextPosition.invalid());
                exports.ui.addLogMessage(e.message);
                console.log(e.message);
            }
            else {
                exports.ui.addErrorMessage("Exception: " + e, astNode_1.TextPosition.invalid());
                exports.ui.addLogMessage("Exception: " + e);
            }
            exports.ui.openTab("main");
            exports.ui.openTab("errors-tab");
        }
    }
};


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9CdWZmZXJlZFRva2VuU3RyZWFtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvQ2hhclN0cmVhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9Db21tb25Ub2tlbkZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9Db21tb25Ub2tlblN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L0ZpbGVTdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9JbnB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L0ludGVydmFsU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvTEwxQW5hbHl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9MZXhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L1BhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L1BhcnNlclJ1bGVDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvUHJlZGljdGlvbkNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9SZWNvZ25pemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvUnVsZUNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9Ub2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L1V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9BVE5Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vQVROQ29uZmlnU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vQVRORGVzZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0FUTlNpbXVsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9BVE5TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9BVE5UeXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0xleGVyQVROU2ltdWxhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0xleGVyQWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL0xleGVyQWN0aW9uRXhlY3V0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9hdG4vUGFyc2VyQVROU2ltdWxhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL1ByZWRpY3Rpb25Nb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL1NlbWFudGljQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2F0bi9UcmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvYXRuL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvZGZhL0RGQS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2RmYS9ERkFTZXJpYWxpemVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvZGZhL0RGQVN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvZGZhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvZXJyb3IvRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9lcnJvci9FcnJvckxpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvZXJyb3IvRXJyb3JTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2Vycm9yL0Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L2Vycm9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnRscjQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9wb2x5ZmlsbHMvY29kZXBvaW50YXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC9wb2x5ZmlsbHMvZnJvbWNvZGVwb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L3RyZWUvVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW50bHI0L3RyZWUvVHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FudGxyNC90cmVlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL2FzdE5vZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL2NvbXBpbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9jb21waWxlckNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL2NvbXBpbGVyRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL2Vycm9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9lcnJvckxpc3RlbmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9leHByZXNzaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb21waWxlci9leHByZXNzaW9uQ29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL2Z1bmN0aW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcGlsZXIvaHlicmlkQ29tcGlsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBpbGVyL3Zpc2l0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2N1cnZlU2ltcGxpZmljYXRpb24vZG91Z2xhc1BldWNrZXJOU2ltcGxpZmljYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2N1cnZlU2ltcGxpZmljYXRpb24vZG91Z2xhc1BldWNrZXJTaW1wbGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3VydmVTaW1wbGlmaWNhdGlvbi9sYW5nU2ltcGxpZmljYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2N1cnZlU2ltcGxpZmljYXRpb24vbnRoUG9pbnRTaW1wbGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3VydmVTaW1wbGlmaWNhdGlvbi9vcGhlaW1TaW1wbGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3VydmVTaW1wbGlmaWNhdGlvbi9wZXJwZW5kaWN1bGFyRGlzdGFuY2VTaW1wbGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY3VydmVTaW1wbGlmaWNhdGlvbi9yYWRpYWxEaXN0YW5jZVNpbXBsaWZpY2F0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jdXJ2ZVNpbXBsaWZpY2F0aW9uL3JldW1hbm5XaXRrYW1TaW1wbGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL2FkYXB0aXZlU3RlcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL2N1c3RvbUVEQUVIeWJyaWRTdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL2N1c3RvbUVEQUVTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9jdXN0b21IeWJyaWRTdGF0ZUxpbmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9jdXN0b21JREFFSHlicmlkU3RhdGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9jdXN0b21JREFFU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvZGFlVmVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvZWRhZUh5YnJpZFNvbHZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL2VkYWVIeWJyaWRTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9lZGFlU29sdmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvZXZlbnREZXRlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9oeWJyaWRTb2x1dGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL2lkYWVIeWJyaWRTb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9pZGFlSHlicmlkU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvaWRhZVNvbHZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL3NvbHZlcnMvZWRhZS9hZGFtcy1iYXNoZm9ydGgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9zb2x2ZXJzL2VkYWUvYWxnZWJyYWljU29sdmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvc29sdmVycy9lZGFlL2V1bGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvc29sdmVycy9lZGFlL21pZHBvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvc29sdmVycy9lZGFlL3JrLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvc29sdmVycy9lZGFlL3RyYXBlem9pZGFsLnRzIiwid2VicGFjazovLy8uL3NyYy9kYWUvc29sdmVycy9pZGFlL2FkYW1zLWJhc2hmb3J0aC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGFlL3NvbHZlcnMvaWRhZS9hbGdlYnJhaWNTb2x2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9zb2x2ZXJzL2lkYWUvZXVsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9zb2x2ZXJzL2lkYWUvbWlkcG9pbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9zb2x2ZXJzL2lkYWUvcmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhZS9zb2x2ZXJzL2lkYWUvdHJhcGV6b2lkYWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4YW1wbGVzLnRzIiwid2VicGFjazovLy8uL3NyYy9ncmFtbWFyL2FudGxyT3V0cHV0L29kZUdyYW1tYXJMZXhlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JhbW1hci9hbnRsck91dHB1dC9vZGVHcmFtbWFyUGFyc2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9ncmFtbWFyL2FudGxyT3V0cHV0L29kZUdyYW1tYXJWaXNpdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9nYXVzcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0aC9tYXRyaXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGgvbmV3dG9uLnRzIiwid2VicGFjazovLy8uL3NyYy9tYXRoL3ZlY3Rvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbWV0aG9kcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdGVzdC90ZXN0LnRzIiwid2VicGFjazovLy8uL3NyYy91aS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEdBQUc7O1FBRUg7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0E7UUFDQTtRQUNBLE9BQU87UUFDUDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLOztRQUVMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLDZCQUE2QjtRQUM3Qiw2QkFBNkI7UUFDN0I7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EscUJBQXFCLGdCQUFnQjtRQUNyQztRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBLHFCQUFxQixnQkFBZ0I7UUFDckM7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0EsS0FBSzs7UUFFTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQSxLQUFLOztRQUVMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQSxrQkFBa0IsOEJBQThCO1FBQ2hEO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0EsT0FBTztRQUNQO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSTtRQUNKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQywrQ0FBUztBQUM3Qix3QkFBd0IsbUJBQU8sQ0FBQyx1REFBYTtBQUM3QyxpQkFBaUIsbUJBQU8sQ0FBQyx5REFBYztBQUN2QywyQkFBMkIsbUJBQU8sQ0FBQywyRUFBdUI7QUFDMUQsc0JBQXNCLG1CQUFPLENBQUMsMkVBQXVCO0FBQ3JELGdDQUFnQyxtQkFBTyxDQUFDLCtGQUFpQztBQUN6RSxtQkFBbUIsbUJBQU8sQ0FBQyx1REFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBYTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0EsVUFBVSxrQkFBa0IsYUFBYTtBQUN6QyxLQUFLLG9CQUFvQjtBQUN6QixtQkFBbUIsa0JBQWtCLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFO0FBQ3ZFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsWUFBWTtBQUNuRCxhQUFhLHNDQUFzQyxNQUFNLGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QyxxQ0FBcUMsMEJBQTBCO0FBQy9ELElBQUksV0FBVztBQUNmLElBQUksd0NBQXdDO0FBQzVDLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFlBQVk7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJLHdDQUF3QztBQUM1QyxxQ0FBcUMsMEJBQTBCO0FBQy9ELElBQUksV0FBVztBQUNmLElBQUksd0NBQXdDO0FBQzVDLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0JBQStCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU0sY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBLFVBQVUsZUFBZSxLQUFLLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQywrQ0FBUzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx3REFBd0QsUUFBUTtBQUNoRSxJQUFJLFFBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckUsSUFBSSx1Q0FBdUM7QUFDM0M7QUFDQTtBQUNBLElBQUksNkNBQTZDO0FBQ2pELElBQUksd0NBQXdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksYUFBYTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxrQkFBa0I7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVcsS0FBSyxhQUFhO0FBQ3pDLHVCQUF1QixZQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsaUJBQWlCLE1BQU0sbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsaUNBQWlDLGdEQUFnRCxFQUFFO0FBQ25GLCtCQUErQix3Q0FBd0MsRUFBRTtBQUN6RSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7Ozs7OztBQ2pxQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQywyREFBZTtBQUN6QyxXQUFXLG1CQUFPLENBQUMsdURBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsMkRBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Qzs7Ozs7Ozs7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLDJEQUFlO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQywrQ0FBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsK0NBQVM7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7O0FBRUEsZUFBZSxRQUFRLHlDQUF5QztBQUNoRSwyQkFBMkIsb0JBQW9CO0FBQy9DLElBQUksUUFBUSxJQUFJLDJCQUEyQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbURBQW1ELEVBQUU7QUFDcEUsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCLE9BQU8sRUFBRSxnQkFBZ0I7QUFDM0MsV0FBVywyQ0FBMkMsUUFBUTtBQUM5RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtCQUFrQixPQUFPLEVBQUUsZ0JBQWdCO0FBQzNDLFdBQVcsMkNBQTJDLFFBQVE7QUFDOUQsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxXQUFXLDJDQUEyQyxZQUFZO0FBQ2xFLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0YsZUFBZTtBQUNmLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGNBQWMsMEJBQTBCLGNBQWM7QUFDaEU7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRixlQUFlO0FBQ2YsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsa0JBQWtCLFlBQVksd0JBQXdCO0FBQ3BFLFdBQVcsY0FBYyxLQUFLLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsT0FBTztBQUNUO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRLEtBQUssUUFBUTtBQUMzRCxJQUFJLGNBQWMseUNBQXlDLFFBQVE7QUFDbkUsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxPQUFPLGNBQWMsMEJBQTBCLFNBQVMsY0FBYztBQUN0RTtBQUNBO0FBQ0EsT0FBTyxjQUFjLGtCQUFrQixjQUFjO0FBQ3JELElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esa0NBQWtDO0FBQ2xDLEdBQUcsMENBQTBDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1YsR0FBRyxrREFBa0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxlQUFlLFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLCtDQUFTO0FBQzdCLDJCQUEyQixtQkFBTyxDQUFDLDJFQUF1QjtBQUMxRCx5QkFBeUIsbUJBQU8sQ0FBQywyRUFBdUI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBLElBQUksaURBQWlEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHVEQUFhO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLHVEQUFhO0FBQzVDLHlCQUF5QixtQkFBTyxDQUFDLG1EQUFXOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwyQkFBMkI7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFPLENBQUMseURBQWM7OztBQUdsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLG1CQUFtQixhQUFhO0FBQ2hDLGtCQUFrQixhQUFhO0FBQy9CLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwrQ0FBK0MsVUFBVTtBQUN6RCxJQUFJLFdBQVcsUUFBUSxnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCLElBQUksZUFBZTtBQUNuQjs7QUFFQSxxQkFBcUIsa0JBQWtCLHVCQUF1QixZQUFZO0FBQzFFO0FBQ0E7QUFDQSxPQUFPLGVBQWUsWUFBWSxrQkFBa0I7QUFDcEQsb0RBQW9ELGFBQWE7QUFDakUsUUFBUSxXQUFXLFlBQVksZUFBZSxjQUFjLGFBQWE7QUFDekUsc0NBQXNDLGdCQUFnQixPQUFPO0FBQzdELDJDQUEyQyw0QkFBNEI7QUFDdkUsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGFBQWEsaUNBQWlDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLEtBQUs7QUFDTCwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDO0FBQ3ZELEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbGNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLGtEQUFZO0FBQ2hDLGVBQWUsbUJBQU8sQ0FBQyw4REFBa0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsOERBQWtCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFtQjtBQUMzQywwQkFBMEIsbUJBQU8sQ0FBQyx1RUFBbUI7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQ0FBc0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjLHFDQUFxQztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7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LEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCLFdBQVcsa0JBQWtCO0FBQzdCLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsbUJBQW1CO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLGFBQWE7O0FBRWI7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtB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RyxDQUFDO0lBQ0QsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFXLEVBQUMsQ0FBVztRQUN0QyxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxHQUFHLGVBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsZUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuRyxDQUFDO0lBQ0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFXLEVBQUMsQ0FBVztRQUM5QixPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGVBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUNELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBVyxFQUFDLENBQVc7UUFDOUIsT0FBTyxJQUFJLFNBQVMsQ0FBQyxlQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLGVBQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUNELE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFZLEVBQUMsRUFBWSxFQUFDLEtBQWU7UUFDOUQsSUFBSSxDQUFDLEdBQUcsU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUMsRUFBRSxDQUFD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LElBQUksSUFBSSxHQUFHLGVBQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQztvQkFDMUMsZUFBTSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuRCxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNuRCxJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFDOUIsNERBQTREO2dCQUM1RCxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNSLElBQUcsQ0FBQyxHQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUUsQ0FBQyxHQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUMzQixNQUFNO2dCQUNWLENBQUMsR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUMsU0FBUyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzdELENBQUMsR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUMsU0FBUyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzdELENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFD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QUMsRUFBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFDLENBQUMsRUFBRSxFQUFDO2dCQUNwQyxJQUFJLElBQUksR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUM7b0JBQzFDLGVBQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkQsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbkQsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7Z0JBQzlCLDREQUE0RDtnQkFDNUQsQ0FBQyxJQUFJLEVBQUUsQ0FBQztnQkFDUixJQUFHLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFFLENBQUMsR0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDM0IsTUFBTTtnQkFDVixDQUFDLEdBQUcsZUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEdBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM3RCxDQUFDLEdBQUcsZUFBTSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEdBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM3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QVEsUUFBUTtJQUNsQyxZQUFZLElBQVc7UUFDbkIsSUFBSSxNQUFNLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6QixLQUFLLENBQUMsSUFBSSxFQUNOO1lBQ0ksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxDQUFDLENBQUM7WUFDVCxDQUFDLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxDQUFDO1lBQ3pDLENBQUMsQ0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUNuRCxDQUFDLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxDQUFDO1lBQ3JFLENBQUMsQ0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxHQUFHLEVBQUMsQ0FBQyxHQUFHLEdBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsQ0FBQztZQUNsRyxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsR0FBQyxDQUFDLENBQUM7WUFDbkQsQ0FBQyxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxHQUFHLEVBQUMsRUFBRSxHQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLEVBQUMsQ0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUM5RSxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLEdBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUNuRyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEdBQUcsR0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsQ0FBQztTQUMzSCxFQUNELENBQUMsQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEdBQUMsR0FBRyxFQUFDLEVBQUUsR0FBQyxFQUFFLEVBQUMsRUFBRSxHQUFDLEdBQUcsRUFBQyxDQUFDLEdBQUMsRUFBRSxDQUFDLEVBQzNDLENBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRTtZQUNwRCxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQ3JDLENBQUM7SUFDVixDQUFDO0NBQ0o7QUFyQkQsNEJBcUJDO0FBR0QsTUFBYSxXQUFZLFNBQVEsU0FBUztJQUN0QyxZQUFZLElBQVcsRUFBQyxPQUFjLEVBQUMsY0FBcUI7UUFDeEQsS0FBSyxDQUFDLElBQUksRUFBQyxPQUFPLEVBQUMsQ0FBQyxFQUFDLGNBQWMsRUFDL0I7WUFDSSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQztZQUNYLENBQUMsRUFBRSxHQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFDLENBQUMsQ0FBQztZQUNwQixDQUFDLEtBQUssR0FBQyxJQUFJLEVBQUMsQ0FBQyxLQUFLLEdBQUMsSUFBSSxFQUFFLEtBQUssR0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLEdBQUMsR0FBRyxDQUFDO1lBQzdDLENBQUMsSUFBSSxHQUFDLElBQUksRUFBQyxDQUFDLEdBQUcsR0FBQyxFQUFFLEVBQUUsS0FBSyxHQUFDLElBQUksRUFBQyxFQUFFLEdBQUMsR0FBRyxFQUFDLENBQUMsSUFBSSxHQUFDLEtBQUssQ0FBQztZQUNsRCxDQUFDLEVBQUUsR0FBQyxHQUFHLEVBQUMsQ0FBQyxFQUFDLEdBQUcsR0FBQyxJQUFJLEVBQUMsR0FBRyxHQUFDLEdBQUcsRUFBQyxDQUFDLElBQUksR0FBQyxJQUFJLEVBQUMsRUFBRSxHQUFDLEVBQUUsQ0FBQztTQUMvQyxFQUNELENBQUMsRUFBRSxHQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUMsR0FBRyxHQUFDLElBQUksRUFBQyxHQUFHLEdBQUMsR0FBRyxFQUFDLENBQUMsSUFBSSxHQUFDLElBQUksRUFBQyxFQUFFLEdBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxFQUM5QyxDQUFDLENBQUMsRUFBQyxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFDeEIsQ0FBQyxJQUFJLEdBQUMsS0FBSyxFQUFDLENBQUMsRUFBQyxJQUFJLEdBQUMsS0FBSyxFQUFDLEdBQUcsR0FBQyxHQUFHLEVBQUMsQ0FBQyxLQUFLLEdBQUMsTUFBTSxFQUFDLEdBQUcsR0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFDLEVBQUUsQ0FBQyxDQUM1RCxDQUFD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QUFJLEVBQUMsSUFBSSxFQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQyxDQUFDLENBQUMsQ0FBQztZQUN6RCxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFFbEUsSUFBSSxHQUFHLEdBQUcsYUFBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3BFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFdEQsSUFBSSxHQUFHLGVBQU0sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTdDLENBQUMsR0FBRyxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUN4QyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7WUFDaEQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFB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LEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDbkQsSUFBSSxFQUFFLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNsQyxJQUFJLEtBQUssR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUMsSUFBSSxLQUFLLEdBQUcsZUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTlDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUMsRUFBRSxFQUFDLEtBQUssRUFBQyxLQUFLLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUNwRCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDdkIsS0FBSSxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLEVBQUMsQ0FBQyxFQUFFLEVBQUM7WUFDaEQsSUFBSSxDQUFDLEdBQVUsZUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7WUFFekQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsS0FBSyxFQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMs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O1lBQzVDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxDQUFDLENBQUM7WUFDMUMsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3BDLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBQyxFQUFFLENBQUMsQ0FBQztZQUNwQyxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBQyxDQUFDLEdBQUMsTUFBTSxFQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsQ0FBQztZQUN4QyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksRUFBQyxDQUFDLEdBQUMsTUFBTSxFQUFDLENBQUMsR0FBQyxNQUFNLEdBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDekQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFDLE1BQU0sR0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUMsQ0FBQyxHQUFDLE1BQU0sR0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUMzRSxLQUFJLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLE1BQU0sRUFBQyxDQUFDLEVBQUUsRUFBQztnQkFDMUIsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxNQUFNLEVBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN6RSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksR0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLE1BQU0sR0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzlGO1NBQ0o7UUFDRCxPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFDTSxRQUFRLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxDQUFTLEVBQUUsTUFBa0I7UUFDL0QsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxHQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqRCxJQUFJLEVBQUUsR0FBWSxFQUFFLENBQUM7UUFDckIsSUFBSSxFQUFFLEdBQVksRUFBRSxDQUFDO1FBQ3JCLEtBQUksSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsTUFBTSxFQUFDLENBQUMsRUFBRSxFQUFDO1lBQzFCLEVBQUUsQ0FBQyxJQUFJLENBQUMsZUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDdEI7UUFDRCxJQUFJLENBQUMsR0FBVSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFDakQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLEtBQUksSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFDLEVBQUUsR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxFQUFDLEVBQUUsRUFBRSxFQUFDO1lBQ3JELElBQUksQ0FBQyxHQUFVLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxNQUFNLENBQUMsQ0FBQztZQUNyRCxJQUFJLEVBQUUsR0FBRyxhQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbkUsS0FBSSxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUMsQ0FBQyxFQUFFLEVBQUM7Z0JBQzFCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUMsTUFBTSxFQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzNELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUMsTUFBTSxHQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ2hGO1lBQ0QsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxNQUFNLENBQUMsQ0FBQztZQUN0QyxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7WUFFdEIsSUFBRyxFQUFFLElBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxJQUFFLEtBQUssR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxHQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLEdBQUMsTUFBTSxFQUFDO2dCQUNsSCxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ3JCLEtBQUksSUFBSSxDQUFDLEdBQUMsQ0FBQyxF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QUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUNuRCxDQUFDLENBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxDQUFDO1lBQ3JFLENBQUMsQ0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxHQUFHLEVBQUMsQ0FBQyxHQUFHLEdBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsQ0FBQztZQUNsRyxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsR0FBQyxDQUFDLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsR0FBQyxDQUFDLENBQUM7WUFDbkQsQ0FBQyxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxHQUFHLEVBQUMsRUFBRSxHQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLEVBQUMsQ0FBQyxFQUFFLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUM5RSxDQUFDLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsR0FBRyxHQUFDLEdBQUcsR0FBQyxNQUFNLENBQUMsR0FBQyxJQUFJLEVBQUMsQ0FBQyxHQUFHLEdBQUMsR0FBRyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEdBQUcsQ0FBQztZQUNuRyxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBRSxHQUFDLENBQUMsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUMsRUFBRSxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEdBQUcsR0FBQyxFQUFFLEdBQUMsTUFBTSxDQUFDLEdBQUMsRUFBRSxFQUFDLENBQUMsRUFBRSxHQUFDLEVBQUUsR0FBQyxNQUFNLENBQUMsR0FBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEdBQUMsQ0FBQyxHQUFDLE1BQU0sQ0FBQyxHQUFDLEVBQUUsQ0FBQztTQUMzSCxFQUNELENBQUMsQ0FBQyxHQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxFQUFFLEdBQUMsR0FBRyxFQUFDLEVBQUUs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QUFPLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDbkQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBQyxFQUFFLEVBQUMsSUFBSSxFQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUMsSUFBSSxFQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN2QixLQUFJLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBQyxDQUFDLEdBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQUUsRUFBQyxDQUFDLEVBQUUsRUFBQztZQUM5QyxJQUFJLENBQUMsR0FBVSxlQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUV6RCxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkgsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxFQUFFLEVBQUMsSUFBSSxFQUFDLElBQUksQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztZQUM1RCxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLElBQUksRUFBQyxJQUFJLENBQUMsRUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekQsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxJQUFJLEVBQUMsSUFBSSxDQUFDLEVBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBRWxFLElBQUksR0FBRyxHQUFHLGFBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRELEVBQUUsR0FBRyxlQUFNLENBQUMsR0FBRyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFM0QsQ0FBQyxHQUFHLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUMs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsbUVBQW1FLHNDQUFzQyxFQUFFOztBQUUzRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjLE9BQU87QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOzs7Ozs7Ozs7Ozs7O0FDeFlBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0RBQWM7QUFDbkMsd0JBQXdCLG1CQUFPLENBQUMsMkVBQXFCOztBQUVyRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEIsMEJBQTBCO0FBQ3RFLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLHNDQUFzQztBQUN0QyxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7OztBQUdBOztBQUVBLG1FQUFtRSxzQ0FBc0MsRUFBRTs7QUFFM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWMsT0FBTzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7Ozs7QUFLQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7OztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7Ozs7Ozs7Ozs7QUNoNEdBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsb0RBQWM7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtB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LENBQUMsYUFBYSxHQUFDLENBQUMsRUFBQyxzQkFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7Z0JBQzNELFVBQUUsQ0FBQyxhQUFhLENBQUMsYUFBYSxHQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsVUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNuQixVQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzVCO0lBQ0wsQ0FBQztDQUNKIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7XG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdFx0aWYgKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XG4gXHR9IDtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJob3QvaG90LXVwZGF0ZS5qc1wiO1xuIFx0XHRpZiAobnVsbCkgc2NyaXB0LmNyb3NzT3JpZ2luID0gbnVsbDtcbiBcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkTWFuaWZlc3QocmVxdWVzdFRpbWVvdXQpIHtcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcbiBcdFx0XHR9XG4gXHRcdFx0dHJ5IHtcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gXHRcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcImhvdC9ob3QtdXBkYXRlLmpzb25cIjtcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbiBcdFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QoZXJyKTtcbiBcdFx0XHR9XG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XG4gXHRcdFx0XHRcdHJlamVjdChcbiBcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpXG4gXHRcdFx0XHRcdCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcbiBcdFx0XHRcdFx0Ly8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDMwNCkge1xuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcbiBcdFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0XHR2YXIgdXBkYXRlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcbiBcdFx0XHRcdFx0XHRyZWplY3QoZSk7XG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdHJlc29sdmUodXBkYXRlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9O1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcImU2Y2RhMDc4ZjM5OTM5MDE5ODEyXCI7XG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcbiBcdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50UGFyZW50c1RlbXAgPSBbXTtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7XG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRpZiAoIW1lKSByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXztcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuIFx0XHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG4gXHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuIFx0XHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcbiBcdFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuIFx0XHRcdFx0XHRcdHJlcXVlc3QgK1xuIFx0XHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWRcbiBcdFx0XHRcdCk7XG4gXHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFtdO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcbiBcdFx0fTtcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcbiBcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG4gXHRcdFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xuIFx0XHRcdFx0fSxcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiBcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXSA9IHZhbHVlO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH07XG4gXHRcdGZvciAodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJlXCIgJiZcbiBcdFx0XHRcdG5hbWUgIT09IFwidFwiXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIE9iamVjdEZhY3RvcnkobmFtZSkpO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRmbi5lID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicmVhZHlcIikgaG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHRob3RDaHVua3NMb2FkaW5nKys7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcbiBcdFx0XHRcdHRocm93IGVycjtcbiBcdFx0XHR9KTtcblxuIFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcbiBcdFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XG4gXHRcdFx0XHRcdGlmICghaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9O1xuIFx0XHRmbi50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0XHRpZiAobW9kZSAmIDEpIHZhbHVlID0gZm4odmFsdWUpO1xuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnQodmFsdWUsIG1vZGUgJiB+MSk7XG4gXHRcdH07XG4gXHRcdHJldHVybiBmbjtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIGhvdCA9IHtcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcbiBcdFx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuIFx0XHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxuXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKSBob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcbiBcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXG4gXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0XHRlbHNlIGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0fSxcbiBcdFx0XHRkZWNsaW5lOiBmdW5jdGlvbihkZXApIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxuIFx0XHRcdGFwcGx5OiBob3RBcHBseSxcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGlmICghbCkgcmV0dXJuIGhvdFN0YXR1cztcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xuIFx0XHRcdH0sXG4gXHRcdFx0cmVtb3ZlU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG4gXHRcdFx0XHRpZiAoaWR4ID49IDApIGhvdFN0YXR1c0hhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdH0sXG5cbiBcdFx0XHQvL2luaGVyaXQgZnJvbSBwcmV2aW91cyBkaXNwb3NlIGNhbGxcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cbiBcdFx0fTtcbiBcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gdW5kZWZpbmVkO1xuIFx0XHRyZXR1cm4gaG90O1xuIFx0fVxuXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcblxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XG4gXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuIFx0fVxuXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xuIFx0dmFyIGhvdFdhaXRpbmdGaWxlcyA9IDA7XG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdERlZmVycmVkO1xuXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2g7XG5cbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcbiBcdFx0dmFyIGlzTnVtYmVyID0gK2lkICsgXCJcIiA9PT0gaWQ7XG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xuIFx0XHRpZiAoaG90U3RhdHVzICE9PSBcImlkbGVcIikge1xuIFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xuIFx0XHR9XG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XG4gXHRcdHJldHVybiBob3REb3dubG9hZE1hbmlmZXN0KGhvdFJlcXVlc3RUaW1lb3V0KS50aGVuKGZ1bmN0aW9uKHVwZGF0ZSkge1xuIFx0XHRcdGlmICghdXBkYXRlKSB7XG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XG5cbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcbiBcdFx0XHRcdFx0cmVqZWN0OiByZWplY3RcbiBcdFx0XHRcdH07XG4gXHRcdFx0fSk7XG4gXHRcdFx0aG90VXBkYXRlID0ge307XG4gXHRcdFx0dmFyIGNodW5rSWQgPSBcIm1haW5cIjtcbiBcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9uZS1ibG9ja3NcbiBcdFx0XHR7XG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJlxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJlxuIFx0XHRcdFx0aG90V2FpdGluZ0ZpbGVzID09PSAwXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvciAodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZiAoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xuIFx0XHRpZiAoIWRlZmVycmVkKSByZXR1cm47XG4gXHRcdGlmIChob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcbiBcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XG4gXHRcdFx0XHR9KVxuIFx0XHRcdFx0LnRoZW4oXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiBcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdCk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwicmVhZHlcIilcbiBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gXHRcdHZhciBjYjtcbiBcdFx0dmFyIGk7XG4gXHRcdHZhciBqO1xuIFx0XHR2YXIgbW9kdWxlO1xuIFx0XHR2YXIgbW9kdWxlSWQ7XG5cbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbihpZCkge1xuIFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXG4gXHRcdFx0XHRcdGlkOiBpZFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuIFx0XHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG4gXHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuIFx0XHRcdFx0XHRcdH07XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuXG4gXHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG4gXHRcdFx0fTtcbiBcdFx0fVxuXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcbiBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcbiBcdFx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG4gXHRcdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUoKSB7XG4gXHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcbiBcdFx0XHQpO1xuIFx0XHR9O1xuXG4gXHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XG4gXHRcdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRcdFx0aWYgKGhvdFVwZGF0ZVtpZF0pIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBpZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG4gXHRcdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGRlZmF1bHQ6XG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xuIFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoZG9BcHBseSkge1xuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0XHRcdFx0aWYgKFxuIFx0XHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkXG4gXHRcdFx0XHRcdFx0XHQpXG4gXHRcdFx0XHRcdFx0KSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG4gXHRcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJlxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWQgJiZcbiBcdFx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmVcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG4gXHRcdE9iamVjdC5rZXlzKGhvdEF2YWlsYWJsZUZpbGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rSWQpIHtcbiBcdFx0XHRpZiAoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XG4gXHRcdFx0XHRob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0fVxuIFx0XHR9KTtcblxuIFx0XHR2YXIgaWR4O1xuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcbiBcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuIFx0XHRcdHZhciBkYXRhID0ge307XG5cbiBcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuIFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xuIFx0XHRcdFx0Y2IoZGF0YSk7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XG5cbiBcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cbiBcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cbiBcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuIFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG4gXHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG4gXHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cbiBcdFx0dmFyIGRlcGVuZGVuY3k7XG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcbiBcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcbiBcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XG5cbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xuXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxuIFx0XHRmb3IgKG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuIFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcbiBcdFx0XHRcdFx0XHRpZiAoY2IpIHtcbiBcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihjYikgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xuIFx0XHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG4gXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXSxcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcbiBcdFx0Zm9yIChpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyMjtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxuIFx0XHRpZiAoZXJyb3IpIHtcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gXHRcdH1cblxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fSk7XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoXCIuL3NyYy9pbmRleC50c1wiKShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgVG9rZW5TdHJlYW19IGxvYWRzIHRva2VucyBmcm9tIGFcbi8vIHtAbGluayBUb2tlblNvdXJjZX0gb24tZGVtYW5kLCBhbmQgcGxhY2VzIHRoZSB0b2tlbnMgaW4gYSBidWZmZXIgdG8gcHJvdmlkZVxuLy8gYWNjZXNzIHRvIGFueSBwcmV2aW91cyB0b2tlbiBieSBpbmRleC5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgdG9rZW4gc3RyZWFtIGlnbm9yZXMgdGhlIHZhbHVlIG9mIHtAbGluayBUb2tlbi8vZ2V0Q2hhbm5lbH0uIElmIHlvdXJcbi8vIHBhcnNlciByZXF1aXJlcyB0aGUgdG9rZW4gc3RyZWFtIGZpbHRlciB0b2tlbnMgdG8gb25seSB0aG9zZSBvbiBhIHBhcnRpY3VsYXJcbi8vIGNoYW5uZWwsIHN1Y2ggYXMge0BsaW5rIFRva2VuLy9ERUZBVUxUX0NIQU5ORUx9IG9yXG4vLyB7QGxpbmsgVG9rZW4vL0hJRERFTl9DSEFOTkVMfSwgdXNlIGEgZmlsdGVyaW5nIHRva2VuIHN0cmVhbSBzdWNoIGFcbi8vIHtAbGluayBDb21tb25Ub2tlblN0cmVhbX0uPC9wPlxuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuL1Rva2VuJykuVG9rZW47XG52YXIgTGV4ZXIgPSByZXF1aXJlKCcuL0xleGVyJykuTGV4ZXI7XG52YXIgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsU2V0JykuSW50ZXJ2YWw7XG5cbi8vIHRoaXMgaXMganVzdCB0byBrZWVwIG1lYW5pbmdmdWwgcGFyYW1ldGVyIHR5cGVzIHRvIFBhcnNlclxuZnVuY3Rpb24gVG9rZW5TdHJlYW0oKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFRva2VuU3RyZWFtKHRva2VuU291cmNlKSB7XG5cblx0VG9rZW5TdHJlYW0uY2FsbCh0aGlzKTtcblx0Ly8gVGhlIHtAbGluayBUb2tlblNvdXJjZX0gZnJvbSB3aGljaCB0b2tlbnMgZm9yIHRoaXMgc3RyZWFtIGFyZSBmZXRjaGVkLlxuXHR0aGlzLnRva2VuU291cmNlID0gdG9rZW5Tb3VyY2U7XG5cblx0Ly8gQSBjb2xsZWN0aW9uIG9mIGFsbCB0b2tlbnMgZmV0Y2hlZCBmcm9tIHRoZSB0b2tlbiBzb3VyY2UuIFRoZSBsaXN0IGlzXG5cdC8vIGNvbnNpZGVyZWQgYSBjb21wbGV0ZSB2aWV3IG9mIHRoZSBpbnB1dCBvbmNlIHtAbGluayAvL2ZldGNoZWRFT0Z9IGlzIHNldFxuXHQvLyB0byB7QGNvZGUgdHJ1ZX0uXG5cdHRoaXMudG9rZW5zID0gW107XG5cblx0Ly8gVGhlIGluZGV4IGludG8ge0BsaW5rIC8vdG9rZW5zfSBvZiB0aGUgY3VycmVudCB0b2tlbiAobmV4dCB0b2tlbiB0b1xuXHQvLyB7QGxpbmsgLy9jb25zdW1lfSkuIHtAbGluayAvL3Rva2Vuc317QGNvZGUgW317QGxpbmsgLy9wfXtAY29kZSBdfSBzaG91bGRcblx0Ly8gYmVcblx0Ly8ge0BsaW5rIC8vTFQgTFQoMSl9LlxuXHQvL1xuXHQvLyA8cD5UaGlzIGZpZWxkIGlzIHNldCB0byAtMSB3aGVuIHRoZSBzdHJlYW0gaXMgZmlyc3QgY29uc3RydWN0ZWQgb3Igd2hlblxuXHQvLyB7QGxpbmsgLy9zZXRUb2tlblNvdXJjZX0gaXMgY2FsbGVkLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGZpcnN0IHRva2VuIGhhc1xuXHQvLyBub3QgeWV0IGJlZW4gZmV0Y2hlZCBmcm9tIHRoZSB0b2tlbiBzb3VyY2UuIEZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLFxuXHQvLyBzZWUgdGhlIGRvY3VtZW50YXRpb24gb2Yge0BsaW5rIEludFN0cmVhbX0gZm9yIGEgZGVzY3JpcHRpb24gb2Zcblx0Ly8gSW5pdGlhbGl6aW5nIE1ldGhvZHMuPC9wPlxuXHR0aGlzLmluZGV4ID0gLTE7XG5cblx0Ly8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUb2tlbi8vRU9GfSB0b2tlbiBoYXMgYmVlbiBmZXRjaGVkIGZyb21cblx0Ly8ge0BsaW5rIC8vdG9rZW5Tb3VyY2V9IGFuZCBhZGRlZCB0byB7QGxpbmsgLy90b2tlbnN9LiBUaGlzIGZpZWxkIGltcHJvdmVzXG5cdC8vIHBlcmZvcm1hbmNlIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvL1xuXHQvLyA8dWw+XG5cdC8vIDxsaT57QGxpbmsgLy9jb25zdW1lfTogVGhlIGxvb2thaGVhZCBjaGVjayBpbiB7QGxpbmsgLy9jb25zdW1lfSB0b1xuXHQvLyBwcmV2ZW50XG5cdC8vIGNvbnN1bWluZyB0aGUgRU9GIHN5bWJvbCBpcyBvcHRpbWl6ZWQgYnkgY2hlY2tpbmcgdGhlIHZhbHVlcyBvZlxuXHQvLyB7QGxpbmsgLy9mZXRjaGVkRU9GfSBhbmQge0BsaW5rIC8vcH0gaW5zdGVhZCBvZiBjYWxsaW5nIHtAbGlua1xuXHQvLyAvL0xBfS48L2xpPlxuXHQvLyA8bGk+e0BsaW5rIC8vZmV0Y2h9OiBUaGUgY2hlY2sgdG8gcHJldmVudCBhZGRpbmcgbXVsdGlwbGUgRU9GIHN5bWJvbHNcblx0Ly8gaW50b1xuXHQvLyB7QGxpbmsgLy90b2tlbnN9IGlzIHRyaXZpYWwgd2l0aCB0aGlzIGZpZWxkLjwvbGk+XG5cdC8vIDx1bD5cblx0dGhpcy5mZXRjaGVkRU9GID0gZmFsc2U7XG5cdHJldHVybiB0aGlzO1xufVxuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVG9rZW5TdHJlYW0ucHJvdG90eXBlKTtcbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQnVmZmVyZWRUb2tlblN0cmVhbTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gMDtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihtYXJrZXIpIHtcblx0Ly8gbm8gcmVzb3VyY2VzIHRvIHJlbGVhc2Vcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc2VlaygwKTtcbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLnNlZWsgPSBmdW5jdGlvbihpbmRleCkge1xuXHR0aGlzLmxhenlJbml0KCk7XG5cdHRoaXMuaW5kZXggPSB0aGlzLmFkanVzdFNlZWtJbmRleChpbmRleCk7XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuXHR0aGlzLmxhenlJbml0KCk7XG5cdHJldHVybiB0aGlzLnRva2Vuc1tpbmRleF07XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG5cdHZhciBza2lwRW9mQ2hlY2sgPSBmYWxzZTtcblx0aWYgKHRoaXMuaW5kZXggPj0gMCkge1xuXHRcdGlmICh0aGlzLmZldGNoZWRFT0YpIHtcblx0XHRcdC8vIHRoZSBsYXN0IHRva2VuIGluIHRva2VucyBpcyBFT0YuIHNraXAgY2hlY2sgaWYgcCBpbmRleGVzIGFueVxuXHRcdFx0Ly8gZmV0Y2hlZCB0b2tlbiBleGNlcHQgdGhlIGxhc3QuXG5cdFx0XHRza2lwRW9mQ2hlY2sgPSB0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm8gRU9GIHRva2VuIGluIHRva2Vucy4gc2tpcCBjaGVjayBpZiBwIGluZGV4ZXMgYSBmZXRjaGVkIHRva2VuLlxuXHRcdFx0c2tpcEVvZkNoZWNrID0gdGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gbm90IHlldCBpbml0aWFsaXplZFxuXHRcdHNraXBFb2ZDaGVjayA9IGZhbHNlO1xuXHR9XG5cdGlmICghc2tpcEVvZkNoZWNrICYmIHRoaXMuTEEoMSkgPT09IFRva2VuLkVPRikge1xuXHRcdHRocm93IFwiY2Fubm90IGNvbnN1bWUgRU9GXCI7XG5cdH1cblx0aWYgKHRoaXMuc3luYyh0aGlzLmluZGV4ICsgMSkpIHtcblx0XHR0aGlzLmluZGV4ID0gdGhpcy5hZGp1c3RTZWVrSW5kZXgodGhpcy5pbmRleCArIDEpO1xuXHR9XG59O1xuXG4vLyBNYWtlIHN1cmUgaW5kZXgge0Bjb2RlIGl9IGluIHRva2VucyBoYXMgYSB0b2tlbi5cbi8vXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiBhIHRva2VuIGlzIGxvY2F0ZWQgYXQgaW5kZXgge0Bjb2RlIGl9LCBvdGhlcndpc2Vcbi8vIHtAY29kZSBmYWxzZX0uXG4vLyBAc2VlIC8vZ2V0KGludCBpKVxuLy8gL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKGkpIHtcblx0dmFyIG4gPSBpIC0gdGhpcy50b2tlbnMubGVuZ3RoICsgMTsgLy8gaG93IG1hbnkgbW9yZSBlbGVtZW50cyB3ZSBuZWVkP1xuXHRpZiAobiA+IDApIHtcblx0XHR2YXIgZmV0Y2hlZCA9IHRoaXMuZmV0Y2gobik7XG5cdFx0cmV0dXJuIGZldGNoZWQgPj0gbjtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEFkZCB7QGNvZGUgbn0gZWxlbWVudHMgdG8gYnVmZmVyLlxuLy9cbi8vIEByZXR1cm4gVGhlIGFjdHVhbCBudW1iZXIgb2YgZWxlbWVudHMgYWRkZWQgdG8gdGhlIGJ1ZmZlci5cbi8vIC9cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24obikge1xuXHRpZiAodGhpcy5mZXRjaGVkRU9GKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgdCA9IHRoaXMudG9rZW5Tb3VyY2UubmV4dFRva2VuKCk7XG5cdFx0dC50b2tlbkluZGV4ID0gdGhpcy50b2tlbnMubGVuZ3RoO1xuXHRcdHRoaXMudG9rZW5zLnB1c2godCk7XG5cdFx0aWYgKHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHR0aGlzLmZldGNoZWRFT0YgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGkgKyAxO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbjtcbn07XG5cbi8vIEdldCBhbGwgdG9rZW5zIGZyb20gc3RhcnQuLnN0b3AgaW5jbHVzaXZlbHkvLy9cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCB0eXBlcykge1xuXHRpZiAodHlwZXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHR5cGVzID0gbnVsbDtcblx0fVxuXHRpZiAoc3RhcnQgPCAwIHx8IHN0b3AgPCAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dGhpcy5sYXp5SW5pdCgpO1xuXHR2YXIgc3Vic2V0ID0gW107XG5cdGlmIChzdG9wID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHRcdHN0b3AgPSB0aGlzLnRva2Vucy5sZW5ndGggLSAxO1xuXHR9XG5cdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0b3A7IGkrKykge1xuXHRcdHZhciB0ID0gdGhpcy50b2tlbnNbaV07XG5cdFx0aWYgKHQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKHR5cGVzID09PSBudWxsIHx8IHR5cGVzLmNvbnRhaW5zKHQudHlwZSkpIHtcblx0XHRcdHN1YnNldC5wdXNoKHQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3Vic2V0O1xufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuTEEgPSBmdW5jdGlvbihpKSB7XG5cdHJldHVybiB0aGlzLkxUKGkpLnR5cGU7XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5MQiA9IGZ1bmN0aW9uKGspIHtcblx0aWYgKHRoaXMuaW5kZXggLSBrIDwgMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLmluZGV4IC0ga107XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5MVCA9IGZ1bmN0aW9uKGspIHtcblx0dGhpcy5sYXp5SW5pdCgpO1xuXHRpZiAoayA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmIChrIDwgMCkge1xuXHRcdHJldHVybiB0aGlzLkxCKC1rKTtcblx0fVxuXHR2YXIgaSA9IHRoaXMuaW5kZXggKyBrIC0gMTtcblx0dGhpcy5zeW5jKGkpO1xuXHRpZiAoaSA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHsgLy8gcmV0dXJuIEVPRiB0b2tlblxuXHRcdC8vIEVPRiBtdXN0IGJlIGxhc3QgdG9rZW5cblx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV07XG5cdH1cblx0cmV0dXJuIHRoaXMudG9rZW5zW2ldO1xufTtcblxuLy8gQWxsb3dlZCBkZXJpdmVkIGNsYXNzZXMgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiBvcGVyYXRpb25zIHdoaWNoIGNoYW5nZVxuLy8gdGhlIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uIGJ5IGFkanVzdGluZyB0aGUgdGFyZ2V0IHRva2VuIGluZGV4IG9mIGEgc2Vla1xuLy8gb3BlcmF0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgcmV0dXJucyB7QGNvZGUgaX0uIElmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGluIHRoaXMgbWV0aG9kLCB0aGUgY3VycmVudCBzdHJlYW0gaW5kZXggc2hvdWxkIG5vdCBiZVxuLy8gY2hhbmdlZC5cbi8vXG4vLyA8cD5Gb3IgZXhhbXBsZSwge0BsaW5rIENvbW1vblRva2VuU3RyZWFtfSBvdmVycmlkZXMgdGhpcyBtZXRob2QgdG8gZW5zdXJlXG4vLyB0aGF0XG4vLyB0aGUgc2VlayB0YXJnZXQgaXMgYWx3YXlzIGFuIG9uLWNoYW5uZWwgdG9rZW4uPC9wPlxuLy9cbi8vIEBwYXJhbSBpIFRoZSB0YXJnZXQgdG9rZW4gaW5kZXguXG4vLyBAcmV0dXJuIFRoZSBhZGp1c3RlZCB0YXJnZXQgdG9rZW4gaW5kZXguXG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkanVzdFNlZWtJbmRleCA9IGZ1bmN0aW9uKGkpIHtcblx0cmV0dXJuIGk7XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5sYXp5SW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5pbmRleCA9PT0gLTEpIHtcblx0XHR0aGlzLnNldHVwKCk7XG5cdH1cbn07XG5cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuc3luYygwKTtcblx0dGhpcy5pbmRleCA9IHRoaXMuYWRqdXN0U2Vla0luZGV4KDApO1xufTtcblxuLy8gUmVzZXQgdGhpcyB0b2tlbiBzdHJlYW0gYnkgc2V0dGluZyBpdHMgdG9rZW4gc291cmNlLi8vL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuc2V0VG9rZW5Tb3VyY2UgPSBmdW5jdGlvbih0b2tlblNvdXJjZSkge1xuXHR0aGlzLnRva2VuU291cmNlID0gdG9rZW5Tb3VyY2U7XG5cdHRoaXMudG9rZW5zID0gW107XG5cdHRoaXMuaW5kZXggPSAtMTtcblx0dGhpcy5mZXRjaGVkRU9GID0gZmFsc2U7XG59O1xuXG5cbi8vIEdpdmVuIGEgc3RhcnRpbmcgaW5kZXgsIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5leHQgdG9rZW4gb24gY2hhbm5lbC5cbi8vIFJldHVybiBpIGlmIHRva2Vuc1tpXSBpcyBvbiBjaGFubmVsLiBSZXR1cm4gLTEgaWYgdGhlcmUgYXJlIG5vIHRva2Vuc1xuLy8gb24gY2hhbm5lbCBiZXR3ZWVuIGkgYW5kIEVPRi5cbi8vIC9cbkJ1ZmZlcmVkVG9rZW5TdHJlYW0ucHJvdG90eXBlLm5leHRUb2tlbk9uQ2hhbm5lbCA9IGZ1bmN0aW9uKGksIGNoYW5uZWwpIHtcblx0dGhpcy5zeW5jKGkpO1xuXHRpZiAoaSA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gLTE7XG5cdH1cblx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG5cdHdoaWxlICh0b2tlbi5jaGFubmVsICE9PSB0aGlzLmNoYW5uZWwpIHtcblx0XHRpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGkgKz0gMTtcblx0XHR0aGlzLnN5bmMoaSk7XG5cdFx0dG9rZW4gPSB0aGlzLnRva2Vuc1tpXTtcblx0fVxuXHRyZXR1cm4gaTtcbn07XG5cbi8vIEdpdmVuIGEgc3RhcnRpbmcgaW5kZXgsIHJldHVybiB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRva2VuIG9uIGNoYW5uZWwuXG4vLyBSZXR1cm4gaSBpZiB0b2tlbnNbaV0gaXMgb24gY2hhbm5lbC4gUmV0dXJuIC0xIGlmIHRoZXJlIGFyZSBubyB0b2tlbnNcbi8vIG9uIGNoYW5uZWwgYmV0d2VlbiBpIGFuZCAwLlxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUucHJldmlvdXNUb2tlbk9uQ2hhbm5lbCA9IGZ1bmN0aW9uKGksIGNoYW5uZWwpIHtcblx0d2hpbGUgKGkgPj0gMCAmJiB0aGlzLnRva2Vuc1tpXS5jaGFubmVsICE9PSBjaGFubmVsKSB7XG5cdFx0aSAtPSAxO1xuXHR9XG5cdHJldHVybiBpO1xufTtcblxuLy8gQ29sbGVjdCBhbGwgdG9rZW5zIG9uIHNwZWNpZmllZCBjaGFubmVsIHRvIHRoZSByaWdodCBvZlxuLy8gdGhlIGN1cnJlbnQgdG9rZW4gdXAgdW50aWwgd2Ugc2VlIGEgdG9rZW4gb24gREVGQVVMVF9UT0tFTl9DSEFOTkVMIG9yXG4vLyBFT0YuIElmIGNoYW5uZWwgaXMgLTEsIGZpbmQgYW55IG5vbiBkZWZhdWx0IGNoYW5uZWwgdG9rZW4uXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5nZXRIaWRkZW5Ub2tlbnNUb1JpZ2h0ID0gZnVuY3Rpb24odG9rZW5JbmRleCxcblx0XHRjaGFubmVsKSB7XG5cdGlmIChjaGFubmVsID09PSB1bmRlZmluZWQpIHtcblx0XHRjaGFubmVsID0gLTE7XG5cdH1cblx0dGhpcy5sYXp5SW5pdCgpO1xuXHRpZiAodG9rZW5JbmRleCA8IDAgfHwgdG9rZW5JbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcblx0XHR0aHJvdyBcIlwiICsgdG9rZW5JbmRleCArIFwiIG5vdCBpbiAwLi5cIiArIHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG5cdH1cblx0dmFyIG5leHRPbkNoYW5uZWwgPSB0aGlzLm5leHRUb2tlbk9uQ2hhbm5lbCh0b2tlbkluZGV4ICsgMSwgTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMKTtcblx0dmFyIGZyb21fID0gdG9rZW5JbmRleCArIDE7XG5cdC8vIGlmIG5vbmUgb25jaGFubmVsIHRvIHJpZ2h0LCBuZXh0T25DaGFubmVsPS0xIHNvIHNldCB0byA9IGxhc3QgdG9rZW5cblx0dmFyIHRvID0gbmV4dE9uQ2hhbm5lbCA9PT0gLTEgPyB0aGlzLnRva2Vucy5sZW5ndGggLSAxIDogbmV4dE9uQ2hhbm5lbDtcblx0cmV0dXJuIHRoaXMuZmlsdGVyRm9yQ2hhbm5lbChmcm9tXywgdG8sIGNoYW5uZWwpO1xufTtcblxuLy8gQ29sbGVjdCBhbGwgdG9rZW5zIG9uIHNwZWNpZmllZCBjaGFubmVsIHRvIHRoZSBsZWZ0IG9mXG4vLyB0aGUgY3VycmVudCB0b2tlbiB1cCB1bnRpbCB3ZSBzZWUgYSB0b2tlbiBvbiBERUZBVUxUX1RPS0VOX0NIQU5ORUwuXG4vLyBJZiBjaGFubmVsIGlzIC0xLCBmaW5kIGFueSBub24gZGVmYXVsdCBjaGFubmVsIHRva2VuLlxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuZ2V0SGlkZGVuVG9rZW5zVG9MZWZ0ID0gZnVuY3Rpb24odG9rZW5JbmRleCxcblx0XHRjaGFubmVsKSB7XG5cdGlmIChjaGFubmVsID09PSB1bmRlZmluZWQpIHtcblx0XHRjaGFubmVsID0gLTE7XG5cdH1cblx0dGhpcy5sYXp5SW5pdCgpO1xuXHRpZiAodG9rZW5JbmRleCA8IDAgfHwgdG9rZW5JbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcblx0XHR0aHJvdyBcIlwiICsgdG9rZW5JbmRleCArIFwiIG5vdCBpbiAwLi5cIiArIHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG5cdH1cblx0dmFyIHByZXZPbkNoYW5uZWwgPSB0aGlzLnByZXZpb3VzVG9rZW5PbkNoYW5uZWwodG9rZW5JbmRleCAtIDEsIExleGVyLkRFRkFVTFRfVE9LRU5fQ0hBTk5FTCk7XG5cdGlmIChwcmV2T25DaGFubmVsID09PSB0b2tlbkluZGV4IC0gMSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdC8vIGlmIG5vbmUgb24gY2hhbm5lbCB0byBsZWZ0LCBwcmV2T25DaGFubmVsPS0xIHRoZW4gZnJvbT0wXG5cdHZhciBmcm9tXyA9IHByZXZPbkNoYW5uZWwgKyAxO1xuXHR2YXIgdG8gPSB0b2tlbkluZGV4IC0gMTtcblx0cmV0dXJuIHRoaXMuZmlsdGVyRm9yQ2hhbm5lbChmcm9tXywgdG8sIGNoYW5uZWwpO1xufTtcblxuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuZmlsdGVyRm9yQ2hhbm5lbCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBjaGFubmVsKSB7XG5cdHZhciBoaWRkZW4gPSBbXTtcblx0Zm9yICh2YXIgaSA9IGxlZnQ7IGkgPCByaWdodCArIDE7IGkrKykge1xuXHRcdHZhciB0ID0gdGhpcy50b2tlbnNbaV07XG5cdFx0aWYgKGNoYW5uZWwgPT09IC0xKSB7XG5cdFx0XHRpZiAodC5jaGFubmVsICE9PSBMZXhlci5ERUZBVUxUX1RPS0VOX0NIQU5ORUwpIHtcblx0XHRcdFx0aGlkZGVuLnB1c2godCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0LmNoYW5uZWwgPT09IGNoYW5uZWwpIHtcblx0XHRcdGhpZGRlbi5wdXNoKHQpO1xuXHRcdH1cblx0fVxuXHRpZiAoaGlkZGVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdHJldHVybiBoaWRkZW47XG59O1xuXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5nZXRTb3VyY2VOYW1lID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnRva2VuU291cmNlLmdldFNvdXJjZU5hbWUoKTtcbn07XG5cbi8vIEdldCB0aGUgdGV4dCBvZiBhbGwgdG9rZW5zIGluIHRoaXMgYnVmZmVyLi8vL1xuQnVmZmVyZWRUb2tlblN0cmVhbS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGludGVydmFsKSB7XG5cdHRoaXMubGF6eUluaXQoKTtcblx0dGhpcy5maWxsKCk7XG5cdGlmIChpbnRlcnZhbCA9PT0gdW5kZWZpbmVkIHx8IGludGVydmFsID09PSBudWxsKSB7XG5cdFx0aW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoMCwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMSk7XG5cdH1cblx0dmFyIHN0YXJ0ID0gaW50ZXJ2YWwuc3RhcnQ7XG5cdGlmIChzdGFydCBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0c3RhcnQgPSBzdGFydC50b2tlbkluZGV4O1xuXHR9XG5cdHZhciBzdG9wID0gaW50ZXJ2YWwuc3RvcDtcblx0aWYgKHN0b3AgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdHN0b3AgPSBzdG9wLnRva2VuSW5kZXg7XG5cdH1cblx0aWYgKHN0YXJ0ID09PSBudWxsIHx8IHN0b3AgPT09IG51bGwgfHwgc3RhcnQgPCAwIHx8IHN0b3AgPCAwKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblx0aWYgKHN0b3AgPj0gdGhpcy50b2tlbnMubGVuZ3RoKSB7XG5cdFx0c3RvcCA9IHRoaXMudG9rZW5zLmxlbmd0aCAtIDE7XG5cdH1cblx0dmFyIHMgPSBcIlwiO1xuXHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdG9wICsgMTsgaSsrKSB7XG5cdFx0dmFyIHQgPSB0aGlzLnRva2Vuc1tpXTtcblx0XHRpZiAodC50eXBlID09PSBUb2tlbi5FT0YpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRzID0gcyArIHQudGV4dDtcblx0fVxuXHRyZXR1cm4gcztcbn07XG5cbi8vIEdldCBhbGwgdG9rZW5zIGZyb20gbGV4ZXIgdW50aWwgRU9GLy8vXG5CdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubGF6eUluaXQoKTtcblx0d2hpbGUgKHRoaXMuZmV0Y2goMTAwMCkgPT09IDEwMDApIHtcblx0XHRjb250aW51ZTtcblx0fVxufTtcblxuZXhwb3J0cy5CdWZmZXJlZFRva2VuU3RyZWFtID0gQnVmZmVyZWRUb2tlblN0cmVhbTtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG52YXIgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJykuSW5wdXRTdHJlYW07XG5cbnZhciBpc05vZGVKcyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAndW5kZWZpbmVkJztcbnZhciBmcyA9IGlzTm9kZUpzID8gcmVxdWlyZShcImZzXCIpIDogbnVsbDtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgdG8gY3JlYXRlIElucHV0U3RyZWFtcyBmcm9tIHZhcmlvdXMgc291cmNlcy5cbi8vXG4vLyBBbGwgcmV0dXJuZWQgSW5wdXRTdHJlYW1zIHN1cHBvcnQgdGhlIGZ1bGwgcmFuZ2Ugb2YgVW5pY29kZVxuLy8gdXAgdG8gVSsxMEZGRkYgKHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIElucHV0U3RyZWFtIG9ubHkgc3VwcG9ydHNcbi8vIGNvZGUgcG9pbnRzIHVwIHRvIFUrRkZGRikuXG52YXIgQ2hhclN0cmVhbXMgPSB7XG4gIC8vIENyZWF0ZXMgYW4gSW5wdXRTdHJlYW0gZnJvbSBhIHN0cmluZy5cbiAgZnJvbVN0cmluZzogZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFN0cmVhbShzdHIsIHRydWUpO1xuICB9LFxuXG4gIC8vIEFzeW5jaHJvbm91c2x5IGNyZWF0ZXMgYW4gSW5wdXRTdHJlYW0gZnJvbSBhIGJsb2IgZ2l2ZW4gdGhlXG4gIC8vIGVuY29kaW5nIG9mIHRoZSBieXRlcyBpbiB0aGF0IGJsb2IgKGRlZmF1bHRzIHRvICd1dGY4JyBpZlxuICAvLyBlbmNvZGluZyBpcyBudWxsKS5cbiAgLy9cbiAgLy8gSW52b2tlcyBvbkxvYWQocmVzdWx0KSBvbiBzdWNjZXNzLCBvbkVycm9yKGVycm9yKSBvblxuICAvLyBmYWlsdXJlLlxuICBmcm9tQmxvYjogZnVuY3Rpb24oYmxvYiwgZW5jb2RpbmcsIG9uTG9hZCwgb25FcnJvcikge1xuICAgIHZhciByZWFkZXIgPSBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBpcyA9IG5ldyBJbnB1dFN0cmVhbShlLnRhcmdldC5yZXN1bHQsIHRydWUpO1xuICAgICAgb25Mb2FkKGlzKTtcbiAgICB9O1xuICAgIHJlYWRlci5vbmVycm9yID0gb25FcnJvcjtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZyk7XG4gIH0sXG5cbiAgLy8gQ3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBmcm9tIGEgQnVmZmVyIGdpdmVuIHRoZVxuICAvLyBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBidWZmZXIgKGRlZmF1bHRzIHRvICd1dGY4JyBpZlxuICAvLyBlbmNvZGluZyBpcyBudWxsKS5cbiAgZnJvbUJ1ZmZlcjogZnVuY3Rpb24oYnVmZmVyLCBlbmNvZGluZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRTdHJlYW0oYnVmZmVyLnRvU3RyaW5nKGVuY29kaW5nKSwgdHJ1ZSk7XG4gIH0sXG5cbiAgLy8gQXN5bmNocm9ub3VzbHkgY3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBmcm9tIGEgZmlsZSBvbiBkaXNrIGdpdmVuXG4gIC8vIHRoZSBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBmaWxlIChkZWZhdWx0cyB0byAndXRmOCcgaWZcbiAgLy8gZW5jb2RpbmcgaXMgbnVsbCkuXG4gIC8vXG4gIC8vIEludm9rZXMgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkgb24gY29tcGxldGlvbi5cbiAgZnJvbVBhdGg6IGZ1bmN0aW9uKHBhdGgsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGZzLnJlYWRGaWxlKHBhdGgsIGVuY29kaW5nLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgIHZhciBpcyA9IG51bGw7XG4gICAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpcyA9IG5ldyBJbnB1dFN0cmVhbShkYXRhLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVyciwgaXMpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIFN5bmNocm9ub3VzbHkgY3JlYXRlcyBhbiBJbnB1dFN0cmVhbSBnaXZlbiBhIHBhdGggdG8gYSBmaWxlXG4gIC8vIG9uIGRpc2sgYW5kIHRoZSBlbmNvZGluZyBvZiB0aGUgYnl0ZXMgaW4gdGhhdCBmaWxlIChkZWZhdWx0cyB0b1xuICAvLyAndXRmOCcgaWYgZW5jb2RpbmcgaXMgbnVsbCkuXG4gIGZyb21QYXRoU3luYzogZnVuY3Rpb24ocGF0aCwgZW5jb2RpbmcpIHtcbiAgICB2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoLCBlbmNvZGluZyk7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFN0cmVhbShkYXRhLCB0cnVlKTtcbiAgfVxufTtcblxuZXhwb3J0cy5DaGFyU3RyZWFtcyA9IENoYXJTdHJlYW1zO1xuIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbi8vXG4vLyBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFRva2VuRmFjdG9yeX0gY3JlYXRlc1xuLy8ge0BsaW5rIENvbW1vblRva2VufSBvYmplY3RzLlxuLy9cblxudmFyIENvbW1vblRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLkNvbW1vblRva2VuO1xuXG5mdW5jdGlvbiBUb2tlbkZhY3RvcnkoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBDb21tb25Ub2tlbkZhY3RvcnkoY29weVRleHQpIHtcblx0VG9rZW5GYWN0b3J5LmNhbGwodGhpcyk7XG4gICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIENvbW1vblRva2VuLy9zZXRUZXh0fSBzaG91bGQgYmUgY2FsbGVkIGFmdGVyXG4gICAgLy8gY29uc3RydWN0aW5nIHRva2VucyB0byBleHBsaWNpdGx5IHNldCB0aGUgdGV4dC4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzXG4gICAgLy8gd2hlcmUgdGhlIGlucHV0IHN0cmVhbSBtaWdodCBub3QgYmUgYWJsZSB0byBwcm92aWRlIGFyYml0cmFyeSBzdWJzdHJpbmdzXG4gICAgLy8gb2YgdGV4dCBmcm9tIHRoZSBpbnB1dCBhZnRlciB0aGUgbGV4ZXIgY3JlYXRlcyBhIHRva2VuIChlLmcuIHRoZVxuICAgIC8vIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBDaGFyU3RyZWFtLy9nZXRUZXh0fSBpblxuICAgIC8vIHtAbGluayBVbmJ1ZmZlcmVkQ2hhclN0cmVhbX0gdGhyb3dzIGFuXG4gICAgLy8ge0BsaW5rIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9ufSkuIEV4cGxpY2l0bHkgc2V0dGluZyB0aGUgdG9rZW4gdGV4dFxuICAgIC8vIGFsbG93cyB7QGxpbmsgVG9rZW4vL2dldFRleHR9IHRvIGJlIGNhbGxlZCBhdCBhbnkgdGltZSByZWdhcmRsZXNzIG9mIHRoZVxuICAgIC8vIGlucHV0IHN0cmVhbSBpbXBsZW1lbnRhdGlvbi5cbiAgICAvL1xuICAgIC8vIDxwPlxuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHtAY29kZSBmYWxzZX0gdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGFuZCBtZW1vcnlcbiAgICAvLyBvdmVyaGVhZCBvZiBjb3B5aW5nIHRleHQgZm9yIGV2ZXJ5IHRva2VuIHVubGVzcyBleHBsaWNpdGx5IHJlcXVlc3RlZC48L3A+XG4gICAgLy9cbiAgICB0aGlzLmNvcHlUZXh0ID0gY29weVRleHQ9PT11bmRlZmluZWQgPyBmYWxzZSA6IGNvcHlUZXh0O1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQ29tbW9uVG9rZW5GYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVG9rZW5GYWN0b3J5LnByb3RvdHlwZSk7XG5Db21tb25Ub2tlbkZhY3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tbW9uVG9rZW5GYWN0b3J5O1xuXG4vL1xuLy8gVGhlIGRlZmF1bHQge0BsaW5rIENvbW1vblRva2VuRmFjdG9yeX0gaW5zdGFuY2UuXG4vL1xuLy8gPHA+XG4vLyBUaGlzIHRva2VuIGZhY3RvcnkgZG9lcyBub3QgZXhwbGljaXRseSBjb3B5IHRva2VuIHRleHQgd2hlbiBjb25zdHJ1Y3Rpbmdcbi8vIHRva2Vucy48L3A+XG4vL1xuQ29tbW9uVG9rZW5GYWN0b3J5LkRFRkFVTFQgPSBuZXcgQ29tbW9uVG9rZW5GYWN0b3J5KCk7XG5cbkNvbW1vblRva2VuRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oc291cmNlLCB0eXBlLCB0ZXh0LCBjaGFubmVsLCBzdGFydCwgc3RvcCwgbGluZSwgY29sdW1uKSB7XG4gICAgdmFyIHQgPSBuZXcgQ29tbW9uVG9rZW4oc291cmNlLCB0eXBlLCBjaGFubmVsLCBzdGFydCwgc3RvcCk7XG4gICAgdC5saW5lID0gbGluZTtcbiAgICB0LmNvbHVtbiA9IGNvbHVtbjtcbiAgICBpZiAodGV4dCAhPT1udWxsKSB7XG4gICAgICAgIHQudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvcHlUZXh0ICYmIHNvdXJjZVsxXSAhPT1udWxsKSB7XG4gICAgICAgIHQudGV4dCA9IHNvdXJjZVsxXS5nZXRUZXh0KHN0YXJ0LHN0b3ApO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5cbkNvbW1vblRva2VuRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlVGhpbiA9IGZ1bmN0aW9uKHR5cGUsIHRleHQpIHtcbiAgICB2YXIgdCA9IG5ldyBDb21tb25Ub2tlbihudWxsLCB0eXBlKTtcbiAgICB0LnRleHQgPSB0ZXh0O1xuICAgIHJldHVybiB0O1xufTtcblxuZXhwb3J0cy5Db21tb25Ub2tlbkZhY3RvcnkgPSBDb21tb25Ub2tlbkZhY3Rvcnk7XG4iLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbi8vXG4vLyBUaGlzIGNsYXNzIGV4dGVuZHMge0BsaW5rIEJ1ZmZlcmVkVG9rZW5TdHJlYW19IHdpdGggZnVuY3Rpb25hbGl0eSB0byBmaWx0ZXJcbi8vIHRva2VuIHN0cmVhbXMgdG8gdG9rZW5zIG9uIGEgcGFydGljdWxhciBjaGFubmVsICh0b2tlbnMgd2hlcmVcbi8vIHtAbGluayBUb2tlbi8vZ2V0Q2hhbm5lbH0gcmV0dXJucyBhIHBhcnRpY3VsYXIgdmFsdWUpLlxuLy9cbi8vIDxwPlxuLy8gVGhpcyB0b2tlbiBzdHJlYW0gcHJvdmlkZXMgYWNjZXNzIHRvIGFsbCB0b2tlbnMgYnkgaW5kZXggb3Igd2hlbiBjYWxsaW5nXG4vLyBtZXRob2RzIGxpa2Uge0BsaW5rIC8vZ2V0VGV4dH0uIFRoZSBjaGFubmVsIGZpbHRlcmluZyBpcyBvbmx5IHVzZWQgZm9yIGNvZGVcbi8vIGFjY2Vzc2luZyB0b2tlbnMgdmlhIHRoZSBsb29rYWhlYWQgbWV0aG9kcyB7QGxpbmsgLy9MQX0sIHtAbGluayAvL0xUfSwgYW5kXG4vLyB7QGxpbmsgLy9MQn0uPC9wPlxuLy9cbi8vIDxwPlxuLy8gQnkgZGVmYXVsdCwgdG9rZW5zIGFyZSBwbGFjZWQgb24gdGhlIGRlZmF1bHQgY2hhbm5lbFxuLy8gKHtAbGluayBUb2tlbi8vREVGQVVMVF9DSEFOTkVMfSksIGJ1dCBtYXkgYmUgcmVhc3NpZ25lZCBieSB1c2luZyB0aGVcbi8vIHtAY29kZSAtPmNoYW5uZWwoSElEREVOKX0gbGV4ZXIgY29tbWFuZCwgb3IgYnkgdXNpbmcgYW4gZW1iZWRkZWQgYWN0aW9uIHRvXG4vLyBjYWxsIHtAbGluayBMZXhlci8vc2V0Q2hhbm5lbH0uXG4vLyA8L3A+XG4vL1xuLy8gPHA+XG4vLyBOb3RlOiBsZXhlciBydWxlcyB3aGljaCB1c2UgdGhlIHtAY29kZSAtPnNraXB9IGxleGVyIGNvbW1hbmQgb3IgY2FsbFxuLy8ge0BsaW5rIExleGVyLy9za2lwfSBkbyBub3QgcHJvZHVjZSB0b2tlbnMgYXQgYWxsLCBzbyBpbnB1dCB0ZXh0IG1hdGNoZWQgYnlcbi8vIHN1Y2ggYSBydWxlIHdpbGwgbm90IGJlIGF2YWlsYWJsZSBhcyBwYXJ0IG9mIHRoZSB0b2tlbiBzdHJlYW0sIHJlZ2FyZGxlc3Mgb2Zcbi8vIGNoYW5uZWwuPC9wPlxuLy8vXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBCdWZmZXJlZFRva2VuU3RyZWFtID0gcmVxdWlyZSgnLi9CdWZmZXJlZFRva2VuU3RyZWFtJykuQnVmZmVyZWRUb2tlblN0cmVhbTtcblxuZnVuY3Rpb24gQ29tbW9uVG9rZW5TdHJlYW0obGV4ZXIsIGNoYW5uZWwpIHtcblx0QnVmZmVyZWRUb2tlblN0cmVhbS5jYWxsKHRoaXMsIGxleGVyKTtcbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsPT09dW5kZWZpbmVkID8gVG9rZW4uREVGQVVMVF9DSEFOTkVMIDogY2hhbm5lbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQ29tbW9uVG9rZW5TdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXJlZFRva2VuU3RyZWFtLnByb3RvdHlwZSk7XG5Db21tb25Ub2tlblN0cmVhbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21tb25Ub2tlblN0cmVhbTtcblxuQ29tbW9uVG9rZW5TdHJlYW0ucHJvdG90eXBlLmFkanVzdFNlZWtJbmRleCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwoaSwgdGhpcy5jaGFubmVsKTtcbn07XG5cbkNvbW1vblRva2VuU3RyZWFtLnByb3RvdHlwZS5MQiA9IGZ1bmN0aW9uKGspIHtcbiAgICBpZiAoaz09PTAgfHwgdGhpcy5pbmRleC1rPDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5pbmRleDtcbiAgICB2YXIgbiA9IDE7XG4gICAgLy8gZmluZCBrIGdvb2QgdG9rZW5zIGxvb2tpbmcgYmFja3dhcmRzXG4gICAgd2hpbGUgKG4gPD0gaykge1xuICAgICAgICAvLyBza2lwIG9mZi1jaGFubmVsIHRva2Vuc1xuICAgICAgICBpID0gdGhpcy5wcmV2aW91c1Rva2VuT25DaGFubmVsKGkgLSAxLCB0aGlzLmNoYW5uZWwpO1xuICAgICAgICBuICs9IDE7XG4gICAgfVxuICAgIGlmIChpIDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9rZW5zW2ldO1xufTtcblxuQ29tbW9uVG9rZW5TdHJlYW0ucHJvdG90eXBlLkxUID0gZnVuY3Rpb24oaykge1xuICAgIHRoaXMubGF6eUluaXQoKTtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkxCKC1rKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmluZGV4O1xuICAgIHZhciBuID0gMTsgLy8gd2Uga25vdyB0b2tlbnNbcG9zXSBpcyBhIGdvb2Qgb25lXG4gICAgLy8gZmluZCBrIGdvb2QgdG9rZW5zXG4gICAgd2hpbGUgKG4gPCBrKSB7XG4gICAgICAgIC8vIHNraXAgb2ZmLWNoYW5uZWwgdG9rZW5zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBsb29rIHBhc3QgRU9GXG4gICAgICAgIGlmICh0aGlzLnN5bmMoaSArIDEpKSB7XG4gICAgICAgICAgICBpID0gdGhpcy5uZXh0VG9rZW5PbkNoYW5uZWwoaSArIDEsIHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICAgICAgbiArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50b2tlbnNbaV07XG59O1xuXG4vLyBDb3VudCBFT0YganVzdCBvbmNlLi8vL1xuQ29tbW9uVG9rZW5TdHJlYW0ucHJvdG90eXBlLmdldE51bWJlck9mT25DaGFubmVsVG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSAwO1xuICAgIHRoaXMuZmlsbCgpO1xuICAgIGZvciAodmFyIGkgPTA7IGk8IHRoaXMudG9rZW5zLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRva2Vuc1tpXTtcbiAgICAgICAgaWYoIHQuY2hhbm5lbD09PXRoaXMuY2hhbm5lbCkge1xuICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmKCB0LnR5cGU9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcblxuZXhwb3J0cy5Db21tb25Ub2tlblN0cmVhbSA9IENvbW1vblRva2VuU3RyZWFtOyIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG4vL1xuLy8gIFRoaXMgaXMgYW4gSW5wdXRTdHJlYW0gdGhhdCBpcyBsb2FkZWQgZnJvbSBhIGZpbGUgYWxsIGF0IG9uY2Vcbi8vICB3aGVuIHlvdSBjb25zdHJ1Y3QgdGhlIG9iamVjdC5cbi8vXG52YXIgSW5wdXRTdHJlYW0gPSByZXF1aXJlKCcuL0lucHV0U3RyZWFtJykuSW5wdXRTdHJlYW07XG52YXIgaXNOb2RlSnMgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ3VuZGVmaW5lZCc7XG52YXIgZnMgPSBpc05vZGVKcyA/IHJlcXVpcmUoXCJmc1wiKSA6IG51bGw7XG5cbmZ1bmN0aW9uIEZpbGVTdHJlYW0oZmlsZU5hbWUsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcblx0dmFyIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZU5hbWUsIFwidXRmOFwiKTtcblx0SW5wdXRTdHJlYW0uY2FsbCh0aGlzLCBkYXRhLCBkZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzKTtcblx0dGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuRmlsZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKElucHV0U3RyZWFtLnByb3RvdHlwZSk7XG5GaWxlU3RyZWFtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpbGVTdHJlYW07XG5cbmV4cG9ydHMuRmlsZVN0cmVhbSA9IEZpbGVTdHJlYW07XG4iLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xucmVxdWlyZSgnLi9wb2x5ZmlsbHMvY29kZXBvaW50YXQnKTtcbnJlcXVpcmUoJy4vcG9seWZpbGxzL2Zyb21jb2RlcG9pbnQnKTtcblxuLy8gVmFjdXVtIGFsbCBpbnB1dCBmcm9tIGEgc3RyaW5nIGFuZCB0aGVuIHRyZWF0IGl0IGxpa2UgYSBidWZmZXIuXG5cbmZ1bmN0aW9uIF9sb2FkU3RyaW5nKHN0cmVhbSkge1xuXHRzdHJlYW0uX2luZGV4ID0gMDtcblx0c3RyZWFtLmRhdGEgPSBbXTtcblx0aWYgKHN0cmVhbS5kZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0uc3RyZGF0YS5sZW5ndGg7ICkge1xuXHRcdFx0dmFyIGNvZGVQb2ludCA9IHN0cmVhbS5zdHJkYXRhLmNvZGVQb2ludEF0KGkpO1xuXHRcdFx0c3RyZWFtLmRhdGEucHVzaChjb2RlUG9pbnQpO1xuXHRcdFx0aSArPSBjb2RlUG9pbnQgPD0gMHhGRkZGID8gMSA6IDI7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3RyZWFtLnN0cmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBjb2RlVW5pdCA9IHN0cmVhbS5zdHJkYXRhLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRzdHJlYW0uZGF0YS5wdXNoKGNvZGVVbml0KTtcblx0XHR9XG5cdH1cblx0c3RyZWFtLl9zaXplID0gc3RyZWFtLmRhdGEubGVuZ3RoO1xufVxuXG4vLyBJZiBkZWNvZGVUb1VuaWNvZGVDb2RlUG9pbnRzIGlzIHRydWUsIHRoZSBpbnB1dCBpcyB0cmVhdGVkXG4vLyBhcyBhIHNlcmllcyBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuLy9cbi8vIE90aGVyd2lzZSwgdGhlIGlucHV0IGlzIHRyZWF0ZWQgYXMgYSBzZXJpZXMgb2YgMTYtYml0IFVURi0xNiBjb2RlXG4vLyB1bml0cy5cbmZ1bmN0aW9uIElucHV0U3RyZWFtKGRhdGEsIGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcblx0dGhpcy5uYW1lID0gXCI8ZW1wdHk+XCI7XG5cdHRoaXMuc3RyZGF0YSA9IGRhdGE7XG5cdHRoaXMuZGVjb2RlVG9Vbmljb2RlQ29kZVBvaW50cyA9IGRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMgfHwgZmFsc2U7XG5cdF9sb2FkU3RyaW5nKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0U3RyZWFtLnByb3RvdHlwZSwgXCJpbmRleFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dFN0cmVhbS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplO1xuXHR9XG59KTtcblxuLy8gUmVzZXQgdGhlIHN0cmVhbSBzbyB0aGF0IGl0J3MgaW4gdGhlIHNhbWUgc3RhdGUgaXQgd2FzXG4vLyB3aGVuIHRoZSBvYmplY3Qgd2FzIGNyZWF0ZWQgKmV4Y2VwdCogdGhlIGRhdGEgYXJyYXkgaXMgbm90XG4vLyB0b3VjaGVkLlxuLy9cbklucHV0U3RyZWFtLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9pbmRleCA9IDA7XG59O1xuXG5JbnB1dFN0cmVhbS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fc2l6ZSkge1xuXHRcdC8vIGFzc2VydCB0aGlzLkxBKDEpID09IFRva2VuLkVPRlxuXHRcdHRocm93IChcImNhbm5vdCBjb25zdW1lIEVPRlwiKTtcblx0fVxuXHR0aGlzLl9pbmRleCArPSAxO1xufTtcblxuSW5wdXRTdHJlYW0ucHJvdG90eXBlLkxBID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdGlmIChvZmZzZXQgPT09IDApIHtcblx0XHRyZXR1cm4gMDsgLy8gdW5kZWZpbmVkXG5cdH1cblx0aWYgKG9mZnNldCA8IDApIHtcblx0XHRvZmZzZXQgKz0gMTsgLy8gZS5nLiwgdHJhbnNsYXRlIExBKC0xKSB0byB1c2Ugb2Zmc2V0PTBcblx0fVxuXHR2YXIgcG9zID0gdGhpcy5faW5kZXggKyBvZmZzZXQgLSAxO1xuXHRpZiAocG9zIDwgMCB8fCBwb3MgPj0gdGhpcy5fc2l6ZSkgeyAvLyBpbnZhbGlkXG5cdFx0cmV0dXJuIFRva2VuLkVPRjtcblx0fVxuXHRyZXR1cm4gdGhpcy5kYXRhW3Bvc107XG59O1xuXG5JbnB1dFN0cmVhbS5wcm90b3R5cGUuTFQgPSBmdW5jdGlvbihvZmZzZXQpIHtcblx0cmV0dXJuIHRoaXMuTEEob2Zmc2V0KTtcbn07XG5cbi8vIG1hcmsvcmVsZWFzZSBkbyBub3RoaW5nOyB3ZSBoYXZlIGVudGlyZSBidWZmZXJcbklucHV0U3RyZWFtLnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAtMTtcbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24obWFya2VyKSB7XG59O1xuXG4vLyBjb25zdW1lKCkgYWhlYWQgdW50aWwgcD09X2luZGV4OyBjYW4ndCBqdXN0IHNldCBwPV9pbmRleCBhcyB3ZSBtdXN0XG4vLyB1cGRhdGUgbGluZSBhbmQgY29sdW1uLiBJZiB3ZSBzZWVrIGJhY2t3YXJkcywganVzdCBzZXQgcFxuLy9cbklucHV0U3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24oX2luZGV4KSB7XG5cdGlmIChfaW5kZXggPD0gdGhpcy5faW5kZXgpIHtcblx0XHR0aGlzLl9pbmRleCA9IF9pbmRleDsgLy8ganVzdCBqdW1wOyBkb24ndCB1cGRhdGUgc3RyZWFtIHN0YXRlIChsaW5lLFxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLilcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gc2VlayBmb3J3YXJkXG5cdHRoaXMuX2luZGV4ID0gTWF0aC5taW4oX2luZGV4LCB0aGlzLl9zaXplKTtcbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oc3RhcnQsIHN0b3ApIHtcblx0aWYgKHN0b3AgPj0gdGhpcy5fc2l6ZSkge1xuXHRcdHN0b3AgPSB0aGlzLl9zaXplIC0gMTtcblx0fVxuXHRpZiAoc3RhcnQgPj0gdGhpcy5fc2l6ZSkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9IGVsc2Uge1xuXHRcdGlmICh0aGlzLmRlY29kZVRvVW5pY29kZUNvZGVQb2ludHMpIHtcblx0XHRcdHZhciByZXN1bHQgPSBcIlwiO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IHN0b3A7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQodGhpcy5kYXRhW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLnN0cmRhdGEuc2xpY2Uoc3RhcnQsIHN0b3AgKyAxKTtcblx0XHR9XG5cdH1cbn07XG5cbklucHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zdHJkYXRhO1xufTtcblxuZXhwb3J0cy5JbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG4vKmpzbGludCBzbWFydHRhYnM6dHJ1ZSAqL1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuL1Rva2VuJykuVG9rZW47XG5cbi8qIHN0b3AgaXMgbm90IGluY2x1ZGVkISAqL1xuZnVuY3Rpb24gSW50ZXJ2YWwoc3RhcnQsIHN0b3ApIHtcblx0dGhpcy5zdGFydCA9IHN0YXJ0O1xuXHR0aGlzLnN0b3AgPSBzdG9wO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuSW50ZXJ2YWwucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oaXRlbSkge1xuXHRyZXR1cm4gaXRlbSA+PSB0aGlzLnN0YXJ0ICYmIGl0ZW0gPCB0aGlzLnN0b3A7XG59O1xuXG5JbnRlcnZhbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYodGhpcy5zdGFydD09PXRoaXMuc3RvcC0xKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQudG9TdHJpbmcoKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5zdGFydC50b1N0cmluZygpICsgXCIuLlwiICsgKHRoaXMuc3RvcC0xKS50b1N0cmluZygpO1xuXHR9XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RvcCAtIHRoaXMuc3RhcnQ7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBJbnRlcnZhbFNldCgpIHtcblx0dGhpcy5pbnRlcnZhbHMgPSBudWxsO1xuXHR0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG59XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5maXJzdCA9IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsIHx8IHRoaXMuaW50ZXJ2YWxzLmxlbmd0aD09PTApIHtcblx0XHRyZXR1cm4gVG9rZW4uSU5WQUxJRF9UWVBFO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLmludGVydmFsc1swXS5zdGFydDtcblx0fVxufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLmFkZE9uZSA9IGZ1bmN0aW9uKHYpIHtcblx0dGhpcy5hZGRJbnRlcnZhbChuZXcgSW50ZXJ2YWwodiwgdiArIDEpKTtcbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5hZGRSYW5nZSA9IGZ1bmN0aW9uKGwsIGgpIHtcblx0dGhpcy5hZGRJbnRlcnZhbChuZXcgSW50ZXJ2YWwobCwgaCArIDEpKTtcbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5hZGRJbnRlcnZhbCA9IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG5cdFx0dGhpcy5pbnRlcnZhbHMgPSBbXTtcblx0XHR0aGlzLmludGVydmFscy5wdXNoKHYpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGZpbmQgaW5zZXJ0IHBvc1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdHZhciBpID0gdGhpcy5pbnRlcnZhbHNba107XG5cdFx0XHQvLyBkaXN0aW5jdCByYW5nZSAtPiBpbnNlcnRcblx0XHRcdGlmICh2LnN0b3AgPCBpLnN0YXJ0KSB7XG5cdFx0XHRcdHRoaXMuaW50ZXJ2YWxzLnNwbGljZShrLCAwLCB2KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29udGlndW91cyByYW5nZSAtPiBhZGp1c3Rcblx0XHRcdGVsc2UgaWYgKHYuc3RvcCA9PT0gaS5zdGFydCkge1xuXHRcdFx0XHR0aGlzLmludGVydmFsc1trXS5zdGFydCA9IHYuc3RhcnQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIG92ZXJsYXBwaW5nIHJhbmdlIC0+IGFkanVzdCBhbmQgcmVkdWNlXG5cdFx0XHRlbHNlIGlmICh2LnN0YXJ0IDw9IGkuc3RvcCkge1xuXHRcdFx0XHR0aGlzLmludGVydmFsc1trXSA9IG5ldyBJbnRlcnZhbChNYXRoLm1pbihpLnN0YXJ0LCB2LnN0YXJ0KSwgTWF0aC5tYXgoaS5zdG9wLCB2LnN0b3ApKTtcblx0XHRcdFx0dGhpcy5yZWR1Y2Uoayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gZ3JlYXRlciB0aGFuIGFueSBleGlzdGluZ1xuXHRcdHRoaXMuaW50ZXJ2YWxzLnB1c2godik7XG5cdH1cbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5hZGRTZXQgPSBmdW5jdGlvbihvdGhlcikge1xuXHRpZiAob3RoZXIuaW50ZXJ2YWxzICE9PSBudWxsKSB7XG5cdFx0Zm9yICh2YXIgayA9IDA7IGsgPCBvdGhlci5pbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdHZhciBpID0gb3RoZXIuaW50ZXJ2YWxzW2tdO1xuXHRcdFx0dGhpcy5hZGRJbnRlcnZhbChuZXcgSW50ZXJ2YWwoaS5zdGFydCwgaS5zdG9wKSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0aGlzO1xufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uKGspIHtcblx0Ly8gb25seSBuZWVkIHRvIHJlZHVjZSBpZiBrIGlzIG5vdCB0aGUgbGFzdFxuXHRpZiAoayA8IHRoaXMuaW50ZXJ2YWxzbGVuZ3RoIC0gMSkge1xuXHRcdHZhciBsID0gdGhpcy5pbnRlcnZhbHNba107XG5cdFx0dmFyIHIgPSB0aGlzLmludGVydmFsc1trICsgMV07XG5cdFx0Ly8gaWYgciBjb250YWluZWQgaW4gbFxuXHRcdGlmIChsLnN0b3AgPj0gci5zdG9wKSB7XG5cdFx0XHR0aGlzLmludGVydmFscy5wb3AoayArIDEpO1xuXHRcdFx0dGhpcy5yZWR1Y2Uoayk7XG5cdFx0fSBlbHNlIGlmIChsLnN0b3AgPj0gci5zdGFydCkge1xuXHRcdFx0dGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwobC5zdGFydCwgci5zdG9wKTtcblx0XHRcdHRoaXMuaW50ZXJ2YWxzLnBvcChrICsgMSk7XG5cdFx0fVxuXHR9XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUuY29tcGxlbWVudCA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgIHJlc3VsdC5hZGRJbnRlcnZhbChuZXcgSW50ZXJ2YWwoc3RhcnQsc3RvcCsxKSk7XG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnJlbW92ZVJhbmdlKHRoaXMuaW50ZXJ2YWxzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0aWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBrKyspIHtcblx0XHRcdGlmKHRoaXMuaW50ZXJ2YWxzW2tdLmNvbnRhaW5zKGl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRlcnZhbFNldC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbiA9IDA7XG5cdFx0dGhpcy5pbnRlcnZhbHMubWFwKGZ1bmN0aW9uKGkpIHtsZW4gKz0gaS5sZW5ndGg7fSk7XG5cdFx0cmV0dXJuIGxlbjtcblx0fVxufSk7XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS5yZW1vdmVSYW5nZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZih2LnN0YXJ0PT09di5zdG9wLTEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVPbmUodi5zdGFydCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmludGVydmFscyE9PW51bGwpIHtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBmb3IodmFyIG49MDsgbjx0aGlzLmludGVydmFscy5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmludGVydmFsc1trXTtcbiAgICAgICAgICAgIC8vIGludGVydmFscyBhcmUgb3JkZXJlZFxuICAgICAgICAgICAgaWYgKHYuc3RvcDw9aS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBpbmNsdWRpbmcgcmFuZ2UsIHNwbGl0IGl0XG4gICAgICAgICAgICBlbHNlIGlmKHYuc3RhcnQ+aS5zdGFydCAmJiB2LnN0b3A8aS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwoaS5zdGFydCwgdi5zdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBuZXcgSW50ZXJ2YWwodi5zdG9wLCBpLnN0b3ApO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzLnNwbGljZShrLCAwLCB4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgaW5jbHVkZWQgcmFuZ2UsIHJlbW92ZSBpdFxuICAgICAgICAgICAgZWxzZSBpZih2LnN0YXJ0PD1pLnN0YXJ0ICYmIHYuc3RvcD49aS5zdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnZhbHMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICAgIGsgPSBrIC0gMTsgLy8gbmVlZCBhbm90aGVyIHBhc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBsb3dlciBib3VuZGFyeVxuICAgICAgICAgICAgZWxzZSBpZih2LnN0YXJ0PGkuc3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWxzW2tdID0gbmV3IEludGVydmFsKGkuc3RhcnQsIHYuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHVwcGVyIGJvdW5kYXJ5XG4gICAgICAgICAgICBlbHNlIGlmKHYuc3RvcDxpLnN0b3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVydmFsc1trXSA9IG5ldyBJbnRlcnZhbCh2LnN0b3AsIGkuc3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUucmVtb3ZlT25lID0gZnVuY3Rpb24odikge1xuXHRpZiAodGhpcy5pbnRlcnZhbHMgIT09IG51bGwpIHtcblx0XHRmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuaW50ZXJ2YWxzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHR2YXIgaSA9IHRoaXMuaW50ZXJ2YWxzW2tdO1xuXHRcdFx0Ly8gaW50ZXJ2YWxzIGlzIG9yZGVyZWRcblx0XHRcdGlmICh2IDwgaS5zdGFydCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjaGVjayBmb3Igc2luZ2xlIHZhbHVlIHJhbmdlXG5cdFx0XHRlbHNlIGlmICh2ID09PSBpLnN0YXJ0ICYmIHYgPT09IGkuc3RvcCAtIDEpIHtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbHMuc3BsaWNlKGssIDEpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjaGVjayBmb3IgbG93ZXIgYm91bmRhcnlcblx0XHRcdGVsc2UgaWYgKHYgPT09IGkuc3RhcnQpIHtcblx0XHRcdFx0dGhpcy5pbnRlcnZhbHNba10gPSBuZXcgSW50ZXJ2YWwoaS5zdGFydCArIDEsIGkuc3RvcCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGNoZWNrIGZvciB1cHBlciBib3VuZGFyeVxuXHRcdFx0ZWxzZSBpZiAodiA9PT0gaS5zdG9wIC0gMSkge1xuXHRcdFx0XHR0aGlzLmludGVydmFsc1trXSA9IG5ldyBJbnRlcnZhbChpLnN0YXJ0LCBpLnN0b3AgLSAxKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3BsaXQgZXhpc3RpbmcgcmFuZ2Vcblx0XHRcdGVsc2UgaWYgKHYgPCBpLnN0b3AgLSAxKSB7XG5cdFx0XHRcdHZhciB4ID0gbmV3IEludGVydmFsKGkuc3RhcnQsIHYpO1xuXHRcdFx0XHRpLnN0YXJ0ID0gdiArIDE7XG5cdFx0XHRcdHRoaXMuaW50ZXJ2YWxzLnNwbGljZShrLCAwLCB4KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24obGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzLCBlbGVtc0FyZUNoYXIpIHtcblx0bGl0ZXJhbE5hbWVzID0gbGl0ZXJhbE5hbWVzIHx8IG51bGw7XG5cdHN5bWJvbGljTmFtZXMgPSBzeW1ib2xpY05hbWVzIHx8IG51bGw7XG5cdGVsZW1zQXJlQ2hhciA9IGVsZW1zQXJlQ2hhciB8fCBmYWxzZTtcblx0aWYgKHRoaXMuaW50ZXJ2YWxzID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIFwie31cIjtcblx0fSBlbHNlIGlmKGxpdGVyYWxOYW1lcyE9PW51bGwgfHwgc3ltYm9saWNOYW1lcyE9PW51bGwpIHtcblx0XHRyZXR1cm4gdGhpcy50b1Rva2VuU3RyaW5nKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcyk7XG5cdH0gZWxzZSBpZihlbGVtc0FyZUNoYXIpIHtcblx0XHRyZXR1cm4gdGhpcy50b0NoYXJTdHJpbmcoKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy50b0luZGV4U3RyaW5nKCk7XG5cdH1cbn07XG5cbkludGVydmFsU2V0LnByb3RvdHlwZS50b0NoYXJTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIG5hbWVzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdiA9IHRoaXMuaW50ZXJ2YWxzW2ldO1xuXHRcdGlmKHYuc3RvcD09PXYuc3RhcnQrMSkge1xuXHRcdFx0aWYgKCB2LnN0YXJ0PT09VG9rZW4uRU9GICkge1xuXHRcdFx0XHRuYW1lcy5wdXNoKFwiPEVPRj5cIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYW1lcy5wdXNoKFwiJ1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZSh2LnN0YXJ0KSArIFwiJ1wiKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bmFtZXMucHVzaChcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodi5zdGFydCkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodi5zdG9wLTEpICsgXCInXCIpO1xuXHRcdH1cblx0fVxuXHRpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiBcIntcIiArIG5hbWVzLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuYW1lc1swXTtcblx0fVxufTtcblxuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUudG9JbmRleFN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbmFtZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB2ID0gdGhpcy5pbnRlcnZhbHNbaV07XG5cdFx0aWYodi5zdG9wPT09di5zdGFydCsxKSB7XG5cdFx0XHRpZiAoIHYuc3RhcnQ9PT1Ub2tlbi5FT0YgKSB7XG5cdFx0XHRcdG5hbWVzLnB1c2goXCI8RU9GPlwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5hbWVzLnB1c2godi5zdGFydC50b1N0cmluZygpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bmFtZXMucHVzaCh2LnN0YXJ0LnRvU3RyaW5nKCkgKyBcIi4uXCIgKyAodi5zdG9wLTEpLnRvU3RyaW5nKCkpO1xuXHRcdH1cblx0fVxuXHRpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiBcIntcIiArIG5hbWVzLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuYW1lc1swXTtcblx0fVxufTtcblxuXG5JbnRlcnZhbFNldC5wcm90b3R5cGUudG9Ub2tlblN0cmluZyA9IGZ1bmN0aW9uKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcykge1xuXHR2YXIgbmFtZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmludGVydmFscy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciB2ID0gdGhpcy5pbnRlcnZhbHNbaV07XG5cdFx0Zm9yICh2YXIgaiA9IHYuc3RhcnQ7IGogPCB2LnN0b3A7IGorKykge1xuXHRcdFx0bmFtZXMucHVzaCh0aGlzLmVsZW1lbnROYW1lKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcywgaikpO1xuXHRcdH1cblx0fVxuXHRpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuXHRcdHJldHVybiBcIntcIiArIG5hbWVzLmpvaW4oXCIsIFwiKSArIFwifVwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuYW1lc1swXTtcblx0fVxufTtcblxuSW50ZXJ2YWxTZXQucHJvdG90eXBlLmVsZW1lbnROYW1lID0gZnVuY3Rpb24obGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzLCBhKSB7XG5cdGlmIChhID09PSBUb2tlbi5FT0YpIHtcblx0XHRyZXR1cm4gXCI8RU9GPlwiO1xuXHR9IGVsc2UgaWYgKGEgPT09IFRva2VuLkVQU0lMT04pIHtcblx0XHRyZXR1cm4gXCI8RVBTSUxPTj5cIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbGl0ZXJhbE5hbWVzW2FdIHx8IHN5bWJvbGljTmFtZXNbYV07XG5cdH1cbn07XG5cbmV4cG9ydHMuSW50ZXJ2YWwgPSBJbnRlcnZhbDtcbmV4cG9ydHMuSW50ZXJ2YWxTZXQgPSBJbnRlcnZhbFNldDtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxudmFyIFNldCA9IHJlcXVpcmUoJy4vVXRpbHMnKS5TZXQ7XG52YXIgQml0U2V0ID0gcmVxdWlyZSgnLi9VdGlscycpLkJpdFNldDtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBBVE5Db25maWcgPSByZXF1aXJlKCcuL2F0bi9BVE5Db25maWcnKS5BVE5Db25maWc7XG52YXIgSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsU2V0JykuSW50ZXJ2YWw7XG52YXIgSW50ZXJ2YWxTZXQgPSByZXF1aXJlKCcuL0ludGVydmFsU2V0JykuSW50ZXJ2YWxTZXQ7XG52YXIgUnVsZVN0b3BTdGF0ZSA9IHJlcXVpcmUoJy4vYXRuL0FUTlN0YXRlJykuUnVsZVN0b3BTdGF0ZTtcbnZhciBSdWxlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vYXRuL1RyYW5zaXRpb24nKS5SdWxlVHJhbnNpdGlvbjtcbnZhciBOb3RTZXRUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9hdG4vVHJhbnNpdGlvbicpLk5vdFNldFRyYW5zaXRpb247XG52YXIgV2lsZGNhcmRUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9hdG4vVHJhbnNpdGlvbicpLldpbGRjYXJkVHJhbnNpdGlvbjtcbnZhciBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL2F0bi9UcmFuc2l0aW9uJykuQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG52YXIgcGMgPSByZXF1aXJlKCcuL1ByZWRpY3Rpb25Db250ZXh0Jyk7XG52YXIgcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQgPSBwYy5wcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dDtcbnZhciBQcmVkaWN0aW9uQ29udGV4dCA9IHBjLlByZWRpY3Rpb25Db250ZXh0O1xudmFyIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0ID0gcGMuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQ7XG5cbmZ1bmN0aW9uIExMMUFuYWx5emVyIChhdG4pIHtcbiAgICB0aGlzLmF0biA9IGF0bjtcbn1cblxuLy8qIFNwZWNpYWwgdmFsdWUgYWRkZWQgdG8gdGhlIGxvb2thaGVhZCBzZXRzIHRvIGluZGljYXRlIHRoYXQgd2UgaGl0XG4vLyAgYSBwcmVkaWNhdGUgZHVyaW5nIGFuYWx5c2lzIGlmIHtAY29kZSBzZWVUaHJ1UHJlZHM9PWZhbHNlfS5cbi8vL1xuTEwxQW5hbHl6ZXIuSElUX1BSRUQgPSBUb2tlbi5JTlZBTElEX1RZUEU7XG5cblxuLy8qXG4vLyBDYWxjdWxhdGVzIHRoZSBTTEwoMSkgZXhwZWN0ZWQgbG9va2FoZWFkIHNldCBmb3IgZWFjaCBvdXRnb2luZyB0cmFuc2l0aW9uXG4vLyBvZiBhbiB7QGxpbmsgQVROU3RhdGV9LiBUaGUgcmV0dXJuZWQgYXJyYXkgaGFzIG9uZSBlbGVtZW50IGZvciBlYWNoXG4vLyBvdXRnb2luZyB0cmFuc2l0aW9uIGluIHtAY29kZSBzfS4gSWYgdGhlIGNsb3N1cmUgZnJvbSB0cmFuc2l0aW9uXG4vLyA8ZW0+aTwvZW0+IGxlYWRzIHRvIGEgc2VtYW50aWMgcHJlZGljYXRlIGJlZm9yZSBtYXRjaGluZyBhIHN5bWJvbCwgdGhlXG4vLyBlbGVtZW50IGF0IGluZGV4IDxlbT5pPC9lbT4gb2YgdGhlIHJlc3VsdCB3aWxsIGJlIHtAY29kZSBudWxsfS5cbi8vXG4vLyBAcGFyYW0gcyB0aGUgQVROIHN0YXRlXG4vLyBAcmV0dXJuIHRoZSBleHBlY3RlZCBzeW1ib2xzIGZvciBlYWNoIG91dGdvaW5nIHRyYW5zaXRpb24gb2Yge0Bjb2RlIHN9LlxuLy8vXG5MTDFBbmFseXplci5wcm90b3R5cGUuZ2V0RGVjaXNpb25Mb29rYWhlYWQgPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjb3VudCA9IHMudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgIHZhciBsb29rID0gW107XG4gICAgZm9yKHZhciBhbHQ9MDsgYWx0PCBjb3VudDsgYWx0KyspIHtcbiAgICAgICAgbG9va1thbHRdID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIHZhciBsb29rQnVzeSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHNlZVRocnVQcmVkcyA9IGZhbHNlOyAvLyBmYWlsIHRvIGdldCBsb29rYWhlYWQgdXBvbiBwcmVkXG4gICAgICAgIHRoaXMuX0xPT0socy50cmFuc2l0aW9uKGFsdCkudGFyZ2V0LCBudWxsLCBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSxcbiAgICAgICAgICAgICAgbG9va1thbHRdLCBsb29rQnVzeSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIGZhbHNlKTtcbiAgICAgICAgLy8gV2lwZSBvdXQgbG9va2FoZWFkIGZvciB0aGlzIGFsdGVybmF0aXZlIGlmIHdlIGZvdW5kIG5vdGhpbmdcbiAgICAgICAgLy8gb3Igd2UgaGFkIGEgcHJlZGljYXRlIHdoZW4gd2UgIXNlZVRocnVQcmVkc1xuICAgICAgICBpZiAobG9va1thbHRdLmxlbmd0aD09PTAgfHwgbG9va1thbHRdLmNvbnRhaW5zKExMMUFuYWx5emVyLkhJVF9QUkVEKSkge1xuICAgICAgICAgICAgbG9va1thbHRdID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9vaztcbn07XG5cbi8vKlxuLy8gQ29tcHV0ZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyB7QGNvZGUgc30gaW4gdGhlIEFUTiBpbiB0aGVcbi8vIHNwZWNpZmllZCB7QGNvZGUgY3R4fS5cbi8vXG4vLyA8cD5JZiB7QGNvZGUgY3R4fSBpcyB7QGNvZGUgbnVsbH0gYW5kIHRoZSBlbmQgb2YgdGhlIHJ1bGUgY29udGFpbmluZ1xuLy8ge0Bjb2RlIHN9IGlzIHJlYWNoZWQsIHtAbGluayBUb2tlbi8vRVBTSUxPTn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuXG4vLyBJZiB7QGNvZGUgY3R4fSBpcyBub3Qge0Bjb2RlIG51bGx9IGFuZCB0aGUgZW5kIG9mIHRoZSBvdXRlcm1vc3QgcnVsZSBpc1xuLy8gcmVhY2hlZCwge0BsaW5rIFRva2VuLy9FT0Z9IGlzIGFkZGVkIHRvIHRoZSByZXN1bHQgc2V0LjwvcD5cbi8vXG4vLyBAcGFyYW0gcyB0aGUgQVROIHN0YXRlXG4vLyBAcGFyYW0gc3RvcFN0YXRlIHRoZSBBVE4gc3RhdGUgdG8gc3RvcCBhdC4gVGhpcyBjYW4gYmUgYVxuLy8ge0BsaW5rIEJsb2NrRW5kU3RhdGV9IHRvIGRldGVjdCBlcHNpbG9uIHBhdGhzIHRocm91Z2ggYSBjbG9zdXJlLlxuLy8gQHBhcmFtIGN0eCB0aGUgY29tcGxldGUgcGFyc2VyIGNvbnRleHQsIG9yIHtAY29kZSBudWxsfSBpZiB0aGUgY29udGV4dFxuLy8gc2hvdWxkIGJlIGlnbm9yZWRcbi8vXG4vLyBAcmV0dXJuIFRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyB7QGNvZGUgc30gaW4gdGhlIEFUTiBpbiB0aGVcbi8vIHNwZWNpZmllZCB7QGNvZGUgY3R4fS5cbi8vL1xuTEwxQW5hbHl6ZXIucHJvdG90eXBlLkxPT0sgPSBmdW5jdGlvbihzLCBzdG9wU3RhdGUsIGN0eCkge1xuICAgIHZhciByID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgdmFyIHNlZVRocnVQcmVkcyA9IHRydWU7IC8vIGlnbm9yZSBwcmVkczsgZ2V0IGFsbCBsb29rYWhlYWRcblx0Y3R4ID0gY3R4IHx8IG51bGw7XG4gICAgdmFyIGxvb2tDb250ZXh0ID0gY3R4IT09bnVsbCA/IHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0KHMuYXRuLCBjdHgpIDogbnVsbDtcbiAgICB0aGlzLl9MT09LKHMsIHN0b3BTdGF0ZSwgbG9va0NvbnRleHQsIHIsIG5ldyBTZXQoKSwgbmV3IEJpdFNldCgpLCBzZWVUaHJ1UHJlZHMsIHRydWUpO1xuICAgIHJldHVybiByO1xufTtcblxuLy8qXG4vLyBDb21wdXRlIHNldCBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IHtAY29kZSBzfSBpbiB0aGUgQVROIGluIHRoZVxuLy8gc3BlY2lmaWVkIHtAY29kZSBjdHh9LlxuLy9cbi8vIDxwPklmIHtAY29kZSBjdHh9IGlzIHtAY29kZSBudWxsfSBhbmQge0Bjb2RlIHN0b3BTdGF0ZX0gb3IgdGhlIGVuZCBvZiB0aGVcbi8vIHJ1bGUgY29udGFpbmluZyB7QGNvZGUgc30gaXMgcmVhY2hlZCwge0BsaW5rIFRva2VuLy9FUFNJTE9OfSBpcyBhZGRlZCB0b1xuLy8gdGhlIHJlc3VsdCBzZXQuIElmIHtAY29kZSBjdHh9IGlzIG5vdCB7QGNvZGUgbnVsbH0gYW5kIHtAY29kZSBhZGRFT0Z9IGlzXG4vLyB7QGNvZGUgdHJ1ZX0gYW5kIHtAY29kZSBzdG9wU3RhdGV9IG9yIHRoZSBlbmQgb2YgdGhlIG91dGVybW9zdCBydWxlIGlzXG4vLyByZWFjaGVkLCB7QGxpbmsgVG9rZW4vL0VPRn0gaXMgYWRkZWQgdG8gdGhlIHJlc3VsdCBzZXQuPC9wPlxuLy9cbi8vIEBwYXJhbSBzIHRoZSBBVE4gc3RhdGUuXG4vLyBAcGFyYW0gc3RvcFN0YXRlIHRoZSBBVE4gc3RhdGUgdG8gc3RvcCBhdC4gVGhpcyBjYW4gYmUgYVxuLy8ge0BsaW5rIEJsb2NrRW5kU3RhdGV9IHRvIGRldGVjdCBlcHNpbG9uIHBhdGhzIHRocm91Z2ggYSBjbG9zdXJlLlxuLy8gQHBhcmFtIGN0eCBUaGUgb3V0ZXIgY29udGV4dCwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSBvdXRlciBjb250ZXh0IHNob3VsZFxuLy8gbm90IGJlIHVzZWQuXG4vLyBAcGFyYW0gbG9vayBUaGUgcmVzdWx0IGxvb2thaGVhZCBzZXQuXG4vLyBAcGFyYW0gbG9va0J1c3kgQSBzZXQgdXNlZCBmb3IgcHJldmVudGluZyBlcHNpbG9uIGNsb3N1cmVzIGluIHRoZSBBVE5cbi8vIGZyb20gY2F1c2luZyBhIHN0YWNrIG92ZXJmbG93LiBPdXRzaWRlIGNvZGUgc2hvdWxkIHBhc3Ncbi8vIHtAY29kZSBuZXcgU2V0PEFUTkNvbmZpZz59IGZvciB0aGlzIGFyZ3VtZW50LlxuLy8gQHBhcmFtIGNhbGxlZFJ1bGVTdGFjayBBIHNldCB1c2VkIGZvciBwcmV2ZW50aW5nIGxlZnQgcmVjdXJzaW9uIGluIHRoZVxuLy8gQVROIGZyb20gY2F1c2luZyBhIHN0YWNrIG92ZXJmbG93LiBPdXRzaWRlIGNvZGUgc2hvdWxkIHBhc3Ncbi8vIHtAY29kZSBuZXcgQml0U2V0KCl9IGZvciB0aGlzIGFyZ3VtZW50LlxuLy8gQHBhcmFtIHNlZVRocnVQcmVkcyB7QGNvZGUgdHJ1ZX0gdG8gdHJ1ZSBzZW1hbnRpYyBwcmVkaWNhdGVzIGFzXG4vLyBpbXBsaWNpdGx5IHtAY29kZSB0cnVlfSBhbmQgXCJzZWUgdGhyb3VnaCB0aGVtXCIsIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9XG4vLyB0byB0cmVhdCBzZW1hbnRpYyBwcmVkaWNhdGVzIGFzIG9wYXF1ZSBhbmQgYWRkIHtAbGluayAvL0hJVF9QUkVEfSB0byB0aGVcbi8vIHJlc3VsdCBpZiBvbmUgaXMgZW5jb3VudGVyZWQuXG4vLyBAcGFyYW0gYWRkRU9GIEFkZCB7QGxpbmsgVG9rZW4vL0VPRn0gdG8gdGhlIHJlc3VsdCBpZiB0aGUgZW5kIG9mIHRoZVxuLy8gb3V0ZXJtb3N0IGNvbnRleHQgaXMgcmVhY2hlZC4gVGhpcyBwYXJhbWV0ZXIgaGFzIG5vIGVmZmVjdCBpZiB7QGNvZGUgY3R4fVxuLy8gaXMge0Bjb2RlIG51bGx9LlxuLy8vXG5MTDFBbmFseXplci5wcm90b3R5cGUuX0xPT0sgPSBmdW5jdGlvbihzLCBzdG9wU3RhdGUgLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKSB7XG4gICAgdmFyIGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTpzLCBhbHQ6MCwgY29udGV4dDogY3R4fSwgbnVsbCk7XG4gICAgaWYgKGxvb2tCdXN5LmNvbnRhaW5zKGMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9va0J1c3kuYWRkKGMpO1xuICAgIGlmIChzID09PSBzdG9wU3RhdGUpIHtcbiAgICAgICAgaWYgKGN0eCA9PT1udWxsKSB7XG4gICAgICAgICAgICBsb29rLmFkZE9uZShUb2tlbi5FUFNJTE9OKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguaXNFbXB0eSgpICYmIGFkZEVPRikge1xuICAgICAgICAgICAgbG9vay5hZGRPbmUoVG9rZW4uRU9GKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocyBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUgKSB7XG4gICAgICAgIGlmIChjdHggPT09bnVsbCkge1xuICAgICAgICAgICAgbG9vay5hZGRPbmUoVG9rZW4uRVBTSUxPTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4LmlzRW1wdHkoKSAmJiBhZGRFT0YpIHtcbiAgICAgICAgICAgIGxvb2suYWRkT25lKFRva2VuLkVPRik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eCAhPT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHtcbiAgICAgICAgICAgIC8vIHJ1biB0aHJ1IGFsbCBwb3NzaWJsZSBzdGFjayB0b3BzIGluIGN0eFxuICAgICAgICAgICAgZm9yKHZhciBpPTA7IGk8Y3R4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW2N0eC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBjYWxsZWRSdWxlU3RhY2suY29udGFpbnMocmV0dXJuU3RhdGUucnVsZUluZGV4KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsZWRSdWxlU3RhY2sucmVtb3ZlKHJldHVyblN0YXRlLnJ1bGVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0xPT0socmV0dXJuU3RhdGUsIHN0b3BTdGF0ZSwgY3R4LmdldFBhcmVudChpKSwgbG9vaywgbG9va0J1c3ksIGNhbGxlZFJ1bGVTdGFjaywgc2VlVGhydVByZWRzLCBhZGRFT0YpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWRSdWxlU3RhY2suYWRkKHJldHVyblN0YXRlLnJ1bGVJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHZhciBqPTA7IGo8cy50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgdCA9IHMudHJhbnNpdGlvbnNbal07XG4gICAgICAgIGlmICh0LmNvbnN0cnVjdG9yID09PSBSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKGNhbGxlZFJ1bGVTdGFjay5jb250YWlucyh0LnRhcmdldC5ydWxlSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3Q29udGV4dCA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShjdHgsIHQuZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsZWRSdWxlU3RhY2suYWRkKHQudGFyZ2V0LnJ1bGVJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBuZXdDb250ZXh0LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGNhbGxlZFJ1bGVTdGFjay5yZW1vdmUodC50YXJnZXQucnVsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uICkge1xuICAgICAgICAgICAgaWYgKHNlZVRocnVQcmVkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX0xPT0sodC50YXJnZXQsIHN0b3BTdGF0ZSwgY3R4LCBsb29rLCBsb29rQnVzeSwgY2FsbGVkUnVsZVN0YWNrLCBzZWVUaHJ1UHJlZHMsIGFkZEVPRik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvb2suYWRkT25lKExMMUFuYWx5emVyLkhJVF9QUkVEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCB0LmlzRXBzaWxvbikge1xuICAgICAgICAgICAgdGhpcy5fTE9PSyh0LnRhcmdldCwgc3RvcFN0YXRlLCBjdHgsIGxvb2ssIGxvb2tCdXN5LCBjYWxsZWRSdWxlU3RhY2ssIHNlZVRocnVQcmVkcywgYWRkRU9GKTtcbiAgICAgICAgfSBlbHNlIGlmICh0LmNvbnN0cnVjdG9yID09PSBXaWxkY2FyZFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIGxvb2suYWRkUmFuZ2UoIFRva2VuLk1JTl9VU0VSX1RPS0VOX1RZUEUsIHRoaXMuYXRuLm1heFRva2VuVHlwZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNldCA9IHQubGFiZWw7XG4gICAgICAgICAgICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBOb3RTZXRUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IHNldC5jb21wbGVtZW50KFRva2VuLk1JTl9VU0VSX1RPS0VOX1RZUEUsIHRoaXMuYXRuLm1heFRva2VuVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvb2suYWRkU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnRzLkxMMUFuYWx5emVyID0gTEwxQW5hbHl6ZXI7XG5cbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG4vLyBBIGxleGVyIGlzIHJlY29nbml6ZXIgdGhhdCBkcmF3cyBpbnB1dCBzeW1ib2xzIGZyb20gYSBjaGFyYWN0ZXIgc3RyZWFtLlxuLy8gIGxleGVyIGdyYW1tYXJzIHJlc3VsdCBpbiBhIHN1YmNsYXNzIG9mIHRoaXMgb2JqZWN0LiBBIExleGVyIG9iamVjdFxuLy8gIHVzZXMgc2ltcGxpZmllZCBtYXRjaCgpIGFuZCBlcnJvciByZWNvdmVyeSBtZWNoYW5pc21zIGluIHRoZSBpbnRlcmVzdCBvZiBzcGVlZC5cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLlRva2VuO1xudmFyIFJlY29nbml6ZXIgPSByZXF1aXJlKCcuL1JlY29nbml6ZXInKS5SZWNvZ25pemVyO1xudmFyIENvbW1vblRva2VuRmFjdG9yeSA9IHJlcXVpcmUoJy4vQ29tbW9uVG9rZW5GYWN0b3J5JykuQ29tbW9uVG9rZW5GYWN0b3J5O1xudmFyIFJlY29nbml0aW9uRXhjZXB0aW9uICA9IHJlcXVpcmUoJy4vZXJyb3IvRXJyb3JzJykuUmVjb2duaXRpb25FeGNlcHRpb247XG52YXIgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vZXJyb3IvRXJyb3JzJykuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcblxuZnVuY3Rpb24gVG9rZW5Tb3VyY2UoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBMZXhlcihpbnB1dCkge1xuXHRSZWNvZ25pemVyLmNhbGwodGhpcyk7XG5cdHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cdHRoaXMuX2ZhY3RvcnkgPSBDb21tb25Ub2tlbkZhY3RvcnkuREVGQVVMVDtcblx0dGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciA9IFsgdGhpcywgaW5wdXQgXTtcblxuXHR0aGlzLl9pbnRlcnAgPSBudWxsOyAvLyBjaGlsZCBjbGFzc2VzIG11c3QgcG9wdWxhdGUgdGhpc1xuXG5cdC8vIFRoZSBnb2FsIG9mIGFsbCBsZXhlciBydWxlcy9tZXRob2RzIGlzIHRvIGNyZWF0ZSBhIHRva2VuIG9iamVjdC5cblx0Ly8gdGhpcyBpcyBhbiBpbnN0YW5jZSB2YXJpYWJsZSBhcyBtdWx0aXBsZSBydWxlcyBtYXkgY29sbGFib3JhdGUgdG9cblx0Ly8gY3JlYXRlIGEgc2luZ2xlIHRva2VuLiBuZXh0VG9rZW4gd2lsbCByZXR1cm4gdGhpcyBvYmplY3QgYWZ0ZXJcblx0Ly8gbWF0Y2hpbmcgbGV4ZXIgcnVsZShzKS4gSWYgeW91IHN1YmNsYXNzIHRvIGFsbG93IG11bHRpcGxlIHRva2VuXG5cdC8vIGVtaXNzaW9ucywgdGhlbiBzZXQgdGhpcyB0byB0aGUgbGFzdCB0b2tlbiB0byBiZSBtYXRjaGVkIG9yXG5cdC8vIHNvbWV0aGluZyBub25udWxsIHNvIHRoYXQgdGhlIGF1dG8gdG9rZW4gZW1pdCBtZWNoYW5pc20gd2lsbCBub3Rcblx0Ly8gZW1pdCBhbm90aGVyIHRva2VuLlxuXHR0aGlzLl90b2tlbiA9IG51bGw7XG5cblx0Ly8gV2hhdCBjaGFyYWN0ZXIgaW5kZXggaW4gdGhlIHN0cmVhbSBkaWQgdGhlIGN1cnJlbnQgdG9rZW4gc3RhcnQgYXQ/XG5cdC8vIE5lZWRlZCwgZm9yIGV4YW1wbGUsIHRvIGdldCB0aGUgdGV4dCBmb3IgY3VycmVudCB0b2tlbi4gU2V0IGF0XG5cdC8vIHRoZSBzdGFydCBvZiBuZXh0VG9rZW4uXG5cdHRoaXMuX3Rva2VuU3RhcnRDaGFySW5kZXggPSAtMTtcblxuXHQvLyBUaGUgbGluZSBvbiB3aGljaCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB0b2tlbiByZXNpZGVzLy8vXG5cdHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gLTE7XG5cblx0Ly8gVGhlIGNoYXJhY3RlciBwb3NpdGlvbiBvZiBmaXJzdCBjaGFyYWN0ZXIgd2l0aGluIHRoZSBsaW5lLy8vXG5cdHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4gPSAtMTtcblxuXHQvLyBPbmNlIHdlIHNlZSBFT0Ygb24gY2hhciBzdHJlYW0sIG5leHQgdG9rZW4gd2lsbCBiZSBFT0YuXG5cdC8vIElmIHlvdSBoYXZlIERPTkUgOiBFT0YgOyB0aGVuIHlvdSBzZWUgRE9ORSBFT0YuXG5cdHRoaXMuX2hpdEVPRiA9IGZhbHNlO1xuXG5cdC8vIFRoZSBjaGFubmVsIG51bWJlciBmb3IgdGhlIGN1cnJlbnQgdG9rZW4vLy9cblx0dGhpcy5fY2hhbm5lbCA9IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcblxuXHQvLyBUaGUgdG9rZW4gdHlwZSBmb3IgdGhlIGN1cnJlbnQgdG9rZW4vLy9cblx0dGhpcy5fdHlwZSA9IFRva2VuLklOVkFMSURfVFlQRTtcblxuXHR0aGlzLl9tb2RlU3RhY2sgPSBbXTtcblx0dGhpcy5fbW9kZSA9IExleGVyLkRFRkFVTFRfTU9ERTtcblxuXHQvLyBZb3UgY2FuIHNldCB0aGUgdGV4dCBmb3IgdGhlIGN1cnJlbnQgdG9rZW4gdG8gb3ZlcnJpZGUgd2hhdCBpcyBpblxuXHQvLyB0aGUgaW5wdXQgY2hhciBidWZmZXIuIFVzZSBzZXRUZXh0KCkgb3IgY2FuIHNldCB0aGlzIGluc3RhbmNlIHZhci5cblx0Ly8gL1xuXHR0aGlzLl90ZXh0ID0gbnVsbDtcblxuXHRyZXR1cm4gdGhpcztcbn1cblxuTGV4ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvZ25pemVyLnByb3RvdHlwZSk7XG5MZXhlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlcjtcblxuTGV4ZXIuREVGQVVMVF9NT0RFID0gMDtcbkxleGVyLk1PUkUgPSAtMjtcbkxleGVyLlNLSVAgPSAtMztcblxuTGV4ZXIuREVGQVVMVF9UT0tFTl9DSEFOTkVMID0gVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuTGV4ZXIuSElEREVOID0gVG9rZW4uSElEREVOX0NIQU5ORUw7XG5MZXhlci5NSU5fQ0hBUl9WQUxVRSA9IDB4MDAwMDtcbkxleGVyLk1BWF9DSEFSX1ZBTFVFID0gMHgxMEZGRkY7XG5cbkxleGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQvLyB3YWNrIExleGVyIHN0YXRlIHZhcmlhYmxlc1xuXHRpZiAodGhpcy5faW5wdXQgIT09IG51bGwpIHtcblx0XHR0aGlzLl9pbnB1dC5zZWVrKDApOyAvLyByZXdpbmQgdGhlIGlucHV0XG5cdH1cblx0dGhpcy5fdG9rZW4gPSBudWxsO1xuXHR0aGlzLl90eXBlID0gVG9rZW4uSU5WQUxJRF9UWVBFO1xuXHR0aGlzLl9jaGFubmVsID0gVG9rZW4uREVGQVVMVF9DSEFOTkVMO1xuXHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4ID0gLTE7XG5cdHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4gPSAtMTtcblx0dGhpcy5fdG9rZW5TdGFydExpbmUgPSAtMTtcblx0dGhpcy5fdGV4dCA9IG51bGw7XG5cblx0dGhpcy5faGl0RU9GID0gZmFsc2U7XG5cdHRoaXMuX21vZGUgPSBMZXhlci5ERUZBVUxUX01PREU7XG5cdHRoaXMuX21vZGVTdGFjayA9IFtdO1xuXG5cdHRoaXMuX2ludGVycC5yZXNldCgpO1xufTtcblxuLy8gUmV0dXJuIGEgdG9rZW4gZnJvbSB0aGlzIHNvdXJjZTsgaS5lLiwgbWF0Y2ggYSB0b2tlbiBvbiB0aGUgY2hhciBzdHJlYW0uXG5MZXhlci5wcm90b3R5cGUubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9pbnB1dCA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwibmV4dFRva2VuIHJlcXVpcmVzIGEgbm9uLW51bGwgaW5wdXQgc3RyZWFtLlwiO1xuXHR9XG5cblx0Ly8gTWFyayBzdGFydCBsb2NhdGlvbiBpbiBjaGFyIHN0cmVhbSBzbyB1bmJ1ZmZlcmVkIHN0cmVhbXMgYXJlXG5cdC8vIGd1YXJhbnRlZWQgYXQgbGVhc3QgaGF2ZSB0ZXh0IG9mIGN1cnJlbnQgdG9rZW5cblx0dmFyIHRva2VuU3RhcnRNYXJrZXIgPSB0aGlzLl9pbnB1dC5tYXJrKCk7XG5cdHRyeSB7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmICh0aGlzLl9oaXRFT0YpIHtcblx0XHRcdFx0dGhpcy5lbWl0RU9GKCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90b2tlbjtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3Rva2VuID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5uZWwgPSBUb2tlbi5ERUZBVUxUX0NIQU5ORUw7XG5cdFx0XHR0aGlzLl90b2tlblN0YXJ0Q2hhckluZGV4ID0gdGhpcy5faW5wdXQuaW5kZXg7XG5cdFx0XHR0aGlzLl90b2tlblN0YXJ0Q29sdW1uID0gdGhpcy5faW50ZXJwLmNvbHVtbjtcblx0XHRcdHRoaXMuX3Rva2VuU3RhcnRMaW5lID0gdGhpcy5faW50ZXJwLmxpbmU7XG5cdFx0XHR0aGlzLl90ZXh0ID0gbnVsbDtcblx0XHRcdHZhciBjb250aW51ZU91dGVyID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHR0aGlzLl90eXBlID0gVG9rZW4uSU5WQUxJRF9UWVBFO1xuXHRcdFx0XHR2YXIgdHR5cGUgPSBMZXhlci5TS0lQO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHR0eXBlID0gdGhpcy5faW50ZXJwLm1hdGNoKHRoaXMuX2lucHV0LCB0aGlzLl9tb2RlKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQgICAgaWYoZSBpbnN0YW5jZW9mIFJlY29nbml0aW9uRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhlKTsgLy8gcmVwb3J0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXIoZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5faW5wdXQuTEEoMSkgPT09IFRva2VuLkVPRikge1xuXHRcdFx0XHRcdHRoaXMuX2hpdEVPRiA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09IFRva2VuLklOVkFMSURfVFlQRSkge1xuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0dHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gTGV4ZXIuU0tJUCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlT3V0ZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSBMZXhlci5NT1JFKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjb250aW51ZU91dGVyKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX3Rva2VuID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMuZW1pdCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3Rva2VuO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHQvLyBtYWtlIHN1cmUgd2UgcmVsZWFzZSBtYXJrZXIgYWZ0ZXIgbWF0Y2ggb3Jcblx0XHQvLyB1bmJ1ZmZlcmVkIGNoYXIgc3RyZWFtIHdpbGwga2VlcCBidWZmZXJpbmdcblx0XHR0aGlzLl9pbnB1dC5yZWxlYXNlKHRva2VuU3RhcnRNYXJrZXIpO1xuXHR9XG59O1xuXG4vLyBJbnN0cnVjdCB0aGUgbGV4ZXIgdG8gc2tpcCBjcmVhdGluZyBhIHRva2VuIGZvciBjdXJyZW50IGxleGVyIHJ1bGVcbi8vIGFuZCBsb29rIGZvciBhbm90aGVyIHRva2VuLiBuZXh0VG9rZW4oKSBrbm93cyB0byBrZWVwIGxvb2tpbmcgd2hlblxuLy8gYSBsZXhlciBydWxlIGZpbmlzaGVzIHdpdGggdG9rZW4gc2V0IHRvIFNLSVBfVE9LRU4uIFJlY2FsbCB0aGF0XG4vLyBpZiB0b2tlbj09bnVsbCBhdCBlbmQgb2YgYW55IHRva2VuIHJ1bGUsIGl0IGNyZWF0ZXMgb25lIGZvciB5b3Vcbi8vIGFuZCBlbWl0cyBpdC5cbi8vIC9cbkxleGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3R5cGUgPSBMZXhlci5TS0lQO1xufTtcblxuTGV4ZXIucHJvdG90eXBlLm1vcmUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fdHlwZSA9IExleGVyLk1PUkU7XG59O1xuXG5MZXhlci5wcm90b3R5cGUubW9kZSA9IGZ1bmN0aW9uKG0pIHtcblx0dGhpcy5fbW9kZSA9IG07XG59O1xuXG5MZXhlci5wcm90b3R5cGUucHVzaE1vZGUgPSBmdW5jdGlvbihtKSB7XG5cdGlmICh0aGlzLl9pbnRlcnAuZGVidWcpIHtcblx0XHRjb25zb2xlLmxvZyhcInB1c2hNb2RlIFwiICsgbSk7XG5cdH1cblx0dGhpcy5fbW9kZVN0YWNrLnB1c2godGhpcy5fbW9kZSk7XG5cdHRoaXMubW9kZShtKTtcbn07XG5cbkxleGVyLnByb3RvdHlwZS5wb3BNb2RlID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9tb2RlU3RhY2subGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgXCJFbXB0eSBTdGFja1wiO1xuXHR9XG5cdGlmICh0aGlzLl9pbnRlcnAuZGVidWcpIHtcblx0XHRjb25zb2xlLmxvZyhcInBvcE1vZGUgYmFjayB0byBcIiArIHRoaXMuX21vZGVTdGFjay5zbGljZSgwLCAtMSkpO1xuXHR9XG5cdHRoaXMubW9kZSh0aGlzLl9tb2RlU3RhY2sucG9wKCkpO1xuXHRyZXR1cm4gdGhpcy5fbW9kZTtcbn07XG5cbi8vIFNldCB0aGUgY2hhciBzdHJlYW0gYW5kIHJlc2V0IHRoZSBsZXhlclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnB1dDtcblx0fSxcblx0c2V0IDogZnVuY3Rpb24oaW5wdXQpIHtcblx0XHR0aGlzLl9pbnB1dCA9IG51bGw7XG5cdFx0dGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciA9IFsgdGhpcywgdGhpcy5faW5wdXQgXTtcblx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcblx0XHR0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyID0gWyB0aGlzLCB0aGlzLl9pbnB1dCBdO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExleGVyLnByb3RvdHlwZSwgXCJzb3VyY2VOYW1lXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24gc291cmNlTmFtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5wdXQuc291cmNlTmFtZTtcblx0fVxufSk7XG5cbi8vIEJ5IGRlZmF1bHQgZG9lcyBub3Qgc3VwcG9ydCBtdWx0aXBsZSBlbWl0cyBwZXIgbmV4dFRva2VuIGludm9jYXRpb25cbi8vIGZvciBlZmZpY2llbmN5IHJlYXNvbnMuIFN1YmNsYXNzIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZCwgbmV4dFRva2VuLFxuLy8gYW5kIGdldFRva2VuICh0byBwdXNoIHRva2VucyBpbnRvIGEgbGlzdCBhbmQgcHVsbCBmcm9tIHRoYXQgbGlzdFxuLy8gcmF0aGVyIHRoYW4gYSBzaW5nbGUgdmFyaWFibGUgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzKS5cbi8vIC9cbkxleGVyLnByb3RvdHlwZS5lbWl0VG9rZW4gPSBmdW5jdGlvbih0b2tlbikge1xuXHR0aGlzLl90b2tlbiA9IHRva2VuO1xufTtcblxuLy8gVGhlIHN0YW5kYXJkIG1ldGhvZCBjYWxsZWQgdG8gYXV0b21hdGljYWxseSBlbWl0IGEgdG9rZW4gYXQgdGhlXG4vLyBvdXRlcm1vc3QgbGV4aWNhbCBydWxlLiBUaGUgdG9rZW4gb2JqZWN0IHNob3VsZCBwb2ludCBpbnRvIHRoZVxuLy8gY2hhciBidWZmZXIgc3RhcnQuLnN0b3AuIElmIHRoZXJlIGlzIGEgdGV4dCBvdmVycmlkZSBpbiAndGV4dCcsXG4vLyB1c2UgdGhhdCB0byBzZXQgdGhlIHRva2VuJ3MgdGV4dC4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZW1pdFxuLy8gY3VzdG9tIFRva2VuIG9iamVjdHMgb3IgcHJvdmlkZSBhIG5ldyBmYWN0b3J5LlxuLy8gL1xuTGV4ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcblx0dmFyIHQgPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZSh0aGlzLl90b2tlbkZhY3RvcnlTb3VyY2VQYWlyLCB0aGlzLl90eXBlLFxuXHRcdFx0dGhpcy5fdGV4dCwgdGhpcy5fY2hhbm5lbCwgdGhpcy5fdG9rZW5TdGFydENoYXJJbmRleCwgdGhpc1xuXHRcdFx0XHRcdC5nZXRDaGFySW5kZXgoKSAtIDEsIHRoaXMuX3Rva2VuU3RhcnRMaW5lLFxuXHRcdFx0dGhpcy5fdG9rZW5TdGFydENvbHVtbik7XG5cdHRoaXMuZW1pdFRva2VuKHQpO1xuXHRyZXR1cm4gdDtcbn07XG5cbkxleGVyLnByb3RvdHlwZS5lbWl0RU9GID0gZnVuY3Rpb24oKSB7XG5cdHZhciBjcG9zID0gdGhpcy5jb2x1bW47XG5cdHZhciBscG9zID0gdGhpcy5saW5lO1xuXHR2YXIgZW9mID0gdGhpcy5fZmFjdG9yeS5jcmVhdGUodGhpcy5fdG9rZW5GYWN0b3J5U291cmNlUGFpciwgVG9rZW4uRU9GLFxuXHRcdFx0bnVsbCwgVG9rZW4uREVGQVVMVF9DSEFOTkVMLCB0aGlzLl9pbnB1dC5pbmRleCxcblx0XHRcdHRoaXMuX2lucHV0LmluZGV4IC0gMSwgbHBvcywgY3Bvcyk7XG5cdHRoaXMuZW1pdFRva2VuKGVvZik7XG5cdHJldHVybiBlb2Y7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXIucHJvdG90eXBlLCBcInR5cGVcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy50eXBlO1xuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXIucHJvdG90eXBlLCBcImxpbmVcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJwLmxpbmU7XG5cdH0sXG5cdHNldCA6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHR0aGlzLl9pbnRlcnAubGluZSA9IGxpbmU7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXIucHJvdG90eXBlLCBcImNvbHVtblwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnRlcnAuY29sdW1uO1xuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbihjb2x1bW4pIHtcblx0XHR0aGlzLl9pbnRlcnAuY29sdW1uID0gY29sdW1uO1xuXHR9XG59KTtcblxuXG4vLyBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgb2YgbG9va2FoZWFkPy8vL1xuTGV4ZXIucHJvdG90eXBlLmdldENoYXJJbmRleCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5faW5wdXQuaW5kZXg7XG59O1xuXG4vLyBSZXR1cm4gdGhlIHRleHQgbWF0Y2hlZCBzbyBmYXIgZm9yIHRoZSBjdXJyZW50IHRva2VuIG9yIGFueSB0ZXh0IG92ZXJyaWRlLlxuLy9TZXQgdGhlIGNvbXBsZXRlIHRleHQgb2YgdGhpcyB0b2tlbjsgaXQgd2lwZXMgYW55IHByZXZpb3VzIGNoYW5nZXMgdG8gdGhlIHRleHQuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGV4ZXIucHJvdG90eXBlLCBcInRleHRcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fdGV4dCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RleHQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pbnRlcnAuZ2V0VGV4dCh0aGlzLl9pbnB1dCk7XG5cdFx0fVxuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dGhpcy5fdGV4dCA9IHRleHQ7XG5cdH1cbn0pO1xuLy8gUmV0dXJuIGEgbGlzdCBvZiBhbGwgVG9rZW4gb2JqZWN0cyBpbiBpbnB1dCBjaGFyIHN0cmVhbS5cbi8vIEZvcmNlcyBsb2FkIG9mIGFsbCB0b2tlbnMuIERvZXMgbm90IGluY2x1ZGUgRU9GIHRva2VuLlxuLy8gL1xuTGV4ZXIucHJvdG90eXBlLmdldEFsbFRva2VucyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdG9rZW5zID0gW107XG5cdHZhciB0ID0gdGhpcy5uZXh0VG9rZW4oKTtcblx0d2hpbGUgKHQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG5cdFx0dG9rZW5zLnB1c2godCk7XG5cdFx0dCA9IHRoaXMubmV4dFRva2VuKCk7XG5cdH1cblx0cmV0dXJuIHRva2Vucztcbn07XG5cbkxleGVyLnByb3RvdHlwZS5ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbihlKSB7XG5cdHZhciBzdGFydCA9IHRoaXMuX3Rva2VuU3RhcnRDaGFySW5kZXg7XG5cdHZhciBzdG9wID0gdGhpcy5faW5wdXQuaW5kZXg7XG5cdHZhciB0ZXh0ID0gdGhpcy5faW5wdXQuZ2V0VGV4dChzdGFydCwgc3RvcCk7XG5cdHZhciBtc2cgPSBcInRva2VuIHJlY29nbml0aW9uIGVycm9yIGF0OiAnXCIgKyB0aGlzLmdldEVycm9yRGlzcGxheSh0ZXh0KSArIFwiJ1wiO1xuXHR2YXIgbGlzdGVuZXIgPSB0aGlzLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpO1xuXHRsaXN0ZW5lci5zeW50YXhFcnJvcih0aGlzLCBudWxsLCB0aGlzLl90b2tlblN0YXJ0TGluZSxcblx0XHRcdHRoaXMuX3Rva2VuU3RhcnRDb2x1bW4sIG1zZywgZSk7XG59O1xuXG5MZXhlci5wcm90b3R5cGUuZ2V0RXJyb3JEaXNwbGF5ID0gZnVuY3Rpb24ocykge1xuXHR2YXIgZCA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcblx0XHRkLnB1c2goc1tpXSk7XG5cdH1cblx0cmV0dXJuIGQuam9pbignJyk7XG59O1xuXG5MZXhlci5wcm90b3R5cGUuZ2V0RXJyb3JEaXNwbGF5Rm9yQ2hhciA9IGZ1bmN0aW9uKGMpIHtcblx0aWYgKGMuY2hhckNvZGVBdCgwKSA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0cmV0dXJuIFwiPEVPRj5cIjtcblx0fSBlbHNlIGlmIChjID09PSAnXFxuJykge1xuXHRcdHJldHVybiBcIlxcXFxuXCI7XG5cdH0gZWxzZSBpZiAoYyA9PT0gJ1xcdCcpIHtcblx0XHRyZXR1cm4gXCJcXFxcdFwiO1xuXHR9IGVsc2UgaWYgKGMgPT09ICdcXHInKSB7XG5cdFx0cmV0dXJuIFwiXFxcXHJcIjtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gYztcblx0fVxufTtcblxuTGV4ZXIucHJvdG90eXBlLmdldENoYXJFcnJvckRpc3BsYXkgPSBmdW5jdGlvbihjKSB7XG5cdHJldHVybiBcIidcIiArIHRoaXMuZ2V0RXJyb3JEaXNwbGF5Rm9yQ2hhcihjKSArIFwiJ1wiO1xufTtcblxuLy8gTGV4ZXJzIGNhbiBub3JtYWxseSBtYXRjaCBhbnkgY2hhciBpbiBpdCdzIHZvY2FidWxhcnkgYWZ0ZXIgbWF0Y2hpbmdcbi8vIGEgdG9rZW4sIHNvIGRvIHRoZSBlYXN5IHRoaW5nIGFuZCBqdXN0IGtpbGwgYSBjaGFyYWN0ZXIgYW5kIGhvcGVcbi8vIGl0IGFsbCB3b3JrcyBvdXQuIFlvdSBjYW4gaW5zdGVhZCB1c2UgdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFja1xuLy8gdG8gZG8gc29waGlzdGljYXRlZCBlcnJvciByZWNvdmVyeSBpZiB5b3UgYXJlIGluIGEgZnJhZ21lbnQgcnVsZS5cbi8vIC9cbkxleGVyLnByb3RvdHlwZS5yZWNvdmVyID0gZnVuY3Rpb24ocmUpIHtcblx0aWYgKHRoaXMuX2lucHV0LkxBKDEpICE9PSBUb2tlbi5FT0YpIHtcblx0XHRpZiAocmUgaW5zdGFuY2VvZiBMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uKSB7XG5cdFx0XHQvLyBza2lwIGEgY2hhciBhbmQgdHJ5IGFnYWluXG5cdFx0XHR0aGlzLl9pbnRlcnAuY29uc3VtZSh0aGlzLl9pbnB1dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRPRE86IERvIHdlIGxvc2UgY2hhcmFjdGVyIG9yIGxpbmUgcG9zaXRpb24gaW5mb3JtYXRpb24/XG5cdFx0XHR0aGlzLl9pbnB1dC5jb25zdW1lKCk7XG5cdFx0fVxuXHR9XG59O1xuXG5leHBvcnRzLkxleGVyID0gTGV4ZXI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbnZhciBQYXJzZVRyZWVMaXN0ZW5lciA9IHJlcXVpcmUoJy4vdHJlZS9UcmVlJykuUGFyc2VUcmVlTGlzdGVuZXI7XG52YXIgUmVjb2duaXplciA9IHJlcXVpcmUoJy4vUmVjb2duaXplcicpLlJlY29nbml6ZXI7XG52YXIgRGVmYXVsdEVycm9yU3RyYXRlZ3kgPSByZXF1aXJlKCcuL2Vycm9yL0Vycm9yU3RyYXRlZ3knKS5EZWZhdWx0RXJyb3JTdHJhdGVneTtcbnZhciBBVE5EZXNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL2F0bi9BVE5EZXNlcmlhbGl6ZXInKS5BVE5EZXNlcmlhbGl6ZXI7XG52YXIgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IHJlcXVpcmUoJy4vYXRuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMnKS5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zO1xudmFyIFRlcm1pbmFsTm9kZSA9IHJlcXVpcmUoJy4vdHJlZS9UcmVlJykuVGVybWluYWxOb2RlO1xudmFyIEVycm9yTm9kZSA9IHJlcXVpcmUoJy4vdHJlZS9UcmVlJykuRXJyb3JOb2RlO1xuXG5mdW5jdGlvbiBUcmFjZUxpc3RlbmVyKHBhcnNlcikge1xuXHRQYXJzZVRyZWVMaXN0ZW5lci5jYWxsKHRoaXMpO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuVHJhY2VMaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcnNlVHJlZUxpc3RlbmVyLnByb3RvdHlwZSk7XG5UcmFjZUxpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYWNlTGlzdGVuZXI7XG5cblRyYWNlTGlzdGVuZXIucHJvdG90eXBlLmVudGVyRXZlcnlSdWxlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGNvbnNvbGUubG9nKFwiZW50ZXIgICBcIiArIHRoaXMucGFyc2VyLnJ1bGVOYW1lc1tjdHgucnVsZUluZGV4XSArIFwiLCBMVCgxKT1cIiArIHRoaXMucGFyc2VyLl9pbnB1dC5MVCgxKS50ZXh0KTtcbn07XG5cblRyYWNlTGlzdGVuZXIucHJvdG90eXBlLnZpc2l0VGVybWluYWwgPSBmdW5jdGlvbiggbm9kZSkge1xuXHRjb25zb2xlLmxvZyhcImNvbnN1bWUgXCIgKyBub2RlLnN5bWJvbCArIFwiIHJ1bGUgXCIgKyB0aGlzLnBhcnNlci5ydWxlTmFtZXNbdGhpcy5wYXJzZXIuX2N0eC5ydWxlSW5kZXhdKTtcbn07XG5cblRyYWNlTGlzdGVuZXIucHJvdG90eXBlLmV4aXRFdmVyeVJ1bGUgPSBmdW5jdGlvbihjdHgpIHtcblx0Y29uc29sZS5sb2coXCJleGl0ICAgIFwiICsgdGhpcy5wYXJzZXIucnVsZU5hbWVzW2N0eC5ydWxlSW5kZXhdICsgXCIsIExUKDEpPVwiICsgdGhpcy5wYXJzZXIuX2lucHV0LkxUKDEpLnRleHQpO1xufTtcblxuLy8gdGhpcyBpcyBhbGwgdGhlIHBhcnNpbmcgc3VwcG9ydCBjb2RlIGVzc2VudGlhbGx5OyBtb3N0IG9mIGl0IGlzIGVycm9yXG4vLyByZWNvdmVyeSBzdHVmZi4vL1xuZnVuY3Rpb24gUGFyc2VyKGlucHV0KSB7XG5cdFJlY29nbml6ZXIuY2FsbCh0aGlzKTtcblx0Ly8gVGhlIGlucHV0IHN0cmVhbS5cblx0dGhpcy5faW5wdXQgPSBudWxsO1xuXHQvLyBUaGUgZXJyb3IgaGFuZGxpbmcgc3RyYXRlZ3kgZm9yIHRoZSBwYXJzZXIuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgbmV3XG5cdC8vIGluc3RhbmNlIG9mIHtAbGluayBEZWZhdWx0RXJyb3JTdHJhdGVneX0uXG5cdHRoaXMuX2VyckhhbmRsZXIgPSBuZXcgRGVmYXVsdEVycm9yU3RyYXRlZ3koKTtcblx0dGhpcy5fcHJlY2VkZW5jZVN0YWNrID0gW107XG5cdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKDApO1xuXHQvLyBUaGUge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0fSBvYmplY3QgZm9yIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJ1bGUuXG5cdC8vIHRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIGR1cmluZyB0aGUgcGFyc2luZyBwcm9jZXNzLlxuXHR0aGlzLl9jdHggPSBudWxsO1xuXHQvLyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhlIHBhcnNlciBzaG91bGQgY29uc3RydWN0IGEgcGFyc2UgdHJlZSBkdXJpbmdcblx0Ly8gdGhlIHBhcnNpbmcgcHJvY2Vzcy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMge0Bjb2RlIHRydWV9LlxuXHR0aGlzLmJ1aWxkUGFyc2VUcmVlcyA9IHRydWU7XG5cdC8vIFdoZW4ge0BsaW5rIC8vc2V0VHJhY2V9e0Bjb2RlICh0cnVlKX0gaXMgY2FsbGVkLCBhIHJlZmVyZW5jZSB0byB0aGVcblx0Ly8ge0BsaW5rIFRyYWNlTGlzdGVuZXJ9IGlzIHN0b3JlZCBoZXJlIHNvIGl0IGNhbiBiZSBlYXNpbHkgcmVtb3ZlZCBpbiBhXG5cdC8vIGxhdGVyIGNhbGwgdG8ge0BsaW5rIC8vc2V0VHJhY2V9e0Bjb2RlIChmYWxzZSl9LiBUaGUgbGlzdGVuZXIgaXRzZWxmIGlzXG5cdC8vIGltcGxlbWVudGVkIGFzIGEgcGFyc2VyIGxpc3RlbmVyIHNvIHRoaXMgZmllbGQgaXMgbm90IGRpcmVjdGx5IHVzZWQgYnlcblx0Ly8gb3RoZXIgcGFyc2VyIG1ldGhvZHMuXG5cdHRoaXMuX3RyYWNlciA9IG51bGw7XG5cdC8vIFRoZSBsaXN0IG9mIHtAbGluayBQYXJzZVRyZWVMaXN0ZW5lcn0gbGlzdGVuZXJzIHJlZ2lzdGVyZWQgdG8gcmVjZWl2ZVxuXHQvLyBldmVudHMgZHVyaW5nIHRoZSBwYXJzZS5cblx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMgPSBudWxsO1xuXHQvLyBUaGUgbnVtYmVyIG9mIHN5bnRheCBlcnJvcnMgcmVwb3J0ZWQgZHVyaW5nIHBhcnNpbmcuIHRoaXMgdmFsdWUgaXNcblx0Ly8gaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHtAbGluayAvL25vdGlmeUVycm9yTGlzdGVuZXJzfSBpcyBjYWxsZWQuXG5cdHRoaXMuX3N5bnRheEVycm9ycyA9IDA7XG5cdHRoaXMuc2V0SW5wdXRTdHJlYW0oaW5wdXQpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXplci5wcm90b3R5cGUpO1xuUGFyc2VyLnByb3RvdHlwZS5jb250cnVjdG9yID0gUGFyc2VyO1xuXG4vLyB0aGlzIGZpZWxkIG1hcHMgZnJvbSB0aGUgc2VyaWFsaXplZCBBVE4gc3RyaW5nIHRvIHRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rXG4vLyBBVE59IHdpdGhcbi8vIGJ5cGFzcyBhbHRlcm5hdGl2ZXMuXG4vL1xuLy8gQHNlZSBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLy9pc0dlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zKClcbi8vXG5QYXJzZXIuYnlwYXNzQWx0c0F0bkNhY2hlID0ge307XG5cbi8vIHJlc2V0IHRoZSBwYXJzZXIncyBzdGF0ZS8vXG5QYXJzZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9pbnB1dCAhPT0gbnVsbCkge1xuXHRcdHRoaXMuX2lucHV0LnNlZWsoMCk7XG5cdH1cblx0dGhpcy5fZXJySGFuZGxlci5yZXNldCh0aGlzKTtcblx0dGhpcy5fY3R4ID0gbnVsbDtcblx0dGhpcy5fc3ludGF4RXJyb3JzID0gMDtcblx0dGhpcy5zZXRUcmFjZShmYWxzZSk7XG5cdHRoaXMuX3ByZWNlZGVuY2VTdGFjayA9IFtdO1xuXHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucHVzaCgwKTtcblx0aWYgKHRoaXMuX2ludGVycCAhPT0gbnVsbCkge1xuXHRcdHRoaXMuX2ludGVycC5yZXNldCgpO1xuXHR9XG59O1xuXG4vLyBNYXRjaCBjdXJyZW50IGlucHV0IHN5bWJvbCBhZ2FpbnN0IHtAY29kZSB0dHlwZX0uIElmIHRoZSBzeW1ib2wgdHlwZVxuLy8gbWF0Y2hlcywge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneS8vcmVwb3J0TWF0Y2h9IGFuZCB7QGxpbmsgLy9jb25zdW1lfSBhcmVcbi8vIGNhbGxlZCB0byBjb21wbGV0ZSB0aGUgbWF0Y2ggcHJvY2Vzcy5cbi8vXG4vLyA8cD5JZiB0aGUgc3ltYm9sIHR5cGUgZG9lcyBub3QgbWF0Y2gsXG4vLyB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5Ly9yZWNvdmVySW5saW5lfSBpcyBjYWxsZWQgb24gdGhlIGN1cnJlbnQgZXJyb3Jcbi8vIHN0cmF0ZWd5IHRvIGF0dGVtcHQgcmVjb3ZlcnkuIElmIHtAbGluayAvL2dldEJ1aWxkUGFyc2VUcmVlfSBpc1xuLy8ge0Bjb2RlIHRydWV9IGFuZCB0aGUgdG9rZW4gaW5kZXggb2YgdGhlIHN5bWJvbCByZXR1cm5lZCBieVxuLy8ge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneS8vcmVjb3ZlcklubGluZX0gaXMgLTEsIHRoZSBzeW1ib2wgaXMgYWRkZWQgdG9cbi8vIHRoZSBwYXJzZSB0cmVlIGJ5IGNhbGxpbmcge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0Ly9hZGRFcnJvck5vZGV9LjwvcD5cbi8vXG4vLyBAcGFyYW0gdHR5cGUgdGhlIHRva2VuIHR5cGUgdG8gbWF0Y2hcbi8vIEByZXR1cm4gdGhlIG1hdGNoZWQgc3ltYm9sXG4vLyBAdGhyb3dzIFJlY29nbml0aW9uRXhjZXB0aW9uIGlmIHRoZSBjdXJyZW50IGlucHV0IHN5bWJvbCBkaWQgbm90IG1hdGNoXG4vLyB7QGNvZGUgdHR5cGV9IGFuZCB0aGUgZXJyb3Igc3RyYXRlZ3kgY291bGQgbm90IHJlY292ZXIgZnJvbSB0aGVcbi8vIG1pc21hdGNoZWQgc3ltYm9sXG5cblBhcnNlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbih0dHlwZSkge1xuXHR2YXIgdCA9IHRoaXMuZ2V0Q3VycmVudFRva2VuKCk7XG5cdGlmICh0LnR5cGUgPT09IHR0eXBlKSB7XG5cdFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcblx0XHR0aGlzLmNvbnN1bWUoKTtcblx0fSBlbHNlIHtcblx0XHR0ID0gdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xuXHRcdGlmICh0aGlzLmJ1aWxkUGFyc2VUcmVlcyAmJiB0LnRva2VuSW5kZXggPT09IC0xKSB7XG5cdFx0XHQvLyB3ZSBtdXN0IGhhdmUgY29uanVyZWQgdXAgYSBuZXcgdG9rZW4gZHVyaW5nIHNpbmdsZSB0b2tlblxuXHRcdFx0Ly8gaW5zZXJ0aW9uXG5cdFx0XHQvLyBpZiBpdCdzIG5vdCB0aGUgY3VycmVudCBzeW1ib2xcblx0XHRcdHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0O1xufTtcbi8vIE1hdGNoIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGFzIGEgd2lsZGNhcmQuIElmIHRoZSBzeW1ib2wgdHlwZSBtYXRjaGVzXG4vLyAoaS5lLiBoYXMgYSB2YWx1ZSBncmVhdGVyIHRoYW4gMCksIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kvL3JlcG9ydE1hdGNofVxuLy8gYW5kIHtAbGluayAvL2NvbnN1bWV9IGFyZSBjYWxsZWQgdG8gY29tcGxldGUgdGhlIG1hdGNoIHByb2Nlc3MuXG4vL1xuLy8gPHA+SWYgdGhlIHN5bWJvbCB0eXBlIGRvZXMgbm90IG1hdGNoLFxuLy8ge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneS8vcmVjb3ZlcklubGluZX0gaXMgY2FsbGVkIG9uIHRoZSBjdXJyZW50IGVycm9yXG4vLyBzdHJhdGVneSB0byBhdHRlbXB0IHJlY292ZXJ5LiBJZiB7QGxpbmsgLy9nZXRCdWlsZFBhcnNlVHJlZX0gaXNcbi8vIHtAY29kZSB0cnVlfSBhbmQgdGhlIHRva2VuIGluZGV4IG9mIHRoZSBzeW1ib2wgcmV0dXJuZWQgYnlcbi8vIHtAbGluayBBTlRMUkVycm9yU3RyYXRlZ3kvL3JlY292ZXJJbmxpbmV9IGlzIC0xLCB0aGUgc3ltYm9sIGlzIGFkZGVkIHRvXG4vLyB0aGUgcGFyc2UgdHJlZSBieSBjYWxsaW5nIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dC8vYWRkRXJyb3JOb2RlfS48L3A+XG4vL1xuLy8gQHJldHVybiB0aGUgbWF0Y2hlZCBzeW1ib2xcbi8vIEB0aHJvd3MgUmVjb2duaXRpb25FeGNlcHRpb24gaWYgdGhlIGN1cnJlbnQgaW5wdXQgc3ltYm9sIGRpZCBub3QgbWF0Y2hcbi8vIGEgd2lsZGNhcmQgYW5kIHRoZSBlcnJvciBzdHJhdGVneSBjb3VsZCBub3QgcmVjb3ZlciBmcm9tIHRoZSBtaXNtYXRjaGVkXG4vLyBzeW1ib2xcblxuUGFyc2VyLnByb3RvdHlwZS5tYXRjaFdpbGRjYXJkID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0ID0gdGhpcy5nZXRDdXJyZW50VG9rZW4oKTtcblx0aWYgKHQudHlwZSA+IDApIHtcblx0XHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xuXHRcdHRoaXMuY29uc3VtZSgpO1xuXHR9IGVsc2Uge1xuXHRcdHQgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XG5cdFx0aWYgKHRoaXMuX2J1aWxkUGFyc2VUcmVlcyAmJiB0LnRva2VuSW5kZXggPT09IC0xKSB7XG5cdFx0XHQvLyB3ZSBtdXN0IGhhdmUgY29uanVyZWQgdXAgYSBuZXcgdG9rZW4gZHVyaW5nIHNpbmdsZSB0b2tlblxuXHRcdFx0Ly8gaW5zZXJ0aW9uXG5cdFx0XHQvLyBpZiBpdCdzIG5vdCB0aGUgY3VycmVudCBzeW1ib2xcblx0XHRcdHRoaXMuX2N0eC5hZGRFcnJvck5vZGUodCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5nZXRQYXJzZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5fcGFyc2VMaXN0ZW5lcnMgfHwgW107XG59O1xuXG4vLyBSZWdpc3RlcnMge0Bjb2RlIGxpc3RlbmVyfSB0byByZWNlaXZlIGV2ZW50cyBkdXJpbmcgdGhlIHBhcnNpbmcgcHJvY2Vzcy5cbi8vXG4vLyA8cD5UbyBzdXBwb3J0IG91dHB1dC1wcmVzZXJ2aW5nIGdyYW1tYXIgdHJhbnNmb3JtYXRpb25zIChpbmNsdWRpbmcgYnV0IG5vdFxuLy8gbGltaXRlZCB0byBsZWZ0LXJlY3Vyc2lvbiByZW1vdmFsLCBhdXRvbWF0ZWQgbGVmdC1mYWN0b3JpbmcsIGFuZFxuLy8gb3B0aW1pemVkIGNvZGUgZ2VuZXJhdGlvbiksIGNhbGxzIHRvIGxpc3RlbmVyIG1ldGhvZHMgZHVyaW5nIHRoZSBwYXJzZVxuLy8gbWF5IGRpZmZlciBzdWJzdGFudGlhbGx5IGZyb20gY2FsbHMgbWFkZSBieVxuLy8ge0BsaW5rIFBhcnNlVHJlZVdhbGtlci8vREVGQVVMVH0gdXNlZCBhZnRlciB0aGUgcGFyc2UgaXMgY29tcGxldGUuIEluXG4vLyBwYXJ0aWN1bGFyLCBydWxlIGVudHJ5IGFuZCBleGl0IGV2ZW50cyBtYXkgb2NjdXIgaW4gYSBkaWZmZXJlbnQgb3JkZXJcbi8vIGR1cmluZyB0aGUgcGFyc2UgdGhhbiBhZnRlciB0aGUgcGFyc2VyLiBJbiBhZGRpdGlvbiwgY2FsbHMgdG8gY2VydGFpblxuLy8gcnVsZSBlbnRyeSBtZXRob2RzIG1heSBiZSBvbWl0dGVkLjwvcD5cbi8vXG4vLyA8cD5XaXRoIHRoZSBmb2xsb3dpbmcgc3BlY2lmaWMgZXhjZXB0aW9ucywgY2FsbHMgdG8gbGlzdGVuZXIgZXZlbnRzIGFyZVxuLy8gPGVtPmRldGVybWluaXN0aWM8L2VtPiwgaS5lLiBmb3IgaWRlbnRpY2FsIGlucHV0IHRoZSBjYWxscyB0byBsaXN0ZW5lclxuLy8gbWV0aG9kcyB3aWxsIGJlIHRoZSBzYW1lLjwvcD5cbi8vXG4vLyA8dWw+XG4vLyA8bGk+QWx0ZXJhdGlvbnMgdG8gdGhlIGdyYW1tYXIgdXNlZCB0byBnZW5lcmF0ZSBjb2RlIG1heSBjaGFuZ2UgdGhlXG4vLyBiZWhhdmlvciBvZiB0aGUgbGlzdGVuZXIgY2FsbHMuPC9saT5cbi8vIDxsaT5BbHRlcmF0aW9ucyB0byB0aGUgY29tbWFuZCBsaW5lIG9wdGlvbnMgcGFzc2VkIHRvIEFOVExSIDQgd2hlblxuLy8gZ2VuZXJhdGluZyB0aGUgcGFyc2VyIG1heSBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSBsaXN0ZW5lciBjYWxscy48L2xpPlxuLy8gPGxpPkNoYW5naW5nIHRoZSB2ZXJzaW9uIG9mIHRoZSBBTlRMUiBUb29sIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHBhcnNlclxuLy8gbWF5IGNoYW5nZSB0aGUgYmVoYXZpb3Igb2YgdGhlIGxpc3RlbmVyIGNhbGxzLjwvbGk+XG4vLyA8L3VsPlxuLy9cbi8vIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYWRkXG4vL1xuLy8gQHRocm93cyBOdWxsUG9pbnRlckV4Y2VwdGlvbiBpZiB7QGNvZGV9IGxpc3RlbmVyIGlzIHtAY29kZSBudWxsfVxuLy9cblBhcnNlci5wcm90b3R5cGUuYWRkUGFyc2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdGlmIChsaXN0ZW5lciA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwibGlzdGVuZXJcIjtcblx0fVxuXHRpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgPT09IG51bGwpIHtcblx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycyA9IFtdO1xuXHR9XG5cdHRoaXMuX3BhcnNlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xufTtcblxuLy9cbi8vIFJlbW92ZSB7QGNvZGUgbGlzdGVuZXJ9IGZyb20gdGhlIGxpc3Qgb2YgcGFyc2UgbGlzdGVuZXJzLlxuLy9cbi8vIDxwPklmIHtAY29kZSBsaXN0ZW5lcn0gaXMge0Bjb2RlIG51bGx9IG9yIGhhcyBub3QgYmVlbiBhZGRlZCBhcyBhIHBhcnNlXG4vLyBsaXN0ZW5lciwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLjwvcD5cbi8vIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4vL1xuUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVQYXJzZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX3BhcnNlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuX3BhcnNlTGlzdGVuZXJzID0gbnVsbDtcblx0XHR9XG5cdH1cbn07XG5cbi8vIFJlbW92ZSBhbGwgcGFyc2UgbGlzdGVuZXJzLlxuUGFyc2VyLnByb3RvdHlwZS5yZW1vdmVQYXJzZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9wYXJzZUxpc3RlbmVycyA9IG51bGw7XG59O1xuXG4vLyBOb3RpZnkgYW55IHBhcnNlIGxpc3RlbmVycyBvZiBhbiBlbnRlciBydWxlIGV2ZW50LlxuUGFyc2VyLnByb3RvdHlwZS50cmlnZ2VyRW50ZXJSdWxlRXZlbnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuX3BhcnNlTGlzdGVuZXJzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0XHRsaXN0ZW5lci5lbnRlckV2ZXJ5UnVsZShjdHgpO1xuXHRcdFx0Y3R4LmVudGVyUnVsZShsaXN0ZW5lcik7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vXG4vLyBOb3RpZnkgYW55IHBhcnNlIGxpc3RlbmVycyBvZiBhbiBleGl0IHJ1bGUgZXZlbnQuXG4vL1xuLy8gQHNlZSAvL2FkZFBhcnNlTGlzdGVuZXJcbi8vXG5QYXJzZXIucHJvdG90eXBlLnRyaWdnZXJFeGl0UnVsZUV2ZW50ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdC8vIHJldmVyc2Ugb3JkZXIgd2FsayBvZiBsaXN0ZW5lcnNcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblx0XHR0aGlzLl9wYXJzZUxpc3RlbmVycy5zbGljZSgwKS5yZXZlcnNlKCkubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0XHRjdHguZXhpdFJ1bGUobGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXIuZXhpdEV2ZXJ5UnVsZShjdHgpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmdldFRva2VuRmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5faW5wdXQudG9rZW5Tb3VyY2UuX2ZhY3Rvcnk7XG59O1xuXG4vLyBUZWxsIG91ciB0b2tlbiBzb3VyY2UgYW5kIGVycm9yIHN0cmF0ZWd5IGFib3V0IGEgbmV3IHdheSB0byBjcmVhdGUgdG9rZW5zLi8vXG5QYXJzZXIucHJvdG90eXBlLnNldFRva2VuRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcblx0dGhpcy5faW5wdXQudG9rZW5Tb3VyY2UuX2ZhY3RvcnkgPSBmYWN0b3J5O1xufTtcblxuLy8gVGhlIEFUTiB3aXRoIGJ5cGFzcyBhbHRlcm5hdGl2ZXMgaXMgZXhwZW5zaXZlIHRvIGNyZWF0ZSBzbyB3ZSBjcmVhdGUgaXRcbi8vIGxhemlseS5cbi8vXG4vLyBAdGhyb3dzIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uIGlmIHRoZSBjdXJyZW50IHBhcnNlciBkb2VzIG5vdFxuLy8gaW1wbGVtZW50IHRoZSB7QGxpbmsgLy9nZXRTZXJpYWxpemVkQVROKCl9IG1ldGhvZC5cbi8vXG5QYXJzZXIucHJvdG90eXBlLmdldEFUTldpdGhCeXBhc3NBbHRzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzZXJpYWxpemVkQXRuID0gdGhpcy5nZXRTZXJpYWxpemVkQVROKCk7XG5cdGlmIChzZXJpYWxpemVkQXRuID09PSBudWxsKSB7XG5cdFx0dGhyb3cgXCJUaGUgY3VycmVudCBwYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbiBBVE4gd2l0aCBieXBhc3MgYWx0ZXJuYXRpdmVzLlwiO1xuXHR9XG5cdHZhciByZXN1bHQgPSB0aGlzLmJ5cGFzc0FsdHNBdG5DYWNoZVtzZXJpYWxpemVkQXRuXTtcblx0aWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuXHRcdHZhciBkZXNlcmlhbGl6YXRpb25PcHRpb25zID0gbmV3IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMoKTtcblx0XHRkZXNlcmlhbGl6YXRpb25PcHRpb25zLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zID0gdHJ1ZTtcblx0XHRyZXN1bHQgPSBuZXcgQVRORGVzZXJpYWxpemVyKGRlc2VyaWFsaXphdGlvbk9wdGlvbnMpXG5cdFx0XHRcdC5kZXNlcmlhbGl6ZShzZXJpYWxpemVkQXRuKTtcblx0XHR0aGlzLmJ5cGFzc0FsdHNBdG5DYWNoZVtzZXJpYWxpemVkQXRuXSA9IHJlc3VsdDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gVGhlIHByZWZlcnJlZCBtZXRob2Qgb2YgZ2V0dGluZyBhIHRyZWUgcGF0dGVybi4gRm9yIGV4YW1wbGUsIGhlcmUncyBhXG4vLyBzYW1wbGUgdXNlOlxuLy9cbi8vIDxwcmU+XG4vLyBQYXJzZVRyZWUgdCA9IHBhcnNlci5leHByKCk7XG4vLyBQYXJzZVRyZWVQYXR0ZXJuIHAgPSBwYXJzZXIuY29tcGlsZVBhcnNlVHJlZVBhdHRlcm4oXCImbHQ7SUQmZ3Q7KzBcIixcbi8vIE15UGFyc2VyLlJVTEVfZXhwcik7XG4vLyBQYXJzZVRyZWVNYXRjaCBtID0gcC5tYXRjaCh0KTtcbi8vIFN0cmluZyBpZCA9IG0uZ2V0KFwiSURcIik7XG4vLyA8L3ByZT5cblxudmFyIExleGVyID0gcmVxdWlyZSgnLi9MZXhlcicpLkxleGVyO1xuXG5QYXJzZXIucHJvdG90eXBlLmNvbXBpbGVQYXJzZVRyZWVQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgcGF0dGVyblJ1bGVJbmRleCwgbGV4ZXIpIHtcblx0bGV4ZXIgPSBsZXhlciB8fCBudWxsO1xuXHRpZiAobGV4ZXIgPT09IG51bGwpIHtcblx0XHRpZiAodGhpcy5nZXRUb2tlblN0cmVhbSgpICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgdG9rZW5Tb3VyY2UgPSB0aGlzLmdldFRva2VuU3RyZWFtKCkudG9rZW5Tb3VyY2U7XG5cdFx0XHRpZiAodG9rZW5Tb3VyY2UgaW5zdGFuY2VvZiBMZXhlcikge1xuXHRcdFx0XHRsZXhlciA9IHRva2VuU291cmNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRpZiAobGV4ZXIgPT09IG51bGwpIHtcblx0XHR0aHJvdyBcIlBhcnNlciBjYW4ndCBkaXNjb3ZlciBhIGxleGVyIHRvIHVzZVwiO1xuXHR9XG5cdHZhciBtID0gbmV3IFBhcnNlVHJlZVBhdHRlcm5NYXRjaGVyKGxleGVyLCB0aGlzKTtcblx0cmV0dXJuIG0uY29tcGlsZShwYXR0ZXJuLCBwYXR0ZXJuUnVsZUluZGV4KTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuZ2V0SW5wdXRTdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5TdHJlYW0oKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2V0SW5wdXRTdHJlYW0gPSBmdW5jdGlvbihpbnB1dCkge1xuXHR0aGlzLnNldFRva2VuU3RyZWFtKGlucHV0KTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5TdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuX2lucHV0O1xufTtcblxuLy8gU2V0IHRoZSB0b2tlbiBzdHJlYW0gYW5kIHJlc2V0IHRoZSBwYXJzZXIuLy9cblBhcnNlci5wcm90b3R5cGUuc2V0VG9rZW5TdHJlYW0gPSBmdW5jdGlvbihpbnB1dCkge1xuXHR0aGlzLl9pbnB1dCA9IG51bGw7XG5cdHRoaXMucmVzZXQoKTtcblx0dGhpcy5faW5wdXQgPSBpbnB1dDtcbn07XG5cbi8vIE1hdGNoIG5lZWRzIHRvIHJldHVybiB0aGUgY3VycmVudCBpbnB1dCBzeW1ib2wsIHdoaWNoIGdldHMgcHV0XG4vLyBpbnRvIHRoZSBsYWJlbCBmb3IgdGhlIGFzc29jaWF0ZWQgdG9rZW4gcmVmOyBlLmcuLCB4PUlELlxuLy9cblBhcnNlci5wcm90b3R5cGUuZ2V0Q3VycmVudFRva2VuID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9pbnB1dC5MVCgxKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUubm90aWZ5RXJyb3JMaXN0ZW5lcnMgPSBmdW5jdGlvbihtc2csIG9mZmVuZGluZ1Rva2VuLCBlcnIpIHtcblx0b2ZmZW5kaW5nVG9rZW4gPSBvZmZlbmRpbmdUb2tlbiB8fCBudWxsO1xuXHRlcnIgPSBlcnIgfHwgbnVsbDtcblx0aWYgKG9mZmVuZGluZ1Rva2VuID09PSBudWxsKSB7XG5cdFx0b2ZmZW5kaW5nVG9rZW4gPSB0aGlzLmdldEN1cnJlbnRUb2tlbigpO1xuXHR9XG5cdHRoaXMuX3N5bnRheEVycm9ycyArPSAxO1xuXHR2YXIgbGluZSA9IG9mZmVuZGluZ1Rva2VuLmxpbmU7XG5cdHZhciBjb2x1bW4gPSBvZmZlbmRpbmdUb2tlbi5jb2x1bW47XG5cdHZhciBsaXN0ZW5lciA9IHRoaXMuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCk7XG5cdGxpc3RlbmVyLnN5bnRheEVycm9yKHRoaXMsIG9mZmVuZGluZ1Rva2VuLCBsaW5lLCBjb2x1bW4sIG1zZywgZXJyKTtcbn07XG5cbi8vXG4vLyBDb25zdW1lIGFuZCByZXR1cm4gdGhlIHtAbGlua3BsYWluIC8vZ2V0Q3VycmVudFRva2VuIGN1cnJlbnQgc3ltYm9sfS5cbi8vXG4vLyA8cD5FLmcuLCBnaXZlbiB0aGUgZm9sbG93aW5nIGlucHV0IHdpdGgge0Bjb2RlIEF9IGJlaW5nIHRoZSBjdXJyZW50XG4vLyBsb29rYWhlYWQgc3ltYm9sLCB0aGlzIGZ1bmN0aW9uIG1vdmVzIHRoZSBjdXJzb3IgdG8ge0Bjb2RlIEJ9IGFuZCByZXR1cm5zXG4vLyB7QGNvZGUgQX0uPC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBBIEJcbi8vIF5cbi8vIDwvcHJlPlxuLy9cbi8vIElmIHRoZSBwYXJzZXIgaXMgbm90IGluIGVycm9yIHJlY292ZXJ5IG1vZGUsIHRoZSBjb25zdW1lZCBzeW1ib2wgaXMgYWRkZWRcbi8vIHRvIHRoZSBwYXJzZSB0cmVlIHVzaW5nIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dC8vYWRkQ2hpbGQoVG9rZW4pfSwgYW5kXG4vLyB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIvL3Zpc2l0VGVybWluYWx9IGlzIGNhbGxlZCBvbiBhbnkgcGFyc2UgbGlzdGVuZXJzLlxuLy8gSWYgdGhlIHBhcnNlciA8ZW0+aXM8L2VtPiBpbiBlcnJvciByZWNvdmVyeSBtb2RlLCB0aGUgY29uc3VtZWQgc3ltYm9sIGlzXG4vLyBhZGRlZCB0byB0aGUgcGFyc2UgdHJlZSB1c2luZ1xuLy8ge0BsaW5rIFBhcnNlclJ1bGVDb250ZXh0Ly9hZGRFcnJvck5vZGUoVG9rZW4pfSwgYW5kXG4vLyB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIvL3Zpc2l0RXJyb3JOb2RlfSBpcyBjYWxsZWQgb24gYW55IHBhcnNlXG4vLyBsaXN0ZW5lcnMuXG4vL1xuUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvID0gdGhpcy5nZXRDdXJyZW50VG9rZW4oKTtcblx0aWYgKG8udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG5cdFx0dGhpcy5nZXRJbnB1dFN0cmVhbSgpLmNvbnN1bWUoKTtcblx0fVxuXHR2YXIgaGFzTGlzdGVuZXIgPSB0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCAmJiB0aGlzLl9wYXJzZUxpc3RlbmVycy5sZW5ndGggPiAwO1xuXHRpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMgfHwgaGFzTGlzdGVuZXIpIHtcblx0XHR2YXIgbm9kZTtcblx0XHRpZiAodGhpcy5fZXJySGFuZGxlci5pbkVycm9yUmVjb3ZlcnlNb2RlKHRoaXMpKSB7XG5cdFx0XHRub2RlID0gdGhpcy5fY3R4LmFkZEVycm9yTm9kZShvKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZSA9IHRoaXMuX2N0eC5hZGRUb2tlbk5vZGUobyk7XG5cdFx0fVxuICAgICAgICBub2RlLmludm9raW5nU3RhdGUgPSB0aGlzLnN0YXRlO1xuXHRcdGlmIChoYXNMaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5fcGFyc2VMaXN0ZW5lcnMubWFwKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0XHRcdGlmIChub2RlIGluc3RhbmNlb2YgRXJyb3JOb2RlIHx8IChub2RlLmlzRXJyb3JOb2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZS5pc0Vycm9yTm9kZSgpKSkge1xuXHRcdFx0XHRcdGxpc3RlbmVyLnZpc2l0RXJyb3JOb2RlKG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcblx0XHRcdFx0XHRsaXN0ZW5lci52aXNpdFRlcm1pbmFsKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG87XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmFkZENvbnRleHRUb1BhcnNlVHJlZSA9IGZ1bmN0aW9uKCkge1xuXHQvLyBhZGQgY3VycmVudCBjb250ZXh0IHRvIHBhcmVudCBpZiB3ZSBoYXZlIGEgcGFyZW50XG5cdGlmICh0aGlzLl9jdHgucGFyZW50Q3R4ICE9PSBudWxsKSB7XG5cdFx0dGhpcy5fY3R4LnBhcmVudEN0eC5hZGRDaGlsZCh0aGlzLl9jdHgpO1xuXHR9XG59O1xuXG4vLyBBbHdheXMgY2FsbGVkIGJ5IGdlbmVyYXRlZCBwYXJzZXJzIHVwb24gZW50cnkgdG8gYSBydWxlLiBBY2Nlc3MgZmllbGRcbi8vIHtAbGluayAvL19jdHh9IGdldCB0aGUgY3VycmVudCBjb250ZXh0LlxuXG5QYXJzZXIucHJvdG90eXBlLmVudGVyUnVsZSA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBzdGF0ZSwgcnVsZUluZGV4KSB7XG5cdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblx0dGhpcy5fY3R4ID0gbG9jYWxjdHg7XG5cdHRoaXMuX2N0eC5zdGFydCA9IHRoaXMuX2lucHV0LkxUKDEpO1xuXHRpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMpIHtcblx0XHR0aGlzLmFkZENvbnRleHRUb1BhcnNlVHJlZSgpO1xuXHR9XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuZXhpdFJ1bGUgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XG5cdC8vIHRyaWdnZXIgZXZlbnQgb24gX2N0eCwgYmVmb3JlIGl0IHJldmVydHMgdG8gcGFyZW50XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdHRoaXMudHJpZ2dlckV4aXRSdWxlRXZlbnQoKTtcblx0fVxuXHR0aGlzLnN0YXRlID0gdGhpcy5fY3R4Lmludm9raW5nU3RhdGU7XG5cdHRoaXMuX2N0eCA9IHRoaXMuX2N0eC5wYXJlbnRDdHg7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmVudGVyT3V0ZXJBbHQgPSBmdW5jdGlvbihsb2NhbGN0eCwgYWx0TnVtKSB7XG4gICBcdGxvY2FsY3R4LnNldEFsdE51bWJlcihhbHROdW0pO1xuXHQvLyBpZiB3ZSBoYXZlIG5ldyBsb2NhbGN0eCwgbWFrZSBzdXJlIHdlIHJlcGxhY2UgZXhpc3RpbmcgY3R4XG5cdC8vIHRoYXQgaXMgcHJldmlvdXMgY2hpbGQgb2YgcGFyc2UgdHJlZVxuXHRpZiAodGhpcy5idWlsZFBhcnNlVHJlZXMgJiYgdGhpcy5fY3R4ICE9PSBsb2NhbGN0eCkge1xuXHRcdGlmICh0aGlzLl9jdHgucGFyZW50Q3R4ICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9jdHgucGFyZW50Q3R4LnJlbW92ZUxhc3RDaGlsZCgpO1xuXHRcdFx0dGhpcy5fY3R4LnBhcmVudEN0eC5hZGRDaGlsZChsb2NhbGN0eCk7XG5cdFx0fVxuXHR9XG5cdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xufTtcblxuLy8gR2V0IHRoZSBwcmVjZWRlbmNlIGxldmVsIGZvciB0aGUgdG9wLW1vc3QgcHJlY2VkZW5jZSBydWxlLlxuLy9cbi8vIEByZXR1cm4gVGhlIHByZWNlZGVuY2UgbGV2ZWwgZm9yIHRoZSB0b3AtbW9zdCBwcmVjZWRlbmNlIHJ1bGUsIG9yIC0xIGlmXG4vLyB0aGUgcGFyc2VyIGNvbnRleHQgaXMgbm90IG5lc3RlZCB3aXRoaW4gYSBwcmVjZWRlbmNlIHJ1bGUuXG5cblBhcnNlci5wcm90b3R5cGUuZ2V0UHJlY2VkZW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5fcHJlY2VkZW5jZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAtMTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJlY2VkZW5jZVN0YWNrW3RoaXMuX3ByZWNlZGVuY2VTdGFjay5sZW5ndGgtMV07XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuZW50ZXJSZWN1cnNpb25SdWxlID0gZnVuY3Rpb24obG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgsXG5cdFx0cHJlY2VkZW5jZSkge1xuXHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdHRoaXMuX3ByZWNlZGVuY2VTdGFjay5wdXNoKHByZWNlZGVuY2UpO1xuXHR0aGlzLl9jdHggPSBsb2NhbGN0eDtcblx0dGhpcy5fY3R4LnN0YXJ0ID0gdGhpcy5faW5wdXQuTFQoMSk7XG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdHRoaXMudHJpZ2dlckVudGVyUnVsZUV2ZW50KCk7IC8vIHNpbXVsYXRlcyBydWxlIGVudHJ5IGZvclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBsZWZ0LXJlY3Vyc2l2ZSBydWxlc1xuXHR9XG59O1xuXG4vL1xuLy8gTGlrZSB7QGxpbmsgLy9lbnRlclJ1bGV9IGJ1dCBmb3IgcmVjdXJzaXZlIHJ1bGVzLlxuXG5QYXJzZXIucHJvdG90eXBlLnB1c2hOZXdSZWN1cnNpb25Db250ZXh0ID0gZnVuY3Rpb24obG9jYWxjdHgsIHN0YXRlLCBydWxlSW5kZXgpIHtcblx0dmFyIHByZXZpb3VzID0gdGhpcy5fY3R4O1xuXHRwcmV2aW91cy5wYXJlbnRDdHggPSBsb2NhbGN0eDtcblx0cHJldmlvdXMuaW52b2tpbmdTdGF0ZSA9IHN0YXRlO1xuXHRwcmV2aW91cy5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xuXG5cdHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xuXHR0aGlzLl9jdHguc3RhcnQgPSBwcmV2aW91cy5zdGFydDtcblx0aWYgKHRoaXMuYnVpbGRQYXJzZVRyZWVzKSB7XG5cdFx0dGhpcy5fY3R4LmFkZENoaWxkKHByZXZpb3VzKTtcblx0fVxuXHRpZiAodGhpcy5fcGFyc2VMaXN0ZW5lcnMgIT09IG51bGwpIHtcblx0XHR0aGlzLnRyaWdnZXJFbnRlclJ1bGVFdmVudCgpOyAvLyBzaW11bGF0ZXMgcnVsZSBlbnRyeSBmb3Jcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gbGVmdC1yZWN1cnNpdmUgcnVsZXNcblx0fVxufTtcblxuUGFyc2VyLnByb3RvdHlwZS51bnJvbGxSZWN1cnNpb25Db250ZXh0cyA9IGZ1bmN0aW9uKHBhcmVudEN0eCkge1xuXHR0aGlzLl9wcmVjZWRlbmNlU3RhY2sucG9wKCk7XG5cdHRoaXMuX2N0eC5zdG9wID0gdGhpcy5faW5wdXQuTFQoLTEpO1xuXHR2YXIgcmV0Q3R4ID0gdGhpcy5fY3R4OyAvLyBzYXZlIGN1cnJlbnQgY3R4IChyZXR1cm4gdmFsdWUpXG5cdC8vIHVucm9sbCBzbyBfY3R4IGlzIGFzIGl0IHdhcyBiZWZvcmUgY2FsbCB0byByZWN1cnNpdmUgbWV0aG9kXG5cdGlmICh0aGlzLl9wYXJzZUxpc3RlbmVycyAhPT0gbnVsbCkge1xuXHRcdHdoaWxlICh0aGlzLl9jdHggIT09IHBhcmVudEN0eCkge1xuXHRcdFx0dGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xuXHRcdFx0dGhpcy5fY3R4ID0gdGhpcy5fY3R4LnBhcmVudEN0eDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5fY3R4ID0gcGFyZW50Q3R4O1xuXHR9XG5cdC8vIGhvb2sgaW50byB0cmVlXG5cdHJldEN0eC5wYXJlbnRDdHggPSBwYXJlbnRDdHg7XG5cdGlmICh0aGlzLmJ1aWxkUGFyc2VUcmVlcyAmJiBwYXJlbnRDdHggIT09IG51bGwpIHtcblx0XHQvLyBhZGQgcmV0dXJuIGN0eCBpbnRvIGludm9raW5nIHJ1bGUncyB0cmVlXG5cdFx0cGFyZW50Q3R4LmFkZENoaWxkKHJldEN0eCk7XG5cdH1cbn07XG5cblBhcnNlci5wcm90b3R5cGUuZ2V0SW52b2tpbmdDb250ZXh0ID0gZnVuY3Rpb24ocnVsZUluZGV4KSB7XG5cdHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdHdoaWxlIChjdHggIT09IG51bGwpIHtcblx0XHRpZiAoY3R4LnJ1bGVJbmRleCA9PT0gcnVsZUluZGV4KSB7XG5cdFx0XHRyZXR1cm4gY3R4O1xuXHRcdH1cblx0XHRjdHggPSBjdHgucGFyZW50Q3R4O1xuXHR9XG5cdHJldHVybiBudWxsO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wcmVjcHJlZCA9IGZ1bmN0aW9uKGxvY2FsY3R4LCBwcmVjZWRlbmNlKSB7XG5cdHJldHVybiBwcmVjZWRlbmNlID49IHRoaXMuX3ByZWNlZGVuY2VTdGFja1t0aGlzLl9wcmVjZWRlbmNlU3RhY2subGVuZ3RoLTFdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5pbkNvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdC8vIFRPRE86IHVzZWZ1bCBpbiBwYXJzZXI/XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbi8vXG4vLyBDaGVja3Mgd2hldGhlciBvciBub3Qge0Bjb2RlIHN5bWJvbH0gY2FuIGZvbGxvdyB0aGUgY3VycmVudCBzdGF0ZSBpbiB0aGVcbi8vIEFUTi4gVGhlIGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGZvbGxvd2luZywgYnV0IGlzXG4vLyBpbXBsZW1lbnRlZCBzdWNoIHRoYXQgdGhlIGNvbXBsZXRlIGNvbnRleHQtc2Vuc2l0aXZlIGZvbGxvdyBzZXQgZG9lcyBub3Rcbi8vIG5lZWQgdG8gYmUgZXhwbGljaXRseSBjb25zdHJ1Y3RlZC5cbi8vXG4vLyA8cHJlPlxuLy8gcmV0dXJuIGdldEV4cGVjdGVkVG9rZW5zKCkuY29udGFpbnMoc3ltYm9sKTtcbi8vIDwvcHJlPlxuLy9cbi8vIEBwYXJhbSBzeW1ib2wgdGhlIHN5bWJvbCB0eXBlIHRvIGNoZWNrXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiB7QGNvZGUgc3ltYm9sfSBjYW4gZm9sbG93IHRoZSBjdXJyZW50IHN0YXRlIGluXG4vLyB0aGUgQVROLCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfS5cblxuUGFyc2VyLnByb3RvdHlwZS5pc0V4cGVjdGVkVG9rZW4gPSBmdW5jdGlvbihzeW1ib2wpIHtcblx0dmFyIGF0biA9IHRoaXMuX2ludGVycC5hdG47XG5cdHZhciBjdHggPSB0aGlzLl9jdHg7XG5cdHZhciBzID0gYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcblx0dmFyIGZvbGxvd2luZyA9IGF0bi5uZXh0VG9rZW5zKHMpO1xuXHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKHN5bWJvbCkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZiAoIWZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR3aGlsZSAoY3R4ICE9PSBudWxsICYmIGN0eC5pbnZva2luZ1N0YXRlID49IDAgJiYgZm9sbG93aW5nLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XG5cdFx0dmFyIGludm9raW5nU3RhdGUgPSBhdG4uc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcblx0XHR2YXIgcnQgPSBpbnZva2luZ1N0YXRlLnRyYW5zaXRpb25zWzBdO1xuXHRcdGZvbGxvd2luZyA9IGF0bi5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcblx0XHRpZiAoZm9sbG93aW5nLmNvbnRhaW5zKHN5bWJvbCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRjdHggPSBjdHgucGFyZW50Q3R4O1xuXHR9XG5cdGlmIChmb2xsb3dpbmcuY29udGFpbnMoVG9rZW4uRVBTSUxPTikgJiYgc3ltYm9sID09PSBUb2tlbi5FT0YpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbi8vIENvbXB1dGVzIHRoZSBzZXQgb2YgaW5wdXQgc3ltYm9scyB3aGljaCBjb3VsZCBmb2xsb3cgdGhlIGN1cnJlbnQgcGFyc2VyXG4vLyBzdGF0ZSBhbmQgY29udGV4dCwgYXMgZ2l2ZW4gYnkge0BsaW5rIC8vZ2V0U3RhdGV9IGFuZCB7QGxpbmsgLy9nZXRDb250ZXh0fSxcbi8vIHJlc3BlY3RpdmVseS5cbi8vXG4vLyBAc2VlIEFUTi8vZ2V0RXhwZWN0ZWRUb2tlbnMoaW50LCBSdWxlQ29udGV4dClcbi8vXG5QYXJzZXIucHJvdG90eXBlLmdldEV4cGVjdGVkVG9rZW5zID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9pbnRlcnAuYXRuLmdldEV4cGVjdGVkVG9rZW5zKHRoaXMuc3RhdGUsIHRoaXMuX2N0eCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmdldEV4cGVjdGVkVG9rZW5zV2l0aGluQ3VycmVudFJ1bGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGF0biA9IHRoaXMuX2ludGVycC5hdG47XG5cdHZhciBzID0gYXRuLnN0YXRlc1t0aGlzLnN0YXRlXTtcblx0cmV0dXJuIGF0bi5uZXh0VG9rZW5zKHMpO1xufTtcblxuLy8gR2V0IGEgcnVsZSdzIGluZGV4IChpLmUuLCB7QGNvZGUgUlVMRV9ydWxlTmFtZX0gZmllbGQpIG9yIC0xIGlmIG5vdCBmb3VuZC4vL1xuUGFyc2VyLnByb3RvdHlwZS5nZXRSdWxlSW5kZXggPSBmdW5jdGlvbihydWxlTmFtZSkge1xuXHR2YXIgcnVsZUluZGV4ID0gdGhpcy5nZXRSdWxlSW5kZXhNYXAoKVtydWxlTmFtZV07XG5cdGlmIChydWxlSW5kZXggIT09IG51bGwpIHtcblx0XHRyZXR1cm4gcnVsZUluZGV4O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiAtMTtcblx0fVxufTtcblxuLy8gUmV0dXJuIExpc3QmbHQ7U3RyaW5nJmd0OyBvZiB0aGUgcnVsZSBuYW1lcyBpbiB5b3VyIHBhcnNlciBpbnN0YW5jZVxuLy8gbGVhZGluZyB1cCB0byBhIGNhbGwgdG8gdGhlIGN1cnJlbnQgcnVsZS4gWW91IGNvdWxkIG92ZXJyaWRlIGlmXG4vLyB5b3Ugd2FudCBtb3JlIGRldGFpbHMgc3VjaCBhcyB0aGUgZmlsZS9saW5lIGluZm8gb2Ygd2hlcmVcbi8vIGluIHRoZSBBVE4gYSBydWxlIGlzIGludm9rZWQuXG4vL1xuLy8gdGhpcyBpcyB2ZXJ5IHVzZWZ1bCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vL1xuUGFyc2VyLnByb3RvdHlwZS5nZXRSdWxlSW52b2NhdGlvblN0YWNrID0gZnVuY3Rpb24ocCkge1xuXHRwID0gcCB8fCBudWxsO1xuXHRpZiAocCA9PT0gbnVsbCkge1xuXHRcdHAgPSB0aGlzLl9jdHg7XG5cdH1cblx0dmFyIHN0YWNrID0gW107XG5cdHdoaWxlIChwICE9PSBudWxsKSB7XG5cdFx0Ly8gY29tcHV0ZSB3aGF0IGZvbGxvd3Mgd2hvIGludm9rZWQgdXNcblx0XHR2YXIgcnVsZUluZGV4ID0gcC5ydWxlSW5kZXg7XG5cdFx0aWYgKHJ1bGVJbmRleCA8IDApIHtcblx0XHRcdHN0YWNrLnB1c2goXCJuL2FcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YWNrLnB1c2godGhpcy5ydWxlTmFtZXNbcnVsZUluZGV4XSk7XG5cdFx0fVxuXHRcdHAgPSBwLnBhcmVudEN0eDtcblx0fVxuXHRyZXR1cm4gc3RhY2s7XG59O1xuXG4vLyBGb3IgZGVidWdnaW5nIGFuZCBvdGhlciBwdXJwb3Nlcy4vL1xuUGFyc2VyLnByb3RvdHlwZS5nZXRERkFTdHJpbmdzID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9pbnRlcnAuZGVjaXNpb25Ub0RGQS50b1N0cmluZygpO1xufTtcbi8vIEZvciBkZWJ1Z2dpbmcgYW5kIG90aGVyIHB1cnBvc2VzLi8vXG5QYXJzZXIucHJvdG90eXBlLmR1bXBERkEgPSBmdW5jdGlvbigpIHtcblx0dmFyIHNlZW5PbmUgPSBmYWxzZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnRlcnAuZGVjaXNpb25Ub0RGQS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkZmEgPSB0aGlzLl9pbnRlcnAuZGVjaXNpb25Ub0RGQVtpXTtcblx0XHRpZiAoZGZhLnN0YXRlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpZiAoc2Vlbk9uZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcmludGVyLnByaW50bG4oXCJEZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArIFwiOlwiKTtcblx0XHRcdHRoaXMucHJpbnRlci5wcmludChkZmEudG9TdHJpbmcodGhpcy5saXRlcmFsTmFtZXMsIHRoaXMuc3ltYm9saWNOYW1lcykpO1xuXHRcdFx0c2Vlbk9uZSA9IHRydWU7XG5cdFx0fVxuXHR9XG59O1xuXG4vKlxuXCJcdFx0XHRwcmludGVyID0gZnVuY3Rpb24oKSB7XFxyXFxuXCIgK1xuXCJcdFx0XHRcdHRoaXMucHJpbnRsbiA9IGZ1bmN0aW9uKHMpIHsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpICs9IHMgKyAnXFxcXG4nOyB9XFxyXFxuXCIgK1xuXCJcdFx0XHRcdHRoaXMucHJpbnQgPSBmdW5jdGlvbihzKSB7IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXRwdXQnKSArPSBzOyB9XFxyXFxuXCIgK1xuXCJcdFx0XHR9O1xcclxcblwiICtcbiovXG5cblBhcnNlci5wcm90b3R5cGUuZ2V0U291cmNlTmFtZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5faW5wdXQuc291cmNlTmFtZTtcbn07XG5cbi8vIER1cmluZyBhIHBhcnNlIGlzIHNvbWV0aW1lcyB1c2VmdWwgdG8gbGlzdGVuIGluIG9uIHRoZSBydWxlIGVudHJ5IGFuZCBleGl0XG4vLyBldmVudHMgYXMgd2VsbCBhcyB0b2tlbiBtYXRjaGVzLiB0aGlzIGlzIGZvciBxdWljayBhbmQgZGlydHkgZGVidWdnaW5nLlxuLy9cblBhcnNlci5wcm90b3R5cGUuc2V0VHJhY2UgPSBmdW5jdGlvbih0cmFjZSkge1xuXHRpZiAoIXRyYWNlKSB7XG5cdFx0dGhpcy5yZW1vdmVQYXJzZUxpc3RlbmVyKHRoaXMuX3RyYWNlcik7XG5cdFx0dGhpcy5fdHJhY2VyID0gbnVsbDtcblx0fSBlbHNlIHtcblx0XHRpZiAodGhpcy5fdHJhY2VyICE9PSBudWxsKSB7XG5cdFx0XHR0aGlzLnJlbW92ZVBhcnNlTGlzdGVuZXIodGhpcy5fdHJhY2VyKTtcblx0XHR9XG5cdFx0dGhpcy5fdHJhY2VyID0gbmV3IFRyYWNlTGlzdGVuZXIodGhpcyk7XG5cdFx0dGhpcy5hZGRQYXJzZUxpc3RlbmVyKHRoaXMuX3RyYWNlcik7XG5cdH1cbn07XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyOyIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLy8qIEEgcnVsZSBpbnZvY2F0aW9uIHJlY29yZCBmb3IgcGFyc2luZy5cbi8vXG4vLyAgQ29udGFpbnMgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBydWxlIG5vdCBzdG9yZWQgaW4gdGhlXG4vLyAgUnVsZUNvbnRleHQuIEl0IGhhbmRsZXMgcGFyc2UgdHJlZSBjaGlsZHJlbiBsaXN0LCBBbnkgQVROIHN0YXRlXG4vLyAgdHJhY2luZywgYW5kIHRoZSBkZWZhdWx0IHZhbHVlcyBhdmFpbGFibGUgZm9yIHJ1bGUgaW5kaWNhdGlvbnM6XG4vLyAgc3RhcnQsIHN0b3AsIHJ1bGUgaW5kZXgsIGN1cnJlbnQgYWx0IG51bWJlciwgY3VycmVudFxuLy8gIEFUTiBzdGF0ZS5cbi8vXG4vLyAgU3ViY2xhc3NlcyBtYWRlIGZvciBlYWNoIHJ1bGUgYW5kIGdyYW1tYXIgdHJhY2sgdGhlIHBhcmFtZXRlcnMsXG4vLyAgcmV0dXJuIHZhbHVlcywgbG9jYWxzLCBhbmQgbGFiZWxzIHNwZWNpZmljIHRvIHRoYXQgcnVsZS4gVGhlc2Vcbi8vICBhcmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgcmV0dXJuZWQgZnJvbSBydWxlcy5cbi8vXG4vLyAgTm90ZSB0ZXh0IGlzIG5vdCBhbiBhY3R1YWwgZmllbGQgb2YgYSBydWxlIHJldHVybiB2YWx1ZTsgaXQgaXMgY29tcHV0ZWRcbi8vICBmcm9tIHN0YXJ0IGFuZCBzdG9wIHVzaW5nIHRoZSBpbnB1dCBzdHJlYW0ncyB0b1N0cmluZygpIG1ldGhvZC4gIElcbi8vICBjb3VsZCBhZGQgYSBjdG9yIHRvIHRoaXMgc28gdGhhdCB3ZSBjYW4gcGFzcyBpbiBhbmQgc3RvcmUgdGhlIGlucHV0XG4vLyAgc3RyZWFtLCBidXQgSSdtIG5vdCBzdXJlIHdlIHdhbnQgdG8gZG8gdGhhdC4gIEl0IHdvdWxkIHNlZW0gdG8gYmUgdW5kZWZpbmVkXG4vLyAgdG8gZ2V0IHRoZSAudGV4dCBwcm9wZXJ0eSBhbnl3YXkgaWYgdGhlIHJ1bGUgbWF0Y2hlcyB0b2tlbnMgZnJvbSBtdWx0aXBsZVxuLy8gIGlucHV0IHN0cmVhbXMuXG4vL1xuLy8gIEkgZG8gbm90IHVzZSBnZXR0ZXJzIGZvciBmaWVsZHMgb2Ygb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHNpbXBseSB0b1xuLy8gIGdyb3VwIHZhbHVlcyBzdWNoIGFzIHRoaXMgYWdncmVnYXRlLiAgVGhlIGdldHRlcnMvc2V0dGVycyBhcmUgdGhlcmUgdG9cbi8vICBzYXRpc2Z5IHRoZSBzdXBlcmNsYXNzIGludGVyZmFjZS5cblxudmFyIFJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi9SdWxlQ29udGV4dCcpLlJ1bGVDb250ZXh0O1xudmFyIFRyZWUgPSByZXF1aXJlKCcuL3RyZWUvVHJlZScpO1xudmFyIElOVkFMSURfSU5URVJWQUwgPSBUcmVlLklOVkFMSURfSU5URVJWQUw7XG52YXIgVGVybWluYWxOb2RlID0gVHJlZS5UZXJtaW5hbE5vZGU7XG52YXIgVGVybWluYWxOb2RlSW1wbCA9IFRyZWUuVGVybWluYWxOb2RlSW1wbDtcbnZhciBFcnJvck5vZGVJbXBsID0gVHJlZS5FcnJvck5vZGVJbXBsO1xudmFyIEludGVydmFsID0gcmVxdWlyZShcIi4vSW50ZXJ2YWxTZXRcIikuSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIFBhcnNlclJ1bGVDb250ZXh0KHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcikge1xuXHRwYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblx0aW52b2tpbmdTdGF0ZU51bWJlciA9IGludm9raW5nU3RhdGVOdW1iZXIgfHwgbnVsbDtcblx0UnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIpO1xuXHR0aGlzLnJ1bGVJbmRleCA9IC0xO1xuICAgIC8vICogSWYgd2UgYXJlIGRlYnVnZ2luZyBvciBidWlsZGluZyBhIHBhcnNlIHRyZWUgZm9yIGEgdmlzaXRvcixcbiAgICAvLyB3ZSBuZWVkIHRvIHRyYWNrIGFsbCBvZiB0aGUgdG9rZW5zIGFuZCBydWxlIGludm9jYXRpb25zIGFzc29jaWF0ZWRcbiAgICAvLyB3aXRoIHRoaXMgcnVsZSdzIGNvbnRleHQuIFRoaXMgaXMgZW1wdHkgZm9yIHBhcnNpbmcgdy9vIHRyZWUgY29uc3RyLlxuICAgIC8vIG9wZXJhdGlvbiBiZWNhdXNlIHdlIGRvbid0IHRoZSBuZWVkIHRvIHRyYWNrIHRoZSBkZXRhaWxzIGFib3V0XG4gICAgLy8gaG93IHdlIHBhcnNlIHRoaXMgcnVsZS5cbiAgICAvLyAvXG4gICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IG51bGw7XG4gICAgdGhpcy5zdG9wID0gbnVsbDtcbiAgICAvLyBUaGUgZXhjZXB0aW9uIHRoYXQgZm9yY2VkIHRoaXMgcnVsZSB0byByZXR1cm4uIElmIHRoZSBydWxlIHN1Y2Nlc3NmdWxseVxuICAgIC8vIGNvbXBsZXRlZCwgdGhpcyBpcyB7QGNvZGUgbnVsbH0uXG4gICAgdGhpcy5leGNlcHRpb24gPSBudWxsO1xufVxuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzZXJSdWxlQ29udGV4dDtcblxuLy8gKiBDT1BZIGEgY3R4IChJJ20gZGVsaWJlcmF0ZWx5IG5vdCB1c2luZyBjb3B5IGNvbnN0cnVjdG9yKS8vL1xuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgLy8gZnJvbSBSdWxlQ29udGV4dFxuICAgIHRoaXMucGFyZW50Q3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICB0aGlzLmludm9raW5nU3RhdGUgPSBjdHguaW52b2tpbmdTdGF0ZTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gY3R4LnN0YXJ0O1xuICAgIHRoaXMuc3RvcCA9IGN0eC5zdG9wO1xuICAgIC8vIGNvcHkgYW55IGVycm9yIG5vZGVzIHRvIGFsdCBsYWJlbCBub2RlXG4gICAgaWYoY3R4LmNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gcmVzZXQgcGFyZW50IHBvaW50ZXIgZm9yIGFueSBlcnJvciBub2Rlc1xuICAgIFx0Y3R4LmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgIFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBFcnJvck5vZGVJbXBsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnRDdHggPSB0aGlzO1xuICAgICAgICAgICAgfVxuXHRcdH0sIHRoaXMpO1xuXHR9XG59O1xuXG4vLyBEb3VibGUgZGlzcGF0Y2ggbWV0aG9kcyBmb3IgbGlzdGVuZXJzXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuZW50ZXJSdWxlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5leGl0UnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG59O1xuXG4vLyAqIERvZXMgbm90IHNldCBwYXJlbnQgbGluazsgb3RoZXIgYWRkIG1ldGhvZHMgZG8gdGhhdC8vL1xuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24oY2hpbGQpIHtcbiAgICBpZiAodGhpcy5jaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgfVxuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLy8gKiBVc2VkIGJ5IGVudGVyT3V0ZXJBbHQgdG8gdG9zcyBvdXQgYSBSdWxlQ29udGV4dCBwcmV2aW91c2x5IGFkZGVkIGFzXG4vLyB3ZSBlbnRlcmVkIGEgcnVsZS4gSWYgd2UgaGF2ZSAvLyBsYWJlbCwgd2Ugd2lsbCBuZWVkIHRvIHJlbW92ZVxuLy8gZ2VuZXJpYyBydWxlQ29udGV4dCBvYmplY3QuXG4vLyAvXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUucmVtb3ZlTGFzdENoaWxkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wb3AoKTtcbiAgICB9XG59O1xuXG5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuYWRkVG9rZW5Ob2RlID0gZnVuY3Rpb24odG9rZW4pIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBUZXJtaW5hbE5vZGVJbXBsKHRva2VuKTtcbiAgICB0aGlzLmFkZENoaWxkKG5vZGUpO1xuICAgIG5vZGUucGFyZW50Q3R4ID0gdGhpcztcbiAgICByZXR1cm4gbm9kZTtcbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5hZGRFcnJvck5vZGUgPSBmdW5jdGlvbihiYWRUb2tlbikge1xuICAgIHZhciBub2RlID0gbmV3IEVycm9yTm9kZUltcGwoYmFkVG9rZW4pO1xuICAgIHRoaXMuYWRkQ2hpbGQobm9kZSk7XG4gICAgbm9kZS5wYXJlbnRDdHggPSB0aGlzO1xuICAgIHJldHVybiBub2RlO1xufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24oaSwgdHlwZSkge1xuXHR0eXBlID0gdHlwZSB8fCBudWxsO1xuXHRpZiAodGhpcy5jaGlsZHJlbiA9PT0gbnVsbCB8fCBpIDwgMCB8fCBpID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKHR5cGUgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcblx0fSBlbHNlIHtcblx0XHRmb3IodmFyIGo9MDsgajx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuXHRcdFx0aWYoY2hpbGQgaW5zdGFuY2VvZiB0eXBlKSB7XG5cdFx0XHRcdGlmKGk9PT0wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uKHR0eXBlLCBpKSB7XG5cdGlmICh0aGlzLmNoaWxkcmVuID09PSBudWxsIHx8IGkgPCAwIHx8IGkgPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRmb3IodmFyIGo9MDsgajx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltqXTtcblx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcblx0XHRcdGlmIChjaGlsZC5zeW1ib2wudHlwZSA9PT0gdHR5cGUpIHtcblx0XHRcdFx0aWYoaT09PTApIHtcblx0XHRcdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiBudWxsO1xufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmdldFRva2VucyA9IGZ1bmN0aW9uKHR0eXBlICkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdGZvcih2YXIgaj0wOyBqPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bal07XG5cdFx0XHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLnN5bWJvbC50eXBlID09PSB0dHlwZSkge1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG9rZW5zO1xuICAgIH1cbn07XG5cblBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRUeXBlZFJ1bGVDb250ZXh0ID0gZnVuY3Rpb24oY3R4VHlwZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkKGksIGN0eFR5cGUpO1xufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmdldFR5cGVkUnVsZUNvbnRleHRzID0gZnVuY3Rpb24oY3R4VHlwZSkge1xuICAgIGlmICh0aGlzLmNoaWxkcmVuPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG5cdFx0dmFyIGNvbnRleHRzID0gW107XG5cdFx0Zm9yKHZhciBqPTA7IGo8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltqXTtcblx0XHRcdGlmIChjaGlsZCBpbnN0YW5jZW9mIGN0eFR5cGUpIHtcblx0XHRcdFx0Y29udGV4dHMucHVzaChjaGlsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb250ZXh0cztcblx0fVxufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuY2hpbGRyZW49PT0gbnVsbCkge1xuXHRcdHJldHVybiAwO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcblx0fVxufTtcblxuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmdldFNvdXJjZUludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoIHRoaXMuc3RhcnQgPT09IG51bGwgfHwgdGhpcy5zdG9wID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBJTlZBTElEX0lOVEVSVkFMO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJ2YWwodGhpcy5zdGFydC50b2tlbkluZGV4LCB0aGlzLnN0b3AudG9rZW5JbmRleCk7XG4gICAgfVxufTtcblxuUnVsZUNvbnRleHQuRU1QVFkgPSBuZXcgUGFyc2VyUnVsZUNvbnRleHQoKTtcblxuZnVuY3Rpb24gSW50ZXJwcmV0ZXJSdWxlQ29udGV4dChwYXJlbnQsIGludm9raW5nU3RhdGVOdW1iZXIsIHJ1bGVJbmRleCkge1xuXHRQYXJzZXJSdWxlQ29udGV4dC5jYWxsKHBhcmVudCwgaW52b2tpbmdTdGF0ZU51bWJlcik7XG4gICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkludGVycHJldGVyUnVsZUNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xuSW50ZXJwcmV0ZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcnByZXRlclJ1bGVDb250ZXh0O1xuXG5leHBvcnRzLlBhcnNlclJ1bGVDb250ZXh0ID0gUGFyc2VyUnVsZUNvbnRleHQ7IiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG52YXIgUnVsZUNvbnRleHQgPSByZXF1aXJlKCcuL1J1bGVDb250ZXh0JykuUnVsZUNvbnRleHQ7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vVXRpbHMnKS5IYXNoO1xudmFyIE1hcCA9IHJlcXVpcmUoJy4vVXRpbHMnKS5NYXA7XG5cbmZ1bmN0aW9uIFByZWRpY3Rpb25Db250ZXh0KGNhY2hlZEhhc2hDb2RlKSB7XG5cdHRoaXMuY2FjaGVkSGFzaENvZGUgPSBjYWNoZWRIYXNoQ29kZTtcbn1cblxuLy8gUmVwcmVzZW50cyB7QGNvZGUgJH0gaW4gbG9jYWwgY29udGV4dCBwcmVkaWN0aW9uLCB3aGljaCBtZWFucyB3aWxkY2FyZC5cbi8vIHtAY29kZS8vK3ggPS8vfS5cbi8vIC9cblByZWRpY3Rpb25Db250ZXh0LkVNUFRZID0gbnVsbDtcblxuLy8gUmVwcmVzZW50cyB7QGNvZGUgJH0gaW4gYW4gYXJyYXkgaW4gZnVsbCBjb250ZXh0IG1vZGUsIHdoZW4ge0Bjb2RlICR9XG4vLyBkb2Vzbid0IG1lYW4gd2lsZGNhcmQ6IHtAY29kZSAkICsgeCA9IFskLHhdfS4gSGVyZSxcbi8vIHtAY29kZSAkfSA9IHtAbGluayAvL0VNUFRZX1JFVFVSTl9TVEFURX0uXG4vLyAvXG5QcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUgPSAweDdGRkZGRkZGO1xuXG5QcmVkaWN0aW9uQ29udGV4dC5nbG9iYWxOb2RlQ291bnQgPSAxO1xuUHJlZGljdGlvbkNvbnRleHQuaWQgPSBQcmVkaWN0aW9uQ29udGV4dC5nbG9iYWxOb2RlQ291bnQ7XG5cbi8vIFN0b3JlcyB0aGUgY29tcHV0ZWQgaGFzaCBjb2RlIG9mIHRoaXMge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fS4gVGhlIGhhc2hcbi8vIGNvZGUgaXMgY29tcHV0ZWQgaW4gcGFydHMgdG8gbWF0Y2ggdGhlIGZvbGxvd2luZyByZWZlcmVuY2UgYWxnb3JpdGhtLlxuLy9cbi8vIDxwcmU+XG4vLyBwcml2YXRlIGludCByZWZlcmVuY2VIYXNoQ29kZSgpIHtcbi8vIGludCBoYXNoID0ge0BsaW5rIE11cm11ckhhc2gvL2luaXRpYWxpemUgTXVybXVySGFzaC5pbml0aWFsaXplfSh7QGxpbmtcbi8vIC8vSU5JVElBTF9IQVNIfSk7XG4vL1xuLy8gZm9yIChpbnQgaSA9IDA7IGkgJmx0OyB7QGxpbmsgLy9zaXplKCl9OyBpKyspIHtcbi8vIGhhc2ggPSB7QGxpbmsgTXVybXVySGFzaC8vdXBkYXRlIE11cm11ckhhc2gudXBkYXRlfShoYXNoLCB7QGxpbmsgLy9nZXRQYXJlbnRcbi8vIGdldFBhcmVudH0oaSkpO1xuLy8gfVxuLy9cbi8vIGZvciAoaW50IGkgPSAwOyBpICZsdDsge0BsaW5rIC8vc2l6ZSgpfTsgaSsrKSB7XG4vLyBoYXNoID0ge0BsaW5rIE11cm11ckhhc2gvL3VwZGF0ZSBNdXJtdXJIYXNoLnVwZGF0ZX0oaGFzaCwge0BsaW5rXG4vLyAvL2dldFJldHVyblN0YXRlIGdldFJldHVyblN0YXRlfShpKSk7XG4vLyB9XG4vL1xuLy8gaGFzaCA9IHtAbGluayBNdXJtdXJIYXNoLy9maW5pc2ggTXVybXVySGFzaC5maW5pc2h9KGhhc2gsIDIvLyB7QGxpbmtcbi8vIC8vc2l6ZSgpfSk7XG4vLyByZXR1cm4gaGFzaDtcbi8vIH1cbi8vIDwvcHJlPlxuLy8gL1xuXG4vLyBUaGlzIG1lYW5zIG9ubHkgdGhlIHtAbGluayAvL0VNUFRZfSBjb250ZXh0IGlzIGluIHNldC5cblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcbn07XG5cblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5oYXNFbXB0eVBhdGggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuZ2V0UmV0dXJuU3RhdGUodGhpcy5sZW5ndGggLSAxKSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFO1xufTtcblxuUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmNhY2hlZEhhc2hDb2RlO1xufTtcblxuXG5QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5jYWNoZWRIYXNoQ29kZSk7XG59O1xuLypcbmZ1bmN0aW9uIGNhbGN1bGF0ZUhhc2hTdHJpbmcocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuXHRyZXR1cm4gXCJcIiArIHBhcmVudCArIHJldHVyblN0YXRlO1xufVxuKi9cblxuLy8gVXNlZCB0byBjYWNoZSB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IG9iamVjdHMuIEl0cyB1c2VkIGZvciB0aGUgc2hhcmVkXG4vLyBjb250ZXh0IGNhc2ggYXNzb2NpYXRlZCB3aXRoIGNvbnRleHRzIGluIERGQSBzdGF0ZXMuIFRoaXMgY2FjaGVcbi8vIGNhbiBiZSB1c2VkIGZvciBib3RoIGxleGVycyBhbmQgcGFyc2Vycy5cblxuZnVuY3Rpb24gUHJlZGljdGlvbkNvbnRleHRDYWNoZSgpIHtcblx0dGhpcy5jYWNoZSA9IG5ldyBNYXAoKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBhIGNvbnRleHQgdG8gdGhlIGNhY2hlIGFuZCByZXR1cm4gaXQuIElmIHRoZSBjb250ZXh0IGFscmVhZHkgZXhpc3RzLFxuLy8gcmV0dXJuIHRoYXQgb25lIGluc3RlYWQgYW5kIGRvIG5vdCBhZGQgYSBuZXcgY29udGV4dCB0byB0aGUgY2FjaGUuXG4vLyBQcm90ZWN0IHNoYXJlZCBjYWNoZSBmcm9tIHVuc2FmZSB0aHJlYWQgYWNjZXNzLlxuLy9cblByZWRpY3Rpb25Db250ZXh0Q2FjaGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGN0eCkge1xuXHRpZiAoY3R4ID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcblx0fVxuXHR2YXIgZXhpc3RpbmcgPSB0aGlzLmNhY2hlLmdldChjdHgpIHx8IG51bGw7XG5cdGlmIChleGlzdGluZyAhPT0gbnVsbCkge1xuXHRcdHJldHVybiBleGlzdGluZztcblx0fVxuXHR0aGlzLmNhY2hlLnB1dChjdHgsIGN0eCk7XG5cdHJldHVybiBjdHg7XG59O1xuXG5QcmVkaWN0aW9uQ29udGV4dENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjdHgpIHtcblx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGN0eCkgfHwgbnVsbDtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVkaWN0aW9uQ29udGV4dENhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jYWNoZS5sZW5ndGg7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dChwYXJlbnQsIHJldHVyblN0YXRlKSB7XG5cdHZhciBoYXNoQ29kZSA9IDA7XG5cdHZhciBoYXNoID0gbmV3IEhhc2goKTtcblx0aWYocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0aGFzaC51cGRhdGUocGFyZW50LCByZXR1cm5TdGF0ZSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFzaC51cGRhdGUoMSk7XG5cdH1cblx0aGFzaENvZGUgPSBoYXNoLmZpbmlzaCgpO1xuXHRQcmVkaWN0aW9uQ29udGV4dC5jYWxsKHRoaXMsIGhhc2hDb2RlKTtcblx0dGhpcy5wYXJlbnRDdHggPSBwYXJlbnQ7XG5cdHRoaXMucmV0dXJuU3RhdGUgPSByZXR1cm5TdGF0ZTtcbn1cblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUpO1xuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnRydWN0b3IgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlID0gZnVuY3Rpb24ocGFyZW50LCByZXR1cm5TdGF0ZSkge1xuXHRpZiAocmV0dXJuU3RhdGUgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSAmJiBwYXJlbnQgPT09IG51bGwpIHtcblx0XHQvLyBzb21lb25lIGNhbiBwYXNzIGluIHRoZSBiaXRzIG9mIGFuIGFycmF5IGN0eCB0aGF0IG1lYW4gJFxuXHRcdHJldHVybiBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbmV3IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0KHBhcmVudCwgcmV0dXJuU3RhdGUpO1xuXHR9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxO1xuXHR9XG59KTtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnBhcmVudEN0eDtcbn07XG5cblNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5nZXRSZXR1cm5TdGF0ZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiB0aGlzLnJldHVyblN0YXRlO1xufTtcblxuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSBpZiAodGhpcy5oYXNoQ29kZSgpICE9PSBvdGhlci5oYXNoQ29kZSgpKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBjYW4ndCBiZSBzYW1lIGlmIGhhc2ggaXMgZGlmZmVyZW50XG5cdH0gZWxzZSB7XG5cdFx0aWYodGhpcy5yZXR1cm5TdGF0ZSAhPT0gb3RoZXIucmV0dXJuU3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYodGhpcy5wYXJlbnRDdHg9PW51bGwpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIucGFyZW50Q3R4PT1udWxsXG5cdFx0ZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Q3R4LmVxdWFscyhvdGhlci5wYXJlbnRDdHgpO1xuXHR9XG59O1xuXG5TaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHVwID0gdGhpcy5wYXJlbnRDdHggPT09IG51bGwgPyBcIlwiIDogdGhpcy5wYXJlbnRDdHgudG9TdHJpbmcoKTtcblx0aWYgKHVwLmxlbmd0aCA9PT0gMCkge1xuXHRcdGlmICh0aGlzLnJldHVyblN0YXRlID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUpIHtcblx0XHRcdHJldHVybiBcIiRcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiXCIgKyB0aGlzLnJldHVyblN0YXRlO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gXCJcIiArIHRoaXMucmV0dXJuU3RhdGUgKyBcIiBcIiArIHVwO1xuXHR9XG59O1xuXG5mdW5jdGlvbiBFbXB0eVByZWRpY3Rpb25Db250ZXh0KCkge1xuXHRTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jYWxsKHRoaXMsIG51bGwsIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5FbXB0eVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlKTtcbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1wdHlQcmVkaWN0aW9uQ29udGV4dDtcblxuRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cdHJldHVybiBudWxsO1xufTtcblxuRW1wdHlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUuZ2V0UmV0dXJuU3RhdGUgPSBmdW5jdGlvbihpbmRleCkge1xuXHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZTtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdHJldHVybiB0aGlzID09PSBvdGhlcjtcbn07XG5cbkVtcHR5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIiRcIjtcbn07XG5cblByZWRpY3Rpb25Db250ZXh0LkVNUFRZID0gbmV3IEVtcHR5UHJlZGljdGlvbkNvbnRleHQoKTtcblxuZnVuY3Rpb24gQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCByZXR1cm5TdGF0ZXMpIHtcblx0Ly8gUGFyZW50IGNhbiBiZSBudWxsIG9ubHkgaWYgZnVsbCBjdHggbW9kZSBhbmQgd2UgbWFrZSBhbiBhcnJheVxuXHQvLyBmcm9tIHtAbGluayAvL0VNUFRZfSBhbmQgbm9uLWVtcHR5LiBXZSBtZXJnZSB7QGxpbmsgLy9FTVBUWX0gYnkgdXNpbmdcblx0Ly8gbnVsbCBwYXJlbnQgYW5kXG5cdC8vIHJldHVyblN0YXRlID09IHtAbGluayAvL0VNUFRZX1JFVFVSTl9TVEFURX0uXG5cdHZhciBoID0gbmV3IEhhc2goKTtcblx0aC51cGRhdGUocGFyZW50cywgcmV0dXJuU3RhdGVzKTtcblx0dmFyIGhhc2hDb2RlID0gaC5maW5pc2goKTtcblx0UHJlZGljdGlvbkNvbnRleHQuY2FsbCh0aGlzLCBoYXNoQ29kZSk7XG5cdHRoaXMucGFyZW50cyA9IHBhcmVudHM7XG5cdHRoaXMucmV0dXJuU3RhdGVzID0gcmV0dXJuU3RhdGVzO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQXJyYXlQcmVkaWN0aW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZSk7XG5BcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5UHJlZGljdGlvbkNvbnRleHQ7XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0Ly8gc2luY2UgRU1QVFlfUkVUVVJOX1NUQVRFIGNhbiBvbmx5IGFwcGVhciBpbiB0aGUgbGFzdCBwb3NpdGlvbiwgd2Vcblx0Ly8gZG9uJ3QgbmVlZCB0byB2ZXJpZnkgdGhhdCBzaXplPT0xXG5cdHJldHVybiB0aGlzLnJldHVyblN0YXRlc1swXSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnJldHVyblN0YXRlcy5sZW5ndGg7XG5cdH1cbn0pO1xuXG5BcnJheVByZWRpY3Rpb25Db250ZXh0LnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbihpbmRleCkge1xuXHRyZXR1cm4gdGhpcy5wYXJlbnRzW2luZGV4XTtcbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmdldFJldHVyblN0YXRlID0gZnVuY3Rpb24oaW5kZXgpIHtcblx0cmV0dXJuIHRoaXMucmV0dXJuU3RhdGVzW2luZGV4XTtcbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBcnJheVByZWRpY3Rpb25Db250ZXh0KSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIGlmICh0aGlzLmhhc2hDb2RlKCkgIT09IG90aGVyLmhhc2hDb2RlKCkpIHtcblx0XHRyZXR1cm4gZmFsc2U7IC8vIGNhbid0IGJlIHNhbWUgaWYgaGFzaCBpcyBkaWZmZXJlbnRcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGhpcy5yZXR1cm5TdGF0ZXMgPT09IG90aGVyLnJldHVyblN0YXRlcyAmJlxuXHRcdFx0XHR0aGlzLnBhcmVudHMgPT09IG90aGVyLnBhcmVudHM7XG5cdH1cbn07XG5cbkFycmF5UHJlZGljdGlvbkNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmlzRW1wdHkoKSkge1xuXHRcdHJldHVybiBcIltdXCI7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHMgPSBcIltcIjtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmV0dXJuU3RhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaSA+IDApIHtcblx0XHRcdFx0cyA9IHMgKyBcIiwgXCI7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5yZXR1cm5TdGF0ZXNbaV0gPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuXHRcdFx0XHRzID0gcyArIFwiJFwiO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHMgPSBzICsgdGhpcy5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHRpZiAodGhpcy5wYXJlbnRzW2ldICE9PSBudWxsKSB7XG5cdFx0XHRcdHMgPSBzICsgXCIgXCIgKyB0aGlzLnBhcmVudHNbaV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzID0gcyArIFwibnVsbFwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcyArIFwiXVwiO1xuXHR9XG59O1xuXG4vLyBDb252ZXJ0IGEge0BsaW5rIFJ1bGVDb250ZXh0fSB0cmVlIHRvIGEge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBncmFwaC5cbi8vIFJldHVybiB7QGxpbmsgLy9FTVBUWX0gaWYge0Bjb2RlIG91dGVyQ29udGV4dH0gaXMgZW1wdHkgb3IgbnVsbC5cbi8vIC9cbmZ1bmN0aW9uIHByZWRpY3Rpb25Db250ZXh0RnJvbVJ1bGVDb250ZXh0KGF0biwgb3V0ZXJDb250ZXh0KSB7XG5cdGlmIChvdXRlckNvbnRleHQgPT09IHVuZGVmaW5lZCB8fCBvdXRlckNvbnRleHQgPT09IG51bGwpIHtcblx0XHRvdXRlckNvbnRleHQgPSBSdWxlQ29udGV4dC5FTVBUWTtcblx0fVxuXHQvLyBpZiB3ZSBhcmUgaW4gUnVsZUNvbnRleHQgb2Ygc3RhcnQgcnVsZSwgcywgdGhlbiBQcmVkaWN0aW9uQ29udGV4dFxuXHQvLyBpcyBFTVBUWS4gTm9ib2R5IGNhbGxlZCB1cy4gKGlmIHdlIGFyZSBlbXB0eSwgcmV0dXJuIGVtcHR5KVxuXHRpZiAob3V0ZXJDb250ZXh0LnBhcmVudEN0eCA9PT0gbnVsbCB8fCBvdXRlckNvbnRleHQgPT09IFJ1bGVDb250ZXh0LkVNUFRZKSB7XG5cdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuXHR9XG5cdC8vIElmIHdlIGhhdmUgYSBwYXJlbnQsIGNvbnZlcnQgaXQgdG8gYSBQcmVkaWN0aW9uQ29udGV4dCBncmFwaFxuXHR2YXIgcGFyZW50ID0gcHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQoYXRuLCBvdXRlckNvbnRleHQucGFyZW50Q3R4KTtcblx0dmFyIHN0YXRlID0gYXRuLnN0YXRlc1tvdXRlckNvbnRleHQuaW52b2tpbmdTdGF0ZV07XG5cdHZhciB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbnNbMF07XG5cdHJldHVybiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUocGFyZW50LCB0cmFuc2l0aW9uLmZvbGxvd1N0YXRlLnN0YXRlTnVtYmVyKTtcbn1cbi8qXG5mdW5jdGlvbiBjYWxjdWxhdGVMaXN0c0hhc2hTdHJpbmcocGFyZW50cywgcmV0dXJuU3RhdGVzKSB7XG5cdHZhciBzID0gXCJcIjtcblx0cGFyZW50cy5tYXAoZnVuY3Rpb24ocCkge1xuXHRcdHMgPSBzICsgcDtcblx0fSk7XG5cdHJldHVyblN0YXRlcy5tYXAoZnVuY3Rpb24ocikge1xuXHRcdHMgPSBzICsgcjtcblx0fSk7XG5cdHJldHVybiBzO1xufVxuKi9cbmZ1bmN0aW9uIG1lcmdlKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdC8vIHNoYXJlIHNhbWUgZ3JhcGggaWYgYm90aCBzYW1lXG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIGE7XG5cdH1cblx0aWYgKGEgaW5zdGFuY2VvZiBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCAmJiBiIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRyZXR1cm4gbWVyZ2VTaW5nbGV0b25zKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0fVxuXHQvLyBBdCBsZWFzdCBvbmUgb2YgYSBvciBiIGlzIGFycmF5XG5cdC8vIElmIG9uZSBpcyAkIGFuZCByb290SXNXaWxkY2FyZCwgcmV0dXJuICQgYXMvLyB3aWxkY2FyZFxuXHRpZiAocm9vdElzV2lsZGNhcmQpIHtcblx0XHRpZiAoYSBpbnN0YW5jZW9mIEVtcHR5UHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRcdHJldHVybiBhO1xuXHRcdH1cblx0XHRpZiAoYiBpbnN0YW5jZW9mIEVtcHR5UHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRcdHJldHVybiBiO1xuXHRcdH1cblx0fVxuXHQvLyBjb252ZXJ0IHNpbmdsZXRvbiBzbyBib3RoIGFyZSBhcnJheXMgdG8gbm9ybWFsaXplXG5cdGlmIChhIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRhID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQoW2EuZ2V0UGFyZW50KCldLCBbYS5yZXR1cm5TdGF0ZV0pO1xuXHR9XG5cdGlmIChiIGluc3RhbmNlb2YgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQpIHtcblx0XHRiID0gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQoW2IuZ2V0UGFyZW50KCldLCBbYi5yZXR1cm5TdGF0ZV0pO1xuXHR9XG5cdHJldHVybiBtZXJnZUFycmF5cyhhLCBiLCByb290SXNXaWxkY2FyZCwgbWVyZ2VDYWNoZSk7XG59XG5cbi8vXG4vLyBNZXJnZSB0d28ge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fSBpbnN0YW5jZXMuXG4vL1xuLy8gPHA+U3RhY2sgdG9wcyBlcXVhbCwgcGFyZW50cyBtZXJnZSBpcyBzYW1lOyByZXR1cm4gbGVmdCBncmFwaC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1NpbmdsZXRvbk1lcmdlX1NhbWVSb290U2FtZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNhbWUgc3RhY2sgdG9wLCBwYXJlbnRzIGRpZmZlcjsgbWVyZ2UgcGFyZW50cyBnaXZpbmcgYXJyYXkgbm9kZSwgdGhlblxuLy8gcmVtYWluZGVycyBvZiB0aG9zZSBncmFwaHMuIEEgbmV3IHJvb3Qgbm9kZSBpcyBjcmVhdGVkIHRvIHBvaW50IHRvIHRoZVxuLy8gbWVyZ2VkIHBhcmVudHMuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9TaW5nbGV0b25NZXJnZV9TYW1lUm9vdERpZmZQYXIuc3ZnXCJcbi8vIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8cD5EaWZmZXJlbnQgc3RhY2sgdG9wcyBwb2ludGluZyB0byBzYW1lIHBhcmVudC4gTWFrZSBhcnJheSBub2RlIGZvciB0aGVcbi8vIHJvb3Qgd2hlcmUgYm90aCBlbGVtZW50IGluIHRoZSByb290IHBvaW50IHRvIHRoZSBzYW1lIChvcmlnaW5hbClcbi8vIHBhcmVudC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1NpbmdsZXRvbk1lcmdlX0RpZmZSb290U2FtZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPkRpZmZlcmVudCBzdGFjayB0b3BzIHBvaW50aW5nIHRvIGRpZmZlcmVudCBwYXJlbnRzLiBNYWtlIGFycmF5IG5vZGUgZm9yXG4vLyB0aGUgcm9vdCB3aGVyZSBlYWNoIGVsZW1lbnQgcG9pbnRzIHRvIHRoZSBjb3JyZXNwb25kaW5nIG9yaWdpbmFsXG4vLyBwYXJlbnQuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9TaW5nbGV0b25NZXJnZV9EaWZmUm9vdERpZmZQYXIuc3ZnXCJcbi8vIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyBAcGFyYW0gYSB0aGUgZmlyc3Qge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fVxuLy8gQHBhcmFtIGIgdGhlIHNlY29uZCB7QGxpbmsgU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHR9XG4vLyBAcGFyYW0gcm9vdElzV2lsZGNhcmQge0Bjb2RlIHRydWV9IGlmIHRoaXMgaXMgYSBsb2NhbC1jb250ZXh0IG1lcmdlLFxuLy8gb3RoZXJ3aXNlIGZhbHNlIHRvIGluZGljYXRlIGEgZnVsbC1jb250ZXh0IG1lcmdlXG4vLyBAcGFyYW0gbWVyZ2VDYWNoZVxuLy8gL1xuZnVuY3Rpb24gbWVyZ2VTaW5nbGV0b25zKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYSwgYik7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHRcdHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYiwgYSk7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHJvb3RNZXJnZSA9IG1lcmdlUm9vdChhLCBiLCByb290SXNXaWxkY2FyZCk7XG5cdGlmIChyb290TWVyZ2UgIT09IG51bGwpIHtcblx0XHRpZiAobWVyZ2VDYWNoZSAhPT0gbnVsbCkge1xuXHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgcm9vdE1lcmdlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJvb3RNZXJnZTtcblx0fVxuXHRpZiAoYS5yZXR1cm5TdGF0ZSA9PT0gYi5yZXR1cm5TdGF0ZSkge1xuXHRcdHZhciBwYXJlbnQgPSBtZXJnZShhLnBhcmVudEN0eCwgYi5wYXJlbnRDdHgsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0XHQvLyBpZiBwYXJlbnQgaXMgc2FtZSBhcyBleGlzdGluZyBhIG9yIGIgcGFyZW50IG9yIHJlZHVjZWQgdG8gYSBwYXJlbnQsXG5cdFx0Ly8gcmV0dXJuIGl0XG5cdFx0aWYgKHBhcmVudCA9PT0gYS5wYXJlbnRDdHgpIHtcblx0XHRcdHJldHVybiBhOyAvLyBheCArIGJ4ID0gYXgsIGlmIGE9YlxuXHRcdH1cblx0XHRpZiAocGFyZW50ID09PSBiLnBhcmVudEN0eCkge1xuXHRcdFx0cmV0dXJuIGI7IC8vIGF4ICsgYnggPSBieCwgaWYgYT1iXG5cdFx0fVxuXHRcdC8vIGVsc2U6IGF4ICsgYXkgPSBhJ1t4LHldXG5cdFx0Ly8gbWVyZ2UgcGFyZW50cyB4IGFuZCB5LCBnaXZpbmcgYXJyYXkgbm9kZSB3aXRoIHgseSB0aGVuIHJlbWFpbmRlcnNcblx0XHQvLyBvZiB0aG9zZSBncmFwaHMuIGR1cCBhLCBhJyBwb2ludHMgYXQgbWVyZ2VkIGFycmF5XG5cdFx0Ly8gbmV3IGpvaW5lZCBwYXJlbnQgc28gY3JlYXRlIG5ldyBzaW5nbGV0b24gcG9pbnRpbmcgdG8gaXQsIGEnXG5cdFx0dmFyIHNwYyA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShwYXJlbnQsIGEucmV0dXJuU3RhdGUpO1xuXHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBzcGMpO1xuXHRcdH1cblx0XHRyZXR1cm4gc3BjO1xuXHR9IGVsc2UgeyAvLyBhICE9IGIgcGF5bG9hZHMgZGlmZmVyXG5cdFx0Ly8gc2VlIGlmIHdlIGNhbiBjb2xsYXBzZSBwYXJlbnRzIGR1ZSB0byAkK3ggcGFyZW50cyBpZiBsb2NhbCBjdHhcblx0XHR2YXIgc2luZ2xlUGFyZW50ID0gbnVsbDtcblx0XHRpZiAoYSA9PT0gYiB8fCAoYS5wYXJlbnRDdHggIT09IG51bGwgJiYgYS5wYXJlbnRDdHggPT09IGIucGFyZW50Q3R4KSkgeyAvLyBheCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYnggPVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFthLGJdeFxuXHRcdFx0c2luZ2xlUGFyZW50ID0gYS5wYXJlbnRDdHg7XG5cdFx0fVxuXHRcdGlmIChzaW5nbGVQYXJlbnQgIT09IG51bGwpIHsgLy8gcGFyZW50cyBhcmUgc2FtZVxuXHRcdFx0Ly8gc29ydCBwYXlsb2FkcyBhbmQgdXNlIHNhbWUgcGFyZW50XG5cdFx0XHR2YXIgcGF5bG9hZHMgPSBbIGEucmV0dXJuU3RhdGUsIGIucmV0dXJuU3RhdGUgXTtcblx0XHRcdGlmIChhLnJldHVyblN0YXRlID4gYi5yZXR1cm5TdGF0ZSkge1xuXHRcdFx0XHRwYXlsb2Fkc1swXSA9IGIucmV0dXJuU3RhdGU7XG5cdFx0XHRcdHBheWxvYWRzWzFdID0gYS5yZXR1cm5TdGF0ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJlbnRzID0gWyBzaW5nbGVQYXJlbnQsIHNpbmdsZVBhcmVudCBdO1xuXHRcdFx0dmFyIGFwYyA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHBheWxvYWRzKTtcblx0XHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRcdG1lcmdlQ2FjaGUuc2V0KGEsIGIsIGFwYyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXBjO1xuXHRcdH1cblx0XHQvLyBwYXJlbnRzIGRpZmZlciBhbmQgY2FuJ3QgbWVyZ2UgdGhlbS4gSnVzdCBwYWNrIHRvZ2V0aGVyXG5cdFx0Ly8gaW50byBhcnJheTsgY2FuJ3QgbWVyZ2UuXG5cdFx0Ly8gYXggKyBieSA9IFtheCxieV1cblx0XHR2YXIgcGF5bG9hZHMgPSBbIGEucmV0dXJuU3RhdGUsIGIucmV0dXJuU3RhdGUgXTtcblx0XHR2YXIgcGFyZW50cyA9IFsgYS5wYXJlbnRDdHgsIGIucGFyZW50Q3R4IF07XG5cdFx0aWYgKGEucmV0dXJuU3RhdGUgPiBiLnJldHVyblN0YXRlKSB7IC8vIHNvcnQgYnkgcGF5bG9hZFxuXHRcdFx0cGF5bG9hZHNbMF0gPSBiLnJldHVyblN0YXRlO1xuXHRcdFx0cGF5bG9hZHNbMV0gPSBhLnJldHVyblN0YXRlO1xuXHRcdFx0cGFyZW50cyA9IFsgYi5wYXJlbnRDdHgsIGEucGFyZW50Q3R4IF07XG5cdFx0fVxuXHRcdHZhciBhXyA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIHBheWxvYWRzKTtcblx0XHRpZiAobWVyZ2VDYWNoZSAhPT0gbnVsbCkge1xuXHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuXHRcdH1cblx0XHRyZXR1cm4gYV87XG5cdH1cbn1cblxuLy9cbi8vIEhhbmRsZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB7QGNvZGUgYX0gb3Ige0Bjb2RlIGJ9IGlzXG4vLyB7QGxpbmsgLy9FTVBUWX0uIEluIHRoZSBmb2xsb3dpbmcgZGlhZ3JhbXMsIHRoZSBzeW1ib2wge0Bjb2RlICR9IGlzIHVzZWRcbi8vIHRvIHJlcHJlc2VudCB7QGxpbmsgLy9FTVBUWX0uXG4vL1xuLy8gPGgyPkxvY2FsLUNvbnRleHQgTWVyZ2VzPC9oMj5cbi8vXG4vLyA8cD5UaGVzZSBsb2NhbC1jb250ZXh0IG1lcmdlIG9wZXJhdGlvbnMgYXJlIHVzZWQgd2hlbiB7QGNvZGUgcm9vdElzV2lsZGNhcmR9XG4vLyBpcyB0cnVlLjwvcD5cbi8vXG4vLyA8cD57QGxpbmsgLy9FTVBUWX0gaXMgc3VwZXJzZXQgb2YgYW55IGdyYXBoOyByZXR1cm4ge0BsaW5rIC8vRU1QVFl9Ljxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvTG9jYWxNZXJnZV9FbXB0eVJvb3Quc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPntAbGluayAvL0VNUFRZfSBhbmQgYW55dGhpbmcgaXMge0Bjb2RlIC8vRU1QVFl9LCBzbyBtZXJnZWQgcGFyZW50IGlzXG4vLyB7QGNvZGUgLy9FTVBUWX07IHJldHVybiBsZWZ0IGdyYXBoLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvTG9jYWxNZXJnZV9FbXB0eVBhcmVudC5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+U3BlY2lhbCBjYXNlIG9mIGxhc3QgbWVyZ2UgaWYgbG9jYWwgY29udGV4dC48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0xvY2FsTWVyZ2VfRGlmZlJvb3RzLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8aDI+RnVsbC1Db250ZXh0IE1lcmdlczwvaDI+XG4vL1xuLy8gPHA+VGhlc2UgZnVsbC1jb250ZXh0IG1lcmdlIG9wZXJhdGlvbnMgYXJlIHVzZWQgd2hlbiB7QGNvZGUgcm9vdElzV2lsZGNhcmR9XG4vLyBpcyBmYWxzZS48L3A+XG4vL1xuLy8gPHA+PGVtYmVkIHNyYz1cImltYWdlcy9GdWxsTWVyZ2VfRW1wdHlSb290cy5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+TXVzdCBrZWVwIGFsbCBjb250ZXh0czsge0BsaW5rIC8vRU1QVFl9IGluIGFycmF5IGlzIGEgc3BlY2lhbCB2YWx1ZSAoYW5kXG4vLyBudWxsIHBhcmVudCkuPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9GdWxsTWVyZ2VfRW1wdHlSb290LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vXG4vLyA8cD48ZW1iZWQgc3JjPVwiaW1hZ2VzL0Z1bGxNZXJnZV9TYW1lUm9vdC5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gQHBhcmFtIGEgdGhlIGZpcnN0IHtAbGluayBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dH1cbi8vIEBwYXJhbSBiIHRoZSBzZWNvbmQge0BsaW5rIFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0fVxuLy8gQHBhcmFtIHJvb3RJc1dpbGRjYXJkIHtAY29kZSB0cnVlfSBpZiB0aGlzIGlzIGEgbG9jYWwtY29udGV4dCBtZXJnZSxcbi8vIG90aGVyd2lzZSBmYWxzZSB0byBpbmRpY2F0ZSBhIGZ1bGwtY29udGV4dCBtZXJnZVxuLy8gL1xuZnVuY3Rpb24gbWVyZ2VSb290KGEsIGIsIHJvb3RJc1dpbGRjYXJkKSB7XG5cdGlmIChyb290SXNXaWxkY2FyZCkge1xuXHRcdGlmIChhID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZOyAvLyAvLyArIGIgPS8vXG5cdFx0fVxuXHRcdGlmIChiID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWSkge1xuXHRcdFx0cmV0dXJuIFByZWRpY3Rpb25Db250ZXh0LkVNUFRZOyAvLyBhICsvLyA9Ly9cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGEgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZICYmIGIgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZKSB7XG5cdFx0XHRyZXR1cm4gUHJlZGljdGlvbkNvbnRleHQuRU1QVFk7IC8vICQgKyAkID0gJFxuXHRcdH0gZWxzZSBpZiAoYSA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHsgLy8gJCArIHggPSBbJCx4XVxuXHRcdFx0dmFyIHBheWxvYWRzID0gWyBiLnJldHVyblN0YXRlLFxuXHRcdFx0XHRcdFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSBdO1xuXHRcdFx0dmFyIHBhcmVudHMgPSBbIGIucGFyZW50Q3R4LCBudWxsIF07XG5cdFx0XHRyZXR1cm4gbmV3IEFycmF5UHJlZGljdGlvbkNvbnRleHQocGFyZW50cywgcGF5bG9hZHMpO1xuXHRcdH0gZWxzZSBpZiAoYiA9PT0gUHJlZGljdGlvbkNvbnRleHQuRU1QVFkpIHsgLy8geCArICQgPSBbJCx4XSAoJCBpcyBhbHdheXMgZmlyc3QgaWYgcHJlc2VudClcblx0XHRcdHZhciBwYXlsb2FkcyA9IFsgYS5yZXR1cm5TdGF0ZSwgUHJlZGljdGlvbkNvbnRleHQuRU1QVFlfUkVUVVJOX1NUQVRFIF07XG5cdFx0XHR2YXIgcGFyZW50cyA9IFsgYS5wYXJlbnRDdHgsIG51bGwgXTtcblx0XHRcdHJldHVybiBuZXcgQXJyYXlQcmVkaWN0aW9uQ29udGV4dChwYXJlbnRzLCBwYXlsb2Fkcyk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG4vL1xuLy8gTWVyZ2UgdHdvIHtAbGluayBBcnJheVByZWRpY3Rpb25Db250ZXh0fSBpbnN0YW5jZXMuXG4vL1xuLy8gPHA+RGlmZmVyZW50IHRvcHMsIGRpZmZlcmVudCBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9EaWZmVG9wRGlmZlBhci5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz48L3A+XG4vL1xuLy8gPHA+U2hhcmVkIHRvcCwgc2FtZSBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9TaGFyZVRvcFNhbWVQYXIuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNoYXJlZCB0b3AsIGRpZmZlcmVudCBwYXJlbnRzLjxicj5cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQXJyYXlNZXJnZV9TaGFyZVRvcERpZmZQYXIuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPlNoYXJlZCB0b3AsIGFsbCBzaGFyZWQgcGFyZW50cy48YnI+XG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL0FycmF5TWVyZ2VfU2hhcmVUb3BTaGFyZVBhci5zdmdcIlxuLy8gdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+PC9wPlxuLy9cbi8vIDxwPkVxdWFsIHRvcHMsIG1lcmdlIHBhcmVudHMgYW5kIHJlZHVjZSB0b3AgdG9cbi8vIHtAbGluayBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dH0uPGJyPlxuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9BcnJheU1lcmdlX0VxdWFsVG9wLnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPjwvcD5cbi8vIC9cbmZ1bmN0aW9uIG1lcmdlQXJyYXlzKGEsIGIsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKSB7XG5cdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0dmFyIHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYSwgYik7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHRcdHByZXZpb3VzID0gbWVyZ2VDYWNoZS5nZXQoYiwgYSk7XG5cdFx0aWYgKHByZXZpb3VzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHR9XG5cdC8vIG1lcmdlIHNvcnRlZCBwYXlsb2FkcyBhICsgYiA9PiBNXG5cdHZhciBpID0gMDsgLy8gd2Fsa3MgYVxuXHR2YXIgaiA9IDA7IC8vIHdhbGtzIGJcblx0dmFyIGsgPSAwOyAvLyB3YWxrcyB0YXJnZXQgTSBhcnJheVxuXG5cdHZhciBtZXJnZWRSZXR1cm5TdGF0ZXMgPSBbXTtcblx0dmFyIG1lcmdlZFBhcmVudHMgPSBbXTtcblx0Ly8gd2FsayBhbmQgbWVyZ2UgdG8geWllbGQgbWVyZ2VkUGFyZW50cywgbWVyZ2VkUmV0dXJuU3RhdGVzXG5cdHdoaWxlIChpIDwgYS5yZXR1cm5TdGF0ZXMubGVuZ3RoICYmIGogPCBiLnJldHVyblN0YXRlcy5sZW5ndGgpIHtcblx0XHR2YXIgYV9wYXJlbnQgPSBhLnBhcmVudHNbaV07XG5cdFx0dmFyIGJfcGFyZW50ID0gYi5wYXJlbnRzW2pdO1xuXHRcdGlmIChhLnJldHVyblN0YXRlc1tpXSA9PT0gYi5yZXR1cm5TdGF0ZXNbal0pIHtcblx0XHRcdC8vIHNhbWUgcGF5bG9hZCAoc3RhY2sgdG9wcyBhcmUgZXF1YWwpLCBtdXN0IHlpZWxkIG1lcmdlZCBzaW5nbGV0b25cblx0XHRcdHZhciBwYXlsb2FkID0gYS5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHQvLyAkKyQgPSAkXG5cdFx0XHR2YXIgYm90aERvbGxhcnMgPSBwYXlsb2FkID09PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUgJiZcblx0XHRcdFx0XHRhX3BhcmVudCA9PT0gbnVsbCAmJiBiX3BhcmVudCA9PT0gbnVsbDtcblx0XHRcdHZhciBheF9heCA9IChhX3BhcmVudCAhPT0gbnVsbCAmJiBiX3BhcmVudCAhPT0gbnVsbCAmJiBhX3BhcmVudCA9PT0gYl9wYXJlbnQpOyAvLyBheCtheFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC0+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYXhcblx0XHRcdGlmIChib3RoRG9sbGFycyB8fCBheF9heCkge1xuXHRcdFx0XHRtZXJnZWRQYXJlbnRzW2tdID0gYV9wYXJlbnQ7IC8vIGNob29zZSBsZWZ0XG5cdFx0XHRcdG1lcmdlZFJldHVyblN0YXRlc1trXSA9IHBheWxvYWQ7XG5cdFx0XHR9IGVsc2UgeyAvLyBheCtheSAtPiBhJ1t4LHldXG5cdFx0XHRcdHZhciBtZXJnZWRQYXJlbnQgPSBtZXJnZShhX3BhcmVudCwgYl9wYXJlbnQsIHJvb3RJc1dpbGRjYXJkLCBtZXJnZUNhY2hlKTtcblx0XHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IG1lcmdlZFBhcmVudDtcblx0XHRcdFx0bWVyZ2VkUmV0dXJuU3RhdGVzW2tdID0gcGF5bG9hZDtcblx0XHRcdH1cblx0XHRcdGkgKz0gMTsgLy8gaG9wIG92ZXIgbGVmdCBvbmUgYXMgdXN1YWxcblx0XHRcdGogKz0gMTsgLy8gYnV0IGFsc28gc2tpcCBvbmUgaW4gcmlnaHQgc2lkZSBzaW5jZSB3ZSBtZXJnZVxuXHRcdH0gZWxzZSBpZiAoYS5yZXR1cm5TdGF0ZXNbaV0gPCBiLnJldHVyblN0YXRlc1tqXSkgeyAvLyBjb3B5IGFbaV0gdG8gTVxuXHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IGFfcGFyZW50O1xuXHRcdFx0bWVyZ2VkUmV0dXJuU3RhdGVzW2tdID0gYS5yZXR1cm5TdGF0ZXNbaV07XG5cdFx0XHRpICs9IDE7XG5cdFx0fSBlbHNlIHsgLy8gYiA+IGEsIGNvcHkgYltqXSB0byBNXG5cdFx0XHRtZXJnZWRQYXJlbnRzW2tdID0gYl9wYXJlbnQ7XG5cdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBiLnJldHVyblN0YXRlc1tqXTtcblx0XHRcdGogKz0gMTtcblx0XHR9XG5cdFx0ayArPSAxO1xuXHR9XG5cdC8vIGNvcHkgb3ZlciBhbnkgcGF5bG9hZHMgcmVtYWluaW5nIGluIGVpdGhlciBhcnJheVxuXHRpZiAoaSA8IGEucmV0dXJuU3RhdGVzLmxlbmd0aCkge1xuXHRcdGZvciAodmFyIHAgPSBpOyBwIDwgYS5yZXR1cm5TdGF0ZXMubGVuZ3RoOyBwKyspIHtcblx0XHRcdG1lcmdlZFBhcmVudHNba10gPSBhLnBhcmVudHNbcF07XG5cdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNba10gPSBhLnJldHVyblN0YXRlc1twXTtcblx0XHRcdGsgKz0gMTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yICh2YXIgcCA9IGo7IHAgPCBiLnJldHVyblN0YXRlcy5sZW5ndGg7IHArKykge1xuXHRcdFx0bWVyZ2VkUGFyZW50c1trXSA9IGIucGFyZW50c1twXTtcblx0XHRcdG1lcmdlZFJldHVyblN0YXRlc1trXSA9IGIucmV0dXJuU3RhdGVzW3BdO1xuXHRcdFx0ayArPSAxO1xuXHRcdH1cblx0fVxuXHQvLyB0cmltIG1lcmdlZCBpZiB3ZSBjb21iaW5lZCBhIGZldyB0aGF0IGhhZCBzYW1lIHN0YWNrIHRvcHNcblx0aWYgKGsgPCBtZXJnZWRQYXJlbnRzLmxlbmd0aCkgeyAvLyB3cml0ZSBpbmRleCA8IGxhc3QgcG9zaXRpb247IHRyaW1cblx0XHRpZiAoayA9PT0gMSkgeyAvLyBmb3IganVzdCBvbmUgbWVyZ2VkIGVsZW1lbnQsIHJldHVybiBzaW5nbGV0b24gdG9wXG5cdFx0XHR2YXIgYV8gPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dC5jcmVhdGUobWVyZ2VkUGFyZW50c1swXSxcblx0XHRcdFx0XHRtZXJnZWRSZXR1cm5TdGF0ZXNbMF0pO1xuXHRcdFx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRcdFx0bWVyZ2VDYWNoZS5zZXQoYSwgYiwgYV8pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFfO1xuXHRcdH1cblx0XHRtZXJnZWRQYXJlbnRzID0gbWVyZ2VkUGFyZW50cy5zbGljZSgwLCBrKTtcblx0XHRtZXJnZWRSZXR1cm5TdGF0ZXMgPSBtZXJnZWRSZXR1cm5TdGF0ZXMuc2xpY2UoMCwgayk7XG5cdH1cblxuXHR2YXIgTSA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KG1lcmdlZFBhcmVudHMsIG1lcmdlZFJldHVyblN0YXRlcyk7XG5cblx0Ly8gaWYgd2UgY3JlYXRlZCBzYW1lIGFycmF5IGFzIGEgb3IgYiwgcmV0dXJuIHRoYXQgaW5zdGVhZFxuXHQvLyBUT0RPOiB0cmFjayB3aGV0aGVyIHRoaXMgaXMgcG9zc2libGUgYWJvdmUgZHVyaW5nIG1lcmdlIHNvcnQgZm9yIHNwZWVkXG5cdGlmIChNID09PSBhKSB7XG5cdFx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRcdG1lcmdlQ2FjaGUuc2V0KGEsIGIsIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fVxuXHRpZiAoTSA9PT0gYikge1xuXHRcdGlmIChtZXJnZUNhY2hlICE9PSBudWxsKSB7XG5cdFx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBiKTtcblx0XHR9XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0Y29tYmluZUNvbW1vblBhcmVudHMobWVyZ2VkUGFyZW50cyk7XG5cblx0aWYgKG1lcmdlQ2FjaGUgIT09IG51bGwpIHtcblx0XHRtZXJnZUNhY2hlLnNldChhLCBiLCBNKTtcblx0fVxuXHRyZXR1cm4gTTtcbn1cblxuLy9cbi8vIE1ha2UgcGFzcyBvdmVyIGFsbCA8ZW0+TTwvZW0+IHtAY29kZSBwYXJlbnRzfTsgbWVyZ2UgYW55IHtAY29kZSBlcXVhbHMoKX1cbi8vIG9uZXMuXG4vLyAvXG5mdW5jdGlvbiBjb21iaW5lQ29tbW9uUGFyZW50cyhwYXJlbnRzKSB7XG5cdHZhciB1bmlxdWVQYXJlbnRzID0gbmV3IE1hcCgpO1xuXG5cdGZvciAodmFyIHAgPSAwOyBwIDwgcGFyZW50cy5sZW5ndGg7IHArKykge1xuXHRcdHZhciBwYXJlbnQgPSBwYXJlbnRzW3BdO1xuXHRcdGlmICghKHVuaXF1ZVBhcmVudHMuY29udGFpbnNLZXkocGFyZW50KSkpIHtcblx0XHRcdHVuaXF1ZVBhcmVudHMucHV0KHBhcmVudCwgcGFyZW50KTtcblx0XHR9XG5cdH1cblx0Zm9yICh2YXIgcSA9IDA7IHEgPCBwYXJlbnRzLmxlbmd0aDsgcSsrKSB7XG5cdFx0cGFyZW50c1txXSA9IHVuaXF1ZVBhcmVudHMuZ2V0KHBhcmVudHNbcV0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQsIGNvbnRleHRDYWNoZSwgdmlzaXRlZCkge1xuXHRpZiAoY29udGV4dC5pc0VtcHR5KCkpIHtcblx0XHRyZXR1cm4gY29udGV4dDtcblx0fVxuXHR2YXIgZXhpc3RpbmcgPSB2aXNpdGVkLmdldChjb250ZXh0KSB8fCBudWxsO1xuXHRpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gZXhpc3Rpbmc7XG5cdH1cblx0ZXhpc3RpbmcgPSBjb250ZXh0Q2FjaGUuZ2V0KGNvbnRleHQpO1xuXHRpZiAoZXhpc3RpbmcgIT09IG51bGwpIHtcblx0XHR2aXNpdGVkLnB1dChjb250ZXh0LCBleGlzdGluZyk7XG5cdFx0cmV0dXJuIGV4aXN0aW5nO1xuXHR9XG5cdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cdHZhciBwYXJlbnRzID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBwYXJlbnQgPSBnZXRDYWNoZWRQcmVkaWN0aW9uQ29udGV4dChjb250ZXh0LmdldFBhcmVudChpKSwgY29udGV4dENhY2hlLCB2aXNpdGVkKTtcblx0XHRpZiAoY2hhbmdlZCB8fCBwYXJlbnQgIT09IGNvbnRleHQuZ2V0UGFyZW50KGkpKSB7XG5cdFx0XHRpZiAoIWNoYW5nZWQpIHtcblx0XHRcdFx0cGFyZW50cyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRleHQubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRwYXJlbnRzW2pdID0gY29udGV4dC5nZXRQYXJlbnQoaik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnRzW2ldID0gcGFyZW50O1xuXHRcdH1cblx0fVxuXHRpZiAoIWNoYW5nZWQpIHtcblx0XHRjb250ZXh0Q2FjaGUuYWRkKGNvbnRleHQpO1xuXHRcdHZpc2l0ZWQucHV0KGNvbnRleHQsIGNvbnRleHQpO1xuXHRcdHJldHVybiBjb250ZXh0O1xuXHR9XG5cdHZhciB1cGRhdGVkID0gbnVsbDtcblx0aWYgKHBhcmVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0dXBkYXRlZCA9IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZO1xuXHR9IGVsc2UgaWYgKHBhcmVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0dXBkYXRlZCA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShwYXJlbnRzWzBdLCBjb250ZXh0XG5cdFx0XHRcdC5nZXRSZXR1cm5TdGF0ZSgwKSk7XG5cdH0gZWxzZSB7XG5cdFx0dXBkYXRlZCA9IG5ldyBBcnJheVByZWRpY3Rpb25Db250ZXh0KHBhcmVudHMsIGNvbnRleHQucmV0dXJuU3RhdGVzKTtcblx0fVxuXHRjb250ZXh0Q2FjaGUuYWRkKHVwZGF0ZWQpO1xuXHR2aXNpdGVkLnB1dCh1cGRhdGVkLCB1cGRhdGVkKTtcblx0dmlzaXRlZC5wdXQoY29udGV4dCwgdXBkYXRlZCk7XG5cblx0cmV0dXJuIHVwZGF0ZWQ7XG59XG5cbi8vIHRlcidzIHJlY3Vyc2l2ZSB2ZXJzaW9uIG9mIFNhbSdzIGdldEFsbE5vZGVzKClcbmZ1bmN0aW9uIGdldEFsbENvbnRleHROb2Rlcyhjb250ZXh0LCBub2RlcywgdmlzaXRlZCkge1xuXHRpZiAobm9kZXMgPT09IG51bGwpIHtcblx0XHRub2RlcyA9IFtdO1xuXHRcdHJldHVybiBnZXRBbGxDb250ZXh0Tm9kZXMoY29udGV4dCwgbm9kZXMsIHZpc2l0ZWQpO1xuXHR9IGVsc2UgaWYgKHZpc2l0ZWQgPT09IG51bGwpIHtcblx0XHR2aXNpdGVkID0gbmV3IE1hcCgpO1xuXHRcdHJldHVybiBnZXRBbGxDb250ZXh0Tm9kZXMoY29udGV4dCwgbm9kZXMsIHZpc2l0ZWQpO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChjb250ZXh0ID09PSBudWxsIHx8IHZpc2l0ZWQuY29udGFpbnNLZXkoY29udGV4dCkpIHtcblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9XG5cdFx0dmlzaXRlZC5wdXQoY29udGV4dCwgY29udGV4dCk7XG5cdFx0bm9kZXMucHVzaChjb250ZXh0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGdldEFsbENvbnRleHROb2Rlcyhjb250ZXh0LmdldFBhcmVudChpKSwgbm9kZXMsIHZpc2l0ZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZXM7XG5cdH1cbn1cblxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dCA9IFByZWRpY3Rpb25Db250ZXh0O1xuZXhwb3J0cy5QcmVkaWN0aW9uQ29udGV4dENhY2hlID0gUHJlZGljdGlvbkNvbnRleHRDYWNoZTtcbmV4cG9ydHMuU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQgPSBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcbmV4cG9ydHMucHJlZGljdGlvbkNvbnRleHRGcm9tUnVsZUNvbnRleHQgPSBwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dDtcbmV4cG9ydHMuZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHQgPSBnZXRDYWNoZWRQcmVkaWN0aW9uQ29udGV4dDtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuL1Rva2VuJykuVG9rZW47XG52YXIgQ29uc29sZUVycm9yTGlzdGVuZXIgPSByZXF1aXJlKCcuL2Vycm9yL0Vycm9yTGlzdGVuZXInKS5Db25zb2xlRXJyb3JMaXN0ZW5lcjtcbnZhciBQcm94eUVycm9yTGlzdGVuZXIgPSByZXF1aXJlKCcuL2Vycm9yL0Vycm9yTGlzdGVuZXInKS5Qcm94eUVycm9yTGlzdGVuZXI7XG5cbmZ1bmN0aW9uIFJlY29nbml6ZXIoKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gWyBDb25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRSBdO1xuICAgIHRoaXMuX2ludGVycCA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGVOdW1iZXIgPSAtMTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUmVjb2duaXplci50b2tlblR5cGVNYXBDYWNoZSA9IHt9O1xuUmVjb2duaXplci5ydWxlSW5kZXhNYXBDYWNoZSA9IHt9O1xuXG5cblJlY29nbml6ZXIucHJvdG90eXBlLmNoZWNrVmVyc2lvbiA9IGZ1bmN0aW9uKHRvb2xWZXJzaW9uKSB7XG4gICAgdmFyIHJ1bnRpbWVWZXJzaW9uID0gXCI0LjhcIjtcbiAgICBpZiAocnVudGltZVZlcnNpb24hPT10b29sVmVyc2lvbikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFOVExSIHJ1bnRpbWUgYW5kIGdlbmVyYXRlZCBjb2RlIHZlcnNpb25zIGRpc2FncmVlOiBcIitydW50aW1lVmVyc2lvbitcIiE9XCIrdG9vbFZlcnNpb24pO1xuICAgIH1cbn07XG5cblJlY29nbml6ZXIucHJvdG90eXBlLmFkZEVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbn07XG5cblJlY29nbml6ZXIucHJvdG90eXBlLnJlbW92ZUVycm9yTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb2tlblR5cGVNYXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9rZW5OYW1lcyA9IHRoaXMuZ2V0VG9rZW5OYW1lcygpO1xuICAgIGlmICh0b2tlbk5hbWVzPT09bnVsbCkge1xuICAgICAgICB0aHJvdyhcIlRoZSBjdXJyZW50IHJlY29nbml6ZXIgZG9lcyBub3QgcHJvdmlkZSBhIGxpc3Qgb2YgdG9rZW4gbmFtZXMuXCIpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy50b2tlblR5cGVNYXBDYWNoZVt0b2tlbk5hbWVzXTtcbiAgICBpZihyZXN1bHQ9PT11bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ID0gdG9rZW5OYW1lcy5yZWR1Y2UoZnVuY3Rpb24obywgaywgaSkgeyBvW2tdID0gaTsgfSk7XG4gICAgICAgIHJlc3VsdC5FT0YgPSBUb2tlbi5FT0Y7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlTWFwQ2FjaGVbdG9rZW5OYW1lc10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBHZXQgYSBtYXAgZnJvbSBydWxlIG5hbWVzIHRvIHJ1bGUgaW5kZXhlcy5cbi8vXG4vLyA8cD5Vc2VkIGZvciBYUGF0aCBhbmQgdHJlZSBwYXR0ZXJuIGNvbXBpbGF0aW9uLjwvcD5cbi8vXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRSdWxlSW5kZXhNYXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcnVsZU5hbWVzID0gdGhpcy5ydWxlTmFtZXM7XG4gICAgaWYgKHJ1bGVOYW1lcz09PW51bGwpIHtcbiAgICAgICAgdGhyb3coXCJUaGUgY3VycmVudCByZWNvZ25pemVyIGRvZXMgbm90IHByb3ZpZGUgYSBsaXN0IG9mIHJ1bGUgbmFtZXMuXCIpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ydWxlSW5kZXhNYXBDYWNoZVtydWxlTmFtZXNdO1xuICAgIGlmKHJlc3VsdD09PXVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSBydWxlTmFtZXMucmVkdWNlKGZ1bmN0aW9uKG8sIGssIGkpIHsgb1trXSA9IGk7IH0pO1xuICAgICAgICB0aGlzLnJ1bGVJbmRleE1hcENhY2hlW3J1bGVOYW1lc10gPSByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb2tlblR5cGUgPSBmdW5jdGlvbih0b2tlbk5hbWUpIHtcbiAgICB2YXIgdHR5cGUgPSB0aGlzLmdldFRva2VuVHlwZU1hcCgpW3Rva2VuTmFtZV07XG4gICAgaWYgKHR0eXBlICE9PXVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFRva2VuLklOVkFMSURfVFlQRTtcbiAgICB9XG59O1xuXG5cbi8vIFdoYXQgaXMgdGhlIGVycm9yIGhlYWRlciwgbm9ybWFsbHkgbGluZS9jaGFyYWN0ZXIgcG9zaXRpb24gaW5mb3JtYXRpb24/Ly9cblJlY29nbml6ZXIucHJvdG90eXBlLmdldEVycm9ySGVhZGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBsaW5lID0gZS5nZXRPZmZlbmRpbmdUb2tlbigpLmxpbmU7XG4gICAgdmFyIGNvbHVtbiA9IGUuZ2V0T2ZmZW5kaW5nVG9rZW4oKS5jb2x1bW47XG4gICAgcmV0dXJuIFwibGluZSBcIiArIGxpbmUgKyBcIjpcIiArIGNvbHVtbjtcbn07XG5cblxuLy8gSG93IHNob3VsZCBhIHRva2VuIGJlIGRpc3BsYXllZCBpbiBhbiBlcnJvciBtZXNzYWdlPyBUaGUgZGVmYXVsdFxuLy8gIGlzIHRvIGRpc3BsYXkganVzdCB0aGUgdGV4dCwgYnV0IGR1cmluZyBkZXZlbG9wbWVudCB5b3UgbWlnaHRcbi8vICB3YW50IHRvIGhhdmUgYSBsb3Qgb2YgaW5mb3JtYXRpb24gc3BpdCBvdXQuICBPdmVycmlkZSBpbiB0aGF0IGNhc2Vcbi8vICB0byB1c2UgdC50b1N0cmluZygpICh3aGljaCwgZm9yIENvbW1vblRva2VuLCBkdW1wcyBldmVyeXRoaW5nIGFib3V0XG4vLyAgdGhlIHRva2VuKS4gVGhpcyBpcyBiZXR0ZXIgdGhhbiBmb3JjaW5nIHlvdSB0byBvdmVycmlkZSBhIG1ldGhvZCBpblxuLy8gIHlvdXIgdG9rZW4gb2JqZWN0cyBiZWNhdXNlIHlvdSBkb24ndCBoYXZlIHRvIGdvIG1vZGlmeSB5b3VyIGxleGVyXG4vLyAgc28gdGhhdCBpdCBjcmVhdGVzIGEgbmV3IEphdmEgdHlwZS5cbi8vXG4vLyBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGJ5IHRoZSBBTlRMUiA0IFJ1bnRpbWUuIFNwZWNpZmljXG4vLyBpbXBsZW1lbnRhdGlvbnMgb2Yge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneX0gbWF5IHByb3ZpZGUgYSBzaW1pbGFyXG4vLyBmZWF0dXJlIHdoZW4gbmVjZXNzYXJ5LiBGb3IgZXhhbXBsZSwgc2VlXG4vLyB7QGxpbmsgRGVmYXVsdEVycm9yU3RyYXRlZ3kvL2dldFRva2VuRXJyb3JEaXNwbGF5fS5cbi8vXG5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb2tlbkVycm9yRGlzcGxheSA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodD09PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiPG5vIHRva2VuPlwiO1xuICAgIH1cbiAgICB2YXIgcyA9IHQudGV4dDtcbiAgICBpZiAocz09PW51bGwpIHtcbiAgICAgICAgaWYgKHQudHlwZT09PVRva2VuLkVPRikge1xuICAgICAgICAgICAgcyA9IFwiPEVPRj5cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBcIjxcIiArIHQudHlwZSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHMgPSBzLnJlcGxhY2UoXCJcXG5cIixcIlxcXFxuXCIpLnJlcGxhY2UoXCJcXHJcIixcIlxcXFxyXCIpLnJlcGxhY2UoXCJcXHRcIixcIlxcXFx0XCIpO1xuICAgIHJldHVybiBcIidcIiArIHMgKyBcIidcIjtcbn07XG5cblJlY29nbml6ZXIucHJvdG90eXBlLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJveHlFcnJvckxpc3RlbmVyKHRoaXMuX2xpc3RlbmVycyk7XG59O1xuXG4vLyBzdWJjbGFzcyBuZWVkcyB0byBvdmVycmlkZSB0aGVzZSBpZiB0aGVyZSBhcmUgc2VtcHJlZHMgb3IgYWN0aW9uc1xuLy8gdGhhdCB0aGUgQVROIGludGVycCBuZWVkcyB0byBleGVjdXRlXG5SZWNvZ25pemVyLnByb3RvdHlwZS5zZW1wcmVkID0gZnVuY3Rpb24obG9jYWxjdHgsIHJ1bGVJbmRleCwgYWN0aW9uSW5kZXgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY29nbml6ZXIucHJvdG90eXBlLnByZWNwcmVkID0gZnVuY3Rpb24obG9jYWxjdHggLCBwcmVjZWRlbmNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vL0luZGljYXRlIHRoYXQgdGhlIHJlY29nbml6ZXIgaGFzIGNoYW5nZWQgaW50ZXJuYWwgc3RhdGUgdGhhdCBpc1xuLy9jb25zaXN0ZW50IHdpdGggdGhlIEFUTiBzdGF0ZSBwYXNzZWQgaW4uICBUaGlzIHdheSB3ZSBhbHdheXMga25vd1xuLy93aGVyZSB3ZSBhcmUgaW4gdGhlIEFUTiBhcyB0aGUgcGFyc2VyIGdvZXMgYWxvbmcuIFRoZSBydWxlXG4vL2NvbnRleHQgb2JqZWN0cyBmb3JtIGEgc3RhY2sgdGhhdCBsZXRzIHVzIHNlZSB0aGUgc3RhY2sgb2Zcbi8vaW52b2tpbmcgcnVsZXMuIENvbWJpbmUgdGhpcyBhbmQgd2UgaGF2ZSBjb21wbGV0ZSBBVE5cbi8vY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbi5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlY29nbml6ZXIucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0YXRlTnVtYmVyO1xuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdHRoaXMuX3N0YXRlTnVtYmVyID0gc3RhdGU7XG5cdH1cbn0pO1xuXG5cbmV4cG9ydHMuUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gIEEgcnVsZSBjb250ZXh0IGlzIGEgcmVjb3JkIG9mIGEgc2luZ2xlIHJ1bGUgaW52b2NhdGlvbi4gSXQga25vd3Ncbi8vICB3aGljaCBjb250ZXh0IGludm9rZWQgaXQsIGlmIGFueS4gSWYgdGhlcmUgaXMgbm8gcGFyZW50IGNvbnRleHQsIHRoZW5cbi8vICBuYXR1cmFsbHkgdGhlIGludm9raW5nIHN0YXRlIGlzIG5vdCB2YWxpZC4gIFRoZSBwYXJlbnQgbGlua1xuLy8gIHByb3ZpZGVzIGEgY2hhaW4gdXB3YXJkcyBmcm9tIHRoZSBjdXJyZW50IHJ1bGUgaW52b2NhdGlvbiB0byB0aGUgcm9vdFxuLy8gIG9mIHRoZSBpbnZvY2F0aW9uIHRyZWUsIGZvcm1pbmcgYSBzdGFjay4gV2UgYWN0dWFsbHkgY2Fycnkgbm9cbi8vICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0IChleGNlcHRcbi8vICB3aGVuIHBhcnNpbmcpLiBXZSBrZWVwIG9ubHkgdGhlIHN0YXRlIG51bWJlciBvZiB0aGUgaW52b2tpbmcgc3RhdGUgZnJvbVxuLy8gIHRoZSBBVE4gc3VibWFjaGluZSB0aGF0IGludm9rZWQgdGhpcy4gQ29udHJhc3QgdGhpcyB3aXRoIHRoZSBzXG4vLyAgcG9pbnRlciBpbnNpZGUgUGFyc2VyUnVsZUNvbnRleHQgdGhhdCB0cmFja3MgdGhlIGN1cnJlbnQgc3RhdGVcbi8vICBiZWluZyBcImV4ZWN1dGVkXCIgZm9yIHRoZSBjdXJyZW50IHJ1bGUuXG4vL1xuLy8gIFRoZSBwYXJlbnQgY29udGV4dHMgYXJlIHVzZWZ1bCBmb3IgY29tcHV0aW5nIGxvb2thaGVhZCBzZXRzIGFuZFxuLy8gIGdldHRpbmcgZXJyb3IgaW5mb3JtYXRpb24uXG4vL1xuLy8gIFRoZXNlIG9iamVjdHMgYXJlIHVzZWQgZHVyaW5nIHBhcnNpbmcgYW5kIHByZWRpY3Rpb24uXG4vLyAgRm9yIHRoZSBzcGVjaWFsIGNhc2Ugb2YgcGFyc2Vycywgd2UgdXNlIHRoZSBzdWJjbGFzc1xuLy8gIFBhcnNlclJ1bGVDb250ZXh0LlxuLy9cbi8vICBAc2VlIFBhcnNlclJ1bGVDb250ZXh0XG4vLy9cblxudmFyIFJ1bGVOb2RlID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKS5SdWxlTm9kZTtcbnZhciBJTlZBTElEX0lOVEVSVkFMID0gcmVxdWlyZSgnLi90cmVlL1RyZWUnKS5JTlZBTElEX0lOVEVSVkFMO1xudmFyIElOVkFMSURfQUxUX05VTUJFUiA9IHJlcXVpcmUoJy4vYXRuL0FUTicpLklOVkFMSURfQUxUX05VTUJFUjtcblxuZnVuY3Rpb24gUnVsZUNvbnRleHQocGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XG5cdFJ1bGVOb2RlLmNhbGwodGhpcyk7XG5cdC8vIFdoYXQgY29udGV4dCBpbnZva2VkIHRoaXMgcnVsZT9cblx0dGhpcy5wYXJlbnRDdHggPSBwYXJlbnQgfHwgbnVsbDtcblx0Ly8gV2hhdCBzdGF0ZSBpbnZva2VkIHRoZSBydWxlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRleHQ/XG5cdC8vIFRoZSBcInJldHVybiBhZGRyZXNzXCIgaXMgdGhlIGZvbGxvd1N0YXRlIG9mIGludm9raW5nU3RhdGVcblx0Ly8gSWYgcGFyZW50IGlzIG51bGwsIHRoaXMgc2hvdWxkIGJlIC0xLlxuXHR0aGlzLmludm9raW5nU3RhdGUgPSBpbnZva2luZ1N0YXRlIHx8IC0xO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUnVsZUNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSdWxlTm9kZS5wcm90b3R5cGUpO1xuUnVsZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVsZUNvbnRleHQ7XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgbiA9IDA7XG5cdHZhciBwID0gdGhpcztcblx0d2hpbGUgKHAgIT09IG51bGwpIHtcblx0XHRwID0gcC5wYXJlbnRDdHg7XG5cdFx0biArPSAxO1xuXHR9XG5cdHJldHVybiBuO1xufTtcblxuLy8gQSBjb250ZXh0IGlzIGVtcHR5IGlmIHRoZXJlIGlzIG5vIGludm9raW5nIHN0YXRlOyBtZWFuaW5nIG5vYm9keSBjYWxsXG4vLyBjdXJyZW50IGNvbnRleHQuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5pbnZva2luZ1N0YXRlID09PSAtMTtcbn07XG5cbi8vIHNhdGlzZnkgdGhlIFBhcnNlVHJlZSAvIFN5bnRheFRyZWUgaW50ZXJmYWNlXG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRTb3VyY2VJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gSU5WQUxJRF9JTlRFUlZBTDtcbn07XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRSdWxlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn07XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRQYXlsb2FkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLy8gUmV0dXJuIHRoZSBjb21iaW5lZCB0ZXh0IG9mIGFsbCBjaGlsZCBub2Rlcy4gVGhpcyBtZXRob2Qgb25seSBjb25zaWRlcnNcbi8vIHRva2VucyB3aGljaCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHBhcnNlIHRyZWUuXG4vLyA8cD5cbi8vIFNpbmNlIHRva2VucyBvbiBoaWRkZW4gY2hhbm5lbHMgKGUuZy4gd2hpdGVzcGFjZSBvciBjb21tZW50cykgYXJlIG5vdFxuLy8gYWRkZWQgdG8gdGhlIHBhcnNlIHRyZWVzLCB0aGV5IHdpbGwgbm90IGFwcGVhciBpbiB0aGUgb3V0cHV0IG9mIHRoaXNcbi8vIG1ldGhvZC5cbi8vIC9cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmdldENoaWxkQ291bnQoKSA9PT0gMCkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0cmV0dXJuIGNoaWxkLmdldFRleHQoKTtcblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9XG59O1xuXG4vLyBGb3IgcnVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBwYXJzZSB0cmVlIGludGVybmFsIG5vZGUsIHJldHVyblxuLy8gdGhlIG91dGVyIGFsdGVybmF0aXZlIG51bWJlciB1c2VkIHRvIG1hdGNoIHRoZSBpbnB1dC4gRGVmYXVsdFxuLy8gaW1wbGVtZW50YXRpb24gZG9lcyBub3QgY29tcHV0ZSBub3Igc3RvcmUgdGhpcyBhbHQgbnVtLiBDcmVhdGVcbi8vIGEgc3ViY2xhc3Mgb2YgUGFyc2VyUnVsZUNvbnRleHQgd2l0aCBiYWNraW5nIGZpZWxkIGFuZCBzZXRcbi8vIG9wdGlvbiBjb250ZXh0U3VwZXJDbGFzcy5cbi8vIHRvIHNldCBpdC5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRBbHROdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIElOVkFMSURfQUxUX05VTUJFUjsgfVxuXG4vLyBTZXQgdGhlIG91dGVyIGFsdGVybmF0aXZlIG51bWJlciBmb3IgdGhpcyBjb250ZXh0IG5vZGUuIERlZmF1bHRcbi8vIGltcGxlbWVudGF0aW9uIGRvZXMgbm90aGluZyB0byBhdm9pZCBiYWNraW5nIGZpZWxkIG92ZXJoZWFkIGZvclxuLy8gdHJlZXMgdGhhdCBkb24ndCBuZWVkIGl0LiAgQ3JlYXRlXG4vLyBhIHN1YmNsYXNzIG9mIFBhcnNlclJ1bGVDb250ZXh0IHdpdGggYmFja2luZyBmaWVsZCBhbmQgc2V0XG4vLyBvcHRpb24gY29udGV4dFN1cGVyQ2xhc3MuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUuc2V0QWx0TnVtYmVyID0gZnVuY3Rpb24oYWx0TnVtYmVyKSB7IH1cblxuUnVsZUNvbnRleHQucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24oaSkge1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cblJ1bGVDb250ZXh0LnByb3RvdHlwZS5nZXRDaGlsZENvdW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAwO1xufTtcblxuUnVsZUNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcblx0cmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcbn07XG5cbi8vbmVlZCB0byBtYW5hZ2UgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLCBzbyBleHBvcnQgbm93XG5leHBvcnRzLlJ1bGVDb250ZXh0ID0gUnVsZUNvbnRleHQ7XG52YXIgVHJlZXMgPSByZXF1aXJlKCcuL3RyZWUvVHJlZXMnKS5UcmVlcztcblxuXG4vLyBQcmludCBvdXQgYSB3aG9sZSB0cmVlLCBub3QganVzdCBhIG5vZGUsIGluIExJU1AgZm9ybWF0XG4vLyAocm9vdCBjaGlsZDEgLi4gY2hpbGROKS4gUHJpbnQganVzdCBhIG5vZGUgaWYgdGhpcyBpcyBhIGxlYWYuXG4vL1xuXG5SdWxlQ29udGV4dC5wcm90b3R5cGUudG9TdHJpbmdUcmVlID0gZnVuY3Rpb24ocnVsZU5hbWVzLCByZWNvZykge1xuXHRyZXR1cm4gVHJlZXMudG9TdHJpbmdUcmVlKHRoaXMsIHJ1bGVOYW1lcywgcmVjb2cpO1xufTtcblxuUnVsZUNvbnRleHQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ocnVsZU5hbWVzLCBzdG9wKSB7XG5cdHJ1bGVOYW1lcyA9IHJ1bGVOYW1lcyB8fCBudWxsO1xuXHRzdG9wID0gc3RvcCB8fCBudWxsO1xuXHR2YXIgcCA9IHRoaXM7XG5cdHZhciBzID0gXCJbXCI7XG5cdHdoaWxlIChwICE9PSBudWxsICYmIHAgIT09IHN0b3ApIHtcblx0XHRpZiAocnVsZU5hbWVzID09PSBudWxsKSB7XG5cdFx0XHRpZiAoIXAuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdHMgKz0gcC5pbnZva2luZ1N0YXRlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcmkgPSBwLnJ1bGVJbmRleDtcblx0XHRcdHZhciBydWxlTmFtZSA9IChyaSA+PSAwICYmIHJpIDwgcnVsZU5hbWVzLmxlbmd0aCkgPyBydWxlTmFtZXNbcmldXG5cdFx0XHRcdFx0OiBcIlwiICsgcmk7XG5cdFx0XHRzICs9IHJ1bGVOYW1lO1xuXHRcdH1cblx0XHRpZiAocC5wYXJlbnRDdHggIT09IG51bGwgJiYgKHJ1bGVOYW1lcyAhPT0gbnVsbCB8fCAhcC5wYXJlbnRDdHguaXNFbXB0eSgpKSkge1xuXHRcdFx0cyArPSBcIiBcIjtcblx0XHR9XG5cdFx0cCA9IHAucGFyZW50Q3R4O1xuXHR9XG5cdHMgKz0gXCJdXCI7XG5cdHJldHVybiBzO1xufTtcblxuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy8gQSB0b2tlbiBoYXMgcHJvcGVydGllczogdGV4dCwgdHlwZSwgbGluZSwgY2hhcmFjdGVyIHBvc2l0aW9uIGluIHRoZSBsaW5lXG4vLyAoc28gd2UgY2FuIGlnbm9yZSB0YWJzKSwgdG9rZW4gY2hhbm5lbCwgaW5kZXgsIGFuZCBzb3VyY2UgZnJvbSB3aGljaFxuLy8gd2Ugb2J0YWluZWQgdGhpcyB0b2tlbi5cblxuZnVuY3Rpb24gVG9rZW4oKSB7XG5cdHRoaXMuc291cmNlID0gbnVsbDtcblx0dGhpcy50eXBlID0gbnVsbDsgLy8gdG9rZW4gdHlwZSBvZiB0aGUgdG9rZW5cblx0dGhpcy5jaGFubmVsID0gbnVsbDsgLy8gVGhlIHBhcnNlciBpZ25vcmVzIGV2ZXJ5dGhpbmcgbm90IG9uIERFRkFVTFRfQ0hBTk5FTFxuXHR0aGlzLnN0YXJ0ID0gbnVsbDsgLy8gb3B0aW9uYWw7IHJldHVybiAtMSBpZiBub3QgaW1wbGVtZW50ZWQuXG5cdHRoaXMuc3RvcCA9IG51bGw7IC8vIG9wdGlvbmFsOyByZXR1cm4gLTEgaWYgbm90IGltcGxlbWVudGVkLlxuXHR0aGlzLnRva2VuSW5kZXggPSBudWxsOyAvLyBmcm9tIDAuLm4tMSBvZiB0aGUgdG9rZW4gb2JqZWN0IGluIHRoZSBpbnB1dCBzdHJlYW1cblx0dGhpcy5saW5lID0gbnVsbDsgLy8gbGluZT0xLi5uIG9mIHRoZSAxc3QgY2hhcmFjdGVyXG5cdHRoaXMuY29sdW1uID0gbnVsbDsgLy8gYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGF0IHdoaWNoIGl0IG9jY3VycywgMC4ubi0xXG5cdHRoaXMuX3RleHQgPSBudWxsOyAvLyB0ZXh0IG9mIHRoZSB0b2tlbi5cblx0cmV0dXJuIHRoaXM7XG59XG5cblRva2VuLklOVkFMSURfVFlQRSA9IDA7XG5cbi8vIER1cmluZyBsb29rYWhlYWQgb3BlcmF0aW9ucywgdGhpcyBcInRva2VuXCIgc2lnbmlmaWVzIHdlIGhpdCBydWxlIGVuZCBBVE4gc3RhdGVcbi8vIGFuZCBkaWQgbm90IGZvbGxvdyBpdCBkZXNwaXRlIG5lZWRpbmcgdG8uXG5Ub2tlbi5FUFNJTE9OID0gLTI7XG5cblRva2VuLk1JTl9VU0VSX1RPS0VOX1RZUEUgPSAxO1xuXG5Ub2tlbi5FT0YgPSAtMTtcblxuLy8gQWxsIHRva2VucyBnbyB0byB0aGUgcGFyc2VyICh1bmxlc3Mgc2tpcCgpIGlzIGNhbGxlZCBpbiB0aGF0IHJ1bGUpXG4vLyBvbiBhIHBhcnRpY3VsYXIgXCJjaGFubmVsXCIuIFRoZSBwYXJzZXIgdHVuZXMgdG8gYSBwYXJ0aWN1bGFyIGNoYW5uZWxcbi8vIHNvIHRoYXQgd2hpdGVzcGFjZSBldGMuLi4gY2FuIGdvIHRvIHRoZSBwYXJzZXIgb24gYSBcImhpZGRlblwiIGNoYW5uZWwuXG5cblRva2VuLkRFRkFVTFRfQ0hBTk5FTCA9IDA7XG5cbi8vIEFueXRoaW5nIG9uIGRpZmZlcmVudCBjaGFubmVsIHRoYW4gREVGQVVMVF9DSEFOTkVMIGlzIG5vdCBwYXJzZWRcbi8vIGJ5IHBhcnNlci5cblxuVG9rZW4uSElEREVOX0NIQU5ORUwgPSAxO1xuXG4vLyBFeHBsaWNpdGx5IHNldCB0aGUgdGV4dCBmb3IgdGhpcyB0b2tlbi4gSWYge2NvZGUgdGV4dH0gaXMgbm90XG4vLyB7QGNvZGUgbnVsbH0sIHRoZW4ge0BsaW5rIC8vZ2V0VGV4dH0gd2lsbCByZXR1cm4gdGhpcyB2YWx1ZSByYXRoZXIgdGhhblxuLy8gZXh0cmFjdGluZyB0aGUgdGV4dCBmcm9tIHRoZSBpbnB1dC5cbi8vXG4vLyBAcGFyYW0gdGV4dCBUaGUgZXhwbGljaXQgdGV4dCBvZiB0aGUgdG9rZW4sIG9yIHtAY29kZSBudWxsfSBpZiB0aGUgdGV4dFxuLy8gc2hvdWxkIGJlIG9idGFpbmVkIGZyb20gdGhlIGlucHV0IGFsb25nIHdpdGggdGhlIHN0YXJ0IGFuZCBzdG9wIGluZGV4ZXNcbi8vIG9mIHRoZSB0b2tlbi5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFRva2VuLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHtcblx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RleHQ7XG5cdH0sXG5cdHNldCA6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR0aGlzLl90ZXh0ID0gdGV4dDtcblx0fVxufSk7XG5cblRva2VuLnByb3RvdHlwZS5nZXRUb2tlblNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5zb3VyY2VbMF07XG59O1xuXG5Ub2tlbi5wcm90b3R5cGUuZ2V0SW5wdXRTdHJlYW0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc291cmNlWzFdO1xufTtcblxuZnVuY3Rpb24gQ29tbW9uVG9rZW4oc291cmNlLCB0eXBlLCBjaGFubmVsLCBzdGFydCwgc3RvcCkge1xuXHRUb2tlbi5jYWxsKHRoaXMpO1xuXHR0aGlzLnNvdXJjZSA9IHNvdXJjZSAhPT0gdW5kZWZpbmVkID8gc291cmNlIDogQ29tbW9uVG9rZW4uRU1QVFlfU09VUkNFO1xuXHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogbnVsbDtcblx0dGhpcy5jaGFubmVsID0gY2hhbm5lbCAhPT0gdW5kZWZpbmVkID8gY2hhbm5lbCA6IFRva2VuLkRFRkFVTFRfQ0hBTk5FTDtcblx0dGhpcy5zdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IC0xO1xuXHR0aGlzLnN0b3AgPSBzdG9wICE9PSB1bmRlZmluZWQgPyBzdG9wIDogLTE7XG5cdHRoaXMudG9rZW5JbmRleCA9IC0xO1xuXHRpZiAodGhpcy5zb3VyY2VbMF0gIT09IG51bGwpIHtcblx0XHR0aGlzLmxpbmUgPSBzb3VyY2VbMF0ubGluZTtcblx0XHR0aGlzLmNvbHVtbiA9IHNvdXJjZVswXS5jb2x1bW47XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5jb2x1bW4gPSAtMTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbn1cblxuQ29tbW9uVG9rZW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUb2tlbi5wcm90b3R5cGUpO1xuQ29tbW9uVG9rZW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tbW9uVG9rZW47XG5cbi8vIEFuIGVtcHR5IHtAbGluayBQYWlyfSB3aGljaCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IHZhbHVlIG9mXG4vLyB7QGxpbmsgLy9zb3VyY2V9IGZvciB0b2tlbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHNvdXJjZS5cbkNvbW1vblRva2VuLkVNUFRZX1NPVVJDRSA9IFsgbnVsbCwgbnVsbCBdO1xuXG4vLyBDb25zdHJ1Y3RzIGEgbmV3IHtAbGluayBDb21tb25Ub2tlbn0gYXMgYSBjb3B5IG9mIGFub3RoZXIge0BsaW5rIFRva2VufS5cbi8vXG4vLyA8cD5cbi8vIElmIHtAY29kZSBvbGRUb2tlbn0gaXMgYWxzbyBhIHtAbGluayBDb21tb25Ub2tlbn0gaW5zdGFuY2UsIHRoZSBuZXdseVxuLy8gY29uc3RydWN0ZWQgdG9rZW4gd2lsbCBzaGFyZSBhIHJlZmVyZW5jZSB0byB0aGUge0BsaW5rIC8vdGV4dH0gZmllbGQgYW5kXG4vLyB0aGUge0BsaW5rIFBhaXJ9IHN0b3JlZCBpbiB7QGxpbmsgLy9zb3VyY2V9LiBPdGhlcndpc2UsIHtAbGluayAvL3RleHR9IHdpbGxcbi8vIGJlIGFzc2lnbmVkIHRoZSByZXN1bHQgb2YgY2FsbGluZyB7QGxpbmsgLy9nZXRUZXh0fSwgYW5kIHtAbGluayAvL3NvdXJjZX1cbi8vIHdpbGwgYmUgY29uc3RydWN0ZWQgZnJvbSB0aGUgcmVzdWx0IG9mIHtAbGluayBUb2tlbi8vZ2V0VG9rZW5Tb3VyY2V9IGFuZFxuLy8ge0BsaW5rIFRva2VuLy9nZXRJbnB1dFN0cmVhbX0uPC9wPlxuLy9cbi8vIEBwYXJhbSBvbGRUb2tlbiBUaGUgdG9rZW4gdG8gY29weS5cbi8vXG5Db21tb25Ub2tlbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0dmFyIHQgPSBuZXcgQ29tbW9uVG9rZW4odGhpcy5zb3VyY2UsIHRoaXMudHlwZSwgdGhpcy5jaGFubmVsLCB0aGlzLnN0YXJ0LFxuXHRcdFx0dGhpcy5zdG9wKTtcblx0dC50b2tlbkluZGV4ID0gdGhpcy50b2tlbkluZGV4O1xuXHR0LmxpbmUgPSB0aGlzLmxpbmU7XG5cdHQuY29sdW1uID0gdGhpcy5jb2x1bW47XG5cdHQudGV4dCA9IHRoaXMudGV4dDtcblx0cmV0dXJuIHQ7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tbW9uVG9rZW4ucHJvdG90eXBlLCBcInRleHRcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fdGV4dCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3RleHQ7XG5cdFx0fVxuXHRcdHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXRTdHJlYW0oKTtcblx0XHRpZiAoaW5wdXQgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgbiA9IGlucHV0LnNpemU7XG5cdFx0aWYgKHRoaXMuc3RhcnQgPCBuICYmIHRoaXMuc3RvcCA8IG4pIHtcblx0XHRcdHJldHVybiBpbnB1dC5nZXRUZXh0KHRoaXMuc3RhcnQsIHRoaXMuc3RvcCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcIjxFT0Y+XCI7XG5cdFx0fVxuXHR9LFxuXHRzZXQgOiBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dGhpcy5fdGV4dCA9IHRleHQ7XG5cdH1cbn0pO1xuXG5Db21tb25Ub2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHR4dCA9IHRoaXMudGV4dDtcblx0aWYgKHR4dCAhPT0gbnVsbCkge1xuXHRcdHR4dCA9IHR4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKTtcblx0fSBlbHNlIHtcblx0XHR0eHQgPSBcIjxubyB0ZXh0PlwiO1xuXHR9XG5cdHJldHVybiBcIltAXCIgKyB0aGlzLnRva2VuSW5kZXggKyBcIixcIiArIHRoaXMuc3RhcnQgKyBcIjpcIiArIHRoaXMuc3RvcCArIFwiPSdcIiArXG5cdFx0XHR0eHQgKyBcIicsPFwiICsgdGhpcy50eXBlICsgXCI+XCIgK1xuXHRcdFx0KHRoaXMuY2hhbm5lbCA+IDAgPyBcIixjaGFubmVsPVwiICsgdGhpcy5jaGFubmVsIDogXCJcIikgKyBcIixcIiArXG5cdFx0XHR0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sdW1uICsgXCJdXCI7XG59O1xuXG5leHBvcnRzLlRva2VuID0gVG9rZW47XG5leHBvcnRzLkNvbW1vblRva2VuID0gQ29tbW9uVG9rZW47XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbmZ1bmN0aW9uIGFycmF5VG9TdHJpbmcoYSkge1xuICAgIHJldHVybiBcIltcIiArIGEuam9pbihcIiwgXCIpICsgXCJdXCI7XG59XG5cblN0cmluZy5wcm90b3R5cGUuc2VlZCA9IFN0cmluZy5wcm90b3R5cGUuc2VlZCB8fCBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCAzMikpO1xuXG5TdHJpbmcucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW1haW5kZXIsIGJ5dGVzLCBoMSwgaDFiLCBjMSwgYzFiLCBjMiwgYzJiLCBrMSwgaSxcbiAgICAgICAga2V5ID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7IC8vIGtleS5sZW5ndGggJSA0XG4gICAgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICAgIGgxID0gU3RyaW5nLnByb3RvdHlwZS5zZWVkO1xuICAgIGMxID0gMHhjYzllMmQ1MTtcbiAgICBjMiA9IDB4MWI4NzM1OTM7XG4gICAgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGJ5dGVzKSB7XG4gICAgICAgIGsxID1cbiAgICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKSkgfFxuICAgICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgOCkgfFxuICAgICAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDI0KTtcbiAgICAgICAgKytpO1xuXG4gICAgICAgIGsxID0gKCgoKGsxICYgMHhmZmZmKSAqIGMxKSArICgoKChrMSA+Pj4gMTYpICogYzEpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgICAgICBrMSA9ICgoKChrMSAmIDB4ZmZmZikgKiBjMikgKyAoKCgoazEgPj4+IDE2KSAqIGMyKSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuXG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IChoMSA8PCAxMykgfCAoaDEgPj4+IDE5KTtcbiAgICAgICAgaDFiID0gKCgoKGgxICYgMHhmZmZmKSAqIDUpICsgKCgoKGgxID4+PiAxNikgKiA1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICBoMSA9ICgoKGgxYiAmIDB4ZmZmZikgKyAweDZiNjQpICsgKCgoKGgxYiA+Pj4gMTYpICsgMHhlNjU0KSAmIDB4ZmZmZikgPDwgMTYpKTtcbiAgICB9XG5cbiAgICBrMSA9IDA7XG5cbiAgICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKTtcblxuICAgICAgICAgICAgazEgPSAoKChrMSAmIDB4ZmZmZikgKiBjMSkgKyAoKCgoazEgPj4+IDE2KSAqIGMxKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICAgICAgICAgIGsxID0gKCgoazEgJiAweGZmZmYpICogYzIpICsgKCgoKGsxID4+PiAxNikgKiBjMikgJiAweGZmZmYpIDw8IDE2KSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgaDEgXj0gazE7XG4gICAgfVxuXG4gICAgaDEgXj0ga2V5Lmxlbmd0aDtcblxuICAgIGgxIF49IGgxID4+PiAxNjtcbiAgICBoMSA9ICgoKGgxICYgMHhmZmZmKSAqIDB4ODVlYmNhNmIpICsgKCgoKGgxID4+PiAxNikgKiAweDg1ZWJjYTZiKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgXj0gaDEgPj4+IDEzO1xuICAgIGgxID0gKCgoKGgxICYgMHhmZmZmKSAqIDB4YzJiMmFlMzUpICsgKCgoKGgxID4+PiAxNikgKiAweGMyYjJhZTM1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGgxIF49IGgxID4+PiAxNjtcblxuICAgIHJldHVybiBoMSA+Pj4gMDtcbn07XG5cbmZ1bmN0aW9uIHN0YW5kYXJkRXF1YWxzRnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhLmVxdWFscyhiKTtcbn1cblxuZnVuY3Rpb24gc3RhbmRhcmRIYXNoQ29kZUZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYS5oYXNoQ29kZSgpO1xufVxuXG5mdW5jdGlvbiBTZXQoaGFzaEZ1bmN0aW9uLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uIHx8IHN0YW5kYXJkSGFzaENvZGVGdW5jdGlvbjtcbiAgICB0aGlzLmVxdWFsc0Z1bmN0aW9uID0gZXF1YWxzRnVuY3Rpb24gfHwgc3RhbmRhcmRFcXVhbHNGdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCJoYXNoX1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGwgPSBsICsgdGhpcy5kYXRhW2tleV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbn0pO1xuXG5TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBoYXNoID0gdGhpcy5oYXNoRnVuY3Rpb24odmFsdWUpO1xuICAgIHZhciBrZXkgPSBcImhhc2hfXCIgKyBoYXNoO1xuICAgIGlmIChrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmRhdGFba2V5XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKHZhbHVlLCB2YWx1ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IFt2YWx1ZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuXG5TZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHZhbHVlKSAhPSBudWxsO1xufTtcblxuU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaEZ1bmN0aW9uKHZhbHVlKTtcbiAgICB2YXIga2V5ID0gXCJoYXNoX1wiICsgaGFzaDtcbiAgICBpZiAoa2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5kYXRhW2tleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHNGdW5jdGlvbih2YWx1ZSwgdmFsdWVzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5TZXQucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwiaGFzaF9cIikgPT09IDApIHtcbiAgICAgICAgICAgIGwgPSBsLmNvbmNhdCh0aGlzLmRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGw7XG59O1xuXG5TZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcnJheVRvU3RyaW5nKHRoaXMudmFsdWVzKCkpO1xufTtcblxuZnVuY3Rpb24gQml0U2V0KCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5CaXRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVt2YWx1ZV0gPSB0cnVlO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYml0cyA9IHRoaXM7XG4gICAgT2JqZWN0LmtleXMoc2V0LmRhdGEpLm1hcChmdW5jdGlvbiAoYWx0KSB7XG4gICAgICAgIGJpdHMuYWRkKGFsdCk7XG4gICAgfSk7XG59O1xuXG5CaXRTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRhdGFbdmFsdWVdO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdmFsdWVdID09PSB0cnVlO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG59O1xuXG5CaXRTZXQucHJvdG90eXBlLm1pblZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLnZhbHVlcygpKTtcbn07XG5cbkJpdFNldC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgIGhhc2gudXBkYXRlKHRoaXMudmFsdWVzKCkpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufTtcblxuQml0U2V0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEJpdFNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXNoQ29kZSgpID09PSBvdGhlci5oYXNoQ29kZSgpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdFNldC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCkubGVuZ3RoO1xuICAgIH1cbn0pO1xuXG5CaXRTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIntcIiArIHRoaXMudmFsdWVzKCkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG59O1xuXG5mdW5jdGlvbiBNYXAoaGFzaEZ1bmN0aW9uLCBlcXVhbHNGdW5jdGlvbikge1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuaGFzaEZ1bmN0aW9uID0gaGFzaEZ1bmN0aW9uIHx8IHN0YW5kYXJkSGFzaENvZGVGdW5jdGlvbjtcbiAgICB0aGlzLmVxdWFsc0Z1bmN0aW9uID0gZXF1YWxzRnVuY3Rpb24gfHwgc3RhbmRhcmRFcXVhbHNGdW5jdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBoYXNoS2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKGhhc2hLZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbCA9IGwgKyB0aGlzLmRhdGFbaGFzaEtleV0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbn0pO1xuXG5NYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGhhc2hLZXkgPSBcImhhc2hfXCIgKyB0aGlzLmhhc2hGdW5jdGlvbihrZXkpO1xuICAgIGlmIChoYXNoS2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuZGF0YVtoYXNoS2V5XTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzRnVuY3Rpb24oa2V5LCBlbnRyeS5rZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZW50cnkudmFsdWU7XG4gICAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW50cmllcy5wdXNoKHtrZXk6a2V5LCB2YWx1ZTp2YWx1ZX0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhW2hhc2hLZXldID0gW3trZXk6a2V5LCB2YWx1ZTp2YWx1ZX1dO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufTtcblxuTWFwLnByb3RvdHlwZS5jb250YWluc0tleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaGFzaEtleSA9IFwiaGFzaF9cIiArIHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgaWYoaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmRhdGFbaGFzaEtleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKGtleSwgZW50cnkua2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaGFzaEtleSA9IFwiaGFzaF9cIiArIHRoaXMuaGFzaEZ1bmN0aW9uKGtleSk7XG4gICAgaWYoaGFzaEtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSB0aGlzLmRhdGFbaGFzaEtleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFsc0Z1bmN0aW9uKGtleSwgZW50cnkua2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5NYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGwgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZihcImhhc2hfXCIpID09PSAwKSB7XG4gICAgICAgICAgICBsID0gbC5jb25jYXQodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsO1xufTtcblxuXG5NYXAucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLmtleTtcbiAgICB9KTtcbn07XG5cblxuTWFwLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICB9KTtcbn07XG5cblxuTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3MgPSB0aGlzLmVudHJpZXMoKS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICd7JyArIGVudHJ5LmtleSArICc6JyArIGVudHJ5LnZhbHVlICsgJ30nO1xuICAgIH0pO1xuICAgIHJldHVybiAnWycgKyBzcy5qb2luKFwiLCBcIikgKyAnXSc7XG59O1xuXG5cbmZ1bmN0aW9uIEFsdERpY3QoKSB7XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblxuQWx0RGljdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGtleSA9IFwiay1cIiArIGtleTtcbiAgICBpZiAoa2V5IGluIHRoaXMuZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuQWx0RGljdC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBcImstXCIgKyBrZXk7XG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbn07XG5cbkFsdERpY3QucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIGtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIERvdWJsZURpY3QoZGVmYXVsdE1hcEN0b3IpIHtcbiAgICB0aGlzLmRlZmF1bHRNYXBDdG9yID0gZGVmYXVsdE1hcEN0b3IgfHwgTWFwO1xuICAgIHRoaXMuY2FjaGVNYXAgPSBuZXcgdGhpcy5kZWZhdWx0TWFwQ3RvcigpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBIYXNoKCkge1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuaGFzaCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5hcHBseSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgIGsgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgayA9IHZhbHVlLmhhc2hDb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlLnVwZGF0ZUhhc2hDb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudXBkYXRlSGFzaENvZGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdXBkYXRlSGFzaENvZGUgZm9yIFwiICsgdmFsdWUudG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrID0gayAqIDB4Q0M5RTJENTE7XG4gICAgICAgICAgICBrID0gKGsgPDwgMTUpIHwgKGsgPj4+ICgzMiAtIDE1KSk7XG4gICAgICAgICAgICBrID0gayAqIDB4MUI4NzM1OTM7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gdGhpcy5jb3VudCArIDE7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCBeIGs7XG4gICAgICAgICAgICBoYXNoID0gKGhhc2ggPDwgMTMpIHwgKGhhc2ggPj4+ICgzMiAtIDEzKSk7XG4gICAgICAgICAgICBoYXNoID0gaGFzaCAqIDUgKyAweEU2NTQ2QjY0O1xuICAgICAgICAgICAgdGhpcy5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkhhc2gucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaCBeICh0aGlzLmNvdW50ICogNCk7XG4gICAgaGFzaCA9IGhhc2ggXiAoaGFzaCA+Pj4gMTYpO1xuICAgIGhhc2ggPSBoYXNoICogMHg4NUVCQ0E2QjtcbiAgICBoYXNoID0gaGFzaCBeIChoYXNoID4+PiAxMyk7XG4gICAgaGFzaCA9IGhhc2ggKiAweEMyQjJBRTM1O1xuICAgIGhhc2ggPSBoYXNoIF4gKGhhc2ggPj4+IDE2KTtcbiAgICByZXR1cm4gaGFzaDtcbn07XG5cbmZ1bmN0aW9uIGhhc2hTdHVmZigpIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBIYXNoKCk7XG4gICAgaGFzaC51cGRhdGUuYXBwbHkoaGFzaCwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn1cblxuRG91YmxlRGljdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgZCA9IHRoaXMuY2FjaGVNYXAuZ2V0KGEpIHx8IG51bGw7XG4gICAgcmV0dXJuIGQgPT09IG51bGwgPyBudWxsIDogKGQuZ2V0KGIpIHx8IG51bGwpO1xufTtcblxuRG91YmxlRGljdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGEsIGIsIG8pIHtcbiAgICB2YXIgZCA9IHRoaXMuY2FjaGVNYXAuZ2V0KGEpIHx8IG51bGw7XG4gICAgaWYgKGQgPT09IG51bGwpIHtcbiAgICAgICAgZCA9IG5ldyB0aGlzLmRlZmF1bHRNYXBDdG9yKCk7XG4gICAgICAgIHRoaXMuY2FjaGVNYXAucHV0KGEsIGQpO1xuICAgIH1cbiAgICBkLnB1dChiLCBvKTtcbn07XG5cblxuZnVuY3Rpb24gZXNjYXBlV2hpdGVzcGFjZShzLCBlc2NhcGVTcGFjZXMpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpXG4gICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIik7XG4gICAgaWYgKGVzY2FwZVNwYWNlcykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKC8gL2csIFwiXFx1MDBCN1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcd1xcUyovZywgZnVuY3Rpb24gKHR4dCkge1xuICAgICAgICByZXR1cm4gdHh0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHh0LnN1YnN0cigxKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGEsIGIpXG57XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID09IGJbaV0pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFhW2ldLmVxdWFscyhiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuZXhwb3J0cy5TZXQgPSBTZXQ7XG5leHBvcnRzLk1hcCA9IE1hcDtcbmV4cG9ydHMuQml0U2V0ID0gQml0U2V0O1xuZXhwb3J0cy5BbHREaWN0ID0gQWx0RGljdDtcbmV4cG9ydHMuRG91YmxlRGljdCA9IERvdWJsZURpY3Q7XG5leHBvcnRzLmhhc2hTdHVmZiA9IGhhc2hTdHVmZjtcbmV4cG9ydHMuZXNjYXBlV2hpdGVzcGFjZSA9IGVzY2FwZVdoaXRlc3BhY2U7XG5leHBvcnRzLmFycmF5VG9TdHJpbmcgPSBhcnJheVRvU3RyaW5nO1xuZXhwb3J0cy50aXRsZUNhc2UgPSB0aXRsZUNhc2U7XG5leHBvcnRzLmVxdWFsQXJyYXlzID0gZXF1YWxBcnJheXM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBMTDFBbmFseXplciA9IHJlcXVpcmUoJy4vLi4vTEwxQW5hbHl6ZXInKS5MTDFBbmFseXplcjtcbnZhciBJbnRlcnZhbFNldCA9IHJlcXVpcmUoJy4vLi4vSW50ZXJ2YWxTZXQnKS5JbnRlcnZhbFNldDtcblxuZnVuY3Rpb24gQVROKGdyYW1tYXJUeXBlICwgbWF4VG9rZW5UeXBlKSB7XG5cbiAgICAvLyBVc2VkIGZvciBydW50aW1lIGRlc2VyaWFsaXphdGlvbiBvZiBBVE5zIGZyb20gc3RyaW5ncy8vL1xuICAgIC8vIFRoZSB0eXBlIG9mIHRoZSBBVE4uXG4gICAgdGhpcy5ncmFtbWFyVHlwZSA9IGdyYW1tYXJUeXBlO1xuICAgIC8vIFRoZSBtYXhpbXVtIHZhbHVlIGZvciBhbnkgc3ltYm9sIHJlY29nbml6ZWQgYnkgYSB0cmFuc2l0aW9uIGluIHRoZSBBVE4uXG4gICAgdGhpcy5tYXhUb2tlblR5cGUgPSBtYXhUb2tlblR5cGU7XG4gICAgdGhpcy5zdGF0ZXMgPSBbXTtcbiAgICAvLyBFYWNoIHN1YnJ1bGUvcnVsZSBpcyBhIGRlY2lzaW9uIHBvaW50IGFuZCB3ZSBtdXN0IHRyYWNrIHRoZW0gc28gd2VcbiAgICAvLyAgY2FuIGdvIGJhY2sgbGF0ZXIgYW5kIGJ1aWxkIERGQSBwcmVkaWN0b3JzIGZvciB0aGVtLiAgVGhpcyBpbmNsdWRlc1xuICAgIC8vICBhbGwgdGhlIHJ1bGVzLCBzdWJydWxlcywgb3B0aW9uYWwgYmxvY2tzLCAoKSssICgpKiBldGMuLi5cbiAgICB0aGlzLmRlY2lzaW9uVG9TdGF0ZSA9IFtdO1xuICAgIC8vIE1hcHMgZnJvbSBydWxlIGluZGV4IHRvIHN0YXJ0aW5nIHN0YXRlIG51bWJlci5cbiAgICB0aGlzLnJ1bGVUb1N0YXJ0U3RhdGUgPSBbXTtcbiAgICAvLyBNYXBzIGZyb20gcnVsZSBpbmRleCB0byBzdG9wIHN0YXRlIG51bWJlci5cbiAgICB0aGlzLnJ1bGVUb1N0b3BTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5tb2RlTmFtZVRvU3RhcnRTdGF0ZSA9IHt9O1xuICAgIC8vIEZvciBsZXhlciBBVE5zLCB0aGlzIG1hcHMgdGhlIHJ1bGUgaW5kZXggdG8gdGhlIHJlc3VsdGluZyB0b2tlbiB0eXBlLlxuICAgIC8vIEZvciBwYXJzZXIgQVROcywgdGhpcyBtYXBzIHRoZSBydWxlIGluZGV4IHRvIHRoZSBnZW5lcmF0ZWQgYnlwYXNzIHRva2VuXG4gICAgLy8gdHlwZSBpZiB0aGVcbiAgICAvLyB7QGxpbmsgQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy8vaXNHZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uc31cbiAgICAvLyBkZXNlcmlhbGl6YXRpb24gb3B0aW9uIHdhcyBzcGVjaWZpZWQ7IG90aGVyd2lzZSwgdGhpcyBpcyB7QGNvZGUgbnVsbH0uXG4gICAgdGhpcy5ydWxlVG9Ub2tlblR5cGUgPSBudWxsO1xuICAgIC8vIEZvciBsZXhlciBBVE5zLCB0aGlzIGlzIGFuIGFycmF5IG9mIHtAbGluayBMZXhlckFjdGlvbn0gb2JqZWN0cyB3aGljaCBtYXlcbiAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGFjdGlvbiB0cmFuc2l0aW9ucyBpbiB0aGUgQVROLlxuICAgIHRoaXMubGV4ZXJBY3Rpb25zID0gbnVsbDtcbiAgICB0aGlzLm1vZGVUb1N0YXJ0U3RhdGUgPSBbXTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBDb21wdXRlIHRoZSBzZXQgb2YgdmFsaWQgdG9rZW5zIHRoYXQgY2FuIG9jY3VyIHN0YXJ0aW5nIGluIHN0YXRlIHtAY29kZSBzfS5cbi8vICBJZiB7QGNvZGUgY3R4fSBpcyBudWxsLCB0aGUgc2V0IG9mIHRva2VucyB3aWxsIG5vdCBpbmNsdWRlIHdoYXQgY2FuIGZvbGxvd1xuLy8gIHRoZSBydWxlIHN1cnJvdW5kaW5nIHtAY29kZSBzfS4gSW4gb3RoZXIgd29yZHMsIHRoZSBzZXQgd2lsbCBiZVxuLy8gIHJlc3RyaWN0ZWQgdG8gdG9rZW5zIHJlYWNoYWJsZSBzdGF5aW5nIHdpdGhpbiB7QGNvZGUgc30ncyBydWxlLlxuQVROLnByb3RvdHlwZS5uZXh0VG9rZW5zSW5Db250ZXh0ID0gZnVuY3Rpb24ocywgY3R4KSB7XG4gICAgdmFyIGFuYWwgPSBuZXcgTEwxQW5hbHl6ZXIodGhpcyk7XG4gICAgcmV0dXJuIGFuYWwuTE9PSyhzLCBudWxsLCBjdHgpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2V0IG9mIHZhbGlkIHRva2VucyB0aGF0IGNhbiBvY2N1ciBzdGFydGluZyBpbiB7QGNvZGUgc30gYW5kXG4vLyBzdGF5aW5nIGluIHNhbWUgcnVsZS4ge0BsaW5rIFRva2VuLy9FUFNJTE9OfSBpcyBpbiBzZXQgaWYgd2UgcmVhY2ggZW5kIG9mXG4vLyBydWxlLlxuQVROLnByb3RvdHlwZS5uZXh0VG9rZW5zTm9Db250ZXh0ID0gZnVuY3Rpb24ocykge1xuICAgIGlmIChzLm5leHRUb2tlbldpdGhpblJ1bGUgIT09IG51bGwgKSB7XG4gICAgICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG4gICAgfVxuICAgIHMubmV4dFRva2VuV2l0aGluUnVsZSA9IHRoaXMubmV4dFRva2Vuc0luQ29udGV4dChzLCBudWxsKTtcbiAgICBzLm5leHRUb2tlbldpdGhpblJ1bGUucmVhZE9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBzLm5leHRUb2tlbldpdGhpblJ1bGU7XG59O1xuXG5BVE4ucHJvdG90eXBlLm5leHRUb2tlbnMgPSBmdW5jdGlvbihzLCBjdHgpIHtcbiAgICBpZiAoIGN0eD09PXVuZGVmaW5lZCApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2Vuc05vQ29udGV4dChzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5zSW5Db250ZXh0KHMsIGN0eCk7XG4gICAgfVxufTtcblxuQVROLnByb3RvdHlwZS5hZGRTdGF0ZSA9IGZ1bmN0aW9uKCBzdGF0ZSkge1xuICAgIGlmICggc3RhdGUgIT09IG51bGwgKSB7XG4gICAgICAgIHN0YXRlLmF0biA9IHRoaXM7XG4gICAgICAgIHN0YXRlLnN0YXRlTnVtYmVyID0gdGhpcy5zdGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbn07XG5cbkFUTi5wcm90b3R5cGUucmVtb3ZlU3RhdGUgPSBmdW5jdGlvbiggc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlc1tzdGF0ZS5zdGF0ZU51bWJlcl0gPSBudWxsOyAvLyBqdXN0IGZyZWUgbWVtLCBkb24ndCBzaGlmdCBzdGF0ZXMgaW4gbGlzdFxufTtcblxuQVROLnByb3RvdHlwZS5kZWZpbmVEZWNpc2lvblN0YXRlID0gZnVuY3Rpb24oIHMpIHtcbiAgICB0aGlzLmRlY2lzaW9uVG9TdGF0ZS5wdXNoKHMpO1xuICAgIHMuZGVjaXNpb24gPSB0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGgtMTtcbiAgICByZXR1cm4gcy5kZWNpc2lvbjtcbn07XG5cbkFUTi5wcm90b3R5cGUuZ2V0RGVjaXNpb25TdGF0ZSA9IGZ1bmN0aW9uKCBkZWNpc2lvbikge1xuICAgIGlmICh0aGlzLmRlY2lzaW9uVG9TdGF0ZS5sZW5ndGg9PT0wKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY2lzaW9uVG9TdGF0ZVtkZWNpc2lvbl07XG4gICAgfVxufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHNldCBvZiBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyBBVE4gc3RhdGUgbnVtYmVyXG4vLyB7QGNvZGUgc3RhdGVOdW1iZXJ9IGluIHRoZSBzcGVjaWZpZWQgZnVsbCB7QGNvZGUgY29udGV4dH0uIFRoaXMgbWV0aG9kXG4vLyBjb25zaWRlcnMgdGhlIGNvbXBsZXRlIHBhcnNlciBjb250ZXh0LCBidXQgZG9lcyBub3QgZXZhbHVhdGUgc2VtYW50aWNcbi8vIHByZWRpY2F0ZXMgKGkuZS4gYWxsIHByZWRpY2F0ZXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBjYWxjdWxhdGlvbiBhcmVcbi8vIGFzc3VtZWQgdHJ1ZSkuIElmIGEgcGF0aCBpbiB0aGUgQVROIGV4aXN0cyBmcm9tIHRoZSBzdGFydGluZyBzdGF0ZSB0byB0aGVcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfSBvZiB0aGUgb3V0ZXJtb3N0IGNvbnRleHQgd2l0aG91dCBtYXRjaGluZyBhbnlcbi8vIHN5bWJvbHMsIHtAbGluayBUb2tlbi8vRU9GfSBpcyBhZGRlZCB0byB0aGUgcmV0dXJuZWQgc2V0LlxuLy9cbi8vIDxwPklmIHtAY29kZSBjb250ZXh0fSBpcyB7QGNvZGUgbnVsbH0sIGl0IGlzIHRyZWF0ZWQgYXNcbi8vIHtAbGluayBQYXJzZXJSdWxlQ29udGV4dC8vRU1QVFl9LjwvcD5cbi8vXG4vLyBAcGFyYW0gc3RhdGVOdW1iZXIgdGhlIEFUTiBzdGF0ZSBudW1iZXJcbi8vIEBwYXJhbSBjb250ZXh0IHRoZSBmdWxsIHBhcnNlIGNvbnRleHRcbi8vIEByZXR1cm4gVGhlIHNldCBvZiBwb3RlbnRpYWxseSB2YWxpZCBpbnB1dCBzeW1ib2xzIHdoaWNoIGNvdWxkIGZvbGxvdyB0aGVcbi8vIHNwZWNpZmllZCBzdGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4vLyBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB0aGUgQVROIGRvZXMgbm90IGNvbnRhaW4gYSBzdGF0ZSB3aXRoXG4vLyBudW1iZXIge0Bjb2RlIHN0YXRlTnVtYmVyfVxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xuXG5BVE4ucHJvdG90eXBlLmdldEV4cGVjdGVkVG9rZW5zID0gZnVuY3Rpb24oIHN0YXRlTnVtYmVyLCBjdHggKSB7XG4gICAgaWYgKCBzdGF0ZU51bWJlciA8IDAgfHwgc3RhdGVOdW1iZXIgPj0gdGhpcy5zdGF0ZXMubGVuZ3RoICkge1xuICAgICAgICB0aHJvdyhcIkludmFsaWQgc3RhdGUgbnVtYmVyLlwiKTtcbiAgICB9XG4gICAgdmFyIHMgPSB0aGlzLnN0YXRlc1tzdGF0ZU51bWJlcl07XG4gICAgdmFyIGZvbGxvd2luZyA9IHRoaXMubmV4dFRva2VucyhzKTtcbiAgICBpZiAoIWZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nO1xuICAgIH1cbiAgICB2YXIgZXhwZWN0ZWQgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICBleHBlY3RlZC5hZGRTZXQoZm9sbG93aW5nKTtcbiAgICBleHBlY3RlZC5yZW1vdmVPbmUoVG9rZW4uRVBTSUxPTik7XG4gICAgd2hpbGUgKGN0eCAhPT0gbnVsbCAmJiBjdHguaW52b2tpbmdTdGF0ZSA+PSAwICYmIGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICB2YXIgaW52b2tpbmdTdGF0ZSA9IHRoaXMuc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcbiAgICAgICAgdmFyIHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgZm9sbG93aW5nID0gdGhpcy5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcbiAgICAgICAgZXhwZWN0ZWQuYWRkU2V0KGZvbGxvd2luZyk7XG4gICAgICAgIGV4cGVjdGVkLnJlbW92ZU9uZShUb2tlbi5FUFNJTE9OKTtcbiAgICAgICAgY3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICB9XG4gICAgaWYgKGZvbGxvd2luZy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSkge1xuICAgICAgICBleHBlY3RlZC5hZGRPbmUoVG9rZW4uRU9GKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGVjdGVkO1xufTtcblxuQVROLklOVkFMSURfQUxUX05VTUJFUiA9IDA7XG5cbmV4cG9ydHMuQVROID0gQVROOyIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gQSB0dXBsZTogKEFUTiBzdGF0ZSwgcHJlZGljdGVkIGFsdCwgc3ludGFjdGljLCBzZW1hbnRpYyBjb250ZXh0KS5cbi8vICBUaGUgc3ludGFjdGljIGNvbnRleHQgaXMgYSBncmFwaC1zdHJ1Y3R1cmVkIHN0YWNrIG5vZGUgd2hvc2Vcbi8vICBwYXRoKHMpIHRvIHRoZSByb290IGlzIHRoZSBydWxlIGludm9jYXRpb24ocylcbi8vICBjaGFpbiB1c2VkIHRvIGFycml2ZSBhdCB0aGUgc3RhdGUuICBUaGUgc2VtYW50aWMgY29udGV4dCBpc1xuLy8gIHRoZSB0cmVlIG9mIHNlbWFudGljIHByZWRpY2F0ZXMgZW5jb3VudGVyZWQgYmVmb3JlIHJlYWNoaW5nXG4vLyAgYW4gQVROIHN0YXRlLlxuLy8vXG5cbnZhciBEZWNpc2lvblN0YXRlID0gcmVxdWlyZSgnLi9BVE5TdGF0ZScpLkRlY2lzaW9uU3RhdGU7XG52YXIgU2VtYW50aWNDb250ZXh0ID0gcmVxdWlyZSgnLi9TZW1hbnRpY0NvbnRleHQnKS5TZW1hbnRpY0NvbnRleHQ7XG52YXIgSGFzaCA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKS5IYXNoO1xuXG5cbmZ1bmN0aW9uIGNoZWNrUGFyYW1zKHBhcmFtcywgaXNDZmcpIHtcblx0aWYocGFyYW1zPT09bnVsbCkge1xuXHRcdHZhciByZXN1bHQgPSB7IHN0YXRlOm51bGwsIGFsdDpudWxsLCBjb250ZXh0Om51bGwsIHNlbWFudGljQ29udGV4dDpudWxsIH07XG5cdFx0aWYoaXNDZmcpIHtcblx0XHRcdHJlc3VsdC5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IDA7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHByb3BzID0ge307XG5cdFx0cHJvcHMuc3RhdGUgPSBwYXJhbXMuc3RhdGUgfHwgbnVsbDtcblx0XHRwcm9wcy5hbHQgPSAocGFyYW1zLmFsdCA9PT0gdW5kZWZpbmVkKSA/IG51bGwgOiBwYXJhbXMuYWx0O1xuXHRcdHByb3BzLmNvbnRleHQgPSBwYXJhbXMuY29udGV4dCB8fCBudWxsO1xuXHRcdHByb3BzLnNlbWFudGljQ29udGV4dCA9IHBhcmFtcy5zZW1hbnRpY0NvbnRleHQgfHwgbnVsbDtcblx0XHRpZihpc0NmZykge1xuXHRcdFx0cHJvcHMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPSBwYXJhbXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgfHwgMDtcblx0XHRcdHByb3BzLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkID0gcGFyYW1zLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkIHx8IGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJvcHM7XG5cdH1cbn1cblxuZnVuY3Rpb24gQVROQ29uZmlnKHBhcmFtcywgY29uZmlnKSB7XG5cdHRoaXMuY2hlY2tDb250ZXh0KHBhcmFtcywgY29uZmlnKTtcblx0cGFyYW1zID0gY2hlY2tQYXJhbXMocGFyYW1zKTtcblx0Y29uZmlnID0gY2hlY2tQYXJhbXMoY29uZmlnLCB0cnVlKTtcbiAgICAvLyBUaGUgQVROIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbmZpZ3VyYXRpb24vLy9cbiAgICB0aGlzLnN0YXRlID0gcGFyYW1zLnN0YXRlIT09bnVsbCA/IHBhcmFtcy5zdGF0ZSA6IGNvbmZpZy5zdGF0ZTtcbiAgICAvLyBXaGF0IGFsdCAob3IgbGV4ZXIgcnVsZSkgaXMgcHJlZGljdGVkIGJ5IHRoaXMgY29uZmlndXJhdGlvbi8vL1xuICAgIHRoaXMuYWx0ID0gcGFyYW1zLmFsdCE9PW51bGwgPyBwYXJhbXMuYWx0IDogY29uZmlnLmFsdDtcbiAgICAvLyBUaGUgc3RhY2sgb2YgaW52b2tpbmcgc3RhdGVzIGxlYWRpbmcgdG8gdGhlIHJ1bGUvc3RhdGVzIGFzc29jaWF0ZWRcbiAgICAvLyAgd2l0aCB0aGlzIGNvbmZpZy4gIFdlIHRyYWNrIG9ubHkgdGhvc2UgY29udGV4dHMgcHVzaGVkIGR1cmluZ1xuICAgIC8vICBleGVjdXRpb24gb2YgdGhlIEFUTiBzaW11bGF0b3IuXG4gICAgdGhpcy5jb250ZXh0ID0gcGFyYW1zLmNvbnRleHQhPT1udWxsID8gcGFyYW1zLmNvbnRleHQgOiBjb25maWcuY29udGV4dDtcbiAgICB0aGlzLnNlbWFudGljQ29udGV4dCA9IHBhcmFtcy5zZW1hbnRpY0NvbnRleHQhPT1udWxsID8gcGFyYW1zLnNlbWFudGljQ29udGV4dCA6XG4gICAgICAgIChjb25maWcuc2VtYW50aWNDb250ZXh0IT09bnVsbCA/IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQgOiBTZW1hbnRpY0NvbnRleHQuTk9ORSk7XG4gICAgLy8gV2UgY2Fubm90IGV4ZWN1dGUgcHJlZGljYXRlcyBkZXBlbmRlbnQgdXBvbiBsb2NhbCBjb250ZXh0IHVubGVzc1xuICAgIC8vIHdlIGtub3cgZm9yIHN1cmUgd2UgYXJlIGluIHRoZSBjb3JyZWN0IGNvbnRleHQuIEJlY2F1c2UgdGhlcmUgaXNcbiAgICAvLyBubyB3YXkgdG8gZG8gdGhpcyBlZmZpY2llbnRseSwgd2Ugc2ltcGx5IGNhbm5vdCBldmFsdWF0ZVxuICAgIC8vIGRlcGVuZGVudCBwcmVkaWNhdGVzIHVubGVzcyB3ZSBhcmUgaW4gdGhlIHJ1bGUgdGhhdCBpbml0aWFsbHlcbiAgICAvLyBpbnZva2VzIHRoZSBBVE4gc2ltdWxhdG9yLlxuICAgIC8vXG4gICAgLy8gY2xvc3VyZSgpIHRyYWNrcyB0aGUgZGVwdGggb2YgaG93IGZhciB3ZSBkaXAgaW50byB0aGVcbiAgICAvLyBvdXRlciBjb250ZXh0OiBkZXB0aCAmZ3Q7IDAuICBOb3RlIHRoYXQgaXQgbWF5IG5vdCBiZSB0b3RhbGx5XG4gICAgLy8gYWNjdXJhdGUgZGVwdGggc2luY2UgSSBkb24ndCBldmVyIGRlY3JlbWVudC4gVE9ETzogbWFrZSBpdCBhIGJvb2xlYW4gdGhlblxuICAgIHRoaXMucmVhY2hlc0ludG9PdXRlckNvbnRleHQgPSBjb25maWcucmVhY2hlc0ludG9PdXRlckNvbnRleHQ7XG4gICAgdGhpcy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9IGNvbmZpZy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQVROQ29uZmlnLnByb3RvdHlwZS5jaGVja0NvbnRleHQgPSBmdW5jdGlvbihwYXJhbXMsIGNvbmZpZykge1xuXHRpZigocGFyYW1zLmNvbnRleHQ9PT1udWxsIHx8IHBhcmFtcy5jb250ZXh0PT09dW5kZWZpbmVkKSAmJlxuXHRcdFx0KGNvbmZpZz09PW51bGwgfHwgY29uZmlnLmNvbnRleHQ9PT1udWxsIHx8IGNvbmZpZy5jb250ZXh0PT09dW5kZWZpbmVkKSkge1xuXHRcdHRoaXMuY29udGV4dCA9IG51bGw7XG5cdH1cbn07XG5cblxuQVROQ29uZmlnLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcbiAgICB0aGlzLnVwZGF0ZUhhc2hDb2RlKGhhc2gpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufTtcblxuXG5BVE5Db25maWcucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuc3RhdGUuc3RhdGVOdW1iZXIsIHRoaXMuYWx0LCB0aGlzLmNvbnRleHQsIHRoaXMuc2VtYW50aWNDb250ZXh0KTtcbn07XG5cbi8vIEFuIEFUTiBjb25maWd1cmF0aW9uIGlzIGVxdWFsIHRvIGFub3RoZXIgaWYgYm90aCBoYXZlXG4vLyAgdGhlIHNhbWUgc3RhdGUsIHRoZXkgcHJlZGljdCB0aGUgc2FtZSBhbHRlcm5hdGl2ZSwgYW5kXG4vLyAgc3ludGFjdGljL3NlbWFudGljIGNvbnRleHRzIGFyZSB0aGUgc2FtZS5cblxuQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgQVROQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdGVOdW1iZXI9PT1vdGhlci5zdGF0ZS5zdGF0ZU51bWJlciAmJlxuICAgICAgICAgICAgdGhpcy5hbHQ9PT1vdGhlci5hbHQgJiZcbiAgICAgICAgICAgICh0aGlzLmNvbnRleHQ9PT1udWxsID8gb3RoZXIuY29udGV4dD09PW51bGwgOiB0aGlzLmNvbnRleHQuZXF1YWxzKG90aGVyLmNvbnRleHQpKSAmJlxuICAgICAgICAgICAgdGhpcy5zZW1hbnRpY0NvbnRleHQuZXF1YWxzKG90aGVyLnNlbWFudGljQ29udGV4dCkgJiZcbiAgICAgICAgICAgIHRoaXMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQ9PT1vdGhlci5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZDtcbiAgICB9XG59O1xuXG5cbkFUTkNvbmZpZy5wcm90b3R5cGUuaGFzaENvZGVGb3JDb25maWdTZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBIYXNoKCk7XG4gICAgaGFzaC51cGRhdGUodGhpcy5zdGF0ZS5zdGF0ZU51bWJlciwgdGhpcy5hbHQsIHRoaXMuc2VtYW50aWNDb250ZXh0KTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn07XG5cblxuQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHNGb3JDb25maWdTZXQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgQVROQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc3RhdGVOdW1iZXI9PT1vdGhlci5zdGF0ZS5zdGF0ZU51bWJlciAmJlxuICAgICAgICAgICAgdGhpcy5hbHQ9PT1vdGhlci5hbHQgJiZcbiAgICAgICAgICAgIHRoaXMuc2VtYW50aWNDb250ZXh0LmVxdWFscyhvdGhlci5zZW1hbnRpY0NvbnRleHQpO1xuICAgIH1cbn07XG5cblxuQVROQ29uZmlnLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIihcIiArIHRoaXMuc3RhdGUgKyBcIixcIiArIHRoaXMuYWx0ICtcbiAgICAgICAgKHRoaXMuY29udGV4dCE9PW51bGwgPyBcIixbXCIgKyB0aGlzLmNvbnRleHQudG9TdHJpbmcoKSArIFwiXVwiIDogXCJcIikgK1xuICAgICAgICAodGhpcy5zZW1hbnRpY0NvbnRleHQgIT09IFNlbWFudGljQ29udGV4dC5OT05FID9cbiAgICAgICAgICAgICAgICAoXCIsXCIgKyB0aGlzLnNlbWFudGljQ29udGV4dC50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgIDogXCJcIikgK1xuICAgICAgICAodGhpcy5yZWFjaGVzSW50b091dGVyQ29udGV4dD4wID9cbiAgICAgICAgICAgICAgICAoXCIsdXA9XCIgKyB0aGlzLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0KVxuICAgICAgICAgICAgICAgIDogXCJcIikgKyBcIilcIjtcbn07XG5cblxuZnVuY3Rpb24gTGV4ZXJBVE5Db25maWcocGFyYW1zLCBjb25maWcpIHtcblx0QVROQ29uZmlnLmNhbGwodGhpcywgcGFyYW1zLCBjb25maWcpO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgYmFja2luZyBmaWVsZCBmb3Ige0BsaW5rIC8vZ2V0TGV4ZXJBY3Rpb25FeGVjdXRvcn0uXG5cdHZhciBsZXhlckFjdGlvbkV4ZWN1dG9yID0gcGFyYW1zLmxleGVyQWN0aW9uRXhlY3V0b3IgfHwgbnVsbDtcbiAgICB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IgPSBsZXhlckFjdGlvbkV4ZWN1dG9yIHx8IChjb25maWchPT1udWxsID8gY29uZmlnLmxleGVyQWN0aW9uRXhlY3V0b3IgOiBudWxsKTtcbiAgICB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9IGNvbmZpZyE9PW51bGwgPyB0aGlzLmNoZWNrTm9uR3JlZWR5RGVjaXNpb24oY29uZmlnLCB0aGlzLnN0YXRlKSA6IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5MZXhlckFUTkNvbmZpZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTkNvbmZpZy5wcm90b3R5cGUpO1xuTGV4ZXJBVE5Db25maWcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJBVE5Db25maWc7XG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLnN0YXRlLnN0YXRlTnVtYmVyLCB0aGlzLmFsdCwgdGhpcy5jb250ZXh0LCB0aGlzLnNlbWFudGljQ29udGV4dCwgdGhpcy5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24sIHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvcik7XG59O1xuXG5MZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIExleGVyQVROQ29uZmlnICYmXG4gICAgICAgICAgICB0aGlzLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiA9PSBvdGhlci5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24gJiZcbiAgICAgICAgICAgICh0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IgPyB0aGlzLmxleGVyQWN0aW9uRXhlY3V0b3IuZXF1YWxzKG90aGVyLmxleGVyQWN0aW9uRXhlY3V0b3IpIDogIW90aGVyLmxleGVyQWN0aW9uRXhlY3V0b3IpICYmXG4gICAgICAgICAgICBBVE5Db25maWcucHJvdG90eXBlLmVxdWFscy5jYWxsKHRoaXMsIG90aGVyKSk7XG59O1xuXG5MZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuaGFzaENvZGVGb3JDb25maWdTZXQgPSBMZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuaGFzaENvZGU7XG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZS5lcXVhbHNGb3JDb25maWdTZXQgPSBMZXhlckFUTkNvbmZpZy5wcm90b3R5cGUuZXF1YWxzO1xuXG5cbkxleGVyQVROQ29uZmlnLnByb3RvdHlwZS5jaGVja05vbkdyZWVkeURlY2lzaW9uID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gc291cmNlLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbiB8fFxuICAgICAgICAodGFyZ2V0IGluc3RhbmNlb2YgRGVjaXNpb25TdGF0ZSkgJiYgdGFyZ2V0Lm5vbkdyZWVkeTtcbn07XG5cbmV4cG9ydHMuQVROQ29uZmlnID0gQVROQ29uZmlnO1xuZXhwb3J0cy5MZXhlckFUTkNvbmZpZyA9IExleGVyQVROQ29uZmlnOyIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbi8vXG4vLyBTcGVjaWFsaXplZCB7QGxpbmsgU2V0fXtAY29kZSA8fXtAbGluayBBVE5Db25maWd9e0Bjb2RlID59IHRoYXQgY2FuIHRyYWNrXG4vLyBpbmZvIGFib3V0IHRoZSBzZXQsIHdpdGggc3VwcG9ydCBmb3IgY29tYmluaW5nIHNpbWlsYXIgY29uZmlndXJhdGlvbnMgdXNpbmcgYVxuLy8gZ3JhcGgtc3RydWN0dXJlZCBzdGFjay5cbi8vL1xuXG52YXIgQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLy4uL1V0aWxzJyk7XG52YXIgSGFzaCA9IFV0aWxzLkhhc2g7XG52YXIgU2V0ID0gVXRpbHMuU2V0O1xudmFyIFNlbWFudGljQ29udGV4dCA9IHJlcXVpcmUoJy4vU2VtYW50aWNDb250ZXh0JykuU2VtYW50aWNDb250ZXh0O1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi8uLi9QcmVkaWN0aW9uQ29udGV4dCcpLm1lcmdlO1xuXG5mdW5jdGlvbiBoYXNoQVROQ29uZmlnKGMpIHtcblx0cmV0dXJuIGMuaGFzaENvZGVGb3JDb25maWdTZXQoKTtcbn1cblxuZnVuY3Rpb24gZXF1YWxBVE5Db25maWdzKGEsIGIpIHtcblx0aWYgKCBhPT09YiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIGlmICggYT09PW51bGwgfHwgYj09PW51bGwgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2VcbiAgICAgICByZXR1cm4gYS5lcXVhbHNGb3JDb25maWdTZXQoYik7XG4gfVxuXG5cbmZ1bmN0aW9uIEFUTkNvbmZpZ1NldChmdWxsQ3R4KSB7XG5cdC8vXG5cdC8vIFRoZSByZWFzb24gdGhhdCB3ZSBuZWVkIHRoaXMgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRoZSBoYXNoIG1hcCB0byB1c2Vcblx0Ly8gdGhlIHN0YW5kYXJkIGhhc2ggY29kZSBhbmQgZXF1YWxzLiBXZSBuZWVkIGFsbCBjb25maWd1cmF0aW9ucyB3aXRoIHRoZVxuXHQvLyBzYW1lXG5cdC8vIHtAY29kZSAocyxpLF8sc2VtY3R4KX0gdG8gYmUgZXF1YWwuIFVuZm9ydHVuYXRlbHksIHRoaXMga2V5IGVmZmVjdGl2ZWx5XG5cdC8vIGRvdWJsZXNcblx0Ly8gdGhlIG51bWJlciBvZiBvYmplY3RzIGFzc29jaWF0ZWQgd2l0aCBBVE5Db25maWdzLiBUaGUgb3RoZXIgc29sdXRpb24gaXNcblx0Ly8gdG9cblx0Ly8gdXNlIGEgaGFzaCB0YWJsZSB0aGF0IGxldHMgdXMgc3BlY2lmeSB0aGUgZXF1YWxzL2hhc2hjb2RlIG9wZXJhdGlvbi5cblx0Ly8gQWxsIGNvbmZpZ3MgYnV0IGhhc2hlZCBieSAocywgaSwgXywgcGkpIG5vdCBpbmNsdWRpbmcgY29udGV4dC4gV2lwZWQgb3V0XG5cdC8vIHdoZW4gd2UgZ28gcmVhZG9ubHkgYXMgdGhpcyBzZXQgYmVjb21lcyBhIERGQSBzdGF0ZS5cblx0dGhpcy5jb25maWdMb29rdXAgPSBuZXcgU2V0KGhhc2hBVE5Db25maWcsIGVxdWFsQVROQ29uZmlncyk7XG5cdC8vIEluZGljYXRlcyB0aGF0IHRoaXMgY29uZmlndXJhdGlvbiBzZXQgaXMgcGFydCBvZiBhIGZ1bGwgY29udGV4dFxuXHQvLyBMTCBwcmVkaWN0aW9uLiBJdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBtZXJnZSAkLiBXaXRoIFNMTFxuXHQvLyBpdCdzIGEgd2lsZGNhcmQgd2hlcmVhcyBpdCBpcyBub3QgZm9yIExMIGNvbnRleHQgbWVyZ2UuXG5cdHRoaXMuZnVsbEN0eCA9IGZ1bGxDdHggPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmdWxsQ3R4O1xuXHQvLyBJbmRpY2F0ZXMgdGhhdCB0aGUgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGlzIHJlYWQtb25seS4gRG8gbm90XG5cdC8vIGFsbG93IGFueSBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIHNldDsgREZBIHN0YXRlcyB3aWxsIHBvaW50IGF0XG5cdC8vIHRoZSBzZXRzIGFuZCB0aGV5IG11c3Qgbm90IGNoYW5nZS4gVGhpcyBkb2VzIG5vdCBwcm90ZWN0IHRoZSBvdGhlclxuXHQvLyBmaWVsZHM7IGluIHBhcnRpY3VsYXIsIGNvbmZsaWN0aW5nQWx0cyBpcyBzZXQgYWZ0ZXJcblx0Ly8gd2UndmUgbWFkZSB0aGlzIHJlYWRvbmx5LlxuXHR0aGlzLnJlYWRPbmx5ID0gZmFsc2U7XG5cdC8vIFRyYWNrIHRoZSBlbGVtZW50cyBhcyB0aGV5IGFyZSBhZGRlZCB0byB0aGUgc2V0OyBzdXBwb3J0cyBnZXQoaSkvLy9cblx0dGhpcy5jb25maWdzID0gW107XG5cblx0Ly8gVE9ETzogdGhlc2UgZmllbGRzIG1ha2UgbWUgcHJldHR5IHVuY29tZm9ydGFibGUgYnV0IG5pY2UgdG8gcGFjayB1cCBpbmZvXG5cdC8vIHRvZ2V0aGVyLCBzYXZlcyByZWNvbXB1dGF0aW9uXG5cdC8vIFRPRE86IGNhbiB3ZSB0cmFjayBjb25mbGljdHMgYXMgdGhleSBhcmUgYWRkZWQgdG8gc2F2ZSBzY2FubmluZyBjb25maWdzXG5cdC8vIGxhdGVyP1xuXHR0aGlzLnVuaXF1ZUFsdCA9IDA7XG5cdHRoaXMuY29uZmxpY3RpbmdBbHRzID0gbnVsbDtcblxuXHQvLyBVc2VkIGluIHBhcnNlciBhbmQgbGV4ZXIuIEluIGxleGVyLCBpdCBpbmRpY2F0ZXMgd2UgaGl0IGEgcHJlZFxuXHQvLyB3aGlsZSBjb21wdXRpbmcgYSBjbG9zdXJlIG9wZXJhdGlvbi4gRG9uJ3QgbWFrZSBhIERGQSBzdGF0ZSBmcm9tIHRoaXMuXG5cdHRoaXMuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XG5cdHRoaXMuZGlwc0ludG9PdXRlckNvbnRleHQgPSBmYWxzZTtcblxuXHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG5cblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZGluZyBhIG5ldyBjb25maWcgbWVhbnMgbWVyZ2luZyBjb250ZXh0cyB3aXRoIGV4aXN0aW5nIGNvbmZpZ3MgZm9yXG4vLyB7QGNvZGUgKHMsIGksIHBpLCBfKX0sIHdoZXJlIHtAY29kZSBzfSBpcyB0aGVcbi8vIHtAbGluayBBVE5Db25maWcvL3N0YXRlfSwge0Bjb2RlIGl9IGlzIHRoZSB7QGxpbmsgQVROQ29uZmlnLy9hbHR9LCBhbmRcbi8vIHtAY29kZSBwaX0gaXMgdGhlIHtAbGluayBBVE5Db25maWcvL3NlbWFudGljQ29udGV4dH0uIFdlIHVzZVxuLy8ge0Bjb2RlIChzLGkscGkpfSBhcyBrZXkuXG4vL1xuLy8gPHA+VGhpcyBtZXRob2QgdXBkYXRlcyB7QGxpbmsgLy9kaXBzSW50b091dGVyQ29udGV4dH0gYW5kXG4vLyB7QGxpbmsgLy9oYXNTZW1hbnRpY0NvbnRleHR9IHdoZW4gbmVjZXNzYXJ5LjwvcD5cbi8vIC9cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY29uZmlnLCBtZXJnZUNhY2hlKSB7XG5cdGlmIChtZXJnZUNhY2hlID09PSB1bmRlZmluZWQpIHtcblx0XHRtZXJnZUNhY2hlID0gbnVsbDtcblx0fVxuXHRpZiAodGhpcy5yZWFkT25seSkge1xuXHRcdHRocm93IFwiVGhpcyBzZXQgaXMgcmVhZG9ubHlcIjtcblx0fVxuXHRpZiAoY29uZmlnLnNlbWFudGljQ29udGV4dCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHR0aGlzLmhhc1NlbWFudGljQ29udGV4dCA9IHRydWU7XG5cdH1cblx0aWYgKGNvbmZpZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA+IDApIHtcblx0XHR0aGlzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID0gdHJ1ZTtcblx0fVxuXHR2YXIgZXhpc3RpbmcgPSB0aGlzLmNvbmZpZ0xvb2t1cC5hZGQoY29uZmlnKTtcblx0aWYgKGV4aXN0aW5nID09PSBjb25maWcpIHtcblx0XHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gLTE7XG5cdFx0dGhpcy5jb25maWdzLnB1c2goY29uZmlnKTsgLy8gdHJhY2sgb3JkZXIgaGVyZVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdC8vIGEgcHJldmlvdXMgKHMsaSxwaSxfKSwgbWVyZ2Ugd2l0aCBpdCBhbmQgc2F2ZSByZXN1bHRcblx0dmFyIHJvb3RJc1dpbGRjYXJkID0gIXRoaXMuZnVsbEN0eDtcblx0dmFyIG1lcmdlZCA9IG1lcmdlKGV4aXN0aW5nLmNvbnRleHQsIGNvbmZpZy5jb250ZXh0LCByb290SXNXaWxkY2FyZCwgbWVyZ2VDYWNoZSk7XG5cdC8vIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGV4aXN0aW5nLmNvbnRleHQsIGNvbmZpZy5jb250ZXh0IGluIGNhY2hlXG5cdC8vIHNpbmNlIG9ubHkgd2F5IHRvIGNyZWF0ZSBuZXcgZ3JhcGhzIGlzIFwiY2FsbCBydWxlXCIgYW5kIGhlcmUuIFdlXG5cdC8vIGNhY2hlIGF0IGJvdGggcGxhY2VzLlxuXHRleGlzdGluZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCA9IE1hdGgubWF4KCBleGlzdGluZy5yZWFjaGVzSW50b091dGVyQ29udGV4dCwgY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0KTtcblx0Ly8gbWFrZSBzdXJlIHRvIHByZXNlcnZlIHRoZSBwcmVjZWRlbmNlIGZpbHRlciBzdXBwcmVzc2lvbiBkdXJpbmcgdGhlIG1lcmdlXG5cdGlmIChjb25maWcucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQpIHtcblx0XHRleGlzdGluZy5wcmVjZWRlbmNlRmlsdGVyU3VwcHJlc3NlZCA9IHRydWU7XG5cdH1cblx0ZXhpc3RpbmcuY29udGV4dCA9IG1lcmdlZDsgLy8gcmVwbGFjZSBjb250ZXh0OyBubyBuZWVkIHRvIGFsdCBtYXBwaW5nXG5cdHJldHVybiB0cnVlO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5nZXRTdGF0ZXMgPSBmdW5jdGlvbigpIHtcblx0dmFyIHN0YXRlcyA9IG5ldyBTZXQoKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRzdGF0ZXMuYWRkKHRoaXMuY29uZmlnc1tpXS5zdGF0ZSk7XG5cdH1cblx0cmV0dXJuIHN0YXRlcztcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuZ2V0UHJlZGljYXRlcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJlZHMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZ3MubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgYyA9IHRoaXMuY29uZmlnc1tpXS5zZW1hbnRpY0NvbnRleHQ7XG5cdFx0aWYgKGMgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG5cdFx0XHRwcmVkcy5wdXNoKGMuc2VtYW50aWNDb250ZXh0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHByZWRzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFUTkNvbmZpZ1NldC5wcm90b3R5cGUsIFwiaXRlbXNcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWdzO1xuXHR9XG59KTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5vcHRpbWl6ZUNvbmZpZ3MgPSBmdW5jdGlvbihpbnRlcnByZXRlcikge1xuXHRpZiAodGhpcy5yZWFkT25seSkge1xuXHRcdHRocm93IFwiVGhpcyBzZXQgaXMgcmVhZG9ubHlcIjtcblx0fVxuXHRpZiAodGhpcy5jb25maWdMb29rdXAubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnc1tpXTtcblx0XHRjb25maWcuY29udGV4dCA9IGludGVycHJldGVyLmdldENhY2hlZENvbnRleHQoY29uZmlnLmNvbnRleHQpO1xuXHR9XG59O1xuXG5BVE5Db25maWdTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uKGNvbGwpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsLmxlbmd0aDsgaSsrKSB7XG5cdFx0dGhpcy5hZGQoY29sbFtpXSk7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHRyZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcblx0XHQob3RoZXIgaW5zdGFuY2VvZiBBVE5Db25maWdTZXQgJiZcblx0XHRVdGlscy5lcXVhbEFycmF5cyh0aGlzLmNvbmZpZ3MsIG90aGVyLmNvbmZpZ3MpICYmXG5cdFx0dGhpcy5mdWxsQ3R4ID09PSBvdGhlci5mdWxsQ3R4ICYmXG5cdFx0dGhpcy51bmlxdWVBbHQgPT09IG90aGVyLnVuaXF1ZUFsdCAmJlxuXHRcdHRoaXMuY29uZmxpY3RpbmdBbHRzID09PSBvdGhlci5jb25mbGljdGluZ0FsdHMgJiZcblx0XHR0aGlzLmhhc1NlbWFudGljQ29udGV4dCA9PT0gb3RoZXIuaGFzU2VtYW50aWNDb250ZXh0ICYmXG5cdFx0dGhpcy5kaXBzSW50b091dGVyQ29udGV4dCA9PT0gb3RoZXIuZGlwc0ludG9PdXRlckNvbnRleHQpO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYXNoID0gbmV3IEhhc2goKTtcblx0aGFzaC51cGRhdGUodGhpcy5jb25maWdzKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn07XG5cblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcblx0aWYgKHRoaXMucmVhZE9ubHkpIHtcblx0XHRpZiAodGhpcy5jYWNoZWRIYXNoQ29kZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkSGFzaENvZGUgPSB0aGlzLmhhc2hDb2RlKCk7XG5cdFx0fVxuICAgICAgICBoYXNoLnVwZGF0ZSh0aGlzLmNhY2hlZEhhc2hDb2RlKTtcblx0fSBlbHNlIHtcbiAgICAgICAgaGFzaC51cGRhdGUodGhpcy5oYXNoQ29kZSgpKTtcblx0fVxufTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQVROQ29uZmlnU2V0LnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25maWdzLmxlbmd0aDtcblx0fVxufSk7XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jb25maWdzLmxlbmd0aCA9PT0gMDtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihpdGVtKSB7XG5cdGlmICh0aGlzLmNvbmZpZ0xvb2t1cCA9PT0gbnVsbCkge1xuXHRcdHRocm93IFwiVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIGZvciByZWFkb25seSBzZXRzLlwiO1xuXHR9XG5cdHJldHVybiB0aGlzLmNvbmZpZ0xvb2t1cC5jb250YWlucyhpdGVtKTtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuY29udGFpbnNGYXN0ID0gZnVuY3Rpb24oaXRlbSkge1xuXHRpZiAodGhpcy5jb25maWdMb29rdXAgPT09IG51bGwpIHtcblx0XHR0aHJvdyBcIlRoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmVhZG9ubHkgc2V0cy5cIjtcblx0fVxuXHRyZXR1cm4gdGhpcy5jb25maWdMb29rdXAuY29udGFpbnNGYXN0KGl0ZW0pO1xufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5yZWFkT25seSkge1xuXHRcdHRocm93IFwiVGhpcyBzZXQgaXMgcmVhZG9ubHlcIjtcblx0fVxuXHR0aGlzLmNvbmZpZ3MgPSBbXTtcblx0dGhpcy5jYWNoZWRIYXNoQ29kZSA9IC0xO1xuXHR0aGlzLmNvbmZpZ0xvb2t1cCA9IG5ldyBTZXQoKTtcbn07XG5cbkFUTkNvbmZpZ1NldC5wcm90b3R5cGUuc2V0UmVhZG9ubHkgPSBmdW5jdGlvbihyZWFkT25seSkge1xuXHR0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG5cdGlmIChyZWFkT25seSkge1xuXHRcdHRoaXMuY29uZmlnTG9va3VwID0gbnVsbDsgLy8gY2FuJ3QgbW9kLCBubyBuZWVkIGZvciBsb29rdXAgY2FjaGVcblx0fVxufTtcblxuQVROQ29uZmlnU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gVXRpbHMuYXJyYXlUb1N0cmluZyh0aGlzLmNvbmZpZ3MpICtcblx0XHQodGhpcy5oYXNTZW1hbnRpY0NvbnRleHQgPyBcIixoYXNTZW1hbnRpY0NvbnRleHQ9XCIgKyB0aGlzLmhhc1NlbWFudGljQ29udGV4dCA6IFwiXCIpICtcblx0XHQodGhpcy51bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIgPyBcIix1bmlxdWVBbHQ9XCIgKyB0aGlzLnVuaXF1ZUFsdCA6IFwiXCIpICtcblx0XHQodGhpcy5jb25mbGljdGluZ0FsdHMgIT09IG51bGwgPyBcIixjb25mbGljdGluZ0FsdHM9XCIgKyB0aGlzLmNvbmZsaWN0aW5nQWx0cyA6IFwiXCIpICtcblx0XHQodGhpcy5kaXBzSW50b091dGVyQ29udGV4dCA/IFwiLGRpcHNJbnRvT3V0ZXJDb250ZXh0XCIgOiBcIlwiKTtcbn07XG5cbmZ1bmN0aW9uIE9yZGVyZWRBVE5Db25maWdTZXQoKSB7XG5cdEFUTkNvbmZpZ1NldC5jYWxsKHRoaXMpO1xuXHR0aGlzLmNvbmZpZ0xvb2t1cCA9IG5ldyBTZXQoKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbk9yZGVyZWRBVE5Db25maWdTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5Db25maWdTZXQucHJvdG90eXBlKTtcbk9yZGVyZWRBVE5Db25maWdTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZEFUTkNvbmZpZ1NldDtcblxuZXhwb3J0cy5BVE5Db25maWdTZXQgPSBBVE5Db25maWdTZXQ7XG5leHBvcnRzLk9yZGVyZWRBVE5Db25maWdTZXQgPSBPcmRlcmVkQVROQ29uZmlnU2V0O1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG5mdW5jdGlvbiBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKGNvcHlGcm9tKSB7XG5cdGlmKGNvcHlGcm9tPT09dW5kZWZpbmVkKSB7XG5cdFx0Y29weUZyb20gPSBudWxsO1xuXHR9XG5cdHRoaXMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmlmeUFUTiA9IGNvcHlGcm9tPT09bnVsbCA/IHRydWUgOiBjb3B5RnJvbS52ZXJpZnlBVE47XG4gICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyA9IGNvcHlGcm9tPT09bnVsbCA/IGZhbHNlIDogY29weUZyb20uZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyA9IG5ldyBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zKCk7XG5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLmRlZmF1bHRPcHRpb25zLnJlYWRPbmx5ID0gdHJ1ZTtcblxuLy8gICAgZGVmIF9fc2V0YXR0cl9fKHNlbGYsIGtleSwgdmFsdWUpOlxuLy8gICAgICAgIGlmIGtleSE9XCJyZWFkT25seVwiIGFuZCBzZWxmLnJlYWRPbmx5OlxuLy8gICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oXCJUaGUgb2JqZWN0IGlzIHJlYWQgb25seS5cIilcbi8vICAgICAgICBzdXBlcih0eXBlKHNlbGYpLCBzZWxmKS5fX3NldGF0dHJfXyhrZXksdmFsdWUpXG5cbmV4cG9ydHMuQVRORGVzZXJpYWxpemF0aW9uT3B0aW9ucyA9IEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnM7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vLi4vVG9rZW4nKS5Ub2tlbjtcbnZhciBBVE4gPSByZXF1aXJlKCcuL0FUTicpLkFUTjtcbnZhciBBVE5UeXBlID0gcmVxdWlyZSgnLi9BVE5UeXBlJykuQVROVHlwZTtcbnZhciBBVE5TdGF0ZXMgPSByZXF1aXJlKCcuL0FUTlN0YXRlJyk7XG52YXIgQVROU3RhdGUgPSBBVE5TdGF0ZXMuQVROU3RhdGU7XG52YXIgQmFzaWNTdGF0ZSA9IEFUTlN0YXRlcy5CYXNpY1N0YXRlO1xudmFyIERlY2lzaW9uU3RhdGUgPSBBVE5TdGF0ZXMuRGVjaXNpb25TdGF0ZTtcbnZhciBCbG9ja1N0YXJ0U3RhdGUgPSBBVE5TdGF0ZXMuQmxvY2tTdGFydFN0YXRlO1xudmFyIEJsb2NrRW5kU3RhdGUgPSBBVE5TdGF0ZXMuQmxvY2tFbmRTdGF0ZTtcbnZhciBMb29wRW5kU3RhdGUgPSBBVE5TdGF0ZXMuTG9vcEVuZFN0YXRlO1xudmFyIFJ1bGVTdGFydFN0YXRlID0gQVROU3RhdGVzLlJ1bGVTdGFydFN0YXRlO1xudmFyIFJ1bGVTdG9wU3RhdGUgPSBBVE5TdGF0ZXMuUnVsZVN0b3BTdGF0ZTtcbnZhciBUb2tlbnNTdGFydFN0YXRlID0gQVROU3RhdGVzLlRva2Vuc1N0YXJ0U3RhdGU7XG52YXIgUGx1c0xvb3BiYWNrU3RhdGUgPSBBVE5TdGF0ZXMuUGx1c0xvb3BiYWNrU3RhdGU7XG52YXIgU3Rhckxvb3BiYWNrU3RhdGUgPSBBVE5TdGF0ZXMuU3Rhckxvb3BiYWNrU3RhdGU7XG52YXIgU3Rhckxvb3BFbnRyeVN0YXRlID0gQVROU3RhdGVzLlN0YXJMb29wRW50cnlTdGF0ZTtcbnZhciBQbHVzQmxvY2tTdGFydFN0YXRlID0gQVROU3RhdGVzLlBsdXNCbG9ja1N0YXJ0U3RhdGU7XG52YXIgU3RhckJsb2NrU3RhcnRTdGF0ZSA9IEFUTlN0YXRlcy5TdGFyQmxvY2tTdGFydFN0YXRlO1xudmFyIEJhc2ljQmxvY2tTdGFydFN0YXRlID0gQVROU3RhdGVzLkJhc2ljQmxvY2tTdGFydFN0YXRlO1xudmFyIFRyYW5zaXRpb25zID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uJyk7XG52YXIgVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlRyYW5zaXRpb247XG52YXIgQXRvbVRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5BdG9tVHJhbnNpdGlvbjtcbnZhciBTZXRUcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuU2V0VHJhbnNpdGlvbjtcbnZhciBOb3RTZXRUcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuTm90U2V0VHJhbnNpdGlvbjtcbnZhciBSdWxlVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlJ1bGVUcmFuc2l0aW9uO1xudmFyIFJhbmdlVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlJhbmdlVHJhbnNpdGlvbjtcbnZhciBBY3Rpb25UcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuQWN0aW9uVHJhbnNpdGlvbjtcbnZhciBFcHNpbG9uVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLkVwc2lsb25UcmFuc2l0aW9uO1xudmFyIFdpbGRjYXJkVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLldpbGRjYXJkVHJhbnNpdGlvbjtcbnZhciBQcmVkaWNhdGVUcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuUHJlZGljYXRlVHJhbnNpdGlvbjtcbnZhciBQcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uO1xudmFyIEludGVydmFsU2V0ID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsU2V0O1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIEFUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSByZXF1aXJlKCcuL0FUTkRlc2VyaWFsaXphdGlvbk9wdGlvbnMnKS5BVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zO1xudmFyIExleGVyQWN0aW9ucyA9IHJlcXVpcmUoJy4vTGV4ZXJBY3Rpb24nKTtcbnZhciBMZXhlckFjdGlvblR5cGUgPSBMZXhlckFjdGlvbnMuTGV4ZXJBY3Rpb25UeXBlO1xudmFyIExleGVyU2tpcEFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlclNraXBBY3Rpb247XG52YXIgTGV4ZXJDaGFubmVsQWN0aW9uID0gTGV4ZXJBY3Rpb25zLkxleGVyQ2hhbm5lbEFjdGlvbjtcbnZhciBMZXhlckN1c3RvbUFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlckN1c3RvbUFjdGlvbjtcbnZhciBMZXhlck1vcmVBY3Rpb24gPSBMZXhlckFjdGlvbnMuTGV4ZXJNb3JlQWN0aW9uO1xudmFyIExleGVyVHlwZUFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlclR5cGVBY3Rpb247XG52YXIgTGV4ZXJQdXNoTW9kZUFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlclB1c2hNb2RlQWN0aW9uO1xudmFyIExleGVyUG9wTW9kZUFjdGlvbiA9IExleGVyQWN0aW9ucy5MZXhlclBvcE1vZGVBY3Rpb247XG52YXIgTGV4ZXJNb2RlQWN0aW9uID0gTGV4ZXJBY3Rpb25zLkxleGVyTW9kZUFjdGlvbjtcbi8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHN1cHBvcnRlZCBzZXJpYWxpemVkIFVVSUQuXG4vLyBzdGljayB0byBzZXJpYWxpemVkIHZlcnNpb24gZm9yIG5vdywgd2UgZG9uJ3QgbmVlZCBhIFVVSUQgaW5zdGFuY2VcbnZhciBCQVNFX1NFUklBTElaRURfVVVJRCA9IFwiQUFEQjhEN0UtQUVFRi00NDE1LUFEMkItODIwNEQ2Q0YwNDJFXCI7XG5cbi8vXG4vLyBUaGlzIFVVSUQgaW5kaWNhdGVzIHRoZSBzZXJpYWxpemVkIEFUTiBjb250YWlucyB0d28gc2V0cyBvZlxuLy8gSW50ZXJ2YWxTZXRzLCB3aGVyZSB0aGUgc2Vjb25kIHNldCdzIHZhbHVlcyBhcmUgZW5jb2RlZCBhc1xuLy8gMzItYml0IGludGVnZXJzIHRvIHN1cHBvcnQgdGhlIGZ1bGwgVW5pY29kZSBTTVAgcmFuZ2UgdXAgdG8gVSsxMEZGRkYuXG4vL1xudmFyIEFEREVEX1VOSUNPREVfU01QID0gXCI1OTYyNzc4NC0zQkU1LTQxN0EtQjlFQi04MTMxQTcyODYwODlcIjtcblxuLy8gVGhpcyBsaXN0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY3VycmVudGx5IHN1cHBvcnRlZCBVVUlEcywgb3JkZXJlZCBieSB3aGVuXG4vLyB0aGUgZmVhdHVyZSBmaXJzdCBhcHBlYXJlZCBpbiB0aGlzIGJyYW5jaC5cbnZhciBTVVBQT1JURURfVVVJRFMgPSBbIEJBU0VfU0VSSUFMSVpFRF9VVUlELCBBRERFRF9VTklDT0RFX1NNUCBdO1xuXG52YXIgU0VSSUFMSVpFRF9WRVJTSU9OID0gMztcblxuLy8gVGhpcyBpcyB0aGUgY3VycmVudCBzZXJpYWxpemVkIFVVSUQuXG52YXIgU0VSSUFMSVpFRF9VVUlEID0gQURERURfVU5JQ09ERV9TTVA7XG5cbmZ1bmN0aW9uIGluaXRBcnJheSggbGVuZ3RoLCB2YWx1ZSkge1xuXHR2YXIgdG1wID0gW107XG5cdHRtcFtsZW5ndGgtMV0gPSB2YWx1ZTtcblx0cmV0dXJuIHRtcC5tYXAoZnVuY3Rpb24oaSkge3JldHVybiB2YWx1ZTt9KTtcbn1cblxuZnVuY3Rpb24gQVRORGVzZXJpYWxpemVyIChvcHRpb25zKSB7XG5cbiAgICBpZiAoIG9wdGlvbnM9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IG51bGwgKSB7XG4gICAgICAgIG9wdGlvbnMgPSBBVE5EZXNlcmlhbGl6YXRpb25PcHRpb25zLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLmRlc2VyaWFsaXphdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc3RhdGVGYWN0b3JpZXMgPSBudWxsO1xuICAgIHRoaXMuYWN0aW9uRmFjdG9yaWVzID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBEZXRlcm1pbmVzIGlmIGEgcGFydGljdWxhciBzZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFUTiBzdXBwb3J0c1xuLy8gYSBwYXJ0aWN1bGFyIGZlYXR1cmUsIGlkZW50aWZpZWQgYnkgdGhlIHtAbGluayBVVUlEfSB1c2VkIGZvciBzZXJpYWxpemluZ1xuLy8gdGhlIEFUTiBhdCB0aGUgdGltZSB0aGUgZmVhdHVyZSB3YXMgZmlyc3QgaW50cm9kdWNlZC5cbi8vXG4vLyBAcGFyYW0gZmVhdHVyZSBUaGUge0BsaW5rIFVVSUR9IG1hcmtpbmcgdGhlIGZpcnN0IHRpbWUgdGhlIGZlYXR1cmUgd2FzXG4vLyBzdXBwb3J0ZWQgaW4gdGhlIHNlcmlhbGl6ZWQgQVROLlxuLy8gQHBhcmFtIGFjdHVhbFV1aWQgVGhlIHtAbGluayBVVUlEfSBvZiB0aGUgYWN0dWFsIHNlcmlhbGl6ZWQgQVROIHdoaWNoIGlzXG4vLyBjdXJyZW50bHkgYmVpbmcgZGVzZXJpYWxpemVkLlxuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgdGhlIHtAY29kZSBhY3R1YWxVdWlkfSB2YWx1ZSByZXByZXNlbnRzIGFcbi8vIHNlcmlhbGl6ZWQgQVROIGF0IG9yIGFmdGVyIHRoZSBmZWF0dXJlIGlkZW50aWZpZWQgYnkge0Bjb2RlIGZlYXR1cmV9IHdhc1xuLy8gaW50cm9kdWNlZDsgb3RoZXJ3aXNlLCB7QGNvZGUgZmFsc2V9LlxuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmlzRmVhdHVyZVN1cHBvcnRlZCA9IGZ1bmN0aW9uKGZlYXR1cmUsIGFjdHVhbFV1aWQpIHtcbiAgICB2YXIgaWR4MSA9IFNVUFBPUlRFRF9VVUlEUy5pbmRleE9mKGZlYXR1cmUpO1xuICAgIGlmIChpZHgxPDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaWR4MiA9IFNVUFBPUlRFRF9VVUlEUy5pbmRleE9mKGFjdHVhbFV1aWQpO1xuICAgIHJldHVybiBpZHgyID49IGlkeDE7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMucmVzZXQoZGF0YSk7XG4gICAgdGhpcy5jaGVja1ZlcnNpb24oKTtcbiAgICB0aGlzLmNoZWNrVVVJRCgpO1xuICAgIHZhciBhdG4gPSB0aGlzLnJlYWRBVE4oKTtcbiAgICB0aGlzLnJlYWRTdGF0ZXMoYXRuKTtcbiAgICB0aGlzLnJlYWRSdWxlcyhhdG4pO1xuICAgIHRoaXMucmVhZE1vZGVzKGF0bik7XG4gICAgdmFyIHNldHMgPSBbXTtcbiAgICAvLyBGaXJzdCwgZGVzZXJpYWxpemUgc2V0cyB3aXRoIDE2LWJpdCBhcmd1bWVudHMgPD0gVStGRkZGLlxuICAgIHRoaXMucmVhZFNldHMoYXRuLCBzZXRzLCB0aGlzLnJlYWRJbnQuYmluZCh0aGlzKSk7XG4gICAgLy8gTmV4dCwgaWYgdGhlIEFUTiB3YXMgc2VyaWFsaXplZCB3aXRoIHRoZSBVbmljb2RlIFNNUCBmZWF0dXJlLFxuICAgIC8vIGRlc2VyaWFsaXplIHNldHMgd2l0aCAzMi1iaXQgYXJndW1lbnRzIDw9IFUrMTBGRkZGLlxuICAgIGlmICh0aGlzLmlzRmVhdHVyZVN1cHBvcnRlZChBRERFRF9VTklDT0RFX1NNUCwgdGhpcy51dWlkKSkge1xuICAgICAgICB0aGlzLnJlYWRTZXRzKGF0biwgc2V0cywgdGhpcy5yZWFkSW50MzIuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHRoaXMucmVhZEVkZ2VzKGF0biwgc2V0cyk7XG4gICAgdGhpcy5yZWFkRGVjaXNpb25zKGF0bik7XG4gICAgdGhpcy5yZWFkTGV4ZXJBY3Rpb25zKGF0bik7XG4gICAgdGhpcy5tYXJrUHJlY2VkZW5jZURlY2lzaW9ucyhhdG4pO1xuICAgIHRoaXMudmVyaWZ5QVROKGF0bik7XG4gICAgaWYgKHRoaXMuZGVzZXJpYWxpemF0aW9uT3B0aW9ucy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9ucyAmJiBhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuUEFSU0VSICkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlUnVsZUJ5cGFzc1RyYW5zaXRpb25zKGF0bik7XG4gICAgICAgIC8vIHJlLXZlcmlmeSBhZnRlciBtb2RpZmljYXRpb25cbiAgICAgICAgdGhpcy52ZXJpZnlBVE4oYXRuKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0bjtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihkYXRhKSB7XG5cdHZhciBhZGp1c3QgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciB2ID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICByZXR1cm4gdj4xICA/IHYtMiA6IHYgKyA2NTUzNDtcblx0fTtcbiAgICB2YXIgdGVtcCA9IGRhdGEuc3BsaXQoXCJcIikubWFwKGFkanVzdCk7XG4gICAgLy8gZG9uJ3QgYWRqdXN0IHRoZSBmaXJzdCB2YWx1ZSBzaW5jZSB0aGF0J3MgdGhlIHZlcnNpb24gbnVtYmVyXG4gICAgdGVtcFswXSA9IGRhdGEuY2hhckNvZGVBdCgwKTtcbiAgICB0aGlzLmRhdGEgPSB0ZW1wO1xuICAgIHRoaXMucG9zID0gMDtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuY2hlY2tWZXJzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlcnNpb24gPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBpZiAoIHZlcnNpb24gIT09IFNFUklBTElaRURfVkVSU0lPTiApIHtcbiAgICAgICAgdGhyb3cgKFwiQ291bGQgbm90IGRlc2VyaWFsaXplIEFUTiB3aXRoIHZlcnNpb24gXCIgKyB2ZXJzaW9uICsgXCIgKGV4cGVjdGVkIFwiICsgU0VSSUFMSVpFRF9WRVJTSU9OICsgXCIpLlwiKTtcbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLmNoZWNrVVVJRCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1dWlkID0gdGhpcy5yZWFkVVVJRCgpO1xuICAgIGlmIChTVVBQT1JURURfVVVJRFMuaW5kZXhPZih1dWlkKTwwKSB7XG4gICAgICAgIHRocm93IChcIkNvdWxkIG5vdCBkZXNlcmlhbGl6ZSBBVE4gd2l0aCBVVUlEOiBcIiArIHV1aWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgKGV4cGVjdGVkIFwiICsgU0VSSUFMSVpFRF9VVUlEICsgXCIgb3IgYSBsZWdhY3kgVVVJRCkuXCIsIHV1aWQsIFNFUklBTElaRURfVVVJRCk7XG4gICAgfVxuICAgIHRoaXMudXVpZCA9IHV1aWQ7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRBVE4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZ3JhbW1hclR5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICB2YXIgbWF4VG9rZW5UeXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgcmV0dXJuIG5ldyBBVE4oZ3JhbW1hclR5cGUsIG1heFRva2VuVHlwZSk7XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRTdGF0ZXMgPSBmdW5jdGlvbihhdG4pIHtcblx0dmFyIGosIHBhaXIsIHN0YXRlTnVtYmVyO1xuICAgIHZhciBsb29wQmFja1N0YXRlTnVtYmVycyA9IFtdO1xuICAgIHZhciBlbmRTdGF0ZU51bWJlcnMgPSBbXTtcbiAgICB2YXIgbnN0YXRlcyA9IHRoaXMucmVhZEludCgpO1xuICAgIGZvcih2YXIgaT0wOyBpPG5zdGF0ZXM7IGkrKykge1xuICAgICAgICB2YXIgc3R5cGUgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgLy8gaWdub3JlIGJhZCB0eXBlIG9mIHN0YXRlc1xuICAgICAgICBpZiAoc3R5cGU9PT1BVE5TdGF0ZS5JTlZBTElEX1RZUEUpIHtcbiAgICAgICAgICAgIGF0bi5hZGRTdGF0ZShudWxsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlSW5kZXggPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgaWYgKHJ1bGVJbmRleCA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICBydWxlSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IHRoaXMuc3RhdGVGYWN0b3J5KHN0eXBlLCBydWxlSW5kZXgpO1xuICAgICAgICBpZiAoc3R5cGUgPT09IEFUTlN0YXRlLkxPT1BfRU5EKSB7IC8vIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgdmFyIGxvb3BCYWNrU3RhdGVOdW1iZXIgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICAgIGxvb3BCYWNrU3RhdGVOdW1iZXJzLnB1c2goW3MsIGxvb3BCYWNrU3RhdGVOdW1iZXJdKTtcbiAgICAgICAgfSBlbHNlIGlmKHMgaW5zdGFuY2VvZiBCbG9ja1N0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBlbmRTdGF0ZU51bWJlciA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICAgICAgZW5kU3RhdGVOdW1iZXJzLnB1c2goW3MsIGVuZFN0YXRlTnVtYmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXRuLmFkZFN0YXRlKHMpO1xuICAgIH1cbiAgICAvLyBkZWxheSB0aGUgYXNzaWdubWVudCBvZiBsb29wIGJhY2sgYW5kIGVuZCBzdGF0ZXMgdW50aWwgd2Uga25vdyBhbGwgdGhlXG5cdC8vIHN0YXRlIGluc3RhbmNlcyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICBmb3IgKGo9MDsgajxsb29wQmFja1N0YXRlTnVtYmVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYWlyID0gbG9vcEJhY2tTdGF0ZU51bWJlcnNbal07XG4gICAgICAgIHBhaXJbMF0ubG9vcEJhY2tTdGF0ZSA9IGF0bi5zdGF0ZXNbcGFpclsxXV07XG4gICAgfVxuXG4gICAgZm9yIChqPTA7IGo8ZW5kU3RhdGVOdW1iZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhaXIgPSBlbmRTdGF0ZU51bWJlcnNbal07XG4gICAgICAgIHBhaXJbMF0uZW5kU3RhdGUgPSBhdG4uc3RhdGVzW3BhaXJbMV1dO1xuICAgIH1cblxuICAgIHZhciBudW1Ob25HcmVlZHlTdGF0ZXMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBmb3IgKGo9MDsgajxudW1Ob25HcmVlZHlTdGF0ZXM7IGorKykge1xuICAgICAgICBzdGF0ZU51bWJlciA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4uc3RhdGVzW3N0YXRlTnVtYmVyXS5ub25HcmVlZHkgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBudW1QcmVjZWRlbmNlU3RhdGVzID0gdGhpcy5yZWFkSW50KCk7XG4gICAgZm9yIChqPTA7IGo8bnVtUHJlY2VkZW5jZVN0YXRlczsgaisrKSB7XG4gICAgICAgIHN0YXRlTnVtYmVyID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGF0bi5zdGF0ZXNbc3RhdGVOdW1iZXJdLmlzUHJlY2VkZW5jZVJ1bGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZFJ1bGVzID0gZnVuY3Rpb24oYXRuKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG5ydWxlcyA9IHRoaXMucmVhZEludCgpO1xuICAgIGlmIChhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIgKSB7XG4gICAgICAgIGF0bi5ydWxlVG9Ub2tlblR5cGUgPSBpbml0QXJyYXkobnJ1bGVzLCAwKTtcbiAgICB9XG4gICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGUgPSBpbml0QXJyYXkobnJ1bGVzLCAwKTtcbiAgICBmb3IgKGk9MDsgaTxucnVsZXM7IGkrKykge1xuICAgICAgICB2YXIgcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgc3RhcnRTdGF0ZSA9IGF0bi5zdGF0ZXNbc107XG4gICAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlW2ldID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgaWYgKCBhdG4uZ3JhbW1hclR5cGUgPT09IEFUTlR5cGUuTEVYRVIgKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5UeXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgICAgICBpZiAodG9rZW5UeXBlID09PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICB0b2tlblR5cGUgPSBUb2tlbi5FT0Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlW2ldID0gdG9rZW5UeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0bi5ydWxlVG9TdG9wU3RhdGUgPSBpbml0QXJyYXkobnJ1bGVzLCAwKTtcbiAgICBmb3IgKGk9MDsgaTxhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGlmICghKHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGF0bi5ydWxlVG9TdG9wU3RhdGVbc3RhdGUucnVsZUluZGV4XSA9IHN0YXRlO1xuICAgICAgICBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtzdGF0ZS5ydWxlSW5kZXhdLnN0b3BTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZE1vZGVzID0gZnVuY3Rpb24oYXRuKSB7XG4gICAgdmFyIG5tb2RlcyA9IHRoaXMucmVhZEludCgpO1xuICAgIGZvciAodmFyIGk9MDsgaTxubW9kZXM7IGkrKykge1xuICAgICAgICB2YXIgcyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4ubW9kZVRvU3RhcnRTdGF0ZS5wdXNoKGF0bi5zdGF0ZXNbc10pO1xuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZFNldHMgPSBmdW5jdGlvbihhdG4sIHNldHMsIHJlYWRVbmljb2RlKSB7XG4gICAgdmFyIG0gPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8bTsgaSsrKSB7XG4gICAgICAgIHZhciBpc2V0ID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIHNldHMucHVzaChpc2V0KTtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgdmFyIGNvbnRhaW5zRW9mID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIGlmIChjb250YWluc0VvZiE9PTApIHtcbiAgICAgICAgICAgIGlzZXQuYWRkT25lKC0xKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqPTA7IGo8bjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaTEgPSByZWFkVW5pY29kZSgpO1xuICAgICAgICAgICAgdmFyIGkyID0gcmVhZFVuaWNvZGUoKTtcbiAgICAgICAgICAgIGlzZXQuYWRkUmFuZ2UoaTEsIGkyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZEVkZ2VzID0gZnVuY3Rpb24oYXRuLCBzZXRzKSB7XG5cdHZhciBpLCBqLCBzdGF0ZSwgdHJhbnMsIHRhcmdldDtcbiAgICB2YXIgbmVkZ2VzID0gdGhpcy5yZWFkSW50KCk7XG4gICAgZm9yIChpPTA7IGk8bmVkZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIHNyYyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgdHJnID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIHZhciB0dHlwZSA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgYXJnMSA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgYXJnMiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB2YXIgYXJnMyA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICB0cmFucyA9IHRoaXMuZWRnZUZhY3RvcnkoYXRuLCB0dHlwZSwgc3JjLCB0cmcsIGFyZzEsIGFyZzIsIGFyZzMsIHNldHMpO1xuICAgICAgICB2YXIgc3JjU3RhdGUgPSBhdG4uc3RhdGVzW3NyY107XG4gICAgICAgIHNyY1N0YXRlLmFkZFRyYW5zaXRpb24odHJhbnMpO1xuICAgIH1cbiAgICAvLyBlZGdlcyBmb3IgcnVsZSBzdG9wIHN0YXRlcyBjYW4gYmUgZGVyaXZlZCwgc28gdGhleSBhcmVuJ3Qgc2VyaWFsaXplZFxuICAgIGZvciAoaT0wOyBpPGF0bi5zdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICBmb3IgKGo9MDsgajxzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHQgPSBzdGF0ZS50cmFuc2l0aW9uc1tqXTtcbiAgICAgICAgICAgIGlmICghKHQgaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblx0XHRcdHZhciBvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gLTE7XG5cdFx0XHRpZiAoYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbdC50YXJnZXQucnVsZUluZGV4XS5pc1ByZWNlZGVuY2VSdWxlKSB7XG5cdFx0XHRcdGlmICh0LnByZWNlZGVuY2UgPT09IDApIHtcblx0XHRcdFx0XHRvdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gdC50YXJnZXQucnVsZUluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRyYW5zID0gbmV3IEVwc2lsb25UcmFuc2l0aW9uKHQuZm9sbG93U3RhdGUsIG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4pO1xuICAgICAgICAgICAgYXRuLnJ1bGVUb1N0b3BTdGF0ZVt0LnRhcmdldC5ydWxlSW5kZXhdLmFkZFRyYW5zaXRpb24odHJhbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBrbm93IHRoZSBlbmQgc3RhdGUgdG8gc2V0IGl0cyBzdGFydCBzdGF0ZVxuICAgICAgICAgICAgaWYgKHN0YXRlLmVuZFN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKFwiSWxsZWdhbFN0YXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYmxvY2sgZW5kIHN0YXRlcyBjYW4gb25seSBiZSBhc3NvY2lhdGVkIHRvIGEgc2luZ2xlIGJsb2NrIHN0YXJ0XG5cdFx0XHQvLyBzdGF0ZVxuICAgICAgICAgICAgaWYgKCBzdGF0ZS5lbmRTdGF0ZS5zdGFydFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKFwiSWxsZWdhbFN0YXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuZW5kU3RhdGUuc3RhcnRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFBsdXNMb29wYmFja1N0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGo9MDsgajxzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHN0YXRlLnRyYW5zaXRpb25zW2pdLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQubG9vcEJhY2tTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wYmFja1N0YXRlKSB7XG4gICAgICAgICAgICBmb3IgKGo9MDsgajxzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHN0YXRlLnRyYW5zaXRpb25zW2pdLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgU3Rhckxvb3BFbnRyeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5sb29wQmFja1N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkRGVjaXNpb25zID0gZnVuY3Rpb24oYXRuKSB7XG4gICAgdmFyIG5kZWNpc2lvbnMgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICBmb3IgKHZhciBpPTA7IGk8bmRlY2lzaW9uczsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgIHZhciBkZWNTdGF0ZSA9IGF0bi5zdGF0ZXNbc107XG4gICAgICAgIGF0bi5kZWNpc2lvblRvU3RhdGUucHVzaChkZWNTdGF0ZSk7XG4gICAgICAgIGRlY1N0YXRlLmRlY2lzaW9uID0gaTtcbiAgICB9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRMZXhlckFjdGlvbnMgPSBmdW5jdGlvbihhdG4pIHtcbiAgICBpZiAoYXRuLmdyYW1tYXJUeXBlID09PSBBVE5UeXBlLkxFWEVSKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICBhdG4ubGV4ZXJBY3Rpb25zID0gaW5pdEFycmF5KGNvdW50LCBudWxsKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb25UeXBlID0gdGhpcy5yZWFkSW50KCk7XG4gICAgICAgICAgICB2YXIgZGF0YTEgPSB0aGlzLnJlYWRJbnQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhMSA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgZGF0YTEgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhMiA9IHRoaXMucmVhZEludCgpO1xuICAgICAgICAgICAgaWYgKGRhdGEyID09PSAweEZGRkYpIHtcbiAgICAgICAgICAgICAgICBkYXRhMiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxleGVyQWN0aW9uID0gdGhpcy5sZXhlckFjdGlvbkZhY3RvcnkoYWN0aW9uVHlwZSwgZGF0YTEsIGRhdGEyKTtcbiAgICAgICAgICAgIGF0bi5sZXhlckFjdGlvbnNbaV0gPSBsZXhlckFjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuZ2VuZXJhdGVSdWxlQnlwYXNzVHJhbnNpdGlvbnMgPSBmdW5jdGlvbihhdG4pIHtcblx0dmFyIGk7XG4gICAgdmFyIGNvdW50ID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGUubGVuZ3RoO1xuICAgIGZvcihpPTA7IGk8Y291bnQ7IGkrKykge1xuICAgICAgICBhdG4ucnVsZVRvVG9rZW5UeXBlW2ldID0gYXRuLm1heFRva2VuVHlwZSArIGkgKyAxO1xuICAgIH1cbiAgICBmb3IoaT0wOyBpPGNvdW50OyBpKyspIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uKGF0biwgaSk7XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5nZW5lcmF0ZVJ1bGVCeXBhc3NUcmFuc2l0aW9uID0gZnVuY3Rpb24oYXRuLCBpZHgpIHtcblx0dmFyIGksIHN0YXRlO1xuICAgIHZhciBieXBhc3NTdGFydCA9IG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSgpO1xuICAgIGJ5cGFzc1N0YXJ0LnJ1bGVJbmRleCA9IGlkeDtcbiAgICBhdG4uYWRkU3RhdGUoYnlwYXNzU3RhcnQpO1xuXG4gICAgdmFyIGJ5cGFzc1N0b3AgPSBuZXcgQmxvY2tFbmRTdGF0ZSgpO1xuICAgIGJ5cGFzc1N0b3AucnVsZUluZGV4ID0gaWR4O1xuICAgIGF0bi5hZGRTdGF0ZShieXBhc3NTdG9wKTtcblxuICAgIGJ5cGFzc1N0YXJ0LmVuZFN0YXRlID0gYnlwYXNzU3RvcDtcbiAgICBhdG4uZGVmaW5lRGVjaXNpb25TdGF0ZShieXBhc3NTdGFydCk7XG5cbiAgICBieXBhc3NTdG9wLnN0YXJ0U3RhdGUgPSBieXBhc3NTdGFydDtcblxuICAgIHZhciBleGNsdWRlVHJhbnNpdGlvbiA9IG51bGw7XG4gICAgdmFyIGVuZFN0YXRlID0gbnVsbDtcblxuICAgIGlmIChhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpZHhdLmlzUHJlY2VkZW5jZVJ1bGUpIHtcbiAgICAgICAgLy8gd3JhcCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1bGUgdG8gdGhlIFN0YXJMb29wRW50cnlTdGF0ZVxuICAgICAgICBlbmRTdGF0ZSA9IG51bGw7XG4gICAgICAgIGZvcihpPTA7IGk8YXRuLnN0YXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RhdGUgPSBhdG4uc3RhdGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVJc0VuZFN0YXRlRm9yKHN0YXRlLCBpZHgpKSB7XG4gICAgICAgICAgICAgICAgZW5kU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBleGNsdWRlVHJhbnNpdGlvbiA9IHN0YXRlLmxvb3BCYWNrU3RhdGUudHJhbnNpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2x1ZGVUcmFuc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyAoXCJDb3VsZG4ndCBpZGVudGlmeSBmaW5hbCBzdGF0ZSBvZiB0aGUgcHJlY2VkZW5jZSBydWxlIHByZWZpeCBzZWN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFN0YXRlID0gYXRuLnJ1bGVUb1N0b3BTdGF0ZVtpZHhdO1xuICAgIH1cblxuICAgIC8vIGFsbCBub24tZXhjbHVkZWQgdHJhbnNpdGlvbnMgdGhhdCBjdXJyZW50bHkgdGFyZ2V0IGVuZCBzdGF0ZSBuZWVkIHRvXG5cdC8vIHRhcmdldCBibG9ja0VuZCBpbnN0ZWFkXG4gICAgZm9yKGk9MDsgaTxhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8c3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uID0gc3RhdGUudHJhbnNpdGlvbnNbal07XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbiA9PT0gZXhjbHVkZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uLnRhcmdldCA9PT0gZW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnRhcmdldCA9IGJ5cGFzc1N0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbGwgdHJhbnNpdGlvbnMgbGVhdmluZyB0aGUgcnVsZSBzdGFydCBzdGF0ZSBuZWVkIHRvIGxlYXZlIGJsb2NrU3RhcnRcblx0Ly8gaW5zdGVhZFxuICAgIHZhciBydWxlVG9TdGFydFN0YXRlID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGVbaWR4XTtcbiAgICB2YXIgY291bnQgPSBydWxlVG9TdGFydFN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoIGNvdW50ID4gMCkge1xuICAgICAgICBieXBhc3NTdGFydC5hZGRUcmFuc2l0aW9uKHJ1bGVUb1N0YXJ0U3RhdGUudHJhbnNpdGlvbnNbY291bnQtMV0pO1xuICAgICAgICBydWxlVG9TdGFydFN0YXRlLnRyYW5zaXRpb25zID0gcnVsZVRvU3RhcnRTdGF0ZS50cmFuc2l0aW9ucy5zbGljZSgtMSk7XG4gICAgfVxuICAgIC8vIGxpbmsgdGhlIG5ldyBzdGF0ZXNcbiAgICBhdG4ucnVsZVRvU3RhcnRTdGF0ZVtpZHhdLmFkZFRyYW5zaXRpb24obmV3IEVwc2lsb25UcmFuc2l0aW9uKGJ5cGFzc1N0YXJ0KSk7XG4gICAgYnlwYXNzU3RvcC5hZGRUcmFuc2l0aW9uKG5ldyBFcHNpbG9uVHJhbnNpdGlvbihlbmRTdGF0ZSkpO1xuXG4gICAgdmFyIG1hdGNoU3RhdGUgPSBuZXcgQmFzaWNTdGF0ZSgpO1xuICAgIGF0bi5hZGRTdGF0ZShtYXRjaFN0YXRlKTtcbiAgICBtYXRjaFN0YXRlLmFkZFRyYW5zaXRpb24obmV3IEF0b21UcmFuc2l0aW9uKGJ5cGFzc1N0b3AsIGF0bi5ydWxlVG9Ub2tlblR5cGVbaWR4XSkpO1xuICAgIGJ5cGFzc1N0YXJ0LmFkZFRyYW5zaXRpb24obmV3IEVwc2lsb25UcmFuc2l0aW9uKG1hdGNoU3RhdGUpKTtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuc3RhdGVJc0VuZFN0YXRlRm9yID0gZnVuY3Rpb24oc3RhdGUsIGlkeCkge1xuICAgIGlmICggc3RhdGUucnVsZUluZGV4ICE9PSBpZHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghKCBzdGF0ZSBpbnN0YW5jZW9mIFN0YXJMb29wRW50cnlTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXliZUxvb3BFbmRTdGF0ZSA9IHN0YXRlLnRyYW5zaXRpb25zW3N0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCAtIDFdLnRhcmdldDtcbiAgICBpZiAoISggbWF5YmVMb29wRW5kU3RhdGUgaW5zdGFuY2VvZiBMb29wRW5kU3RhdGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobWF5YmVMb29wRW5kU3RhdGUuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucyAmJlxuICAgICAgICAobWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vXG4vLyBBbmFseXplIHRoZSB7QGxpbmsgU3Rhckxvb3BFbnRyeVN0YXRlfSBzdGF0ZXMgaW4gdGhlIHNwZWNpZmllZCBBVE4gdG8gc2V0XG4vLyB0aGUge0BsaW5rIFN0YXJMb29wRW50cnlTdGF0ZS8vaXNQcmVjZWRlbmNlRGVjaXNpb259IGZpZWxkIHRvIHRoZVxuLy8gY29ycmVjdCB2YWx1ZS5cbi8vXG4vLyBAcGFyYW0gYXRuIFRoZSBBVE4uXG4vL1xuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5tYXJrUHJlY2VkZW5jZURlY2lzaW9ucyA9IGZ1bmN0aW9uKGF0bikge1xuXHRmb3IodmFyIGk9MDsgaTxhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHN0YXRlID0gYXRuLnN0YXRlc1tpXTtcblx0XHRpZiAoISggc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhbmFseXplIHRoZSBBVE4gdG8gZGV0ZXJtaW5lIGlmIHRoaXMgQVROIGRlY2lzaW9uIHN0YXRlIGlzIHRoZVxuICAgICAgICAvLyBkZWNpc2lvbiBmb3IgdGhlIGNsb3N1cmUgYmxvY2sgdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgYVxuICAgICAgICAvLyBwcmVjZWRlbmNlIHJ1bGUgc2hvdWxkIGNvbnRpbnVlIG9yIGNvbXBsZXRlLlxuICAgICAgICAvL1xuICAgICAgICBpZiAoIGF0bi5ydWxlVG9TdGFydFN0YXRlW3N0YXRlLnJ1bGVJbmRleF0uaXNQcmVjZWRlbmNlUnVsZSkge1xuICAgICAgICAgICAgdmFyIG1heWJlTG9vcEVuZFN0YXRlID0gc3RhdGUudHJhbnNpdGlvbnNbc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoIC0gMV0udGFyZ2V0O1xuICAgICAgICAgICAgaWYgKG1heWJlTG9vcEVuZFN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBtYXliZUxvb3BFbmRTdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobWF5YmVMb29wRW5kU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNQcmVjZWRlbmNlRGVjaXNpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXHR9XG59O1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnZlcmlmeUFUTiA9IGZ1bmN0aW9uKGF0bikge1xuICAgIGlmICghdGhpcy5kZXNlcmlhbGl6YXRpb25PcHRpb25zLnZlcmlmeUFUTikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHZlcmlmeSBhc3N1bXB0aW9uc1xuXHRmb3IodmFyIGk9MDsgaTxhdG4uc3RhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGF0bi5zdGF0ZXNbaV07XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zIHx8IHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCA8PSAxKTtcbiAgICAgICAgaWYgKHN0YXRlIGluc3RhbmNlb2YgUGx1c0Jsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5sb29wQmFja1N0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubG9vcEJhY2tTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMik7XG4gICAgICAgICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0IGluc3RhbmNlb2YgU3RhckJsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnNbMV0udGFyZ2V0IGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKCFzdGF0ZS5ub25HcmVlZHkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50cmFuc2l0aW9uc1swXS50YXJnZXQgaW5zdGFuY2VvZiBMb29wRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnRyYW5zaXRpb25zWzFdLnRhcmdldCBpbnN0YW5jZW9mIFN0YXJCbG9ja1N0YXJ0U3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUubm9uR3JlZWR5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3coXCJJbGxlZ2FsU3RhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcGJhY2tTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9uc1swXS50YXJnZXQgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgTG9vcEVuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLmxvb3BCYWNrU3RhdGUgIT09IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0YXJ0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUuc3RvcFN0YXRlICE9PSBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEJsb2NrU3RhcnRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS5lbmRTdGF0ZSAhPT0gbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgaW5zdGFuY2VvZiBCbG9ja0VuZFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ29uZGl0aW9uKHN0YXRlLnN0YXJ0U3RhdGUgIT09IG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgRGVjaXNpb25TdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvbmRpdGlvbihzdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGggPD0gMSB8fCBzdGF0ZS5kZWNpc2lvbiA+PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25kaXRpb24oc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoIDw9IDEgfHwgKHN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpO1xuICAgICAgICB9XG5cdH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuY2hlY2tDb25kaXRpb24gPSBmdW5jdGlvbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IG1lc3NhZ2U9PT1udWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJJbGxlZ2FsU3RhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyAobWVzc2FnZSk7XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5yZWFkSW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvdyA9IHRoaXMucmVhZEludCgpO1xuICAgIHZhciBoaWdoID0gdGhpcy5yZWFkSW50KCk7XG4gICAgcmV0dXJuIGxvdyB8IChoaWdoIDw8IDE2KTtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUucmVhZExvbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbG93ID0gdGhpcy5yZWFkSW50MzIoKTtcbiAgICB2YXIgaGlnaCA9IHRoaXMucmVhZEludDMyKCk7XG4gICAgcmV0dXJuIChsb3cgJiAweDAwMDAwMDAwRkZGRkZGRkYpIHwgKGhpZ2ggPDwgMzIpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQnl0ZVRvSGV4KCkge1xuXHR2YXIgYnRoID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0XHRidGhbaV0gPSAoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XG5cdH1cblx0cmV0dXJuIGJ0aDtcbn1cblxudmFyIGJ5dGVUb0hleCA9IGNyZWF0ZUJ5dGVUb0hleCgpO1xuXG5BVE5EZXNlcmlhbGl6ZXIucHJvdG90eXBlLnJlYWRVVUlEID0gZnVuY3Rpb24oKSB7XG5cdHZhciBiYiA9IFtdO1xuXHRmb3IodmFyIGk9NztpPj0wO2ktLSkge1xuXHRcdHZhciBpbnQgPSB0aGlzLnJlYWRJbnQoKTtcblx0XHQvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cblx0XHRiYlsoMippKSsxXSA9IGludCAmIDB4RkY7XG5cdFx0YmJbMippXSA9IChpbnQgPj4gOCkgJiAweEZGO1xuXHR9XG4gICAgcmV0dXJuIGJ5dGVUb0hleFtiYlswXV0gKyBieXRlVG9IZXhbYmJbMV1dICtcbiAgICBieXRlVG9IZXhbYmJbMl1dICsgYnl0ZVRvSGV4W2JiWzNdXSArICctJyArXG4gICAgYnl0ZVRvSGV4W2JiWzRdXSArIGJ5dGVUb0hleFtiYls1XV0gKyAnLScgK1xuICAgIGJ5dGVUb0hleFtiYls2XV0gKyBieXRlVG9IZXhbYmJbN11dICsgJy0nICtcbiAgICBieXRlVG9IZXhbYmJbOF1dICsgYnl0ZVRvSGV4W2JiWzldXSArICctJyArXG4gICAgYnl0ZVRvSGV4W2JiWzEwXV0gKyBieXRlVG9IZXhbYmJbMTFdXSArXG4gICAgYnl0ZVRvSGV4W2JiWzEyXV0gKyBieXRlVG9IZXhbYmJbMTNdXSArXG4gICAgYnl0ZVRvSGV4W2JiWzE0XV0gKyBieXRlVG9IZXhbYmJbMTVdXTtcbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUuZWRnZUZhY3RvcnkgPSBmdW5jdGlvbihhdG4sIHR5cGUsIHNyYywgdHJnLCBhcmcxLCBhcmcyLCBhcmczLCBzZXRzKSB7XG4gICAgdmFyIHRhcmdldCA9IGF0bi5zdGF0ZXNbdHJnXTtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgVHJhbnNpdGlvbi5FUFNJTE9OOlxuICAgICAgICByZXR1cm4gbmV3IEVwc2lsb25UcmFuc2l0aW9uKHRhcmdldCk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLlJBTkdFOlxuICAgICAgICByZXR1cm4gYXJnMyAhPT0gMCA/IG5ldyBSYW5nZVRyYW5zaXRpb24odGFyZ2V0LCBUb2tlbi5FT0YsIGFyZzIpIDogbmV3IFJhbmdlVHJhbnNpdGlvbih0YXJnZXQsIGFyZzEsIGFyZzIpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5SVUxFOlxuICAgICAgICByZXR1cm4gbmV3IFJ1bGVUcmFuc2l0aW9uKGF0bi5zdGF0ZXNbYXJnMV0sIGFyZzIsIGFyZzMsIHRhcmdldCk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLlBSRURJQ0FURTpcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMiwgYXJnMyAhPT0gMCk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLlBSRUNFREVOQ0U6XG4gICAgICAgIHJldHVybiBuZXcgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBhcmcxKTtcbiAgICBjYXNlIFRyYW5zaXRpb24uQVRPTTpcbiAgICAgICAgcmV0dXJuIGFyZzMgIT09IDAgPyBuZXcgQXRvbVRyYW5zaXRpb24odGFyZ2V0LCBUb2tlbi5FT0YpIDogbmV3IEF0b21UcmFuc2l0aW9uKHRhcmdldCwgYXJnMSk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLkFDVElPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb25UcmFuc2l0aW9uKHRhcmdldCwgYXJnMSwgYXJnMiwgYXJnMyAhPT0gMCk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLlNFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0c1thcmcxXSk7XG4gICAgY2FzZSBUcmFuc2l0aW9uLk5PVF9TRVQ6XG4gICAgICAgIHJldHVybiBuZXcgTm90U2V0VHJhbnNpdGlvbih0YXJnZXQsIHNldHNbYXJnMV0pO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5XSUxEQ0FSRDpcbiAgICAgICAgcmV0dXJuIG5ldyBXaWxkY2FyZFRyYW5zaXRpb24odGFyZ2V0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBcIlRoZSBzcGVjaWZpZWQgdHJhbnNpdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIiBpcyBub3QgdmFsaWQuXCI7XG4gICAgfVxufTtcblxuQVRORGVzZXJpYWxpemVyLnByb3RvdHlwZS5zdGF0ZUZhY3RvcnkgPSBmdW5jdGlvbih0eXBlLCBydWxlSW5kZXgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZUZhY3RvcmllcyA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgc2YgPSBbXTtcbiAgICAgICAgc2ZbQVROU3RhdGUuSU5WQUxJRF9UWVBFXSA9IG51bGw7XG4gICAgICAgIHNmW0FUTlN0YXRlLkJBU0lDXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEJhc2ljU3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUlVMRV9TVEFSVF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBSdWxlU3RhcnRTdGF0ZSgpOyB9O1xuICAgICAgICBzZltBVE5TdGF0ZS5CTE9DS19TVEFSVF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBCYXNpY0Jsb2NrU3RhcnRTdGF0ZSgpOyB9O1xuICAgICAgICBzZltBVE5TdGF0ZS5QTFVTX0JMT0NLX1NUQVJUXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFBsdXNCbG9ja1N0YXJ0U3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuU1RBUl9CTE9DS19TVEFSVF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBTdGFyQmxvY2tTdGFydFN0YXRlKCk7IH07XG4gICAgICAgIHNmW0FUTlN0YXRlLlRPS0VOX1NUQVJUXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFRva2Vuc1N0YXJ0U3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuUlVMRV9TVE9QXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFJ1bGVTdG9wU3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuQkxPQ0tfRU5EXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IEJsb2NrRW5kU3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuU1RBUl9MT09QX0JBQ0tdID0gZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgU3Rhckxvb3BiYWNrU3RhdGUoKTsgfTtcbiAgICAgICAgc2ZbQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IFN0YXJMb29wRW50cnlTdGF0ZSgpOyB9O1xuICAgICAgICBzZltBVE5TdGF0ZS5QTFVTX0xPT1BfQkFDS10gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBQbHVzTG9vcGJhY2tTdGF0ZSgpOyB9O1xuICAgICAgICBzZltBVE5TdGF0ZS5MT09QX0VORF0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMb29wRW5kU3RhdGUoKTsgfTtcbiAgICAgICAgdGhpcy5zdGF0ZUZhY3RvcmllcyA9IHNmO1xuICAgIH1cbiAgICBpZiAodHlwZT50aGlzLnN0YXRlRmFjdG9yaWVzLmxlbmd0aCB8fCB0aGlzLnN0YXRlRmFjdG9yaWVzW3R5cGVdID09PSBudWxsKSB7XG4gICAgICAgIHRocm93KFwiVGhlIHNwZWNpZmllZCBzdGF0ZSB0eXBlIFwiICsgdHlwZSArIFwiIGlzIG5vdCB2YWxpZC5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnN0YXRlRmFjdG9yaWVzW3R5cGVdKCk7XG4gICAgICAgIGlmIChzIT09bnVsbCkge1xuICAgICAgICAgICAgcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFUTkRlc2VyaWFsaXplci5wcm90b3R5cGUubGV4ZXJBY3Rpb25GYWN0b3J5ID0gZnVuY3Rpb24odHlwZSwgZGF0YTEsIGRhdGEyKSB7XG4gICAgaWYgKHRoaXMuYWN0aW9uRmFjdG9yaWVzID09PSBudWxsKSB7XG4gICAgICAgIHZhciBhZiA9IFtdO1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuQ0hBTk5FTF0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIG5ldyBMZXhlckNoYW5uZWxBY3Rpb24oZGF0YTEpOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuQ1VTVE9NXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gbmV3IExleGVyQ3VzdG9tQWN0aW9uKGRhdGExLCBkYXRhMik7IH07XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5NT0RFXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gbmV3IExleGVyTW9kZUFjdGlvbihkYXRhMSk7IH07XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5NT1JFXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gTGV4ZXJNb3JlQWN0aW9uLklOU1RBTkNFOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuUE9QX01PREVdID0gZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IHJldHVybiBMZXhlclBvcE1vZGVBY3Rpb24uSU5TVEFOQ0U7IH07XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5QVVNIX01PREVdID0gZnVuY3Rpb24oZGF0YTEsIGRhdGEyKSB7IHJldHVybiBuZXcgTGV4ZXJQdXNoTW9kZUFjdGlvbihkYXRhMSk7IH07XG4gICAgICAgIGFmW0xleGVyQWN0aW9uVHlwZS5TS0lQXSA9IGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyByZXR1cm4gTGV4ZXJTa2lwQWN0aW9uLklOU1RBTkNFOyB9O1xuICAgICAgICBhZltMZXhlckFjdGlvblR5cGUuVFlQRV0gPSBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgcmV0dXJuIG5ldyBMZXhlclR5cGVBY3Rpb24oZGF0YTEpOyB9O1xuICAgICAgICB0aGlzLmFjdGlvbkZhY3RvcmllcyA9IGFmO1xuICAgIH1cbiAgICBpZiAodHlwZT50aGlzLmFjdGlvbkZhY3Rvcmllcy5sZW5ndGggfHwgdGhpcy5hY3Rpb25GYWN0b3JpZXNbdHlwZV0gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3coXCJUaGUgc3BlY2lmaWVkIGxleGVyIGFjdGlvbiB0eXBlIFwiICsgdHlwZSArIFwiIGlzIG5vdCB2YWxpZC5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uRmFjdG9yaWVzW3R5cGVdKGRhdGExLCBkYXRhMik7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkFUTkRlc2VyaWFsaXplciA9IEFUTkRlc2VyaWFsaXplcjsiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbnZhciBERkFTdGF0ZSA9IHJlcXVpcmUoJy4vLi4vZGZhL0RGQVN0YXRlJykuREZBU3RhdGU7XG52YXIgQVROQ29uZmlnU2V0ID0gcmVxdWlyZSgnLi9BVE5Db25maWdTZXQnKS5BVE5Db25maWdTZXQ7XG52YXIgZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLy4uL1ByZWRpY3Rpb25Db250ZXh0JykuZ2V0Q2FjaGVkUHJlZGljdGlvbkNvbnRleHQ7XG52YXIgTWFwID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLk1hcDtcblxuZnVuY3Rpb24gQVROU2ltdWxhdG9yKGF0biwgc2hhcmVkQ29udGV4dENhY2hlKSB7XG5cbiAgICAvLyBUaGUgY29udGV4dCBjYWNoZSBtYXBzIGFsbCBQcmVkaWN0aW9uQ29udGV4dCBvYmplY3RzIHRoYXQgYXJlID09XG4gICAgLy8gIHRvIGEgc2luZ2xlIGNhY2hlZCBjb3B5LiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgYWxsIGNvbnRleHRzXG4gICAgLy8gIGluIGFsbCBBVE5Db25maWdzIGluIGFsbCBERkEgc3RhdGVzLiAgV2UgcmVidWlsZCBlYWNoIEFUTkNvbmZpZ1NldFxuICAgIC8vICB0byB1c2Ugb25seSBjYWNoZWQgbm9kZXMvZ3JhcGhzIGluIGFkZERGQVN0YXRlKCkuIFdlIGRvbid0IHdhbnQgdG9cbiAgICAvLyAgZmlsbCB0aGlzIGR1cmluZyBjbG9zdXJlKCkgc2luY2UgdGhlcmUgYXJlIGxvdHMgb2YgY29udGV4dHMgdGhhdFxuICAgIC8vICBwb3AgdXAgYnV0IGFyZSBub3QgdXNlZCBldmVyIGFnYWluLiBJdCBhbHNvIGdyZWF0bHkgc2xvd3MgZG93biBjbG9zdXJlKCkuXG4gICAgLy9cbiAgICAvLyAgPHA+VGhpcyBjYWNoZSBtYWtlcyBhIGh1Z2UgZGlmZmVyZW5jZSBpbiBtZW1vcnkgYW5kIGEgbGl0dGxlIGJpdCBpbiBzcGVlZC5cbiAgICAvLyAgRm9yIHRoZSBKYXZhIGdyYW1tYXIgb24gamF2YS4qLCBpdCBkcm9wcGVkIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzXG4gICAgLy8gIGF0IHRoZSBlbmQgZnJvbSAyNU0gdG8gMTZNLiBXZSBkb24ndCBzdG9yZSBhbnkgb2YgdGhlIGZ1bGwgY29udGV4dFxuICAgIC8vICBncmFwaHMgaW4gdGhlIERGQSBiZWNhdXNlIHRoZXkgYXJlIGxpbWl0ZWQgdG8gbG9jYWwgY29udGV4dCBvbmx5LFxuICAgIC8vICBidXQgYXBwYXJlbnRseSB0aGVyZSdzIGEgbG90IG9mIHJlcGV0aXRpb24gdGhlcmUgYXMgd2VsbC4gV2Ugb3B0aW1pemVcbiAgICAvLyAgdGhlIGNvbmZpZyBjb250ZXh0cyBiZWZvcmUgc3RvcmluZyB0aGUgY29uZmlnIHNldCBpbiB0aGUgREZBIHN0YXRlc1xuICAgIC8vICBieSBsaXRlcmFsbHkgcmVidWlsZGluZyB0aGVtIHdpdGggY2FjaGVkIHN1YmdyYXBocyBvbmx5LjwvcD5cbiAgICAvL1xuICAgIC8vICA8cD5JIHRyaWVkIGEgY2FjaGUgZm9yIHVzZSBkdXJpbmcgY2xvc3VyZSBvcGVyYXRpb25zLCB0aGF0IHdhc1xuICAgIC8vICB3aGFja2VkIGFmdGVyIGVhY2ggYWRhcHRpdmVQcmVkaWN0KCkuIEl0IGNvc3QgYSBsaXR0bGUgYml0XG4gICAgLy8gIG1vcmUgdGltZSBJIHRoaW5rIGFuZCBkb2Vzbid0IHNhdmUgb24gdGhlIG92ZXJhbGwgZm9vdHByaW50XG4gICAgLy8gIHNvIGl0J3Mgbm90IHdvcnRoIHRoZSBjb21wbGV4aXR5LjwvcD5cbiAgICAvLy9cbiAgICB0aGlzLmF0biA9IGF0bjtcbiAgICB0aGlzLnNoYXJlZENvbnRleHRDYWNoZSA9IHNoYXJlZENvbnRleHRDYWNoZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuLy8gTXVzdCBkaXN0aW5ndWlzaCBiZXR3ZWVuIG1pc3NpbmcgZWRnZSBhbmQgZWRnZSB3ZSBrbm93IGxlYWRzIG5vd2hlcmUvLy9cbkFUTlNpbXVsYXRvci5FUlJPUiA9IG5ldyBERkFTdGF0ZSgweDdGRkZGRkZGLCBuZXcgQVROQ29uZmlnU2V0KCkpO1xuXG5cbkFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0Q2FjaGVkQ29udGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5zaGFyZWRDb250ZXh0Q2FjaGUgPT09bnVsbCkge1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIGdldENhY2hlZFByZWRpY3Rpb25Db250ZXh0KGNvbnRleHQsIHRoaXMuc2hhcmVkQ29udGV4dENhY2hlLCB2aXNpdGVkKTtcbn07XG5cbmV4cG9ydHMuQVROU2ltdWxhdG9yID0gQVROU2ltdWxhdG9yO1xuIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbi8vIFRoZSBmb2xsb3dpbmcgaW1hZ2VzIHNob3cgdGhlIHJlbGF0aW9uIG9mIHN0YXRlcyBhbmRcbi8vIHtAbGluayBBVE5TdGF0ZS8vdHJhbnNpdGlvbnN9IGZvciB2YXJpb3VzIGdyYW1tYXIgY29uc3RydWN0cy5cbi8vXG4vLyA8dWw+XG4vL1xuLy8gPGxpPlNvbGlkIGVkZ2VzIG1hcmtlZCB3aXRoIGFuICYvLzA5NDk7IGluZGljYXRlIGEgcmVxdWlyZWRcbi8vIHtAbGluayBFcHNpbG9uVHJhbnNpdGlvbn0uPC9saT5cbi8vXG4vLyA8bGk+RGFzaGVkIGVkZ2VzIGluZGljYXRlIGxvY2F0aW9ucyB3aGVyZSBhbnkgdHJhbnNpdGlvbiBkZXJpdmVkIGZyb21cbi8vIHtAbGluayBUcmFuc2l0aW9ufSBtaWdodCBhcHBlYXIuPC9saT5cbi8vXG4vLyA8bGk+RGFzaGVkIG5vZGVzIGFyZSBwbGFjZSBob2xkZXJzIGZvciBlaXRoZXIgYSBzZXF1ZW5jZSBvZiBsaW5rZWRcbi8vIHtAbGluayBCYXNpY1N0YXRlfSBzdGF0ZXMgb3IgdGhlIGluY2x1c2lvbiBvZiBhIGJsb2NrIHJlcHJlc2VudGluZyBhIG5lc3RlZFxuLy8gY29uc3RydWN0IGluIG9uZSBvZiB0aGUgZm9ybXMgYmVsb3cuPC9saT5cbi8vXG4vLyA8bGk+Tm9kZXMgc2hvd2luZyBtdWx0aXBsZSBvdXRnb2luZyBhbHRlcm5hdGl2ZXMgd2l0aCBhIHtAY29kZSAuLi59IHN1cHBvcnRcbi8vIGFueSBudW1iZXIgb2YgYWx0ZXJuYXRpdmVzIChvbmUgb3IgbW9yZSkuIE5vZGVzIHdpdGhvdXQgdGhlIHtAY29kZSAuLi59IG9ubHlcbi8vIHN1cHBvcnQgdGhlIGV4YWN0IG51bWJlciBvZiBhbHRlcm5hdGl2ZXMgc2hvd24gaW4gdGhlIGRpYWdyYW0uPC9saT5cbi8vXG4vLyA8L3VsPlxuLy9cbi8vIDxoMj5CYXNpYyBCbG9ja3M8L2gyPlxuLy9cbi8vIDxoMz5SdWxlPC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL1J1bGUuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XG4vL1xuLy8gPGgzPkJsb2NrIG9mIDEgb3IgbW9yZSBhbHRlcm5hdGl2ZXM8L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQmxvY2suc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XG4vL1xuLy8gPGgyPkdyZWVkeSBMb29wczwvaDI+XG4vL1xuLy8gPGgzPkdyZWVkeSBDbG9zdXJlOiB7QGNvZGUgKC4uLikqfTwvaDM+XG4vL1xuLy8gPGVtYmVkIHNyYz1cImltYWdlcy9DbG9zdXJlR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMz5HcmVlZHkgUG9zaXRpdmUgQ2xvc3VyZToge0Bjb2RlICguLi4pK308L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvUG9zaXRpdmVDbG9zdXJlR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMz5HcmVlZHkgT3B0aW9uYWw6IHtAY29kZSAoLi4uKT99PC9oMz5cbi8vXG4vLyA8ZW1iZWQgc3JjPVwiaW1hZ2VzL09wdGlvbmFsR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMj5Ob24tR3JlZWR5IExvb3BzPC9oMj5cbi8vXG4vLyA8aDM+Tm9uLUdyZWVkeSBDbG9zdXJlOiB7QGNvZGUgKC4uLikqP308L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvQ2xvc3VyZU5vbkdyZWVkeS5zdmdcIiB0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiLz5cbi8vXG4vLyA8aDM+Tm9uLUdyZWVkeSBQb3NpdGl2ZSBDbG9zdXJlOiB7QGNvZGUgKC4uLikrP308L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvUG9zaXRpdmVDbG9zdXJlTm9uR3JlZWR5LnN2Z1wiIHR5cGU9XCJpbWFnZS9zdmcreG1sXCIvPlxuLy9cbi8vIDxoMz5Ob24tR3JlZWR5IE9wdGlvbmFsOiB7QGNvZGUgKC4uLik/P308L2gzPlxuLy9cbi8vIDxlbWJlZCBzcmM9XCJpbWFnZXMvT3B0aW9uYWxOb25HcmVlZHkuc3ZnXCIgdHlwZT1cImltYWdlL3N2Zyt4bWxcIi8+XG4vL1xuXG52YXIgSU5JVElBTF9OVU1fVFJBTlNJVElPTlMgPSA0O1xuXG5mdW5jdGlvbiBBVE5TdGF0ZSgpIHtcbiAgICAvLyBXaGljaCBBVE4gYXJlIHdlIGluP1xuICAgIHRoaXMuYXRuID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlTnVtYmVyID0gQVROU3RhdGUuSU5WQUxJRF9TVEFURV9OVU1CRVI7XG4gICAgdGhpcy5zdGF0ZVR5cGUgPSBudWxsO1xuICAgIHRoaXMucnVsZUluZGV4ID0gMDsgLy8gYXQgcnVudGltZSwgd2UgZG9uJ3QgaGF2ZSBSdWxlIG9iamVjdHNcbiAgICB0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAvLyBUcmFjayB0aGUgdHJhbnNpdGlvbnMgZW1hbmF0aW5nIGZyb20gdGhpcyBBVE4gc3RhdGUuXG4gICAgdGhpcy50cmFuc2l0aW9ucyA9IFtdO1xuICAgIC8vIFVzZWQgdG8gY2FjaGUgbG9va2FoZWFkIGR1cmluZyBwYXJzaW5nLCBub3QgdXNlZCBkdXJpbmcgY29uc3RydWN0aW9uXG4gICAgdGhpcy5uZXh0VG9rZW5XaXRoaW5SdWxlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuLy8gY29uc3RhbnRzIGZvciBzZXJpYWxpemF0aW9uXG5BVE5TdGF0ZS5JTlZBTElEX1RZUEUgPSAwO1xuQVROU3RhdGUuQkFTSUMgPSAxO1xuQVROU3RhdGUuUlVMRV9TVEFSVCA9IDI7XG5BVE5TdGF0ZS5CTE9DS19TVEFSVCA9IDM7XG5BVE5TdGF0ZS5QTFVTX0JMT0NLX1NUQVJUID0gNDtcbkFUTlN0YXRlLlNUQVJfQkxPQ0tfU1RBUlQgPSA1O1xuQVROU3RhdGUuVE9LRU5fU1RBUlQgPSA2O1xuQVROU3RhdGUuUlVMRV9TVE9QID0gNztcbkFUTlN0YXRlLkJMT0NLX0VORCA9IDg7XG5BVE5TdGF0ZS5TVEFSX0xPT1BfQkFDSyA9IDk7XG5BVE5TdGF0ZS5TVEFSX0xPT1BfRU5UUlkgPSAxMDtcbkFUTlN0YXRlLlBMVVNfTE9PUF9CQUNLID0gMTE7XG5BVE5TdGF0ZS5MT09QX0VORCA9IDEyO1xuXG5BVE5TdGF0ZS5zZXJpYWxpemF0aW9uTmFtZXMgPSBbXG4gICAgICAgICAgICBcIklOVkFMSURcIixcbiAgICAgICAgICAgIFwiQkFTSUNcIixcbiAgICAgICAgICAgIFwiUlVMRV9TVEFSVFwiLFxuICAgICAgICAgICAgXCJCTE9DS19TVEFSVFwiLFxuICAgICAgICAgICAgXCJQTFVTX0JMT0NLX1NUQVJUXCIsXG4gICAgICAgICAgICBcIlNUQVJfQkxPQ0tfU1RBUlRcIixcbiAgICAgICAgICAgIFwiVE9LRU5fU1RBUlRcIixcbiAgICAgICAgICAgIFwiUlVMRV9TVE9QXCIsXG4gICAgICAgICAgICBcIkJMT0NLX0VORFwiLFxuICAgICAgICAgICAgXCJTVEFSX0xPT1BfQkFDS1wiLFxuICAgICAgICAgICAgXCJTVEFSX0xPT1BfRU5UUllcIixcbiAgICAgICAgICAgIFwiUExVU19MT09QX0JBQ0tcIixcbiAgICAgICAgICAgIFwiTE9PUF9FTkRcIiBdO1xuXG5BVE5TdGF0ZS5JTlZBTElEX1NUQVRFX05VTUJFUiA9IC0xO1xuXG5BVE5TdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMuc3RhdGVOdW1iZXI7XG59O1xuXG5BVE5TdGF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBVE5TdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWJlcj09PW90aGVyLnN0YXRlTnVtYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5BVE5TdGF0ZS5wcm90b3R5cGUuaXNOb25HcmVlZHlFeGl0U3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbkFUTlN0YXRlLnByb3RvdHlwZS5hZGRUcmFuc2l0aW9uID0gZnVuY3Rpb24odHJhbnMsIGluZGV4KSB7XG5cdGlmKGluZGV4PT09dW5kZWZpbmVkKSB7XG5cdFx0aW5kZXggPSAtMTtcblx0fVxuICAgIGlmICh0aGlzLnRyYW5zaXRpb25zLmxlbmd0aD09PTApIHtcbiAgICAgICAgdGhpcy5lcHNpbG9uT25seVRyYW5zaXRpb25zID0gdHJhbnMuaXNFcHNpbG9uO1xuICAgIH0gZWxzZSBpZih0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgIT09IHRyYW5zLmlzRXBzaWxvbikge1xuICAgICAgICB0aGlzLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4PT09LTEpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9ucy5wdXNoKHRyYW5zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25zLnNwbGljZShpbmRleCwgMSwgdHJhbnMpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEJhc2ljU3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5CQVNJQztcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQmFzaWNTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlN0YXRlLnByb3RvdHlwZSk7XG5CYXNpY1N0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2ljU3RhdGU7XG5cblxuZnVuY3Rpb24gRGVjaXNpb25TdGF0ZSgpIHtcblx0QVROU3RhdGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRlY2lzaW9uID0gLTE7XG4gICAgdGhpcy5ub25HcmVlZHkgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuRGVjaXNpb25TdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlN0YXRlLnByb3RvdHlwZSk7XG5EZWNpc2lvblN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlY2lzaW9uU3RhdGU7XG5cblxuLy8gIFRoZSBzdGFydCBvZiBhIHJlZ3VsYXIge0Bjb2RlICguLi4pfSBibG9jay5cbmZ1bmN0aW9uIEJsb2NrU3RhcnRTdGF0ZSgpIHtcblx0RGVjaXNpb25TdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLmVuZFN0YXRlID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkJsb2NrU3RhcnRTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlY2lzaW9uU3RhdGUucHJvdG90eXBlKTtcbkJsb2NrU3RhcnRTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbG9ja1N0YXJ0U3RhdGU7XG5cblxuZnVuY3Rpb24gQmFzaWNCbG9ja1N0YXJ0U3RhdGUoKSB7XG5cdEJsb2NrU3RhcnRTdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLkJMT0NLX1NUQVJUO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQmFzaWNCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlKTtcbkJhc2ljQmxvY2tTdGFydFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJhc2ljQmxvY2tTdGFydFN0YXRlO1xuXG5cbi8vIFRlcm1pbmFsIG5vZGUgb2YgYSBzaW1wbGUge0Bjb2RlIChhfGJ8Yyl9IGJsb2NrLlxuZnVuY3Rpb24gQmxvY2tFbmRTdGF0ZSgpIHtcblx0QVROU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5CTE9DS19FTkQ7XG4gICAgdGhpcy5zdGFydFN0YXRlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQmxvY2tFbmRTdGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlN0YXRlLnByb3RvdHlwZSk7XG5CbG9ja0VuZFN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsb2NrRW5kU3RhdGU7XG5cblxuLy8gVGhlIGxhc3Qgbm9kZSBpbiB0aGUgQVROIGZvciBhIHJ1bGUsIHVubGVzcyB0aGF0IHJ1bGUgaXMgdGhlIHN0YXJ0IHN5bWJvbC5cbi8vICBJbiB0aGF0IGNhc2UsIHRoZXJlIGlzIG9uZSB0cmFuc2l0aW9uIHRvIEVPRi4gTGF0ZXIsIHdlIG1pZ2h0IGVuY29kZVxuLy8gIHJlZmVyZW5jZXMgdG8gYWxsIGNhbGxzIHRvIHRoaXMgcnVsZSB0byBjb21wdXRlIEZPTExPVyBzZXRzIGZvclxuLy8gIGVycm9yIGhhbmRsaW5nLlxuLy9cbmZ1bmN0aW9uIFJ1bGVTdG9wU3RhdGUoKSB7XG5cdEFUTlN0YXRlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5SVUxFX1NUT1A7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblJ1bGVTdG9wU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TdGF0ZS5wcm90b3R5cGUpO1xuUnVsZVN0b3BTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdWxlU3RvcFN0YXRlO1xuXG5mdW5jdGlvbiBSdWxlU3RhcnRTdGF0ZSgpIHtcblx0QVROU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5SVUxFX1NUQVJUO1xuXHR0aGlzLnN0b3BTdGF0ZSA9IG51bGw7XG5cdHRoaXMuaXNQcmVjZWRlbmNlUnVsZSA9IGZhbHNlO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUnVsZVN0YXJ0U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBVE5TdGF0ZS5wcm90b3R5cGUpO1xuUnVsZVN0YXJ0U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVsZVN0YXJ0U3RhdGU7XG5cbi8vIERlY2lzaW9uIHN0YXRlIGZvciB7QGNvZGUgQSt9IGFuZCB7QGNvZGUgKEF8QikrfS4gIEl0IGhhcyB0d28gdHJhbnNpdGlvbnM6XG4vLyAgb25lIHRvIHRoZSBsb29wIGJhY2sgdG8gc3RhcnQgb2YgdGhlIGJsb2NrIGFuZCBvbmUgdG8gZXhpdC5cbi8vXG5mdW5jdGlvbiBQbHVzTG9vcGJhY2tTdGF0ZSgpIHtcblx0RGVjaXNpb25TdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLlBMVVNfTE9PUF9CQUNLO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGx1c0xvb3BiYWNrU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWNpc2lvblN0YXRlLnByb3RvdHlwZSk7XG5QbHVzTG9vcGJhY2tTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbHVzTG9vcGJhY2tTdGF0ZTtcblxuXG4vLyBTdGFydCBvZiB7QGNvZGUgKEF8QnwuLi4pK30gbG9vcC4gVGVjaG5pY2FsbHkgYSBkZWNpc2lvbiBzdGF0ZSwgYnV0XG4vLyAgd2UgZG9uJ3QgdXNlIGZvciBjb2RlIGdlbmVyYXRpb247IHNvbWVib2R5IG1pZ2h0IG5lZWQgaXQsIHNvIEknbSBkZWZpbmluZ1xuLy8gIGl0IGZvciBjb21wbGV0ZW5lc3MuIEluIHJlYWxpdHksIHRoZSB7QGxpbmsgUGx1c0xvb3BiYWNrU3RhdGV9IG5vZGUgaXMgdGhlXG4vLyAgcmVhbCBkZWNpc2lvbi1tYWtpbmcgbm90ZSBmb3Ige0Bjb2RlIEErfS5cbi8vXG5mdW5jdGlvbiBQbHVzQmxvY2tTdGFydFN0YXRlKCkge1xuXHRCbG9ja1N0YXJ0U3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5QTFVTX0JMT0NLX1NUQVJUO1xuICAgIHRoaXMubG9vcEJhY2tTdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblBsdXNCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlKTtcblBsdXNCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGx1c0Jsb2NrU3RhcnRTdGF0ZTtcblxuLy8gVGhlIGJsb2NrIHRoYXQgYmVnaW5zIGEgY2xvc3VyZSBsb29wLlxuZnVuY3Rpb24gU3RhckJsb2NrU3RhcnRTdGF0ZSgpIHtcblx0QmxvY2tTdGFydFN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuU1RBUl9CTE9DS19TVEFSVDtcblx0cmV0dXJuIHRoaXM7XG59XG5cblN0YXJCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlKTtcblN0YXJCbG9ja1N0YXJ0U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhckJsb2NrU3RhcnRTdGF0ZTtcblxuXG5mdW5jdGlvbiBTdGFyTG9vcGJhY2tTdGF0ZSgpIHtcblx0QVROU3RhdGUuY2FsbCh0aGlzKTtcblx0dGhpcy5zdGF0ZVR5cGUgPSBBVE5TdGF0ZS5TVEFSX0xPT1BfQkFDSztcblx0cmV0dXJuIHRoaXM7XG59XG5cblN0YXJMb29wYmFja1N0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROU3RhdGUucHJvdG90eXBlKTtcblN0YXJMb29wYmFja1N0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXJMb29wYmFja1N0YXRlO1xuXG5cbmZ1bmN0aW9uIFN0YXJMb29wRW50cnlTdGF0ZSgpIHtcblx0RGVjaXNpb25TdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLlNUQVJfTE9PUF9FTlRSWTtcbiAgICB0aGlzLmxvb3BCYWNrU3RhdGUgPSBudWxsO1xuICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgc3RhdGUgY2FuIGJlbmVmaXQgZnJvbSBhIHByZWNlZGVuY2UgREZBIGR1cmluZyBTTEwgZGVjaXNpb24gbWFraW5nLlxuICAgIHRoaXMuaXNQcmVjZWRlbmNlRGVjaXNpb24gPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5TdGFyTG9vcEVudHJ5U3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWNpc2lvblN0YXRlLnByb3RvdHlwZSk7XG5TdGFyTG9vcEVudHJ5U3RhdGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3Rhckxvb3BFbnRyeVN0YXRlO1xuXG5cbi8vIE1hcmsgdGhlIGVuZCBvZiBhICogb3IgKyBsb29wLlxuZnVuY3Rpb24gTG9vcEVuZFN0YXRlKCkge1xuXHRBVE5TdGF0ZS5jYWxsKHRoaXMpO1xuXHR0aGlzLnN0YXRlVHlwZSA9IEFUTlN0YXRlLkxPT1BfRU5EO1xuXHR0aGlzLmxvb3BCYWNrU3RhdGUgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuTG9vcEVuZFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROU3RhdGUucHJvdG90eXBlKTtcbkxvb3BFbmRTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29wRW5kU3RhdGU7XG5cblxuLy8gVGhlIFRva2VucyBydWxlIHN0YXJ0IHN0YXRlIGxpbmtpbmcgdG8gZWFjaCBsZXhlciBydWxlIHN0YXJ0IHN0YXRlICovXG5mdW5jdGlvbiBUb2tlbnNTdGFydFN0YXRlKCkge1xuXHREZWNpc2lvblN0YXRlLmNhbGwodGhpcyk7XG5cdHRoaXMuc3RhdGVUeXBlID0gQVROU3RhdGUuVE9LRU5fU1RBUlQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5Ub2tlbnNTdGFydFN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVjaXNpb25TdGF0ZS5wcm90b3R5cGUpO1xuVG9rZW5zU3RhcnRTdGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb2tlbnNTdGFydFN0YXRlO1xuXG5leHBvcnRzLkFUTlN0YXRlID0gQVROU3RhdGU7XG5leHBvcnRzLkJhc2ljU3RhdGUgPSBCYXNpY1N0YXRlO1xuZXhwb3J0cy5EZWNpc2lvblN0YXRlID0gRGVjaXNpb25TdGF0ZTtcbmV4cG9ydHMuQmxvY2tTdGFydFN0YXRlID0gQmxvY2tTdGFydFN0YXRlO1xuZXhwb3J0cy5CbG9ja0VuZFN0YXRlID0gQmxvY2tFbmRTdGF0ZTtcbmV4cG9ydHMuTG9vcEVuZFN0YXRlID0gTG9vcEVuZFN0YXRlO1xuZXhwb3J0cy5SdWxlU3RhcnRTdGF0ZSA9IFJ1bGVTdGFydFN0YXRlO1xuZXhwb3J0cy5SdWxlU3RvcFN0YXRlID0gUnVsZVN0b3BTdGF0ZTtcbmV4cG9ydHMuVG9rZW5zU3RhcnRTdGF0ZSA9IFRva2Vuc1N0YXJ0U3RhdGU7XG5leHBvcnRzLlBsdXNMb29wYmFja1N0YXRlID0gUGx1c0xvb3BiYWNrU3RhdGU7XG5leHBvcnRzLlN0YXJMb29wYmFja1N0YXRlID0gU3Rhckxvb3BiYWNrU3RhdGU7XG5leHBvcnRzLlN0YXJMb29wRW50cnlTdGF0ZSA9IFN0YXJMb29wRW50cnlTdGF0ZTtcbmV4cG9ydHMuUGx1c0Jsb2NrU3RhcnRTdGF0ZSA9IFBsdXNCbG9ja1N0YXJ0U3RhdGU7XG5leHBvcnRzLlN0YXJCbG9ja1N0YXJ0U3RhdGUgPSBTdGFyQmxvY2tTdGFydFN0YXRlO1xuZXhwb3J0cy5CYXNpY0Jsb2NrU3RhcnRTdGF0ZSA9IEJhc2ljQmxvY2tTdGFydFN0YXRlO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbi8vIFJlcHJlc2VudHMgdGhlIHR5cGUgb2YgcmVjb2duaXplciBhbiBBVE4gYXBwbGllcyB0by5cblxuZnVuY3Rpb24gQVROVHlwZSgpIHtcblxufVxuXG5BVE5UeXBlLkxFWEVSID0gMDtcbkFUTlR5cGUuUEFSU0VSID0gMTtcblxuZXhwb3J0cy5BVE5UeXBlID0gQVROVHlwZTtcblxuIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vL1xuXG4vLyBXaGVuIHdlIGhpdCBhbiBhY2NlcHQgc3RhdGUgaW4gZWl0aGVyIHRoZSBERkEgb3IgdGhlIEFUTiwgd2Vcbi8vICBoYXZlIHRvIG5vdGlmeSB0aGUgY2hhcmFjdGVyIHN0cmVhbSB0byBzdGFydCBidWZmZXJpbmcgY2hhcmFjdGVyc1xuLy8gIHZpYSB7QGxpbmsgSW50U3RyZWFtLy9tYXJrfSBhbmQgcmVjb3JkIHRoZSBjdXJyZW50IHN0YXRlLiBUaGUgY3VycmVudCBzaW0gc3RhdGVcbi8vICBpbmNsdWRlcyB0aGUgY3VycmVudCBpbmRleCBpbnRvIHRoZSBpbnB1dCwgdGhlIGN1cnJlbnQgbGluZSxcbi8vICBhbmQgY3VycmVudCBjaGFyYWN0ZXIgcG9zaXRpb24gaW4gdGhhdCBsaW5lLiBOb3RlIHRoYXQgdGhlIExleGVyIGlzXG4vLyAgdHJhY2tpbmcgdGhlIHN0YXJ0aW5nIGxpbmUgYW5kIGNoYXJhY3Rlcml6YXRpb24gb2YgdGhlIHRva2VuLiBUaGVzZVxuLy8gIHZhcmlhYmxlcyB0cmFjayB0aGUgXCJzdGF0ZVwiIG9mIHRoZSBzaW11bGF0b3Igd2hlbiBpdCBoaXRzIGFuIGFjY2VwdCBzdGF0ZS5cbi8vXG4vLyAgPHA+V2UgdHJhY2sgdGhlc2UgdmFyaWFibGVzIHNlcGFyYXRlbHkgZm9yIHRoZSBERkEgYW5kIEFUTiBzaW11bGF0aW9uXG4vLyAgYmVjYXVzZSB0aGUgREZBIHNpbXVsYXRpb24gb2Z0ZW4gaGFzIHRvIGZhaWwgb3ZlciB0byB0aGUgQVROXG4vLyAgc2ltdWxhdGlvbi4gSWYgdGhlIEFUTiBzaW11bGF0aW9uIGZhaWxzLCB3ZSBuZWVkIHRoZSBERkEgdG8gZmFsbFxuLy8gIGJhY2sgdG8gaXRzIHByZXZpb3VzbHkgYWNjZXB0ZWQgc3RhdGUsIGlmIGFueS4gSWYgdGhlIEFUTiBzdWNjZWVkcyxcbi8vICB0aGVuIHRoZSBBVE4gZG9lcyB0aGUgYWNjZXB0IGFuZCB0aGUgREZBIHNpbXVsYXRvciB0aGF0IGludm9rZWQgaXRcbi8vICBjYW4gc2ltcGx5IHJldHVybiB0aGUgcHJlZGljdGVkIHRva2VuIHR5cGUuPC9wPlxuLy8vXG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vLi4vVG9rZW4nKS5Ub2tlbjtcbnZhciBMZXhlciA9IHJlcXVpcmUoJy4vLi4vTGV4ZXInKS5MZXhlcjtcbnZhciBBVE4gPSByZXF1aXJlKCcuL0FUTicpLkFUTjtcbnZhciBBVE5TaW11bGF0b3IgPSByZXF1aXJlKCcuL0FUTlNpbXVsYXRvcicpLkFUTlNpbXVsYXRvcjtcbnZhciBERkFTdGF0ZSA9IHJlcXVpcmUoJy4vLi4vZGZhL0RGQVN0YXRlJykuREZBU3RhdGU7XG52YXIgQVROQ29uZmlnU2V0ID0gcmVxdWlyZSgnLi9BVE5Db25maWdTZXQnKS5BVE5Db25maWdTZXQ7XG52YXIgT3JkZXJlZEFUTkNvbmZpZ1NldCA9IHJlcXVpcmUoJy4vQVROQ29uZmlnU2V0JykuT3JkZXJlZEFUTkNvbmZpZ1NldDtcbnZhciBQcmVkaWN0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5QcmVkaWN0aW9uQ29udGV4dDtcbnZhciBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5TaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcbnZhciBSdWxlU3RvcFN0YXRlID0gcmVxdWlyZSgnLi9BVE5TdGF0ZScpLlJ1bGVTdG9wU3RhdGU7XG52YXIgTGV4ZXJBVE5Db25maWcgPSByZXF1aXJlKCcuL0FUTkNvbmZpZycpLkxleGVyQVROQ29uZmlnO1xudmFyIFRyYW5zaXRpb24gPSByZXF1aXJlKCcuL1RyYW5zaXRpb24nKS5UcmFuc2l0aW9uO1xudmFyIExleGVyQWN0aW9uRXhlY3V0b3IgPSByZXF1aXJlKCcuL0xleGVyQWN0aW9uRXhlY3V0b3InKS5MZXhlckFjdGlvbkV4ZWN1dG9yO1xudmFyIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24gPSByZXF1aXJlKCcuLy4uL2Vycm9yL0Vycm9ycycpLkxleGVyTm9WaWFibGVBbHRFeGNlcHRpb247XG5cbmZ1bmN0aW9uIHJlc2V0U2ltU3RhdGUoc2ltKSB7XG5cdHNpbS5pbmRleCA9IC0xO1xuXHRzaW0ubGluZSA9IDA7XG5cdHNpbS5jb2x1bW4gPSAtMTtcblx0c2ltLmRmYVN0YXRlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gU2ltU3RhdGUoKSB7XG5cdHJlc2V0U2ltU3RhdGUodGhpcyk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5TaW1TdGF0ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0cmVzZXRTaW1TdGF0ZSh0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIExleGVyQVROU2ltdWxhdG9yKHJlY29nLCBhdG4sIGRlY2lzaW9uVG9ERkEsIHNoYXJlZENvbnRleHRDYWNoZSkge1xuXHRBVE5TaW11bGF0b3IuY2FsbCh0aGlzLCBhdG4sIHNoYXJlZENvbnRleHRDYWNoZSk7XG5cdHRoaXMuZGVjaXNpb25Ub0RGQSA9IGRlY2lzaW9uVG9ERkE7XG5cdHRoaXMucmVjb2cgPSByZWNvZztcblx0Ly8gVGhlIGN1cnJlbnQgdG9rZW4ncyBzdGFydGluZyBpbmRleCBpbnRvIHRoZSBjaGFyYWN0ZXIgc3RyZWFtLlxuXHQvLyBTaGFyZWQgYWNyb3NzIERGQSB0byBBVE4gc2ltdWxhdGlvbiBpbiBjYXNlIHRoZSBBVE4gZmFpbHMgYW5kIHRoZVxuXHQvLyBERkEgZGlkIG5vdCBoYXZlIGEgcHJldmlvdXMgYWNjZXB0IHN0YXRlLiBJbiB0aGlzIGNhc2UsIHdlIHVzZSB0aGVcblx0Ly8gQVROLWdlbmVyYXRlZCBleGNlcHRpb24gb2JqZWN0LlxuXHR0aGlzLnN0YXJ0SW5kZXggPSAtMTtcblx0Ly8gbGluZSBudW1iZXIgMS4ubiB3aXRoaW4gdGhlIGlucHV0Ly8vXG5cdHRoaXMubGluZSA9IDE7XG5cdC8vIFRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcblx0Ly8gMC4ubi0xLy8vXG5cdHRoaXMuY29sdW1uID0gMDtcblx0dGhpcy5tb2RlID0gTGV4ZXIuREVGQVVMVF9NT0RFO1xuXHQvLyBVc2VkIGR1cmluZyBERkEvQVROIGV4ZWMgdG8gcmVjb3JkIHRoZSBtb3N0IHJlY2VudCBhY2NlcHQgY29uZmlndXJhdGlvblxuXHQvLyBpbmZvXG5cdHRoaXMucHJldkFjY2VwdCA9IG5ldyBTaW1TdGF0ZSgpO1xuXHQvLyBkb25lXG5cdHJldHVybiB0aGlzO1xufVxuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFUTlNpbXVsYXRvci5wcm90b3R5cGUpO1xuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJBVE5TaW11bGF0b3I7XG5cbkxleGVyQVROU2ltdWxhdG9yLmRlYnVnID0gZmFsc2U7XG5MZXhlckFUTlNpbXVsYXRvci5kZmFfZGVidWcgPSBmYWxzZTtcblxuTGV4ZXJBVE5TaW11bGF0b3IuTUlOX0RGQV9FREdFID0gMDtcbkxleGVyQVROU2ltdWxhdG9yLk1BWF9ERkFfRURHRSA9IDEyNzsgLy8gZm9yY2VzIHVuaWNvZGUgdG8gc3RheSBpbiBBVE5cblxuTGV4ZXJBVE5TaW11bGF0b3IubWF0Y2hfY2FsbHMgPSAwO1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY29weVN0YXRlID0gZnVuY3Rpb24oc2ltdWxhdG9yKSB7XG5cdHRoaXMuY29sdW1uID0gc2ltdWxhdG9yLmNvbHVtbjtcblx0dGhpcy5saW5lID0gc2ltdWxhdG9yLmxpbmU7XG5cdHRoaXMubW9kZSA9IHNpbXVsYXRvci5tb2RlO1xuXHR0aGlzLnN0YXJ0SW5kZXggPSBzaW11bGF0b3Iuc3RhcnRJbmRleDtcbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBtb2RlKSB7XG5cdHRoaXMubWF0Y2hfY2FsbHMgKz0gMTtcblx0dGhpcy5tb2RlID0gbW9kZTtcblx0dmFyIG1hcmsgPSBpbnB1dC5tYXJrKCk7XG5cdHRyeSB7XG5cdFx0dGhpcy5zdGFydEluZGV4ID0gaW5wdXQuaW5kZXg7XG5cdFx0dGhpcy5wcmV2QWNjZXB0LnJlc2V0KCk7XG5cdFx0dmFyIGRmYSA9IHRoaXMuZGVjaXNpb25Ub0RGQVttb2RlXTtcblx0XHRpZiAoZGZhLnMwID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXRjaEFUTihpbnB1dCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmV4ZWNBVE4oaW5wdXQsIGRmYS5zMCk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlucHV0LnJlbGVhc2UobWFyayk7XG5cdH1cbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnByZXZBY2NlcHQucmVzZXQoKTtcblx0dGhpcy5zdGFydEluZGV4ID0gLTE7XG5cdHRoaXMubGluZSA9IDE7XG5cdHRoaXMuY29sdW1uID0gMDtcblx0dGhpcy5tb2RlID0gTGV4ZXIuREVGQVVMVF9NT0RFO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLm1hdGNoQVROID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0dmFyIHN0YXJ0U3RhdGUgPSB0aGlzLmF0bi5tb2RlVG9TdGFydFN0YXRlW3RoaXMubW9kZV07XG5cblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJtYXRjaEFUTiBtb2RlIFwiICsgdGhpcy5tb2RlICsgXCIgc3RhcnQ6IFwiICsgc3RhcnRTdGF0ZSk7XG5cdH1cblx0dmFyIG9sZF9tb2RlID0gdGhpcy5tb2RlO1xuXHR2YXIgczBfY2xvc3VyZSA9IHRoaXMuY29tcHV0ZVN0YXJ0U3RhdGUoaW5wdXQsIHN0YXJ0U3RhdGUpO1xuXHR2YXIgc3VwcHJlc3NFZGdlID0gczBfY2xvc3VyZS5oYXNTZW1hbnRpY0NvbnRleHQ7XG5cdHMwX2Nsb3N1cmUuaGFzU2VtYW50aWNDb250ZXh0ID0gZmFsc2U7XG5cblx0dmFyIG5leHQgPSB0aGlzLmFkZERGQVN0YXRlKHMwX2Nsb3N1cmUpO1xuXHRpZiAoIXN1cHByZXNzRWRnZSkge1xuXHRcdHRoaXMuZGVjaXNpb25Ub0RGQVt0aGlzLm1vZGVdLnMwID0gbmV4dDtcblx0fVxuXG5cdHZhciBwcmVkaWN0ID0gdGhpcy5leGVjQVROKGlucHV0LCBuZXh0KTtcblxuXHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRjb25zb2xlLmxvZyhcIkRGQSBhZnRlciBtYXRjaEFUTjogXCIgKyB0aGlzLmRlY2lzaW9uVG9ERkFbb2xkX21vZGVdLnRvTGV4ZXJTdHJpbmcoKSk7XG5cdH1cblx0cmV0dXJuIHByZWRpY3Q7XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZXhlY0FUTiA9IGZ1bmN0aW9uKGlucHV0LCBkczApIHtcblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJzdGFydCBzdGF0ZSBjbG9zdXJlPVwiICsgZHMwLmNvbmZpZ3MpO1xuXHR9XG5cdGlmIChkczAuaXNBY2NlcHRTdGF0ZSkge1xuXHRcdC8vIGFsbG93IHplcm8tbGVuZ3RoIHRva2Vuc1xuXHRcdHRoaXMuY2FwdHVyZVNpbVN0YXRlKHRoaXMucHJldkFjY2VwdCwgaW5wdXQsIGRzMCk7XG5cdH1cblx0dmFyIHQgPSBpbnB1dC5MQSgxKTtcblx0dmFyIHMgPSBkczA7IC8vIHMgaXMgY3VycmVudC9mcm9tIERGQSBzdGF0ZVxuXG5cdHdoaWxlICh0cnVlKSB7IC8vIHdoaWxlIG1vcmUgd29ya1xuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coXCJleGVjQVROIGxvb3Agc3RhcnRpbmcgY2xvc3VyZTogXCIgKyBzLmNvbmZpZ3MpO1xuXHRcdH1cblxuXHRcdC8vIEFzIHdlIG1vdmUgc3JjLT50cmcsIHNyYy0+dHJnLCB3ZSBrZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyB0cmcgdG9cblx0XHQvLyBhdm9pZCBsb29raW5nIHVwIHRoZSBERkEgc3RhdGUgYWdhaW4sIHdoaWNoIGlzIGV4cGVuc2l2ZS5cblx0XHQvLyBJZiB0aGUgcHJldmlvdXMgdGFyZ2V0IHdhcyBhbHJlYWR5IHBhcnQgb2YgdGhlIERGQSwgd2UgbWlnaHRcblx0XHQvLyBiZSBhYmxlIHRvIGF2b2lkIGRvaW5nIGEgcmVhY2ggb3BlcmF0aW9uIHVwb24gdC4gSWYgcyE9bnVsbCxcblx0XHQvLyBpdCBtZWFucyB0aGF0IHNlbWFudGljIHByZWRpY2F0ZXMgZGlkbid0IHByZXZlbnQgdXMgZnJvbVxuXHRcdC8vIGNyZWF0aW5nIGEgREZBIHN0YXRlLiBPbmNlIHdlIGtub3cgcyE9bnVsbCwgd2UgY2hlY2sgdG8gc2VlIGlmXG5cdFx0Ly8gdGhlIERGQSBzdGF0ZSBoYXMgYW4gZWRnZSBhbHJlYWR5IGZvciB0LiBJZiBzbywgd2UgY2FuIGp1c3QgcmV1c2Vcblx0XHQvLyBpdCdzIGNvbmZpZ3VyYXRpb24gc2V0OyB0aGVyZSdzIG5vIHBvaW50IGluIHJlLWNvbXB1dGluZyBpdC5cblx0XHQvLyBUaGlzIGlzIGtpbmQgb2YgbGlrZSBkb2luZyBERkEgc2ltdWxhdGlvbiB3aXRoaW4gdGhlIEFUTlxuXHRcdC8vIHNpbXVsYXRpb24gYmVjYXVzZSBERkEgc2ltdWxhdGlvbiBpcyByZWFsbHkganVzdCBhIHdheSB0byBhdm9pZFxuXHRcdC8vIGNvbXB1dGluZyByZWFjaC9jbG9zdXJlIHNldHMuIFRlY2huaWNhbGx5LCBvbmNlIHdlIGtub3cgdGhhdFxuXHRcdC8vIHdlIGhhdmUgYSBwcmV2aW91c2x5IGFkZGVkIERGQSBzdGF0ZSwgd2UgY291bGQganVtcCBvdmVyIHRvXG5cdFx0Ly8gdGhlIERGQSBzaW11bGF0b3IuIEJ1dCwgdGhhdCB3b3VsZCBtZWFuIHBvcHBpbmcgYmFjayBhbmQgZm9ydGhcblx0XHQvLyBhIGxvdCBhbmQgbWFraW5nIHRoaW5ncyBtb3JlIGNvbXBsaWNhdGVkIGFsZ29yaXRobWljYWxseS5cblx0XHQvLyBUaGlzIG9wdGltaXphdGlvbiBtYWtlcyBhIGxvdCBvZiBzZW5zZSBmb3IgbG9vcHMgd2l0aGluIERGQS5cblx0XHQvLyBBIGNoYXJhY3RlciB3aWxsIHRha2UgdXMgYmFjayB0byBhbiBleGlzdGluZyBERkEgc3RhdGVcblx0XHQvLyB0aGF0IGFscmVhZHkgaGFzIGxvdHMgb2YgZWRnZXMgb3V0IG9mIGl0LiBlLmcuLCAuKiBpbiBjb21tZW50cy5cblx0XHQvLyBwcmludChcIlRhcmdldCBmb3I6XCIgKyBzdHIocykgKyBcIiBhbmQ6XCIgKyBzdHIodCkpXG5cdFx0dmFyIHRhcmdldCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShzLCB0KTtcblx0XHQvLyBwcmludChcIkV4aXN0aW5nOlwiICsgc3RyKHRhcmdldCkpXG5cdFx0aWYgKHRhcmdldCA9PT0gbnVsbCkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5jb21wdXRlVGFyZ2V0U3RhdGUoaW5wdXQsIHMsIHQpO1xuXHRcdFx0Ly8gcHJpbnQoXCJDb21wdXRlZDpcIiArIHN0cih0YXJnZXQpKVxuXHRcdH1cblx0XHRpZiAodGFyZ2V0ID09PSBBVE5TaW11bGF0b3IuRVJST1IpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIGlzIGEgY29uc3VtYWJsZSBpbnB1dCBlbGVtZW50LCBtYWtlIHN1cmUgdG8gY29uc3VtZSBiZWZvcmVcblx0XHQvLyBjYXB0dXJpbmcgdGhlIGFjY2VwdCBzdGF0ZSBzbyB0aGUgaW5wdXQgaW5kZXgsIGxpbmUsIGFuZCBjaGFyXG5cdFx0Ly8gcG9zaXRpb24gYWNjdXJhdGVseSByZWZsZWN0IHRoZSBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIgYXQgdGhlXG5cdFx0Ly8gZW5kIG9mIHRoZSB0b2tlbi5cblx0XHRpZiAodCAhPT0gVG9rZW4uRU9GKSB7XG5cdFx0XHR0aGlzLmNvbnN1bWUoaW5wdXQpO1xuXHRcdH1cblx0XHRpZiAodGFyZ2V0LmlzQWNjZXB0U3RhdGUpIHtcblx0XHRcdHRoaXMuY2FwdHVyZVNpbVN0YXRlKHRoaXMucHJldkFjY2VwdCwgaW5wdXQsIHRhcmdldCk7XG5cdFx0XHRpZiAodCA9PT0gVG9rZW4uRU9GKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0ID0gaW5wdXQuTEEoMSk7XG5cdFx0cyA9IHRhcmdldDsgLy8gZmxpcDsgY3VycmVudCBERkEgdGFyZ2V0IGJlY29tZXMgbmV3IHNyYy9mcm9tIHN0YXRlXG5cdH1cblx0cmV0dXJuIHRoaXMuZmFpbE9yQWNjZXB0KHRoaXMucHJldkFjY2VwdCwgaW5wdXQsIHMuY29uZmlncywgdCk7XG59O1xuXG4vLyBHZXQgYW4gZXhpc3RpbmcgdGFyZ2V0IHN0YXRlIGZvciBhbiBlZGdlIGluIHRoZSBERkEuIElmIHRoZSB0YXJnZXQgc3RhdGVcbi8vIGZvciB0aGUgZWRnZSBoYXMgbm90IHlldCBiZWVuIGNvbXB1dGVkIG9yIGlzIG90aGVyd2lzZSBub3QgYXZhaWxhYmxlLFxuLy8gdGhpcyBtZXRob2QgcmV0dXJucyB7QGNvZGUgbnVsbH0uXG4vL1xuLy8gQHBhcmFtIHMgVGhlIGN1cnJlbnQgREZBIHN0YXRlXG4vLyBAcGFyYW0gdCBUaGUgbmV4dCBpbnB1dCBzeW1ib2xcbi8vIEByZXR1cm4gVGhlIGV4aXN0aW5nIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcbi8vIHtAY29kZSB0fSwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSB0YXJnZXQgc3RhdGUgZm9yIHRoaXMgZWRnZSBpcyBub3Rcbi8vIGFscmVhZHkgY2FjaGVkXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uKHMsIHQpIHtcblx0aWYgKHMuZWRnZXMgPT09IG51bGwgfHwgdCA8IExleGVyQVROU2ltdWxhdG9yLk1JTl9ERkFfRURHRSB8fCB0ID4gTGV4ZXJBVE5TaW11bGF0b3IuTUFYX0RGQV9FREdFKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgdGFyZ2V0ID0gcy5lZGdlc1t0IC0gTGV4ZXJBVE5TaW11bGF0b3IuTUlOX0RGQV9FREdFXTtcblx0aWYodGFyZ2V0PT09dW5kZWZpbmVkKSB7XG5cdFx0dGFyZ2V0ID0gbnVsbDtcblx0fVxuXHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0Y29uc29sZS5sb2coXCJyZXVzZSBzdGF0ZSBcIiArIHMuc3RhdGVOdW1iZXIgKyBcIiBlZGdlIHRvIFwiICsgdGFyZ2V0LnN0YXRlTnVtYmVyKTtcblx0fVxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxuLy8gQ29tcHV0ZSBhIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLCBhbmQgYXR0ZW1wdCB0byBhZGQgdGhlXG4vLyBjb21wdXRlZCBzdGF0ZSBhbmQgY29ycmVzcG9uZGluZyBlZGdlIHRvIHRoZSBERkEuXG4vL1xuLy8gQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJlYW1cbi8vIEBwYXJhbSBzIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxuLy8gQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXG4vL1xuLy8gQHJldHVybiBUaGUgY29tcHV0ZWQgdGFyZ2V0IERGQSBzdGF0ZSBmb3IgdGhlIGdpdmVuIGlucHV0IHN5bWJvbFxuLy8ge0Bjb2RlIHR9LiBJZiB7QGNvZGUgdH0gZG9lcyBub3QgbGVhZCB0byBhIHZhbGlkIERGQSBzdGF0ZSwgdGhpcyBtZXRob2Rcbi8vIHJldHVybnMge0BsaW5rIC8vRVJST1J9LlxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbXB1dGVUYXJnZXRTdGF0ZSA9IGZ1bmN0aW9uKGlucHV0LCBzLCB0KSB7XG5cdHZhciByZWFjaCA9IG5ldyBPcmRlcmVkQVROQ29uZmlnU2V0KCk7XG5cdC8vIGlmIHdlIGRvbid0IGZpbmQgYW4gZXhpc3RpbmcgREZBIHN0YXRlXG5cdC8vIEZpbGwgcmVhY2ggc3RhcnRpbmcgZnJvbSBjbG9zdXJlLCBmb2xsb3dpbmcgdCB0cmFuc2l0aW9uc1xuXHR0aGlzLmdldFJlYWNoYWJsZUNvbmZpZ1NldChpbnB1dCwgcy5jb25maWdzLCByZWFjaCwgdCk7XG5cblx0aWYgKHJlYWNoLml0ZW1zLmxlbmd0aCA9PT0gMCkgeyAvLyB3ZSBnb3Qgbm93aGVyZSBvbiB0IGZyb20gc1xuXHRcdGlmICghcmVhY2guaGFzU2VtYW50aWNDb250ZXh0KSB7XG5cdFx0XHQvLyB3ZSBnb3Qgbm93aGVyZSBvbiB0LCBkb24ndCB0aHJvdyBvdXQgdGhpcyBrbm93bGVkZ2U7IGl0J2Rcblx0XHRcdC8vIGNhdXNlIGEgZmFpbG92ZXIgZnJvbSBERkEgbGF0ZXIuXG5cdFx0XHR0aGlzLmFkZERGQUVkZ2UocywgdCwgQVROU2ltdWxhdG9yLkVSUk9SKTtcblx0XHR9XG5cdFx0Ly8gc3RvcCB3aGVuIHdlIGNhbid0IG1hdGNoIGFueSBtb3JlIGNoYXJcblx0XHRyZXR1cm4gQVROU2ltdWxhdG9yLkVSUk9SO1xuXHR9XG5cdC8vIEFkZCBhbiBlZGdlIGZyb20gcyB0byB0YXJnZXQgREZBIGZvdW5kL2NyZWF0ZWQgZm9yIHJlYWNoXG5cdHJldHVybiB0aGlzLmFkZERGQUVkZ2UocywgdCwgbnVsbCwgcmVhY2gpO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmZhaWxPckFjY2VwdCA9IGZ1bmN0aW9uKHByZXZBY2NlcHQsIGlucHV0LCByZWFjaCwgdCkge1xuXHRpZiAodGhpcy5wcmV2QWNjZXB0LmRmYVN0YXRlICE9PSBudWxsKSB7XG5cdFx0dmFyIGxleGVyQWN0aW9uRXhlY3V0b3IgPSBwcmV2QWNjZXB0LmRmYVN0YXRlLmxleGVyQWN0aW9uRXhlY3V0b3I7XG5cdFx0dGhpcy5hY2NlcHQoaW5wdXQsIGxleGVyQWN0aW9uRXhlY3V0b3IsIHRoaXMuc3RhcnRJbmRleCxcblx0XHRcdFx0cHJldkFjY2VwdC5pbmRleCwgcHJldkFjY2VwdC5saW5lLCBwcmV2QWNjZXB0LmNvbHVtbik7XG5cdFx0cmV0dXJuIHByZXZBY2NlcHQuZGZhU3RhdGUucHJlZGljdGlvbjtcblx0fSBlbHNlIHtcblx0XHQvLyBpZiBubyBhY2NlcHQgYW5kIEVPRiBpcyBmaXJzdCBjaGFyLCByZXR1cm4gRU9GXG5cdFx0aWYgKHQgPT09IFRva2VuLkVPRiAmJiBpbnB1dC5pbmRleCA9PT0gdGhpcy5zdGFydEluZGV4KSB7XG5cdFx0XHRyZXR1cm4gVG9rZW4uRU9GO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzLnJlY29nLCBpbnB1dCwgdGhpcy5zdGFydEluZGV4LCByZWFjaCk7XG5cdH1cbn07XG5cbi8vIEdpdmVuIGEgc3RhcnRpbmcgY29uZmlndXJhdGlvbiBzZXQsIGZpZ3VyZSBvdXQgYWxsIEFUTiBjb25maWd1cmF0aW9uc1xuLy8gd2UgY2FuIHJlYWNoIHVwb24gaW5wdXQge0Bjb2RlIHR9LiBQYXJhbWV0ZXIge0Bjb2RlIHJlYWNofSBpcyBhIHJldHVyblxuLy8gcGFyYW1ldGVyLlxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFJlYWNoYWJsZUNvbmZpZ1NldCA9IGZ1bmN0aW9uKGlucHV0LCBjbG9zdXJlLFxuXHRcdHJlYWNoLCB0KSB7XG5cdC8vIHRoaXMgaXMgdXNlZCB0byBza2lwIHByb2Nlc3NpbmcgZm9yIGNvbmZpZ3Mgd2hpY2ggaGF2ZSBhIGxvd2VyIHByaW9yaXR5XG5cdC8vIHRoYW4gYSBjb25maWcgdGhhdCBhbHJlYWR5IHJlYWNoZWQgYW4gYWNjZXB0IHN0YXRlIGZvciB0aGUgc2FtZSBydWxlXG5cdHZhciBza2lwQWx0ID0gQVROLklOVkFMSURfQUxUX05VTUJFUjtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbG9zdXJlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNmZyA9IGNsb3N1cmUuaXRlbXNbaV07XG5cdFx0dmFyIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgPSAoY2ZnLmFsdCA9PT0gc2tpcEFsdCk7XG5cdFx0aWYgKGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgJiYgY2ZnLnBhc3NlZFRocm91Z2hOb25HcmVlZHlEZWNpc2lvbikge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdFx0Y29uc29sZS5sb2coXCJ0ZXN0aW5nICVzIGF0ICVzXFxuXCIsIHRoaXMuZ2V0VG9rZW5OYW1lKHQpLCBjZmdcblx0XHRcdFx0XHQudG9TdHJpbmcodGhpcy5yZWNvZywgdHJ1ZSkpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNmZy5zdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7IGorKykge1xuXHRcdFx0dmFyIHRyYW5zID0gY2ZnLnN0YXRlLnRyYW5zaXRpb25zW2pdOyAvLyBmb3IgZWFjaCB0cmFuc2l0aW9uXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5nZXRSZWFjaGFibGVUYXJnZXQodHJhbnMsIHQpO1xuXHRcdFx0aWYgKHRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IGNmZy5sZXhlckFjdGlvbkV4ZWN1dG9yO1xuXHRcdFx0XHRpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGxleGVyQWN0aW9uRXhlY3V0b3IgPSBsZXhlckFjdGlvbkV4ZWN1dG9yLmZpeE9mZnNldEJlZm9yZU1hdGNoKGlucHV0LmluZGV4IC0gdGhpcy5zdGFydEluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdHJlYXRFb2ZBc0Vwc2lsb24gPSAodCA9PT0gVG9rZW4uRU9GKTtcblx0XHRcdFx0dmFyIGNvbmZpZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7c3RhdGU6dGFyZ2V0LCBsZXhlckFjdGlvbkV4ZWN1dG9yOmxleGVyQWN0aW9uRXhlY3V0b3J9LCBjZmcpO1xuXHRcdFx0XHRpZiAodGhpcy5jbG9zdXJlKGlucHV0LCBjb25maWcsIHJlYWNoLFxuXHRcdFx0XHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgdHJ1ZSwgdHJlYXRFb2ZBc0Vwc2lsb24pKSB7XG5cdFx0XHRcdFx0Ly8gYW55IHJlbWFpbmluZyBjb25maWdzIGZvciB0aGlzIGFsdCBoYXZlIGEgbG93ZXIgcHJpb3JpdHlcblx0XHRcdFx0XHQvLyB0aGFuIHRoZSBvbmUgdGhhdCBqdXN0IHJlYWNoZWQgYW4gYWNjZXB0IHN0YXRlLlxuXHRcdFx0XHRcdHNraXBBbHQgPSBjZmcuYWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24oaW5wdXQsIGxleGVyQWN0aW9uRXhlY3V0b3IsXG5cdFx0c3RhcnRJbmRleCwgaW5kZXgsIGxpbmUsIGNoYXJQb3MpIHtcblx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0Y29uc29sZS5sb2coXCJBQ1RJT04gJXNcXG5cIiwgbGV4ZXJBY3Rpb25FeGVjdXRvcik7XG5cdH1cblx0Ly8gc2VlayB0byBhZnRlciBsYXN0IGNoYXIgaW4gdG9rZW5cblx0aW5wdXQuc2VlayhpbmRleCk7XG5cdHRoaXMubGluZSA9IGxpbmU7XG5cdHRoaXMuY29sdW1uID0gY2hhclBvcztcblx0aWYgKGxleGVyQWN0aW9uRXhlY3V0b3IgIT09IG51bGwgJiYgdGhpcy5yZWNvZyAhPT0gbnVsbCkge1xuXHRcdGxleGVyQWN0aW9uRXhlY3V0b3IuZXhlY3V0ZSh0aGlzLnJlY29nLCBpbnB1dCwgc3RhcnRJbmRleCk7XG5cdH1cbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRSZWFjaGFibGVUYXJnZXQgPSBmdW5jdGlvbih0cmFucywgdCkge1xuXHRpZiAodHJhbnMubWF0Y2hlcyh0LCAwLCBMZXhlci5NQVhfQ0hBUl9WQUxVRSkpIHtcblx0XHRyZXR1cm4gdHJhbnMudGFyZ2V0O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY29tcHV0ZVN0YXJ0U3RhdGUgPSBmdW5jdGlvbihpbnB1dCwgcCkge1xuXHR2YXIgaW5pdGlhbENvbnRleHQgPSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWTtcblx0dmFyIGNvbmZpZ3MgPSBuZXcgT3JkZXJlZEFUTkNvbmZpZ1NldCgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHAudHJhbnNpdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgdGFyZ2V0ID0gcC50cmFuc2l0aW9uc1tpXS50YXJnZXQ7XG4gICAgICAgIHZhciBjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoe3N0YXRlOnRhcmdldCwgYWx0OmkrMSwgY29udGV4dDppbml0aWFsQ29udGV4dH0sIG51bGwpO1xuXHRcdHRoaXMuY2xvc3VyZShpbnB1dCwgY2ZnLCBjb25maWdzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblx0fVxuXHRyZXR1cm4gY29uZmlncztcbn07XG5cbi8vIFNpbmNlIHRoZSBhbHRlcm5hdGl2ZXMgd2l0aGluIGFueSBsZXhlciBkZWNpc2lvbiBhcmUgb3JkZXJlZCBieVxuLy8gcHJlZmVyZW5jZSwgdGhpcyBtZXRob2Qgc3RvcHMgcHVyc3VpbmcgdGhlIGNsb3N1cmUgYXMgc29vbiBhcyBhbiBhY2NlcHRcbi8vIHN0YXRlIGlzIHJlYWNoZWQuIEFmdGVyIHRoZSBmaXJzdCBhY2NlcHQgc3RhdGUgaXMgcmVhY2hlZCBieSBkZXB0aC1maXJzdFxuLy8gc2VhcmNoIGZyb20ge0Bjb2RlIGNvbmZpZ30sIGFsbCBvdGhlciAocG90ZW50aWFsbHkgcmVhY2hhYmxlKSBzdGF0ZXMgZm9yXG4vLyB0aGlzIHJ1bGUgd291bGQgaGF2ZSBhIGxvd2VyIHByaW9yaXR5LlxuLy9cbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGFuIGFjY2VwdCBzdGF0ZSBpcyByZWFjaGVkLCBvdGhlcndpc2Vcbi8vIHtAY29kZSBmYWxzZX0uXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY2xvc3VyZSA9IGZ1bmN0aW9uKGlucHV0LCBjb25maWcsIGNvbmZpZ3MsXG5cdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG5cdHZhciBjZmcgPSBudWxsO1xuXHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5yZWNvZywgdHJ1ZSkgKyBcIilcIik7XG5cdH1cblx0aWYgKGNvbmZpZy5zdGF0ZSBpbnN0YW5jZW9mIFJ1bGVTdG9wU3RhdGUpIHtcblx0XHRpZiAoTGV4ZXJBVE5TaW11bGF0b3IuZGVidWcpIHtcblx0XHRcdGlmICh0aGlzLnJlY29nICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiY2xvc3VyZSBhdCAlcyBydWxlIHN0b3AgJXNcXG5cIiwgdGhpcy5yZWNvZy5ydWxlTmFtZXNbY29uZmlnLnN0YXRlLnJ1bGVJbmRleF0sIGNvbmZpZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhcImNsb3N1cmUgYXQgcnVsZSBzdG9wICVzXFxuXCIsIGNvbmZpZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjb25maWcuY29udGV4dCA9PT0gbnVsbCB8fCBjb25maWcuY29udGV4dC5oYXNFbXB0eVBhdGgoKSkge1xuXHRcdFx0aWYgKGNvbmZpZy5jb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZy5jb250ZXh0LmlzRW1wdHkoKSkge1xuXHRcdFx0XHRjb25maWdzLmFkZChjb25maWcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbmZpZ3MuYWRkKG5ldyBMZXhlckFUTkNvbmZpZyh7IHN0YXRlOmNvbmZpZy5zdGF0ZSwgY29udGV4dDpQcmVkaWN0aW9uQ29udGV4dC5FTVBUWX0sIGNvbmZpZykpO1xuXHRcdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNvbmZpZy5jb250ZXh0ICE9PSBudWxsICYmICFjb25maWcuY29udGV4dC5pc0VtcHR5KCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlnLmNvbnRleHQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGNvbmZpZy5jb250ZXh0LmdldFJldHVyblN0YXRlKGkpICE9PSBQcmVkaWN0aW9uQ29udGV4dC5FTVBUWV9SRVRVUk5fU1RBVEUpIHtcblx0XHRcdFx0XHR2YXIgbmV3Q29udGV4dCA9IGNvbmZpZy5jb250ZXh0LmdldFBhcmVudChpKTsgLy8gXCJwb3BcIiByZXR1cm4gc3RhdGVcblx0XHRcdFx0XHR2YXIgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSldO1xuXHRcdFx0XHRcdGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyh7IHN0YXRlOnJldHVyblN0YXRlLCBjb250ZXh0Om5ld0NvbnRleHQgfSwgY29uZmlnKTtcblx0XHRcdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdGhpcy5jbG9zdXJlKGlucHV0LCBjZmcsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3MsIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUsIHNwZWN1bGF0aXZlLFxuXHRcdFx0XHRcdFx0XHR0cmVhdEVvZkFzRXBzaWxvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XG5cdH1cblx0Ly8gb3B0aW1pemF0aW9uXG5cdGlmICghY29uZmlnLnN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMpIHtcblx0XHRpZiAoIWN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGUgfHwgIWNvbmZpZy5wYXNzZWRUaHJvdWdoTm9uR3JlZWR5RGVjaXNpb24pIHtcblx0XHRcdGNvbmZpZ3MuYWRkKGNvbmZpZyk7XG5cdFx0fVxuXHR9XG5cdGZvciAodmFyIGogPSAwOyBqIDwgY29uZmlnLnN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIHRyYW5zID0gY29uZmlnLnN0YXRlLnRyYW5zaXRpb25zW2pdO1xuXHRcdGNmZyA9IHRoaXMuZ2V0RXBzaWxvblRhcmdldChpbnB1dCwgY29uZmlnLCB0cmFucywgY29uZmlncywgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcblx0XHRpZiAoY2ZnICE9PSBudWxsKSB7XG5cdFx0XHRjdXJyZW50QWx0UmVhY2hlZEFjY2VwdFN0YXRlID0gdGhpcy5jbG9zdXJlKGlucHV0LCBjZmcsIGNvbmZpZ3MsXG5cdFx0XHRcdFx0Y3VycmVudEFsdFJlYWNoZWRBY2NlcHRTdGF0ZSwgc3BlY3VsYXRpdmUsIHRyZWF0RW9mQXNFcHNpbG9uKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGN1cnJlbnRBbHRSZWFjaGVkQWNjZXB0U3RhdGU7XG59O1xuXG4vLyBzaWRlLWVmZmVjdDogY2FuIGFsdGVyIGNvbmZpZ3MuaGFzU2VtYW50aWNDb250ZXh0XG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0RXBzaWxvblRhcmdldCA9IGZ1bmN0aW9uKGlucHV0LCBjb25maWcsIHRyYW5zLFxuXHRcdGNvbmZpZ3MsIHNwZWN1bGF0aXZlLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuXHR2YXIgY2ZnID0gbnVsbDtcblx0aWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLlJVTEUpIHtcblx0XHR2YXIgbmV3Q29udGV4dCA9IFNpbmdsZXRvblByZWRpY3Rpb25Db250ZXh0LmNyZWF0ZShjb25maWcuY29udGV4dCwgdHJhbnMuZm9sbG93U3RhdGUuc3RhdGVOdW1iZXIpO1xuXHRcdGNmZyA9IG5ldyBMZXhlckFUTkNvbmZpZyggeyBzdGF0ZTp0cmFucy50YXJnZXQsIGNvbnRleHQ6bmV3Q29udGV4dH0sIGNvbmZpZyk7XG5cdH0gZWxzZSBpZiAodHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uUFJFQ0VERU5DRSkge1xuXHRcdHRocm93IFwiUHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGxleGVycy5cIjtcblx0fSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5QUkVESUNBVEUpIHtcblx0XHQvLyBUcmFjayB0cmF2ZXJzaW5nIHNlbWFudGljIHByZWRpY2F0ZXMuIElmIHdlIHRyYXZlcnNlLFxuXHRcdC8vIHdlIGNhbm5vdCBhZGQgYSBERkEgc3RhdGUgZm9yIHRoaXMgXCJyZWFjaFwiIGNvbXB1dGF0aW9uXG5cdFx0Ly8gYmVjYXVzZSB0aGUgREZBIHdvdWxkIG5vdCB0ZXN0IHRoZSBwcmVkaWNhdGUgYWdhaW4gaW4gdGhlXG5cdFx0Ly8gZnV0dXJlLiBSYXRoZXIgdGhhbiBjcmVhdGluZyBjb2xsZWN0aW9ucyBvZiBzZW1hbnRpYyBwcmVkaWNhdGVzXG5cdFx0Ly8gbGlrZSB2MyBhbmQgdGVzdGluZyB0aGVtIG9uIHByZWRpY3Rpb24sIHY0IHdpbGwgdGVzdCB0aGVtIG9uIHRoZVxuXHRcdC8vIGZseSBhbGwgdGhlIHRpbWUgdXNpbmcgdGhlIEFUTiBub3QgdGhlIERGQS4gVGhpcyBpcyBzbG93ZXIgYnV0XG5cdFx0Ly8gc2VtYW50aWNhbGx5IGl0J3Mgbm90IHVzZWQgdGhhdCBvZnRlbi4gT25lIG9mIHRoZSBrZXkgZWxlbWVudHMgdG9cblx0XHQvLyB0aGlzIHByZWRpY2F0ZSBtZWNoYW5pc20gaXMgbm90IGFkZGluZyBERkEgc3RhdGVzIHRoYXQgc2VlXG5cdFx0Ly8gcHJlZGljYXRlcyBpbW1lZGlhdGVseSBhZnRlcndhcmRzIGluIHRoZSBBVE4uIEZvciBleGFtcGxlLFxuXG5cdFx0Ly8gYSA6IElEIHtwMX0/IHwgSUQge3AyfT8gO1xuXG5cdFx0Ly8gc2hvdWxkIGNyZWF0ZSB0aGUgc3RhcnQgc3RhdGUgZm9yIHJ1bGUgJ2EnICh0byBzYXZlIHN0YXJ0IHN0YXRlXG5cdFx0Ly8gY29tcGV0aXRpb24pLCBidXQgc2hvdWxkIG5vdCBjcmVhdGUgdGFyZ2V0IG9mIElEIHN0YXRlLiBUaGVcblx0XHQvLyBjb2xsZWN0aW9uIG9mIEFUTiBzdGF0ZXMgdGhlIGZvbGxvd2luZyBJRCByZWZlcmVuY2VzIGluY2x1ZGVzXG5cdFx0Ly8gc3RhdGVzIHJlYWNoZWQgYnkgdHJhdmVyc2luZyBwcmVkaWNhdGVzLiBTaW5jZSB0aGlzIGlzIHdoZW4gd2Vcblx0XHQvLyB0ZXN0IHRoZW0sIHdlIGNhbm5vdCBjYXNoIHRoZSBERkEgc3RhdGUgdGFyZ2V0IG9mIElELlxuXG5cdFx0aWYgKExleGVyQVROU2ltdWxhdG9yLmRlYnVnKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIkVWQUwgcnVsZSBcIiArIHRyYW5zLnJ1bGVJbmRleCArIFwiOlwiICsgdHJhbnMucHJlZEluZGV4KTtcblx0XHR9XG5cdFx0Y29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQgPSB0cnVlO1xuXHRcdGlmICh0aGlzLmV2YWx1YXRlUHJlZGljYXRlKGlucHV0LCB0cmFucy5ydWxlSW5kZXgsIHRyYW5zLnByZWRJbmRleCwgc3BlY3VsYXRpdmUpKSB7XG5cdFx0XHRjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoeyBzdGF0ZTp0cmFucy50YXJnZXR9LCBjb25maWcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0cmFucy5zZXJpYWxpemF0aW9uVHlwZSA9PT0gVHJhbnNpdGlvbi5BQ1RJT04pIHtcblx0XHRpZiAoY29uZmlnLmNvbnRleHQgPT09IG51bGwgfHwgY29uZmlnLmNvbnRleHQuaGFzRW1wdHlQYXRoKCkpIHtcblx0XHRcdC8vIGV4ZWN1dGUgYWN0aW9ucyBhbnl3aGVyZSBpbiB0aGUgc3RhcnQgcnVsZSBmb3IgYSB0b2tlbi5cblx0XHRcdC8vXG5cdFx0XHQvLyBUT0RPOiBpZiB0aGUgZW50cnkgcnVsZSBpcyBpbnZva2VkIHJlY3Vyc2l2ZWx5LCBzb21lXG5cdFx0XHQvLyBhY3Rpb25zIG1heSBiZSBleGVjdXRlZCBkdXJpbmcgdGhlIHJlY3Vyc2l2ZSBjYWxsLiBUaGVcblx0XHRcdC8vIHByb2JsZW0gY2FuIGFwcGVhciB3aGVuIGhhc0VtcHR5UGF0aCgpIGlzIHRydWUgYnV0XG5cdFx0XHQvLyBpc0VtcHR5KCkgaXMgZmFsc2UuIEluIHRoaXMgY2FzZSwgdGhlIGNvbmZpZyBuZWVkcyB0byBiZVxuXHRcdFx0Ly8gc3BsaXQgaW50byB0d28gY29udGV4dHMgLSBvbmUgd2l0aCBqdXN0IHRoZSBlbXB0eSBwYXRoXG5cdFx0XHQvLyBhbmQgYW5vdGhlciB3aXRoIGV2ZXJ5dGhpbmcgYnV0IHRoZSBlbXB0eSBwYXRoLlxuXHRcdFx0Ly8gVW5mb3J0dW5hdGVseSwgdGhlIGN1cnJlbnQgYWxnb3JpdGhtIGRvZXMgbm90IGFsbG93XG5cdFx0XHQvLyBnZXRFcHNpbG9uVGFyZ2V0IHRvIHJldHVybiB0d28gY29uZmlndXJhdGlvbnMsIHNvXG5cdFx0XHQvLyBhZGRpdGlvbmFsIG1vZGlmaWNhdGlvbnMgYXJlIG5lZWRlZCBiZWZvcmUgd2UgY2FuIHN1cHBvcnRcblx0XHRcdC8vIHRoZSBzcGxpdCBvcGVyYXRpb24uXG5cdFx0XHR2YXIgbGV4ZXJBY3Rpb25FeGVjdXRvciA9IExleGVyQWN0aW9uRXhlY3V0b3IuYXBwZW5kKGNvbmZpZy5sZXhlckFjdGlvbkV4ZWN1dG9yLFxuXHRcdFx0XHRcdHRoaXMuYXRuLmxleGVyQWN0aW9uc1t0cmFucy5hY3Rpb25JbmRleF0pO1xuXHRcdFx0Y2ZnID0gbmV3IExleGVyQVROQ29uZmlnKHsgc3RhdGU6dHJhbnMudGFyZ2V0LCBsZXhlckFjdGlvbkV4ZWN1dG9yOmxleGVyQWN0aW9uRXhlY3V0b3IgfSwgY29uZmlnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWdub3JlIGFjdGlvbnMgaW4gcmVmZXJlbmNlZCBydWxlc1xuXHRcdFx0Y2ZnID0gbmV3IExleGVyQVROQ29uZmlnKCB7IHN0YXRlOnRyYW5zLnRhcmdldH0sIGNvbmZpZyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLkVQU0lMT04pIHtcblx0XHRjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoeyBzdGF0ZTp0cmFucy50YXJnZXR9LCBjb25maWcpO1xuXHR9IGVsc2UgaWYgKHRyYW5zLnNlcmlhbGl6YXRpb25UeXBlID09PSBUcmFuc2l0aW9uLkFUT00gfHxcblx0XHRcdFx0dHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uUkFOR0UgfHxcblx0XHRcdFx0dHJhbnMuc2VyaWFsaXphdGlvblR5cGUgPT09IFRyYW5zaXRpb24uU0VUKSB7XG5cdFx0aWYgKHRyZWF0RW9mQXNFcHNpbG9uKSB7XG5cdFx0XHRpZiAodHJhbnMubWF0Y2hlcyhUb2tlbi5FT0YsIDAsIExleGVyLk1BWF9DSEFSX1ZBTFVFKSkge1xuXHRcdFx0XHRjZmcgPSBuZXcgTGV4ZXJBVE5Db25maWcoIHsgc3RhdGU6dHJhbnMudGFyZ2V0IH0sIGNvbmZpZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjZmc7XG59O1xuXG4vLyBFdmFsdWF0ZSBhIHByZWRpY2F0ZSBzcGVjaWZpZWQgaW4gdGhlIGxleGVyLlxuLy9cbi8vIDxwPklmIHtAY29kZSBzcGVjdWxhdGl2ZX0gaXMge0Bjb2RlIHRydWV9LCB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlZm9yZVxuLy8ge0BsaW5rIC8vY29uc3VtZX0gZm9yIHRoZSBtYXRjaGVkIGNoYXJhY3Rlci4gVGhpcyBtZXRob2Qgc2hvdWxkIGNhbGxcbi8vIHtAbGluayAvL2NvbnN1bWV9IGJlZm9yZSBldmFsdWF0aW5nIHRoZSBwcmVkaWNhdGUgdG8gZW5zdXJlIHBvc2l0aW9uXG4vLyBzZW5zaXRpdmUgdmFsdWVzLCBpbmNsdWRpbmcge0BsaW5rIExleGVyLy9nZXRUZXh0fSwge0BsaW5rIExleGVyLy9nZXRMaW5lfSxcbi8vIGFuZCB7QGxpbmsgTGV4ZXIvL2dldGNvbHVtbn0sIHByb3Blcmx5IHJlZmxlY3QgdGhlIGN1cnJlbnRcbi8vIGxleGVyIHN0YXRlLiBUaGlzIG1ldGhvZCBzaG91bGQgcmVzdG9yZSB7QGNvZGUgaW5wdXR9IGFuZCB0aGUgc2ltdWxhdG9yXG4vLyB0byB0aGUgb3JpZ2luYWwgc3RhdGUgYmVmb3JlIHJldHVybmluZyAoaS5lLiB1bmRvIHRoZSBhY3Rpb25zIG1hZGUgYnkgdGhlXG4vLyBjYWxsIHRvIHtAbGluayAvL2NvbnN1bWV9LjwvcD5cbi8vXG4vLyBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHN0cmVhbS5cbi8vIEBwYXJhbSBydWxlSW5kZXggVGhlIHJ1bGUgY29udGFpbmluZyB0aGUgcHJlZGljYXRlLlxuLy8gQHBhcmFtIHByZWRJbmRleCBUaGUgaW5kZXggb2YgdGhlIHByZWRpY2F0ZSB3aXRoaW4gdGhlIHJ1bGUuXG4vLyBAcGFyYW0gc3BlY3VsYXRpdmUge0Bjb2RlIHRydWV9IGlmIHRoZSBjdXJyZW50IGluZGV4IGluIHtAY29kZSBpbnB1dH0gaXNcbi8vIG9uZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBwcmVkaWNhdGUncyBsb2NhdGlvbi5cbi8vXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiB0aGUgc3BlY2lmaWVkIHByZWRpY2F0ZSBldmFsdWF0ZXMgdG9cbi8vIHtAY29kZSB0cnVlfS5cbi8vIC9cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5ldmFsdWF0ZVByZWRpY2F0ZSA9IGZ1bmN0aW9uKGlucHV0LCBydWxlSW5kZXgsXG5cdFx0cHJlZEluZGV4LCBzcGVjdWxhdGl2ZSkge1xuXHQvLyBhc3N1bWUgdHJ1ZSBpZiBubyByZWNvZ25pemVyIHdhcyBwcm92aWRlZFxuXHRpZiAodGhpcy5yZWNvZyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdGlmICghc3BlY3VsYXRpdmUpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWNvZy5zZW1wcmVkKG51bGwsIHJ1bGVJbmRleCwgcHJlZEluZGV4KTtcblx0fVxuXHR2YXIgc2F2ZWRjb2x1bW4gPSB0aGlzLmNvbHVtbjtcblx0dmFyIHNhdmVkTGluZSA9IHRoaXMubGluZTtcblx0dmFyIGluZGV4ID0gaW5wdXQuaW5kZXg7XG5cdHZhciBtYXJrZXIgPSBpbnB1dC5tYXJrKCk7XG5cdHRyeSB7XG5cdFx0dGhpcy5jb25zdW1lKGlucHV0KTtcblx0XHRyZXR1cm4gdGhpcy5yZWNvZy5zZW1wcmVkKG51bGwsIHJ1bGVJbmRleCwgcHJlZEluZGV4KTtcblx0fSBmaW5hbGx5IHtcblx0XHR0aGlzLmNvbHVtbiA9IHNhdmVkY29sdW1uO1xuXHRcdHRoaXMubGluZSA9IHNhdmVkTGluZTtcblx0XHRpbnB1dC5zZWVrKGluZGV4KTtcblx0XHRpbnB1dC5yZWxlYXNlKG1hcmtlcik7XG5cdH1cbn07XG5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5jYXB0dXJlU2ltU3RhdGUgPSBmdW5jdGlvbihzZXR0aW5ncywgaW5wdXQsIGRmYVN0YXRlKSB7XG5cdHNldHRpbmdzLmluZGV4ID0gaW5wdXQuaW5kZXg7XG5cdHNldHRpbmdzLmxpbmUgPSB0aGlzLmxpbmU7XG5cdHNldHRpbmdzLmNvbHVtbiA9IHRoaXMuY29sdW1uO1xuXHRzZXR0aW5ncy5kZmFTdGF0ZSA9IGRmYVN0YXRlO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFkZERGQUVkZ2UgPSBmdW5jdGlvbihmcm9tXywgdGssIHRvLCBjZmdzKSB7XG5cdGlmICh0byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dG8gPSBudWxsO1xuXHR9XG5cdGlmIChjZmdzID09PSB1bmRlZmluZWQpIHtcblx0XHRjZmdzID0gbnVsbDtcblx0fVxuXHRpZiAodG8gPT09IG51bGwgJiYgY2ZncyAhPT0gbnVsbCkge1xuXHRcdC8vIGxlYWRpbmcgdG8gdGhpcyBjYWxsLCBBVE5Db25maWdTZXQuaGFzU2VtYW50aWNDb250ZXh0IGlzIHVzZWQgYXMgYVxuXHRcdC8vIG1hcmtlciBpbmRpY2F0aW5nIGR5bmFtaWMgcHJlZGljYXRlIGV2YWx1YXRpb24gbWFrZXMgdGhpcyBlZGdlXG5cdFx0Ly8gZGVwZW5kZW50IG9uIHRoZSBzcGVjaWZpYyBpbnB1dCBzZXF1ZW5jZSwgc28gdGhlIHN0YXRpYyBlZGdlIGluIHRoZVxuXHRcdC8vIERGQSBzaG91bGQgYmUgb21pdHRlZC4gVGhlIHRhcmdldCBERkFTdGF0ZSBpcyBzdGlsbCBjcmVhdGVkIHNpbmNlXG5cdFx0Ly8gZXhlY0FUTiBoYXMgdGhlIGFiaWxpdHkgdG8gcmVzeW5jaHJvbml6ZSB3aXRoIHRoZSBERkEgc3RhdGUgY2FjaGVcblx0XHQvLyBmb2xsb3dpbmcgdGhlIHByZWRpY2F0ZSBldmFsdWF0aW9uIHN0ZXAuXG5cdFx0Ly9cblx0XHQvLyBUSlAgbm90ZXM6IG5leHQgdGltZSB0aHJvdWdoIHRoZSBERkEsIHdlIHNlZSBhIHByZWQgYWdhaW4gYW5kIGV2YWwuXG5cdFx0Ly8gSWYgdGhhdCBnZXRzIHVzIHRvIGEgcHJldmlvdXNseSBjcmVhdGVkIChidXQgZGFuZ2xpbmcpIERGQVxuXHRcdC8vIHN0YXRlLCB3ZSBjYW4gY29udGludWUgaW4gcHVyZSBERkEgbW9kZSBmcm9tIHRoZXJlLlxuXHRcdC8vIC9cblx0XHR2YXIgc3VwcHJlc3NFZGdlID0gY2Zncy5oYXNTZW1hbnRpY0NvbnRleHQ7XG5cdFx0Y2Zncy5oYXNTZW1hbnRpY0NvbnRleHQgPSBmYWxzZTtcblxuXHRcdHRvID0gdGhpcy5hZGRERkFTdGF0ZShjZmdzKTtcblxuXHRcdGlmIChzdXBwcmVzc0VkZ2UpIHtcblx0XHRcdHJldHVybiB0bztcblx0XHR9XG5cdH1cblx0Ly8gYWRkIHRoZSBlZGdlXG5cdGlmICh0ayA8IExleGVyQVROU2ltdWxhdG9yLk1JTl9ERkFfRURHRSB8fCB0ayA+IExleGVyQVROU2ltdWxhdG9yLk1BWF9ERkFfRURHRSkge1xuXHRcdC8vIE9ubHkgdHJhY2sgZWRnZXMgd2l0aGluIHRoZSBERkEgYm91bmRzXG5cdFx0cmV0dXJuIHRvO1xuXHR9XG5cdGlmIChMZXhlckFUTlNpbXVsYXRvci5kZWJ1Zykge1xuXHRcdGNvbnNvbGUubG9nKFwiRURHRSBcIiArIGZyb21fICsgXCIgLT4gXCIgKyB0byArIFwiIHVwb24gXCIgKyB0ayk7XG5cdH1cblx0aWYgKGZyb21fLmVkZ2VzID09PSBudWxsKSB7XG5cdFx0Ly8gbWFrZSByb29tIGZvciB0b2tlbnMgMS4ubiBhbmQgLTEgbWFzcXVlcmFkaW5nIGFzIGluZGV4IDBcblx0XHRmcm9tXy5lZGdlcyA9IFtdO1xuXHR9XG5cdGZyb21fLmVkZ2VzW3RrIC0gTGV4ZXJBVE5TaW11bGF0b3IuTUlOX0RGQV9FREdFXSA9IHRvOyAvLyBjb25uZWN0XG5cblx0cmV0dXJuIHRvO1xufTtcblxuLy8gQWRkIGEgbmV3IERGQSBzdGF0ZSBpZiB0aGVyZSBpc24ndCBvbmUgd2l0aCB0aGlzIHNldCBvZlxuLy8gY29uZmlndXJhdGlvbnMgYWxyZWFkeS4gVGhpcyBtZXRob2QgYWxzbyBkZXRlY3RzIHRoZSBmaXJzdFxuLy8gY29uZmlndXJhdGlvbiBjb250YWluaW5nIGFuIEFUTiBydWxlIHN0b3Agc3RhdGUuIExhdGVyLCB3aGVuXG4vLyB0cmF2ZXJzaW5nIHRoZSBERkEsIHdlIHdpbGwga25vdyB3aGljaCBydWxlIHRvIGFjY2VwdC5cbkxleGVyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5hZGRERkFTdGF0ZSA9IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcblx0dmFyIHByb3Bvc2VkID0gbmV3IERGQVN0YXRlKG51bGwsIGNvbmZpZ3MpO1xuXHR2YXIgZmlyc3RDb25maWdXaXRoUnVsZVN0b3BTdGF0ZSA9IG51bGw7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjZmcgPSBjb25maWdzLml0ZW1zW2ldO1xuXHRcdGlmIChjZmcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG5cdFx0XHRmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlID0gY2ZnO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cdGlmIChmaXJzdENvbmZpZ1dpdGhSdWxlU3RvcFN0YXRlICE9PSBudWxsKSB7XG5cdFx0cHJvcG9zZWQuaXNBY2NlcHRTdGF0ZSA9IHRydWU7XG5cdFx0cHJvcG9zZWQubGV4ZXJBY3Rpb25FeGVjdXRvciA9IGZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUubGV4ZXJBY3Rpb25FeGVjdXRvcjtcblx0XHRwcm9wb3NlZC5wcmVkaWN0aW9uID0gdGhpcy5hdG4ucnVsZVRvVG9rZW5UeXBlW2ZpcnN0Q29uZmlnV2l0aFJ1bGVTdG9wU3RhdGUuc3RhdGUucnVsZUluZGV4XTtcblx0fVxuXHR2YXIgZGZhID0gdGhpcy5kZWNpc2lvblRvREZBW3RoaXMubW9kZV07XG5cdHZhciBleGlzdGluZyA9IGRmYS5zdGF0ZXMuZ2V0KHByb3Bvc2VkKTtcblx0aWYgKGV4aXN0aW5nIT09bnVsbCkge1xuXHRcdHJldHVybiBleGlzdGluZztcblx0fVxuXHR2YXIgbmV3U3RhdGUgPSBwcm9wb3NlZDtcblx0bmV3U3RhdGUuc3RhdGVOdW1iZXIgPSBkZmEuc3RhdGVzLmxlbmd0aDtcblx0Y29uZmlncy5zZXRSZWFkb25seSh0cnVlKTtcblx0bmV3U3RhdGUuY29uZmlncyA9IGNvbmZpZ3M7XG5cdGRmYS5zdGF0ZXMuYWRkKG5ld1N0YXRlKTtcblx0cmV0dXJuIG5ld1N0YXRlO1xufTtcblxuTGV4ZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldERGQSA9IGZ1bmN0aW9uKG1vZGUpIHtcblx0cmV0dXJuIHRoaXMuZGVjaXNpb25Ub0RGQVttb2RlXTtcbn07XG5cbi8vIEdldCB0aGUgdGV4dCBtYXRjaGVkIHNvIGZhciBmb3IgdGhlIGN1cnJlbnQgdG9rZW4uXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdC8vIGluZGV4IGlzIGZpcnN0IGxvb2thaGVhZCBjaGFyLCBkb24ndCBpbmNsdWRlLlxuXHRyZXR1cm4gaW5wdXQuZ2V0VGV4dCh0aGlzLnN0YXJ0SW5kZXgsIGlucHV0LmluZGV4IC0gMSk7XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHZhciBjdXJDaGFyID0gaW5wdXQuTEEoMSk7XG5cdGlmIChjdXJDaGFyID09PSBcIlxcblwiLmNoYXJDb2RlQXQoMCkpIHtcblx0XHR0aGlzLmxpbmUgKz0gMTtcblx0XHR0aGlzLmNvbHVtbiA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5jb2x1bW4gKz0gMTtcblx0fVxuXHRpbnB1dC5jb25zdW1lKCk7XG59O1xuXG5MZXhlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0VG9rZW5OYW1lID0gZnVuY3Rpb24odHQpIHtcblx0aWYgKHR0ID09PSAtMSkge1xuXHRcdHJldHVybiBcIkVPRlwiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodHQpICsgXCInXCI7XG5cdH1cbn07XG5cbmV4cG9ydHMuTGV4ZXJBVE5TaW11bGF0b3IgPSBMZXhlckFUTlNpbXVsYXRvcjtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4gLy9cblxuZnVuY3Rpb24gTGV4ZXJBY3Rpb25UeXBlKCkge1xufVxuXG5MZXhlckFjdGlvblR5cGUuQ0hBTk5FTCA9IDA7ICAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyQ2hhbm5lbEFjdGlvbn0gYWN0aW9uLlxuTGV4ZXJBY3Rpb25UeXBlLkNVU1RPTSA9IDE7ICAgICAgLy9UaGUgdHlwZSBvZiBhIHtAbGluayBMZXhlckN1c3RvbUFjdGlvbn0gYWN0aW9uLlxuTGV4ZXJBY3Rpb25UeXBlLk1PREUgPSAyOyAgICAgICAgLy9UaGUgdHlwZSBvZiBhIHtAbGluayBMZXhlck1vZGVBY3Rpb259IGFjdGlvbi5cbkxleGVyQWN0aW9uVHlwZS5NT1JFID0gMzsgICAgICAgIC8vVGhlIHR5cGUgb2YgYSB7QGxpbmsgTGV4ZXJNb3JlQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuUE9QX01PREUgPSA0OyAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyUG9wTW9kZUFjdGlvbn0gYWN0aW9uLlxuTGV4ZXJBY3Rpb25UeXBlLlBVU0hfTU9ERSA9IDU7ICAgLy9UaGUgdHlwZSBvZiBhIHtAbGluayBMZXhlclB1c2hNb2RlQWN0aW9ufSBhY3Rpb24uXG5MZXhlckFjdGlvblR5cGUuU0tJUCA9IDY7ICAgICAgICAvL1RoZSB0eXBlIG9mIGEge0BsaW5rIExleGVyU2tpcEFjdGlvbn0gYWN0aW9uLlxuTGV4ZXJBY3Rpb25UeXBlLlRZUEUgPSA3OyAgICAgICAgLy9UaGUgdHlwZSBvZiBhIHtAbGluayBMZXhlclR5cGVBY3Rpb259IGFjdGlvbi5cblxuZnVuY3Rpb24gTGV4ZXJBY3Rpb24oYWN0aW9uKSB7XG4gICAgdGhpcy5hY3Rpb25UeXBlID0gYWN0aW9uO1xuICAgIHRoaXMuaXNQb3NpdGlvbkRlcGVuZGVudCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5MZXhlckFjdGlvbi5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGFzaCA9IG5ldyBIYXNoKCk7XG4gICAgdGhpcy51cGRhdGVIYXNoQ29kZShoYXNoKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKVxufTtcblxuTGV4ZXJBY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSk7XG59O1xuXG5MZXhlckFjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyA9PT0gb3RoZXI7XG59O1xuXG5cblxuLy9cbi8vIEltcGxlbWVudHMgdGhlIHtAY29kZSBza2lwfSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3NraXB9LlxuLy9cbi8vIDxwPlRoZSB7QGNvZGUgc2tpcH0gY29tbWFuZCBkb2VzIG5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzLCBzbyB0aGlzIGFjdGlvbiBpc1xuLy8gaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gaW5zdGFuY2UgZXhwb3NlZCBieSB7QGxpbmsgLy9JTlNUQU5DRX0uPC9wPlxuZnVuY3Rpb24gTGV4ZXJTa2lwQWN0aW9uKCkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsIExleGVyQWN0aW9uVHlwZS5TS0lQKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkxleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlclNraXBBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJTa2lwQWN0aW9uO1xuXG4vLyBQcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIHBhcmFtZXRlcmxlc3MgbGV4ZXIgYWN0aW9uLlxuTGV4ZXJTa2lwQWN0aW9uLklOU1RBTkNFID0gbmV3IExleGVyU2tpcEFjdGlvbigpO1xuXG5MZXhlclNraXBBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLnNraXAoKTtcbn07XG5cbkxleGVyU2tpcEFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwic2tpcFwiO1xufTtcblxuLy8gIEltcGxlbWVudHMgdGhlIHtAY29kZSB0eXBlfSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3NldFR5cGV9XG4vLyB3aXRoIHRoZSBhc3NpZ25lZCB0eXBlLlxuZnVuY3Rpb24gTGV4ZXJUeXBlQWN0aW9uKHR5cGUpIHtcblx0TGV4ZXJBY3Rpb24uY2FsbCh0aGlzLCBMZXhlckFjdGlvblR5cGUuVFlQRSk7XG5cdHRoaXMudHlwZSA9IHR5cGU7XG5cdHJldHVybiB0aGlzO1xufVxuXG5MZXhlclR5cGVBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyVHlwZUFjdGlvbjtcblxuTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICBsZXhlci50eXBlID0gdGhpcy50eXBlO1xufTtcblxuTGV4ZXJUeXBlQWN0aW9uLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLmFjdGlvblR5cGUsIHRoaXMudHlwZSk7XG59O1xuXG5cbkxleGVyVHlwZUFjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZih0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJUeXBlQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZTtcbiAgICB9XG59O1xuXG5MZXhlclR5cGVBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHlwZShcIiArIHRoaXMudHlwZSArIFwiKVwiO1xufTtcblxuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIHB1c2hNb2RlfSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZ1xuLy8ge0BsaW5rIExleGVyLy9wdXNoTW9kZX0gd2l0aCB0aGUgYXNzaWduZWQgbW9kZS5cbmZ1bmN0aW9uIExleGVyUHVzaE1vZGVBY3Rpb24obW9kZSkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsIExleGVyQWN0aW9uVHlwZS5QVVNIX01PREUpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlclB1c2hNb2RlQWN0aW9uO1xuXG4vLyA8cD5UaGlzIGFjdGlvbiBpcyBpbXBsZW1lbnRlZCBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vcHVzaE1vZGV9IHdpdGggdGhlXG4vLyB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgLy9nZXRNb2RlfS48L3A+XG5MZXhlclB1c2hNb2RlQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICBsZXhlci5wdXNoTW9kZSh0aGlzLm1vZGUpO1xufTtcblxuTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLm1vZGUpO1xufTtcblxuTGV4ZXJQdXNoTW9kZUFjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIChvdGhlciBpbnN0YW5jZW9mIExleGVyUHVzaE1vZGVBY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09PSBvdGhlci5tb2RlO1xuICAgIH1cbn07XG5cbkxleGVyUHVzaE1vZGVBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcInB1c2hNb2RlKFwiICsgdGhpcy5tb2RlICsgXCIpXCI7XG59O1xuXG5cbi8vIEltcGxlbWVudHMgdGhlIHtAY29kZSBwb3BNb2RlfSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3BvcE1vZGV9LlxuLy9cbi8vIDxwPlRoZSB7QGNvZGUgcG9wTW9kZX0gY29tbWFuZCBkb2VzIG5vdCBoYXZlIGFueSBwYXJhbWV0ZXJzLCBzbyB0aGlzIGFjdGlvbiBpc1xuLy8gaW1wbGVtZW50ZWQgYXMgYSBzaW5nbGV0b24gaW5zdGFuY2UgZXhwb3NlZCBieSB7QGxpbmsgLy9JTlNUQU5DRX0uPC9wPlxuZnVuY3Rpb24gTGV4ZXJQb3BNb2RlQWN0aW9uKCkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsTGV4ZXJBY3Rpb25UeXBlLlBPUF9NT0RFKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkxleGVyUG9wTW9kZUFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlclBvcE1vZGVBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJQb3BNb2RlQWN0aW9uO1xuXG5MZXhlclBvcE1vZGVBY3Rpb24uSU5TVEFOQ0UgPSBuZXcgTGV4ZXJQb3BNb2RlQWN0aW9uKCk7XG5cbi8vIDxwPlRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyLy9wb3BNb2RlfS48L3A+XG5MZXhlclBvcE1vZGVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLnBvcE1vZGUoKTtcbn07XG5cbkxleGVyUG9wTW9kZUFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwicG9wTW9kZVwiO1xufTtcblxuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIG1vcmV9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vbW9yZX0uXG4vL1xuLy8gPHA+VGhlIHtAY29kZSBtb3JlfSBjb21tYW5kIGRvZXMgbm90IGhhdmUgYW55IHBhcmFtZXRlcnMsIHNvIHRoaXMgYWN0aW9uIGlzXG4vLyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBleHBvc2VkIGJ5IHtAbGluayAvL0lOU1RBTkNFfS48L3A+XG5mdW5jdGlvbiBMZXhlck1vcmVBY3Rpb24oKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgTGV4ZXJBY3Rpb25UeXBlLk1PUkUpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVyTW9yZUFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlck1vcmVBY3Rpb247XG5cbkxleGVyTW9yZUFjdGlvbi5JTlNUQU5DRSA9IG5ldyBMZXhlck1vcmVBY3Rpb24oKTtcblxuLy8gPHA+VGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL3BvcE1vZGV9LjwvcD5cbkxleGVyTW9yZUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyKSB7XG4gICAgbGV4ZXIubW9yZSgpO1xufTtcblxuTGV4ZXJNb3JlQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIm1vcmVcIjtcbn07XG5cblxuLy8gSW1wbGVtZW50cyB0aGUge0Bjb2RlIG1vZGV9IGxleGVyIGFjdGlvbiBieSBjYWxsaW5nIHtAbGluayBMZXhlci8vbW9kZX0gd2l0aFxuLy8gdGhlIGFzc2lnbmVkIG1vZGUuXG5mdW5jdGlvbiBMZXhlck1vZGVBY3Rpb24obW9kZSkge1xuXHRMZXhlckFjdGlvbi5jYWxsKHRoaXMsIExleGVyQWN0aW9uVHlwZS5NT0RFKTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5MZXhlck1vZGVBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMZXhlckFjdGlvbi5wcm90b3R5cGUpO1xuTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyTW9kZUFjdGlvbjtcblxuLy8gPHA+VGhpcyBhY3Rpb24gaXMgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL21vZGV9IHdpdGggdGhlXG4vLyB2YWx1ZSBwcm92aWRlZCBieSB7QGxpbmsgLy9nZXRNb2RlfS48L3A+XG5MZXhlck1vZGVBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihsZXhlcikge1xuICAgIGxleGVyLm1vZGUodGhpcy5tb2RlKTtcbn07XG5cbkxleGVyTW9kZUFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLm1vZGUpO1xufTtcblxuTGV4ZXJNb2RlQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJNb2RlQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gb3RoZXIubW9kZTtcbiAgICB9XG59O1xuXG5MZXhlck1vZGVBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwibW9kZShcIiArIHRoaXMubW9kZSArIFwiKVwiO1xufTtcblxuLy8gRXhlY3V0ZXMgYSBjdXN0b20gbGV4ZXIgYWN0aW9uIGJ5IGNhbGxpbmcge0BsaW5rIFJlY29nbml6ZXIvL2FjdGlvbn0gd2l0aCB0aGVcbi8vIHJ1bGUgYW5kIGFjdGlvbiBpbmRleGVzIGFzc2lnbmVkIHRvIHRoZSBjdXN0b20gYWN0aW9uLiBUaGUgaW1wbGVtZW50YXRpb24gb2Zcbi8vIGEgY3VzdG9tIGFjdGlvbiBpcyBhZGRlZCB0byB0aGUgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBsZXhlciBpbiBhbiBvdmVycmlkZVxuLy8gb2Yge0BsaW5rIFJlY29nbml6ZXIvL2FjdGlvbn0gd2hlbiB0aGUgZ3JhbW1hciBpcyBjb21waWxlZC5cbi8vXG4vLyA8cD5UaGlzIGNsYXNzIG1heSByZXByZXNlbnQgZW1iZWRkZWQgYWN0aW9ucyBjcmVhdGVkIHdpdGggdGhlIDxjb2RlPnsuLi59PC9jb2RlPlxuLy8gc3ludGF4IGluIEFOVExSIDQsIGFzIHdlbGwgYXMgYWN0aW9ucyBjcmVhdGVkIGZvciBsZXhlciBjb21tYW5kcyB3aGVyZSB0aGVcbi8vIGNvbW1hbmQgYXJndW1lbnQgY291bGQgbm90IGJlIGV2YWx1YXRlZCB3aGVuIHRoZSBncmFtbWFyIHdhcyBjb21waWxlZC48L3A+XG5cblxuICAgIC8vIENvbnN0cnVjdHMgYSBjdXN0b20gbGV4ZXIgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBydWxlIGFuZCBhY3Rpb25cbiAgICAvLyBpbmRleGVzLlxuICAgIC8vXG4gICAgLy8gQHBhcmFtIHJ1bGVJbmRleCBUaGUgcnVsZSBpbmRleCB0byB1c2UgZm9yIGNhbGxzIHRvXG4gICAgLy8ge0BsaW5rIFJlY29nbml6ZXIvL2FjdGlvbn0uXG4gICAgLy8gQHBhcmFtIGFjdGlvbkluZGV4IFRoZSBhY3Rpb24gaW5kZXggdG8gdXNlIGZvciBjYWxscyB0b1xuICAgIC8vIHtAbGluayBSZWNvZ25pemVyLy9hY3Rpb259LlxuXG5mdW5jdGlvbiBMZXhlckN1c3RvbUFjdGlvbihydWxlSW5kZXgsIGFjdGlvbkluZGV4KSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgTGV4ZXJBY3Rpb25UeXBlLkNVU1RPTSk7XG4gICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgdGhpcy5hY3Rpb25JbmRleCA9IGFjdGlvbkluZGV4O1xuICAgIHRoaXMuaXNQb3NpdGlvbkRlcGVuZGVudCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExleGVyQ3VzdG9tQWN0aW9uO1xuXG4vLyA8cD5DdXN0b20gYWN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgYnkgY2FsbGluZyB7QGxpbmsgTGV4ZXIvL2FjdGlvbn0gd2l0aCB0aGVcbi8vIGFwcHJvcHJpYXRlIHJ1bGUgYW5kIGFjdGlvbiBpbmRleGVzLjwvcD5cbkxleGVyQ3VzdG9tQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICBsZXhlci5hY3Rpb24obnVsbCwgdGhpcy5ydWxlSW5kZXgsIHRoaXMuYWN0aW9uSW5kZXgpO1xufTtcblxuTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy5ydWxlSW5kZXgsIHRoaXMuYWN0aW9uSW5kZXgpO1xufTtcblxuTGV4ZXJDdXN0b21BY3Rpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoISAob3RoZXIgaW5zdGFuY2VvZiBMZXhlckN1c3RvbUFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVJbmRleCA9PT0gb3RoZXIucnVsZUluZGV4ICYmIHRoaXMuYWN0aW9uSW5kZXggPT09IG90aGVyLmFjdGlvbkluZGV4O1xuICAgIH1cbn07XG5cbi8vIEltcGxlbWVudHMgdGhlIHtAY29kZSBjaGFubmVsfSBsZXhlciBhY3Rpb24gYnkgY2FsbGluZ1xuLy8ge0BsaW5rIExleGVyLy9zZXRDaGFubmVsfSB3aXRoIHRoZSBhc3NpZ25lZCBjaGFubmVsLlxuLy8gQ29uc3RydWN0cyBhIG5ldyB7QGNvZGUgY2hhbm5lbH0gYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBjaGFubmVsIHZhbHVlLlxuLy8gQHBhcmFtIGNoYW5uZWwgVGhlIGNoYW5uZWwgdmFsdWUgdG8gcGFzcyB0byB7QGxpbmsgTGV4ZXIvL3NldENoYW5uZWx9LlxuZnVuY3Rpb24gTGV4ZXJDaGFubmVsQWN0aW9uKGNoYW5uZWwpIHtcblx0TGV4ZXJBY3Rpb24uY2FsbCh0aGlzLCBMZXhlckFjdGlvblR5cGUuQ0hBTk5FTCk7XG4gICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGV4ZXJBY3Rpb24ucHJvdG90eXBlKTtcbkxleGVyQ2hhbm5lbEFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZXhlckNoYW5uZWxBY3Rpb247XG5cbi8vIDxwPlRoaXMgYWN0aW9uIGlzIGltcGxlbWVudGVkIGJ5IGNhbGxpbmcge0BsaW5rIExleGVyLy9zZXRDaGFubmVsfSB3aXRoIHRoZVxuLy8gdmFsdWUgcHJvdmlkZWQgYnkge0BsaW5rIC8vZ2V0Q2hhbm5lbH0uPC9wPlxuTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24obGV4ZXIpIHtcbiAgICBsZXhlci5fY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbn07XG5cbkxleGVyQ2hhbm5lbEFjdGlvbi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5hY3Rpb25UeXBlLCB0aGlzLmNoYW5uZWwpO1xufTtcblxuTGV4ZXJDaGFubmVsQWN0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCEgKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJDaGFubmVsQWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbCA9PT0gb3RoZXIuY2hhbm5lbDtcbiAgICB9XG59O1xuXG5MZXhlckNoYW5uZWxBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiY2hhbm5lbChcIiArIHRoaXMuY2hhbm5lbCArIFwiKVwiO1xufTtcblxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTGV4ZXJBY3Rpb259IGlzIHVzZWQgZm9yIHRyYWNraW5nIGlucHV0IG9mZnNldHNcbi8vIGZvciBwb3NpdGlvbi1kZXBlbmRlbnQgYWN0aW9ucyB3aXRoaW4gYSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvcn0uXG4vL1xuLy8gPHA+VGhpcyBhY3Rpb24gaXMgbm90IHNlcmlhbGl6ZWQgYXMgcGFydCBvZiB0aGUgQVROLCBhbmQgaXMgb25seSByZXF1aXJlZCBmb3Jcbi8vIHBvc2l0aW9uLWRlcGVuZGVudCBsZXhlciBhY3Rpb25zIHdoaWNoIGFwcGVhciBhdCBhIGxvY2F0aW9uIG90aGVyIHRoYW4gdGhlXG4vLyBlbmQgb2YgYSBydWxlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBERkEgb3B0aW1pemF0aW9ucyBlbXBsb3llZCBmb3Jcbi8vIGxleGVyIGFjdGlvbnMsIHNlZSB7QGxpbmsgTGV4ZXJBY3Rpb25FeGVjdXRvci8vYXBwZW5kfSBhbmRcbi8vIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yLy9maXhPZmZzZXRCZWZvcmVNYXRjaH0uPC9wPlxuXG4vLyBDb25zdHJ1Y3RzIGEgbmV3IGluZGV4ZWQgY3VzdG9tIGFjdGlvbiBieSBhc3NvY2lhdGluZyBhIGNoYXJhY3RlciBvZmZzZXRcbi8vIHdpdGggYSB7QGxpbmsgTGV4ZXJBY3Rpb259LlxuLy9cbi8vIDxwPk5vdGU6IFRoaXMgY2xhc3MgaXMgb25seSByZXF1aXJlZCBmb3IgbGV4ZXIgYWN0aW9ucyBmb3Igd2hpY2hcbi8vIHtAbGluayBMZXhlckFjdGlvbi8vaXNQb3NpdGlvbkRlcGVuZGVudH0gcmV0dXJucyB7QGNvZGUgdHJ1ZX0uPC9wPlxuLy9cbi8vIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0sIHJlbGF0aXZlIHRvXG4vLyB0aGUgdG9rZW4gc3RhcnQgaW5kZXgsIGF0IHdoaWNoIHRoZSBzcGVjaWZpZWQgbGV4ZXIgYWN0aW9uIHNob3VsZCBiZVxuLy8gZXhlY3V0ZWQuXG4vLyBAcGFyYW0gYWN0aW9uIFRoZSBsZXhlciBhY3Rpb24gdG8gZXhlY3V0ZSBhdCBhIHBhcnRpY3VsYXIgb2Zmc2V0IGluIHRoZVxuLy8gaW5wdXQge0BsaW5rIENoYXJTdHJlYW19LlxuZnVuY3Rpb24gTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKG9mZnNldCwgYWN0aW9uKSB7XG5cdExleGVyQWN0aW9uLmNhbGwodGhpcywgYWN0aW9uLmFjdGlvblR5cGUpO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuaXNQb3NpdGlvbkRlcGVuZGVudCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExleGVyQWN0aW9uLnByb3RvdHlwZSk7XG5MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uO1xuXG4vLyA8cD5UaGlzIG1ldGhvZCBjYWxscyB7QGxpbmsgLy9leGVjdXRlfSBvbiB0aGUgcmVzdWx0IG9mIHtAbGluayAvL2dldEFjdGlvbn1cbi8vIHVzaW5nIHRoZSBwcm92aWRlZCB7QGNvZGUgbGV4ZXJ9LjwvcD5cbkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyKSB7XG4gICAgLy8gYXNzdW1lIHRoZSBpbnB1dCBzdHJlYW0gcG9zaXRpb24gd2FzIHByb3Blcmx5IHNldCBieSB0aGUgY2FsbGluZyBjb2RlXG4gICAgdGhpcy5hY3Rpb24uZXhlY3V0ZShsZXhlcik7XG59O1xuXG5MZXhlckluZGV4ZWRDdXN0b21BY3Rpb24ucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuYWN0aW9uVHlwZSwgdGhpcy5vZmZzZXQsIHRoaXMuYWN0aW9uKTtcbn07XG5cbkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghIChvdGhlciBpbnN0YW5jZW9mIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldCA9PT0gb3RoZXIub2Zmc2V0ICYmIHRoaXMuYWN0aW9uID09PSBvdGhlci5hY3Rpb247XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkxleGVyQWN0aW9uVHlwZSA9IExleGVyQWN0aW9uVHlwZTtcbmV4cG9ydHMuTGV4ZXJTa2lwQWN0aW9uID0gTGV4ZXJTa2lwQWN0aW9uO1xuZXhwb3J0cy5MZXhlckNoYW5uZWxBY3Rpb24gPSBMZXhlckNoYW5uZWxBY3Rpb247XG5leHBvcnRzLkxleGVyQ3VzdG9tQWN0aW9uID0gTGV4ZXJDdXN0b21BY3Rpb247XG5leHBvcnRzLkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbiA9IExleGVySW5kZXhlZEN1c3RvbUFjdGlvbjtcbmV4cG9ydHMuTGV4ZXJNb3JlQWN0aW9uID0gTGV4ZXJNb3JlQWN0aW9uO1xuZXhwb3J0cy5MZXhlclR5cGVBY3Rpb24gPSBMZXhlclR5cGVBY3Rpb247XG5leHBvcnRzLkxleGVyUHVzaE1vZGVBY3Rpb24gPSBMZXhlclB1c2hNb2RlQWN0aW9uO1xuZXhwb3J0cy5MZXhlclBvcE1vZGVBY3Rpb24gPSBMZXhlclBvcE1vZGVBY3Rpb247XG5leHBvcnRzLkxleGVyTW9kZUFjdGlvbiA9IExleGVyTW9kZUFjdGlvbjsiLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbi8vIFJlcHJlc2VudHMgYW4gZXhlY3V0b3IgZm9yIGEgc2VxdWVuY2Ugb2YgbGV4ZXIgYWN0aW9ucyB3aGljaCB0cmF2ZXJzZWQgZHVyaW5nXG4vLyB0aGUgbWF0Y2hpbmcgb3BlcmF0aW9uIG9mIGEgbGV4ZXIgcnVsZSAodG9rZW4pLlxuLy9cbi8vIDxwPlRoZSBleGVjdXRvciB0cmFja3MgcG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHBvc2l0aW9uLWRlcGVuZGVudCBsZXhlciBhY3Rpb25zXG4vLyBlZmZpY2llbnRseSwgZW5zdXJpbmcgdGhhdCBhY3Rpb25zIGFwcGVhcmluZyBvbmx5IGF0IHRoZSBlbmQgb2YgdGhlIHJ1bGUgZG9cbi8vIG5vdCBjYXVzZSBibG9hdGluZyBvZiB0aGUge0BsaW5rIERGQX0gY3JlYXRlZCBmb3IgdGhlIGxleGVyLjwvcD5cblxudmFyIGhhc2hTdHVmZiA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKS5oYXNoU3R1ZmY7XG52YXIgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uID0gcmVxdWlyZSgnLi9MZXhlckFjdGlvbicpLkxleGVySW5kZXhlZEN1c3RvbUFjdGlvbjtcblxuZnVuY3Rpb24gTGV4ZXJBY3Rpb25FeGVjdXRvcihsZXhlckFjdGlvbnMpIHtcblx0dGhpcy5sZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbnMgPT09IG51bGwgPyBbXSA6IGxleGVyQWN0aW9ucztcblx0Ly8gQ2FjaGVzIHRoZSByZXN1bHQgb2Yge0BsaW5rIC8vaGFzaENvZGV9IHNpbmNlIHRoZSBoYXNoIGNvZGUgaXMgYW4gZWxlbWVudFxuXHQvLyBvZiB0aGUgcGVyZm9ybWFuY2UtY3JpdGljYWwge0BsaW5rIExleGVyQVROQ29uZmlnLy9oYXNoQ29kZX0gb3BlcmF0aW9uLlxuXHR0aGlzLmNhY2hlZEhhc2hDb2RlID0gaGFzaFN0dWZmKGxleGVyQWN0aW9ucyk7IC8vIFwiXCIuam9pbihbc3RyKGxhKSBmb3IgbGEgaW5cblx0Ly8gbGV4ZXJBY3Rpb25zXSkpXG5cdHJldHVybiB0aGlzO1xufVxuXG4vLyBDcmVhdGVzIGEge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9IHdoaWNoIGV4ZWN1dGVzIHRoZSBhY3Rpb25zIGZvclxuLy8gdGhlIGlucHV0IHtAY29kZSBsZXhlckFjdGlvbkV4ZWN1dG9yfSBmb2xsb3dlZCBieSBhIHNwZWNpZmllZFxuLy8ge0Bjb2RlIGxleGVyQWN0aW9ufS5cbi8vXG4vLyBAcGFyYW0gbGV4ZXJBY3Rpb25FeGVjdXRvciBUaGUgZXhlY3V0b3IgZm9yIGFjdGlvbnMgYWxyZWFkeSB0cmF2ZXJzZWQgYnlcbi8vIHRoZSBsZXhlciB3aGlsZSBtYXRjaGluZyBhIHRva2VuIHdpdGhpbiBhIHBhcnRpY3VsYXJcbi8vIHtAbGluayBMZXhlckFUTkNvbmZpZ30uIElmIHRoaXMgaXMge0Bjb2RlIG51bGx9LCB0aGUgbWV0aG9kIGJlaGF2ZXMgYXNcbi8vIHRob3VnaCBpdCB3ZXJlIGFuIGVtcHR5IGV4ZWN1dG9yLlxuLy8gQHBhcmFtIGxleGVyQWN0aW9uIFRoZSBsZXhlciBhY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgYWN0aW9uc1xuLy8gc3BlY2lmaWVkIGluIHtAY29kZSBsZXhlckFjdGlvbkV4ZWN1dG9yfS5cbi8vXG4vLyBAcmV0dXJuIEEge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9IGZvciBleGVjdXRpbmcgdGhlIGNvbWJpbmUgYWN0aW9uc1xuLy8gb2Yge0Bjb2RlIGxleGVyQWN0aW9uRXhlY3V0b3J9IGFuZCB7QGNvZGUgbGV4ZXJBY3Rpb259LlxuTGV4ZXJBY3Rpb25FeGVjdXRvci5hcHBlbmQgPSBmdW5jdGlvbihsZXhlckFjdGlvbkV4ZWN1dG9yLCBsZXhlckFjdGlvbikge1xuXHRpZiAobGV4ZXJBY3Rpb25FeGVjdXRvciA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBuZXcgTGV4ZXJBY3Rpb25FeGVjdXRvcihbIGxleGVyQWN0aW9uIF0pO1xuXHR9XG5cdHZhciBsZXhlckFjdGlvbnMgPSBsZXhlckFjdGlvbkV4ZWN1dG9yLmxleGVyQWN0aW9ucy5jb25jYXQoWyBsZXhlckFjdGlvbiBdKTtcblx0cmV0dXJuIG5ldyBMZXhlckFjdGlvbkV4ZWN1dG9yKGxleGVyQWN0aW9ucyk7XG59O1xuXG4vLyBDcmVhdGVzIGEge0BsaW5rIExleGVyQWN0aW9uRXhlY3V0b3J9IHdoaWNoIGVuY29kZXMgdGhlIGN1cnJlbnQgb2Zmc2V0XG4vLyBmb3IgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMuXG4vL1xuLy8gPHA+Tm9ybWFsbHksIHdoZW4gdGhlIGV4ZWN1dG9yIGVuY291bnRlcnMgbGV4ZXIgYWN0aW9ucyB3aGVyZVxuLy8ge0BsaW5rIExleGVyQWN0aW9uLy9pc1Bvc2l0aW9uRGVwZW5kZW50fSByZXR1cm5zIHtAY29kZSB0cnVlfSwgaXQgY2FsbHNcbi8vIHtAbGluayBJbnRTdHJlYW0vL3NlZWt9IG9uIHRoZSBpbnB1dCB7QGxpbmsgQ2hhclN0cmVhbX0gdG8gc2V0IHRoZSBpbnB1dFxuLy8gcG9zaXRpb24gdG8gdGhlIDxlbT5lbmQ8L2VtPiBvZiB0aGUgY3VycmVudCB0b2tlbi4gVGhpcyBiZWhhdmlvciBwcm92aWRlc1xuLy8gZm9yIGVmZmljaWVudCBERkEgcmVwcmVzZW50YXRpb24gb2YgbGV4ZXIgYWN0aW9ucyB3aGljaCBhcHBlYXIgYXQgdGhlIGVuZFxuLy8gb2YgYSBsZXhlciBydWxlLCBldmVuIHdoZW4gdGhlIGxleGVyIHJ1bGUgbWF0Y2hlcyBhIHZhcmlhYmxlIG51bWJlciBvZlxuLy8gY2hhcmFjdGVycy48L3A+XG4vL1xuLy8gPHA+UHJpb3IgdG8gdHJhdmVyc2luZyBhIG1hdGNoIHRyYW5zaXRpb24gaW4gdGhlIEFUTiwgdGhlIGN1cnJlbnQgb2Zmc2V0XG4vLyBmcm9tIHRoZSB0b2tlbiBzdGFydCBpbmRleCBpcyBhc3NpZ25lZCB0byBhbGwgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyXG4vLyBhY3Rpb25zIHdoaWNoIGhhdmUgbm90IGFscmVhZHkgYmVlbiBhc3NpZ25lZCBhIGZpeGVkIG9mZnNldC4gQnkgc3RvcmluZ1xuLy8gdGhlIG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHRva2VuIHN0YXJ0IGluZGV4LCB0aGUgREZBIHJlcHJlc2VudGF0aW9uIG9mXG4vLyBsZXhlciBhY3Rpb25zIHdoaWNoIGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIHRva2VucyByZW1haW5zIGVmZmljaWVudCBkdWVcbi8vIHRvIHNoYXJpbmcgYW1vbmcgdG9rZW5zIG9mIHRoZSBzYW1lIGxlbmd0aCwgcmVnYXJkbGVzcyBvZiB0aGVpciBhYnNvbHV0ZVxuLy8gcG9zaXRpb24gaW4gdGhlIGlucHV0IHN0cmVhbS48L3A+XG4vL1xuLy8gPHA+SWYgdGhlIGN1cnJlbnQgZXhlY3V0b3IgYWxyZWFkeSBoYXMgb2Zmc2V0cyBhc3NpZ25lZCB0byBhbGxcbi8vIHBvc2l0aW9uLWRlcGVuZGVudCBsZXhlciBhY3Rpb25zLCB0aGUgbWV0aG9kIHJldHVybnMge0Bjb2RlIHRoaXN9LjwvcD5cbi8vXG4vLyBAcGFyYW0gb2Zmc2V0IFRoZSBjdXJyZW50IG9mZnNldCB0byBhc3NpZ24gdG8gYWxsIHBvc2l0aW9uLWRlcGVuZGVudFxuLy8gbGV4ZXIgYWN0aW9ucyB3aGljaCBkbyBub3QgYWxyZWFkeSBoYXZlIG9mZnNldHMgYXNzaWduZWQuXG4vL1xuLy8gQHJldHVybiBBIHtAbGluayBMZXhlckFjdGlvbkV4ZWN1dG9yfSB3aGljaCBzdG9yZXMgaW5wdXQgc3RyZWFtIG9mZnNldHNcbi8vIGZvciBhbGwgcG9zaXRpb24tZGVwZW5kZW50IGxleGVyIGFjdGlvbnMuXG4vLyAvXG5MZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZS5maXhPZmZzZXRCZWZvcmVNYXRjaCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuXHR2YXIgdXBkYXRlZExleGVyQWN0aW9ucyA9IG51bGw7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXhlckFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAodGhpcy5sZXhlckFjdGlvbnNbaV0uaXNQb3NpdGlvbkRlcGVuZGVudCAmJlxuXHRcdFx0XHQhKHRoaXMubGV4ZXJBY3Rpb25zW2ldIGluc3RhbmNlb2YgTGV4ZXJJbmRleGVkQ3VzdG9tQWN0aW9uKSkge1xuXHRcdFx0aWYgKHVwZGF0ZWRMZXhlckFjdGlvbnMgPT09IG51bGwpIHtcblx0XHRcdFx0dXBkYXRlZExleGVyQWN0aW9ucyA9IHRoaXMubGV4ZXJBY3Rpb25zLmNvbmNhdChbXSk7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVkTGV4ZXJBY3Rpb25zW2ldID0gbmV3IExleGVySW5kZXhlZEN1c3RvbUFjdGlvbihvZmZzZXQsXG5cdFx0XHRcdFx0dGhpcy5sZXhlckFjdGlvbnNbaV0pO1xuXHRcdH1cblx0fVxuXHRpZiAodXBkYXRlZExleGVyQWN0aW9ucyA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuZXcgTGV4ZXJBY3Rpb25FeGVjdXRvcih1cGRhdGVkTGV4ZXJBY3Rpb25zKTtcblx0fVxufTtcblxuLy8gRXhlY3V0ZSB0aGUgYWN0aW9ucyBlbmNhcHN1bGF0ZWQgYnkgdGhpcyBleGVjdXRvciB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYVxuLy8gcGFydGljdWxhciB7QGxpbmsgTGV4ZXJ9LlxuLy9cbi8vIDxwPlRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayBJbnRTdHJlYW0vL3NlZWt9IHRvIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlXG4vLyB7QGNvZGUgaW5wdXR9IHtAbGluayBDaGFyU3RyZWFtfSBwcmlvciB0byBjYWxsaW5nXG4vLyB7QGxpbmsgTGV4ZXJBY3Rpb24vL2V4ZWN1dGV9IG9uIGEgcG9zaXRpb24tZGVwZW5kZW50IGFjdGlvbi4gQmVmb3JlIHRoZVxuLy8gbWV0aG9kIHJldHVybnMsIHRoZSBpbnB1dCBwb3NpdGlvbiB3aWxsIGJlIHJlc3RvcmVkIHRvIHRoZSBzYW1lIHBvc2l0aW9uXG4vLyBpdCB3YXMgaW4gd2hlbiB0aGUgbWV0aG9kIHdhcyBpbnZva2VkLjwvcD5cbi8vXG4vLyBAcGFyYW0gbGV4ZXIgVGhlIGxleGVyIGluc3RhbmNlLlxuLy8gQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJlYW0gd2hpY2ggaXMgdGhlIHNvdXJjZSBmb3IgdGhlIGN1cnJlbnQgdG9rZW4uXG4vLyBXaGVuIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGN1cnJlbnQge0BsaW5rIEludFN0cmVhbS8vaW5kZXh9IGZvclxuLy8ge0Bjb2RlIGlucHV0fSBzaG91bGQgYmUgdGhlIHN0YXJ0IG9mIHRoZSBmb2xsb3dpbmcgdG9rZW4sIGkuZS4gMVxuLy8gY2hhcmFjdGVyIHBhc3QgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0b2tlbi5cbi8vIEBwYXJhbSBzdGFydEluZGV4IFRoZSB0b2tlbiBzdGFydCBpbmRleC4gVGhpcyB2YWx1ZSBtYXkgYmUgcGFzc2VkIHRvXG4vLyB7QGxpbmsgSW50U3RyZWFtLy9zZWVrfSB0byBzZXQgdGhlIHtAY29kZSBpbnB1dH0gcG9zaXRpb24gdG8gdGhlIGJlZ2lubmluZ1xuLy8gb2YgdGhlIHRva2VuLlxuLy8gL1xuTGV4ZXJBY3Rpb25FeGVjdXRvci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGxleGVyLCBpbnB1dCwgc3RhcnRJbmRleCkge1xuXHR2YXIgcmVxdWlyZXNTZWVrID0gZmFsc2U7XG5cdHZhciBzdG9wSW5kZXggPSBpbnB1dC5pbmRleDtcblx0dHJ5IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGV4ZXJBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbGV4ZXJBY3Rpb24gPSB0aGlzLmxleGVyQWN0aW9uc1tpXTtcblx0XHRcdGlmIChsZXhlckFjdGlvbiBpbnN0YW5jZW9mIExleGVySW5kZXhlZEN1c3RvbUFjdGlvbikge1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gbGV4ZXJBY3Rpb24ub2Zmc2V0O1xuXHRcdFx0XHRpbnB1dC5zZWVrKHN0YXJ0SW5kZXggKyBvZmZzZXQpO1xuXHRcdFx0XHRsZXhlckFjdGlvbiA9IGxleGVyQWN0aW9uLmFjdGlvbjtcblx0XHRcdFx0cmVxdWlyZXNTZWVrID0gKHN0YXJ0SW5kZXggKyBvZmZzZXQpICE9PSBzdG9wSW5kZXg7XG5cdFx0XHR9IGVsc2UgaWYgKGxleGVyQWN0aW9uLmlzUG9zaXRpb25EZXBlbmRlbnQpIHtcblx0XHRcdFx0aW5wdXQuc2VlayhzdG9wSW5kZXgpO1xuXHRcdFx0XHRyZXF1aXJlc1NlZWsgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGxleGVyQWN0aW9uLmV4ZWN1dGUobGV4ZXIpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpZiAocmVxdWlyZXNTZWVrKSB7XG5cdFx0XHRpbnB1dC5zZWVrKHN0b3BJbmRleCk7XG5cdFx0fVxuXHR9XG59O1xuXG5MZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5jYWNoZWRIYXNoQ29kZTtcbn07XG5cbkxleGVyQWN0aW9uRXhlY3V0b3IucHJvdG90eXBlLnVwZGF0ZUhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGhhc2gudXBkYXRlKHRoaXMuY2FjaGVkSGFzaENvZGUpO1xufTtcblxuXG5MZXhlckFjdGlvbkV4ZWN1dG9yLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHRpZiAodGhpcyA9PT0gb3RoZXIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgTGV4ZXJBY3Rpb25FeGVjdXRvcikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSBpZiAodGhpcy5jYWNoZWRIYXNoQ29kZSAhPSBvdGhlci5jYWNoZWRIYXNoQ29kZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIGlmICh0aGlzLmxleGVyQWN0aW9ucy5sZW5ndGggIT0gb3RoZXIubGV4ZXJBY3Rpb25zLmxlbmd0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBlbHNlIHtcblx0XHR2YXIgbnVtQWN0aW9ucyA9IHRoaXMubGV4ZXJBY3Rpb25zLmxlbmd0aFxuXHRcdGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IG51bUFjdGlvbnM7ICsraWR4KSB7XG5cdFx0XHRpZiAoIXRoaXMubGV4ZXJBY3Rpb25zW2lkeF0uZXF1YWxzKG90aGVyLmxleGVyQWN0aW9uc1tpZHhdKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG5leHBvcnRzLkxleGVyQWN0aW9uRXhlY3V0b3IgPSBMZXhlckFjdGlvbkV4ZWN1dG9yO1xuIiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG5cbi8vXG4vLyBUaGUgZW1ib2RpbWVudCBvZiB0aGUgYWRhcHRpdmUgTEwoKiksIEFMTCgqKSwgcGFyc2luZyBzdHJhdGVneS5cbi8vXG4vLyA8cD5cbi8vIFRoZSBiYXNpYyBjb21wbGV4aXR5IG9mIHRoZSBhZGFwdGl2ZSBzdHJhdGVneSBtYWtlcyBpdCBoYXJkZXIgdG8gdW5kZXJzdGFuZC5cbi8vIFdlIGJlZ2luIHdpdGggQVROIHNpbXVsYXRpb24gdG8gYnVpbGQgcGF0aHMgaW4gYSBERkEuIFN1YnNlcXVlbnQgcHJlZGljdGlvblxuLy8gcmVxdWVzdHMgZ28gdGhyb3VnaCB0aGUgREZBIGZpcnN0LiBJZiB0aGV5IHJlYWNoIGEgc3RhdGUgd2l0aG91dCBhbiBlZGdlIGZvclxuLy8gdGhlIGN1cnJlbnQgc3ltYm9sLCB0aGUgYWxnb3JpdGhtIGZhaWxzIG92ZXIgdG8gdGhlIEFUTiBzaW11bGF0aW9uIHRvXG4vLyBjb21wbGV0ZSB0aGUgREZBIHBhdGggZm9yIHRoZSBjdXJyZW50IGlucHV0ICh1bnRpbCBpdCBmaW5kcyBhIGNvbmZsaWN0IHN0YXRlXG4vLyBvciB1bmlxdWVseSBwcmVkaWN0aW5nIHN0YXRlKS48L3A+XG4vL1xuLy8gPHA+XG4vLyBBbGwgb2YgdGhhdCBpcyBkb25lIHdpdGhvdXQgdXNpbmcgdGhlIG91dGVyIGNvbnRleHQgYmVjYXVzZSB3ZSB3YW50IHRvIGNyZWF0ZVxuLy8gYSBERkEgdGhhdCBpcyBub3QgZGVwZW5kZW50IHVwb24gdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFjayB3aGVuIHdlIGRvIGFcbi8vIHByZWRpY3Rpb24uIE9uZSBERkEgd29ya3MgaW4gYWxsIGNvbnRleHRzLiBXZSBhdm9pZCB1c2luZyBjb250ZXh0IG5vdFxuLy8gbmVjZXNzYXJpbHkgYmVjYXVzZSBpdCdzIHNsb3dlciwgYWx0aG91Z2ggaXQgY2FuIGJlLCBidXQgYmVjYXVzZSBvZiB0aGUgREZBXG4vLyBjYWNoaW5nIHByb2JsZW0uIFRoZSBjbG9zdXJlIHJvdXRpbmUgb25seSBjb25zaWRlcnMgdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFja1xuLy8gY3JlYXRlZCBkdXJpbmcgcHJlZGljdGlvbiBiZWdpbm5pbmcgaW4gdGhlIGRlY2lzaW9uIHJ1bGUuIEZvciBleGFtcGxlLCBpZlxuLy8gcHJlZGljdGlvbiBvY2N1cnMgd2l0aG91dCBpbnZva2luZyBhbm90aGVyIHJ1bGUncyBBVE4sIHRoZXJlIGFyZSBubyBjb250ZXh0XG4vLyBzdGFja3MgaW4gdGhlIGNvbmZpZ3VyYXRpb25zLiBXaGVuIGxhY2sgb2YgY29udGV4dCBsZWFkcyB0byBhIGNvbmZsaWN0LCB3ZVxuLy8gZG9uJ3Qga25vdyBpZiBpdCdzIGFuIGFtYmlndWl0eSBvciBhIHdlYWtuZXNzIGluIHRoZSBzdHJvbmcgTEwoKikgcGFyc2luZ1xuLy8gc3RyYXRlZ3kgKHZlcnN1cyBmdWxsIExMKCopKS48L3A+XG4vL1xuLy8gPHA+XG4vLyBXaGVuIFNMTCB5aWVsZHMgYSBjb25maWd1cmF0aW9uIHNldCB3aXRoIGNvbmZsaWN0LCB3ZSByZXdpbmQgdGhlIGlucHV0IGFuZFxuLy8gcmV0cnkgdGhlIEFUTiBzaW11bGF0aW9uLCB0aGlzIHRpbWUgdXNpbmcgZnVsbCBvdXRlciBjb250ZXh0IHdpdGhvdXQgYWRkaW5nXG4vLyB0byB0aGUgREZBLiBDb25maWd1cmF0aW9uIGNvbnRleHQgc3RhY2tzIHdpbGwgYmUgdGhlIGZ1bGwgaW52b2NhdGlvbiBzdGFja3Ncbi8vIGZyb20gdGhlIHN0YXJ0IHJ1bGUuIElmIHdlIGdldCBhIGNvbmZsaWN0IHVzaW5nIGZ1bGwgY29udGV4dCwgdGhlbiB3ZSBjYW5cbi8vIGRlZmluaXRpdmVseSBzYXkgd2UgaGF2ZSBhIHRydWUgYW1iaWd1aXR5IGZvciB0aGF0IGlucHV0IHNlcXVlbmNlLiBJZiB3ZVxuLy8gZG9uJ3QgZ2V0IGEgY29uZmxpY3QsIGl0IGltcGxpZXMgdGhhdCB0aGUgZGVjaXNpb24gaXMgc2Vuc2l0aXZlIHRvIHRoZSBvdXRlclxuLy8gY29udGV4dC4gKEl0IGlzIG5vdCBjb250ZXh0LXNlbnNpdGl2ZSBpbiB0aGUgc2Vuc2Ugb2YgY29udGV4dC1zZW5zaXRpdmVcbi8vIGdyYW1tYXJzLik8L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGUgbmV4dCB0aW1lIHdlIHJlYWNoIHRoaXMgREZBIHN0YXRlIHdpdGggYW4gU0xMIGNvbmZsaWN0LCB0aHJvdWdoIERGQVxuLy8gc2ltdWxhdGlvbiwgd2Ugd2lsbCBhZ2FpbiByZXRyeSB0aGUgQVROIHNpbXVsYXRpb24gdXNpbmcgZnVsbCBjb250ZXh0IG1vZGUuXG4vLyBUaGlzIGlzIHNsb3cgYmVjYXVzZSB3ZSBjYW4ndCBzYXZlIHRoZSByZXN1bHRzIGFuZCBoYXZlIHRvIFwiaW50ZXJwcmV0XCIgdGhlXG4vLyBBVE4gZWFjaCB0aW1lIHdlIGdldCB0aGF0IGlucHV0LjwvcD5cbi8vXG4vLyA8cD5cbi8vIDxzdHJvbmc+Q0FDSElORyBGVUxMIENPTlRFWFQgUFJFRElDVElPTlM8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+XG4vLyBXZSBjb3VsZCBjYWNoZSByZXN1bHRzIGZyb20gZnVsbCBjb250ZXh0IHRvIHByZWRpY3RlZCBhbHRlcm5hdGl2ZSBlYXNpbHkgYW5kXG4vLyB0aGF0IHNhdmVzIGEgbG90IG9mIHRpbWUgYnV0IGRvZXNuJ3Qgd29yayBpbiBwcmVzZW5jZSBvZiBwcmVkaWNhdGVzLiBUaGUgc2V0XG4vLyBvZiB2aXNpYmxlIHByZWRpY2F0ZXMgZnJvbSB0aGUgQVROIHN0YXJ0IHN0YXRlIGNoYW5nZXMgZGVwZW5kaW5nIG9uIHRoZVxuLy8gY29udGV4dCwgYmVjYXVzZSBjbG9zdXJlIGNhbiBmYWxsIG9mZiB0aGUgZW5kIG9mIGEgcnVsZS4gSSB0cmllZCB0byBjYWNoZVxuLy8gdHVwbGVzIChzdGFjayBjb250ZXh0LCBzZW1hbnRpYyBjb250ZXh0LCBwcmVkaWN0ZWQgYWx0KSBidXQgaXQgd2FzIHNsb3dlclxuLy8gdGhhbiBpbnRlcnByZXRpbmcgYW5kIG11Y2ggbW9yZSBjb21wbGljYXRlZC4gQWxzbyByZXF1aXJlZCBhIGh1Z2UgYW1vdW50IG9mXG4vLyBtZW1vcnkuIFRoZSBnb2FsIGlzIG5vdCB0byBjcmVhdGUgdGhlIHdvcmxkJ3MgZmFzdGVzdCBwYXJzZXIgYW55d2F5LiBJJ2QgbGlrZVxuLy8gdG8ga2VlcCB0aGlzIGFsZ29yaXRobSBzaW1wbGUuIEJ5IGxhdW5jaGluZyBtdWx0aXBsZSB0aHJlYWRzLCB3ZSBjYW4gaW1wcm92ZVxuLy8gdGhlIHNwZWVkIG9mIHBhcnNpbmcgYWNyb3NzIGEgbGFyZ2UgbnVtYmVyIG9mIGZpbGVzLjwvcD5cbi8vXG4vLyA8cD5cbi8vIFRoZXJlIGlzIG5vIHN0cmljdCBvcmRlcmluZyBiZXR3ZWVuIHRoZSBhbW91bnQgb2YgaW5wdXQgdXNlZCBieSBTTEwgdnMgTEwsXG4vLyB3aGljaCBtYWtlcyBpdCByZWFsbHkgaGFyZCB0byBidWlsZCBhIGNhY2hlIGZvciBmdWxsIGNvbnRleHQuIExldCdzIHNheSB0aGF0XG4vLyB3ZSBoYXZlIGlucHV0IEEgQiBDIHRoYXQgbGVhZHMgdG8gYW4gU0xMIGNvbmZsaWN0IHdpdGggZnVsbCBjb250ZXh0IFguIFRoYXRcbi8vIGltcGxpZXMgdGhhdCB1c2luZyBYIHdlIG1pZ2h0IG9ubHkgdXNlIEEgQiBidXQgd2UgY291bGQgYWxzbyB1c2UgQSBCIEMgRCB0b1xuLy8gcmVzb2x2ZSBjb25mbGljdC4gSW5wdXQgQSBCIEMgRCBjb3VsZCBwcmVkaWN0IGFsdGVybmF0aXZlIDEgaW4gb25lIHBvc2l0aW9uXG4vLyBpbiB0aGUgaW5wdXQgYW5kIEEgQiBDIEUgY291bGQgcHJlZGljdCBhbHRlcm5hdGl2ZSAyIGluIGFub3RoZXIgcG9zaXRpb24gaW5cbi8vIGlucHV0LiBUaGUgY29uZmxpY3RpbmcgU0xMIGNvbmZpZ3VyYXRpb25zIGNvdWxkIHN0aWxsIGJlIG5vbi11bmlxdWUgaW4gdGhlXG4vLyBmdWxsIGNvbnRleHQgcHJlZGljdGlvbiwgd2hpY2ggd291bGQgbGVhZCB1cyB0byByZXF1aXJpbmcgbW9yZSBpbnB1dCB0aGFuIHRoZVxuLy8gb3JpZ2luYWwgQSBCIEMuXHRUbyBtYWtlIGFcdHByZWRpY3Rpb24gY2FjaGUgd29yaywgd2UgaGF2ZSB0byB0cmFja1x0dGhlIGV4YWN0XG4vLyBpbnB1dFx0dXNlZCBkdXJpbmcgdGhlIHByZXZpb3VzIHByZWRpY3Rpb24uIFRoYXQgYW1vdW50cyB0byBhIGNhY2hlIHRoYXQgbWFwc1xuLy8gWCB0byBhIHNwZWNpZmljIERGQSBmb3IgdGhhdCBjb250ZXh0LjwvcD5cbi8vXG4vLyA8cD5cbi8vIFNvbWV0aGluZyBzaG91bGQgYmUgZG9uZSBmb3IgbGVmdC1yZWN1cnNpdmUgZXhwcmVzc2lvbiBwcmVkaWN0aW9ucy4gVGhleSBhcmVcbi8vIGxpa2VseSBMTCgxKSArIHByZWQgZXZhbC4gRWFzaWVyIHRvIGRvIHRoZSB3aG9sZSBTTEwgdW5sZXNzIGVycm9yIGFuZCByZXRyeVxuLy8gd2l0aCBmdWxsIExMIHRoaW5nIFNhbSBkb2VzLjwvcD5cbi8vXG4vLyA8cD5cbi8vIDxzdHJvbmc+QVZPSURJTkcgRlVMTCBDT05URVhUIFBSRURJQ1RJT048L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+XG4vLyBXZSBhdm9pZCBkb2luZyBmdWxsIGNvbnRleHQgcmV0cnkgd2hlbiB0aGUgb3V0ZXIgY29udGV4dCBpcyBlbXB0eSwgd2UgZGlkIG5vdFxuLy8gZGlwIGludG8gdGhlIG91dGVyIGNvbnRleHQgYnkgZmFsbGluZyBvZmYgdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gc3RhdGUgcnVsZSxcbi8vIG9yIHdoZW4gd2UgZm9yY2UgU0xMIG1vZGUuPC9wPlxuLy9cbi8vIDxwPlxuLy8gQXMgYW4gZXhhbXBsZSBvZiB0aGUgbm90IGRpcCBpbnRvIG91dGVyIGNvbnRleHQgY2FzZSwgY29uc2lkZXIgYXMgc3VwZXJcbi8vIGNvbnN0cnVjdG9yIGNhbGxzIHZlcnN1cyBmdW5jdGlvbiBjYWxscy4gT25lIGdyYW1tYXIgbWlnaHQgbG9vayBsaWtlXG4vLyB0aGlzOjwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gY3RvckJvZHlcbi8vICAgOiAneycgc3VwZXJDYWxsPyBzdGF0KiAnfSdcbi8vICAgO1xuLy8gPC9wcmU+XG4vL1xuLy8gPHA+XG4vLyBPciwgeW91IG1pZ2h0IHNlZSBzb21ldGhpbmcgbGlrZTwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gc3RhdFxuLy8gICA6IHN1cGVyQ2FsbCAnOydcbi8vICAgfCBleHByZXNzaW9uICc7J1xuLy8gICB8IC4uLlxuLy8gICA7XG4vLyA8L3ByZT5cbi8vXG4vLyA8cD5cbi8vIEluIGJvdGggY2FzZXMgSSBiZWxpZXZlIHRoYXQgbm8gY2xvc3VyZSBvcGVyYXRpb25zIHdpbGwgZGlwIGludG8gdGhlIG91dGVyXG4vLyBjb250ZXh0LiBJbiB0aGUgZmlyc3QgY2FzZSBjdG9yQm9keSBpbiB0aGUgd29yc3QgY2FzZSB3aWxsIHN0b3AgYXQgdGhlICd9Jy5cbi8vIEluIHRoZSAybmQgY2FzZSBpdCBzaG91bGQgc3RvcCBhdCB0aGUgJzsnLiBCb3RoIGNhc2VzIHNob3VsZCBzdGF5IHdpdGhpbiB0aGVcbi8vIGVudHJ5IHJ1bGUgYW5kIG5vdCBkaXAgaW50byB0aGUgb3V0ZXIgY29udGV4dC48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPlBSRURJQ0FURVM8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+XG4vLyBQcmVkaWNhdGVzIGFyZSBhbHdheXMgZXZhbHVhdGVkIGlmIHByZXNlbnQgaW4gZWl0aGVyIFNMTCBvciBMTCBib3RoLiBTTEwgYW5kXG4vLyBMTCBzaW11bGF0aW9uIGRlYWxzIHdpdGggcHJlZGljYXRlcyBkaWZmZXJlbnRseS4gU0xMIGNvbGxlY3RzIHByZWRpY2F0ZXMgYXNcbi8vIGl0IHBlcmZvcm1zIGNsb3N1cmUgb3BlcmF0aW9ucyBsaWtlIEFOVExSIHYzIGRpZC4gSXQgZGVsYXlzIHByZWRpY2F0ZVxuLy8gZXZhbHVhdGlvbiB1bnRpbCBpdCByZWFjaGVzIGFuZCBhY2NlcHQgc3RhdGUuIFRoaXMgYWxsb3dzIHVzIHRvIGNhY2hlIHRoZSBTTExcbi8vIEFUTiBzaW11bGF0aW9uIHdoZXJlYXMsIGlmIHdlIGhhZCBldmFsdWF0ZWQgcHJlZGljYXRlcyBvbi10aGUtZmx5IGR1cmluZ1xuLy8gY2xvc3VyZSwgdGhlIERGQSBzdGF0ZSBjb25maWd1cmF0aW9uIHNldHMgd291bGQgYmUgZGlmZmVyZW50IGFuZCB3ZSBjb3VsZG4ndFxuLy8gYnVpbGQgdXAgYSBzdWl0YWJsZSBERkEuPC9wPlxuLy9cbi8vIDxwPlxuLy8gV2hlbiBidWlsZGluZyBhIERGQSBhY2NlcHQgc3RhdGUgZHVyaW5nIEFUTiBzaW11bGF0aW9uLCB3ZSBldmFsdWF0ZSBhbnlcbi8vIHByZWRpY2F0ZXMgYW5kIHJldHVybiB0aGUgc29sZSBzZW1hbnRpY2FsbHkgdmFsaWQgYWx0ZXJuYXRpdmUuIElmIHRoZXJlIGlzXG4vLyBtb3JlIHRoYW4gMSBhbHRlcm5hdGl2ZSwgd2UgcmVwb3J0IGFuIGFtYmlndWl0eS4gSWYgdGhlcmUgYXJlIDAgYWx0ZXJuYXRpdmVzLFxuLy8gd2UgdGhyb3cgYW4gZXhjZXB0aW9uLiBBbHRlcm5hdGl2ZXMgd2l0aG91dCBwcmVkaWNhdGVzIGFjdCBsaWtlIHRoZXkgaGF2ZVxuLy8gdHJ1ZSBwcmVkaWNhdGVzLiBUaGUgc2ltcGxlIHdheSB0byB0aGluayBhYm91dCBpdCBpcyB0byBzdHJpcCBhd2F5IGFsbFxuLy8gYWx0ZXJuYXRpdmVzIHdpdGggZmFsc2UgcHJlZGljYXRlcyBhbmQgY2hvb3NlIHRoZSBtaW5pbXVtIGFsdGVybmF0aXZlIHRoYXRcbi8vIHJlbWFpbnMuPC9wPlxuLy9cbi8vIDxwPlxuLy8gV2hlbiB3ZSBzdGFydCBpbiB0aGUgREZBIGFuZCByZWFjaCBhbiBhY2NlcHQgc3RhdGUgdGhhdCdzIHByZWRpY2F0ZWQsIHdlIHRlc3Rcbi8vIHRob3NlIGFuZCByZXR1cm4gdGhlIG1pbmltdW0gc2VtYW50aWNhbGx5IHZpYWJsZSBhbHRlcm5hdGl2ZS4gSWYgbm9cbi8vIGFsdGVybmF0aXZlcyBhcmUgdmlhYmxlLCB3ZSB0aHJvdyBhbiBleGNlcHRpb24uPC9wPlxuLy9cbi8vIDxwPlxuLy8gRHVyaW5nIGZ1bGwgTEwgQVROIHNpbXVsYXRpb24sIGNsb3N1cmUgYWx3YXlzIGV2YWx1YXRlcyBwcmVkaWNhdGVzIGFuZFxuLy8gb24tdGhlLWZseS4gVGhpcyBpcyBjcnVjaWFsIHRvIHJlZHVjaW5nIHRoZSBjb25maWd1cmF0aW9uIHNldCBzaXplIGR1cmluZ1xuLy8gY2xvc3VyZS4gSXQgaGl0cyBhIGxhbmRtaW5lIHdoZW4gcGFyc2luZyB3aXRoIHRoZSBKYXZhIGdyYW1tYXIsIGZvciBleGFtcGxlLFxuLy8gd2l0aG91dCB0aGlzIG9uLXRoZS1mbHkgZXZhbHVhdGlvbi48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPlNIQVJJTkcgREZBPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPlxuLy8gQWxsIGluc3RhbmNlcyBvZiB0aGUgc2FtZSBwYXJzZXIgc2hhcmUgdGhlIHNhbWUgZGVjaXNpb24gREZBcyB0aHJvdWdoIGFcbi8vIHN0YXRpYyBmaWVsZC4gRWFjaCBpbnN0YW5jZSBnZXRzIGl0cyBvd24gQVROIHNpbXVsYXRvciBidXQgdGhleSBzaGFyZSB0aGVcbi8vIHNhbWUge0BsaW5rIC8vZGVjaXNpb25Ub0RGQX0gZmllbGQuIFRoZXkgYWxzbyBzaGFyZSBhXG4vLyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHRDYWNoZX0gb2JqZWN0IHRoYXQgbWFrZXMgc3VyZSB0aGF0IGFsbFxuLy8ge0BsaW5rIFByZWRpY3Rpb25Db250ZXh0fSBvYmplY3RzIGFyZSBzaGFyZWQgYW1vbmcgdGhlIERGQSBzdGF0ZXMuIFRoaXMgbWFrZXNcbi8vIGEgYmlnIHNpemUgZGlmZmVyZW5jZS48L3A+XG4vL1xuLy8gPHA+XG4vLyA8c3Ryb25nPlRIUkVBRCBTQUZFVFk8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGUge0BsaW5rIFBhcnNlckFUTlNpbXVsYXRvcn0gbG9ja3Mgb24gdGhlIHtAbGluayAvL2RlY2lzaW9uVG9ERkF9IGZpZWxkIHdoZW5cbi8vIGl0IGFkZHMgYSBuZXcgREZBIG9iamVjdCB0byB0aGF0IGFycmF5LiB7QGxpbmsgLy9hZGRERkFFZGdlfVxuLy8gbG9ja3Mgb24gdGhlIERGQSBmb3IgdGhlIGN1cnJlbnQgZGVjaXNpb24gd2hlbiBzZXR0aW5nIHRoZVxuLy8ge0BsaW5rIERGQVN0YXRlLy9lZGdlc30gZmllbGQuIHtAbGluayAvL2FkZERGQVN0YXRlfSBsb2NrcyBvblxuLy8gdGhlIERGQSBmb3IgdGhlIGN1cnJlbnQgZGVjaXNpb24gd2hlbiBsb29raW5nIHVwIGEgREZBIHN0YXRlIHRvIHNlZSBpZiBpdFxuLy8gYWxyZWFkeSBleGlzdHMuIFdlIG11c3QgbWFrZSBzdXJlIHRoYXQgYWxsIHJlcXVlc3RzIHRvIGFkZCBERkEgc3RhdGVzIHRoYXRcbi8vIGFyZSBlcXVpdmFsZW50IHJlc3VsdCBpbiB0aGUgc2FtZSBzaGFyZWQgREZBIG9iamVjdC4gVGhpcyBpcyBiZWNhdXNlIGxvdHMgb2Zcbi8vIHRocmVhZHMgd2lsbCBiZSB0cnlpbmcgdG8gdXBkYXRlIHRoZSBERkEgYXQgb25jZS4gVGhlXG4vLyB7QGxpbmsgLy9hZGRERkFTdGF0ZX0gbWV0aG9kIGFsc28gbG9ja3MgaW5zaWRlIHRoZSBERkEgbG9ja1xuLy8gYnV0IHRoaXMgdGltZSBvbiB0aGUgc2hhcmVkIGNvbnRleHQgY2FjaGUgd2hlbiBpdCByZWJ1aWxkcyB0aGVcbi8vIGNvbmZpZ3VyYXRpb25zJyB7QGxpbmsgUHJlZGljdGlvbkNvbnRleHR9IG9iamVjdHMgdXNpbmcgY2FjaGVkXG4vLyBzdWJncmFwaHMvbm9kZXMuIE5vIG90aGVyIGxvY2tpbmcgb2NjdXJzLCBldmVuIGR1cmluZyBERkEgc2ltdWxhdGlvbi4gVGhpcyBpc1xuLy8gc2FmZSBhcyBsb25nIGFzIHdlIGNhbiBndWFyYW50ZWUgdGhhdCBhbGwgdGhyZWFkcyByZWZlcmVuY2luZ1xuLy8ge0Bjb2RlIHMuZWRnZVt0XX0gZ2V0IHRoZSBzYW1lIHBoeXNpY2FsIHRhcmdldCB7QGxpbmsgREZBU3RhdGV9LCBvclxuLy8ge0Bjb2RlIG51bGx9LiBPbmNlIGludG8gdGhlIERGQSwgdGhlIERGQSBzaW11bGF0aW9uIGRvZXMgbm90IHJlZmVyZW5jZSB0aGVcbi8vIHtAbGluayBERkEvL3N0YXRlc30gbWFwLiBJdCBmb2xsb3dzIHRoZSB7QGxpbmsgREZBU3RhdGUvL2VkZ2VzfSBmaWVsZCB0byBuZXdcbi8vIHRhcmdldHMuIFRoZSBERkEgc2ltdWxhdG9yIHdpbGwgZWl0aGVyIGZpbmQge0BsaW5rIERGQVN0YXRlLy9lZGdlc30gdG8gYmVcbi8vIHtAY29kZSBudWxsfSwgdG8gYmUgbm9uLXtAY29kZSBudWxsfSBhbmQge0Bjb2RlIGRmYS5lZGdlc1t0XX0gbnVsbCwgb3Jcbi8vIHtAY29kZSBkZmEuZWRnZXNbdF19IHRvIGJlIG5vbi1udWxsLiBUaGVcbi8vIHtAbGluayAvL2FkZERGQUVkZ2V9IG1ldGhvZCBjb3VsZCBiZSByYWNpbmcgdG8gc2V0IHRoZSBmaWVsZFxuLy8gYnV0IGluIGVpdGhlciBjYXNlIHRoZSBERkEgc2ltdWxhdG9yIHdvcmtzOyBpZiB7QGNvZGUgbnVsbH0sIGFuZCByZXF1ZXN0cyBBVE5cbi8vIHNpbXVsYXRpb24uIEl0IGNvdWxkIGFsc28gcmFjZSB0cnlpbmcgdG8gZ2V0IHtAY29kZSBkZmEuZWRnZXNbdF19LCBidXQgZWl0aGVyXG4vLyB3YXkgaXQgd2lsbCB3b3JrIGJlY2F1c2UgaXQncyBub3QgZG9pbmcgYSB0ZXN0IGFuZCBzZXQgb3BlcmF0aW9uLjwvcD5cbi8vXG4vLyA8cD5cbi8vIDxzdHJvbmc+U3RhcnRpbmcgd2l0aCBTTEwgdGhlbiBmYWlsaW5nIHRvIGNvbWJpbmVkIFNMTC9MTCAoVHdvLVN0YWdlXG4vLyBQYXJzaW5nKTwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5cbi8vIFNhbSBwb2ludGVkIG91dCB0aGF0IGlmIFNMTCBkb2VzIG5vdCBnaXZlIGEgc3ludGF4IGVycm9yLCB0aGVuIHRoZXJlIGlzIG5vXG4vLyBwb2ludCBpbiBkb2luZyBmdWxsIExMLCB3aGljaCBpcyBzbG93ZXIuIFdlIG9ubHkgaGF2ZSB0byB0cnkgTEwgaWYgd2UgZ2V0IGFcbi8vIHN5bnRheCBlcnJvci4gRm9yIG1heGltdW0gc3BlZWQsIFNhbSBzdGFydHMgdGhlIHBhcnNlciBzZXQgdG8gcHVyZSBTTExcbi8vIG1vZGUgd2l0aCB0aGUge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5fTo8L3A+XG4vL1xuLy8gPHByZT5cbi8vIHBhcnNlci57QGxpbmsgUGFyc2VyLy9nZXRJbnRlcnByZXRlcigpIGdldEludGVycHJldGVyKCl9LntAbGluayAvL3NldFByZWRpY3Rpb25Nb2RlIHNldFByZWRpY3Rpb25Nb2RlfXtAY29kZSAofXtAbGluayBQcmVkaWN0aW9uTW9kZS8vU0xMfXtAY29kZSApfTtcbi8vIHBhcnNlci57QGxpbmsgUGFyc2VyLy9zZXRFcnJvckhhbmRsZXIgc2V0RXJyb3JIYW5kbGVyfShuZXcge0BsaW5rIEJhaWxFcnJvclN0cmF0ZWd5fSgpKTtcbi8vIDwvcHJlPlxuLy9cbi8vIDxwPlxuLy8gSWYgaXQgZG9lcyBub3QgZ2V0IGEgc3ludGF4IGVycm9yLCB0aGVuIHdlJ3JlIGRvbmUuIElmIGl0IGRvZXMgZ2V0IGEgc3ludGF4XG4vLyBlcnJvciwgd2UgbmVlZCB0byByZXRyeSB3aXRoIHRoZSBjb21iaW5lZCBTTEwvTEwgc3RyYXRlZ3kuPC9wPlxuLy9cbi8vIDxwPlxuLy8gVGhlIHJlYXNvbiB0aGlzIHdvcmtzIGlzIGFzIGZvbGxvd3MuIElmIHRoZXJlIGFyZSBubyBTTEwgY29uZmxpY3RzLCB0aGVuIHRoZVxuLy8gZ3JhbW1hciBpcyBTTEwgKGF0IGxlYXN0IGZvciB0aGF0IGlucHV0IHNldCkuIElmIHRoZXJlIGlzIGFuIFNMTCBjb25mbGljdCxcbi8vIHRoZSBmdWxsIExMIGFuYWx5c2lzIG11c3QgeWllbGQgYSBzZXQgb2YgdmlhYmxlIGFsdGVybmF0aXZlcyB3aGljaCBpcyBhXG4vLyBzdWJzZXQgb2YgdGhlIGFsdGVybmF0aXZlcyByZXBvcnRlZCBieSBTTEwuIElmIHRoZSBMTCBzZXQgaXMgYSBzaW5nbGV0b24sXG4vLyB0aGVuIHRoZSBncmFtbWFyIGlzIExMIGJ1dCBub3QgU0xMLiBJZiB0aGUgTEwgc2V0IGlzIHRoZSBzYW1lIHNpemUgYXMgdGhlIFNMTFxuLy8gc2V0LCB0aGUgZGVjaXNpb24gaXMgU0xMLiBJZiB0aGUgTEwgc2V0IGhhcyBzaXplICZndDsgMSwgdGhlbiB0aGF0IGRlY2lzaW9uXG4vLyBpcyB0cnVseSBhbWJpZ3VvdXMgb24gdGhlIGN1cnJlbnQgaW5wdXQuIElmIHRoZSBMTCBzZXQgaXMgc21hbGxlciwgdGhlbiB0aGVcbi8vIFNMTCBjb25mbGljdCByZXNvbHV0aW9uIG1pZ2h0IGNob29zZSBhbiBhbHRlcm5hdGl2ZSB0aGF0IHRoZSBmdWxsIExMIHdvdWxkXG4vLyBydWxlIG91dCBhcyBhIHBvc3NpYmlsaXR5IGJhc2VkIHVwb24gYmV0dGVyIGNvbnRleHQgaW5mb3JtYXRpb24uIElmIHRoYXQnc1xuLy8gdGhlIGNhc2UsIHRoZW4gdGhlIFNMTCBwYXJzZSB3aWxsIGRlZmluaXRlbHkgZ2V0IGFuIGVycm9yIGJlY2F1c2UgdGhlIGZ1bGwgTExcbi8vIGFuYWx5c2lzIHNheXMgaXQncyBub3QgdmlhYmxlLiBJZiBTTEwgY29uZmxpY3QgcmVzb2x1dGlvbiBjaG9vc2VzIGFuXG4vLyBhbHRlcm5hdGl2ZSB3aXRoaW4gdGhlIExMIHNldCwgdGhlbSBib3RoIFNMTCBhbmQgTEwgd291bGQgY2hvb3NlIHRoZSBzYW1lXG4vLyBhbHRlcm5hdGl2ZSBiZWNhdXNlIHRoZXkgYm90aCBjaG9vc2UgdGhlIG1pbmltdW0gb2YgbXVsdGlwbGUgY29uZmxpY3Rpbmdcbi8vIGFsdGVybmF0aXZlcy48L3A+XG4vL1xuLy8gPHA+XG4vLyBMZXQncyBzYXkgd2UgaGF2ZSBhIHNldCBvZiBTTEwgY29uZmxpY3RpbmcgYWx0ZXJuYXRpdmVzIHtAY29kZSB7MSwgMiwgM319IGFuZFxuLy8gYSBzbWFsbGVyIExMIHNldCBjYWxsZWQgPGVtPnM8L2VtPi4gSWYgPGVtPnM8L2VtPiBpcyB7QGNvZGUgezIsIDN9fSwgdGhlbiBTTExcbi8vIHBhcnNpbmcgd2lsbCBnZXQgYW4gZXJyb3IgYmVjYXVzZSBTTEwgd2lsbCBwdXJzdWUgYWx0ZXJuYXRpdmUgMS4gSWZcbi8vIDxlbT5zPC9lbT4gaXMge0Bjb2RlIHsxLCAyfX0gb3Ige0Bjb2RlIHsxLCAzfX0gdGhlbiBib3RoIFNMTCBhbmQgTEwgd2lsbFxuLy8gY2hvb3NlIHRoZSBzYW1lIGFsdGVybmF0aXZlIGJlY2F1c2UgYWx0ZXJuYXRpdmUgb25lIGlzIHRoZSBtaW5pbXVtIG9mIGVpdGhlclxuLy8gc2V0LiBJZiA8ZW0+czwvZW0+IGlzIHtAY29kZSB7Mn19IG9yIHtAY29kZSB7M319IHRoZW4gU0xMIHdpbGwgZ2V0IGEgc3ludGF4XG4vLyBlcnJvci4gSWYgPGVtPnM8L2VtPiBpcyB7QGNvZGUgezF9fSB0aGVuIFNMTCB3aWxsIHN1Y2NlZWQuPC9wPlxuLy9cbi8vIDxwPlxuLy8gT2YgY291cnNlLCBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZCwgdGhlbiB3ZSB3aWxsIGdldCBhbiBlcnJvciBmb3Igc3VyZSBpblxuLy8gYm90aCBTTEwgYW5kIExMIHBhcnNpbmcuIEVycm9uZW91cyBpbnB1dCB3aWxsIHRoZXJlZm9yZSByZXF1aXJlIDIgcGFzc2VzIG92ZXJcbi8vIHRoZSBpbnB1dC48L3A+XG4vL1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLy4uL1V0aWxzJyk7XG52YXIgU2V0ID0gVXRpbHMuU2V0O1xudmFyIEJpdFNldCA9IFV0aWxzLkJpdFNldDtcbnZhciBEb3VibGVEaWN0ID0gVXRpbHMuRG91YmxlRGljdDtcbnZhciBBVE4gPSByZXF1aXJlKCcuL0FUTicpLkFUTjtcbnZhciBBVE5TdGF0ZSA9IHJlcXVpcmUoJy4vQVROU3RhdGUnKS5BVE5TdGF0ZTtcbnZhciBBVE5Db25maWcgPSByZXF1aXJlKCcuL0FUTkNvbmZpZycpLkFUTkNvbmZpZztcbnZhciBBVE5Db25maWdTZXQgPSByZXF1aXJlKCcuL0FUTkNvbmZpZ1NldCcpLkFUTkNvbmZpZ1NldDtcbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4vLi4vVG9rZW4nKS5Ub2tlbjtcbnZhciBERkFTdGF0ZSA9IHJlcXVpcmUoJy4vLi4vZGZhL0RGQVN0YXRlJykuREZBU3RhdGU7XG52YXIgUHJlZFByZWRpY3Rpb24gPSByZXF1aXJlKCcuLy4uL2RmYS9ERkFTdGF0ZScpLlByZWRQcmVkaWN0aW9uO1xudmFyIEFUTlNpbXVsYXRvciA9IHJlcXVpcmUoJy4vQVROU2ltdWxhdG9yJykuQVROU2ltdWxhdG9yO1xudmFyIFByZWRpY3Rpb25Nb2RlID0gcmVxdWlyZSgnLi9QcmVkaWN0aW9uTW9kZScpLlByZWRpY3Rpb25Nb2RlO1xudmFyIFJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi8uLi9SdWxlQ29udGV4dCcpLlJ1bGVDb250ZXh0O1xudmFyIFBhcnNlclJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi8uLi9QYXJzZXJSdWxlQ29udGV4dCcpLlBhcnNlclJ1bGVDb250ZXh0O1xudmFyIFNlbWFudGljQ29udGV4dCA9IHJlcXVpcmUoJy4vU2VtYW50aWNDb250ZXh0JykuU2VtYW50aWNDb250ZXh0O1xudmFyIFN0YXJMb29wRW50cnlTdGF0ZSA9IHJlcXVpcmUoJy4vQVROU3RhdGUnKS5TdGFyTG9vcEVudHJ5U3RhdGU7XG52YXIgUnVsZVN0b3BTdGF0ZSA9IHJlcXVpcmUoJy4vQVROU3RhdGUnKS5SdWxlU3RvcFN0YXRlO1xudmFyIFByZWRpY3Rpb25Db250ZXh0ID0gcmVxdWlyZSgnLi8uLi9QcmVkaWN0aW9uQ29udGV4dCcpLlByZWRpY3Rpb25Db250ZXh0O1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIFRyYW5zaXRpb25zID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uJyk7XG52YXIgVHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlRyYW5zaXRpb247XG52YXIgU2V0VHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLlNldFRyYW5zaXRpb247XG52YXIgTm90U2V0VHJhbnNpdGlvbiA9IFRyYW5zaXRpb25zLk5vdFNldFRyYW5zaXRpb247XG52YXIgUnVsZVRyYW5zaXRpb24gPSBUcmFuc2l0aW9ucy5SdWxlVHJhbnNpdGlvbjtcbnZhciBBY3Rpb25UcmFuc2l0aW9uID0gVHJhbnNpdGlvbnMuQWN0aW9uVHJhbnNpdGlvbjtcbnZhciBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vLi4vZXJyb3IvRXJyb3JzJykuTm9WaWFibGVBbHRFeGNlcHRpb247XG5cbnZhciBTaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5TaW5nbGV0b25QcmVkaWN0aW9uQ29udGV4dDtcbnZhciBwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vLi4vUHJlZGljdGlvbkNvbnRleHQnKS5wcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dDtcblxuZnVuY3Rpb24gUGFyc2VyQVROU2ltdWxhdG9yKHBhcnNlciwgYXRuLCBkZWNpc2lvblRvREZBLCBzaGFyZWRDb250ZXh0Q2FjaGUpIHtcblx0QVROU2ltdWxhdG9yLmNhbGwodGhpcywgYXRuLCBzaGFyZWRDb250ZXh0Q2FjaGUpO1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMuZGVjaXNpb25Ub0RGQSA9IGRlY2lzaW9uVG9ERkE7XG4gICAgLy8gU0xMLCBMTCwgb3IgTEwgKyBleGFjdCBhbWJpZyBkZXRlY3Rpb24/Ly9cbiAgICB0aGlzLnByZWRpY3Rpb25Nb2RlID0gUHJlZGljdGlvbk1vZGUuTEw7XG4gICAgLy8gTEFNRSBnbG9iYWxzIHRvIGF2b2lkIHBhcmFtZXRlcnMhISEhISBJIG5lZWQgdGhlc2UgZG93biBkZWVwIGluIHByZWRUcmFuc2l0aW9uXG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0SW5kZXggPSAwO1xuICAgIHRoaXMuX291dGVyQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZGZhID0gbnVsbDtcbiAgICAvLyBFYWNoIHByZWRpY3Rpb24gb3BlcmF0aW9uIHVzZXMgYSBjYWNoZSBmb3IgbWVyZ2Ugb2YgcHJlZGljdGlvbiBjb250ZXh0cy5cbiAgICAvLyAgRG9uJ3Qga2VlcCBhcm91bmQgYXMgaXQgd2FzdGVzIGh1Z2UgYW1vdW50cyBvZiBtZW1vcnkuIERvdWJsZUtleU1hcFxuICAgIC8vICBpc24ndCBzeW5jaHJvbml6ZWQgYnV0IHdlJ3JlIG9rIHNpbmNlIHR3byB0aHJlYWRzIHNob3VsZG4ndCByZXVzZSBzYW1lXG4gICAgLy8gIHBhcnNlci9hdG5zaW0gb2JqZWN0IGJlY2F1c2UgaXQgY2FuIG9ubHkgaGFuZGxlIG9uZSBpbnB1dCBhdCBhIHRpbWUuXG4gICAgLy8gIFRoaXMgbWFwcyBncmFwaHMgYSBhbmQgYiB0byBtZXJnZWQgcmVzdWx0IGMuIChhLGIpJnJhcnI7Yy4gV2UgY2FuIGF2b2lkXG4gICAgLy8gIHRoZSBtZXJnZSBpZiB3ZSBldmVyIHNlZSBhIGFuZCBiIGFnYWluLiAgTm90ZSB0aGF0IChiLGEpJnJhcnI7YyBzaG91bGRcbiAgICAvLyAgYWxzbyBiZSBleGFtaW5lZCBkdXJpbmcgY2FjaGUgbG9va3VwLlxuICAgIC8vXG4gICAgdGhpcy5tZXJnZUNhY2hlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQVROU2ltdWxhdG9yLnByb3RvdHlwZSk7XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyc2VyQVROU2ltdWxhdG9yO1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmRlYnVnID0gZmFsc2U7XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmRlYnVnX2Nsb3N1cmUgPSBmYWxzZTtcblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZGVidWdfYWRkID0gZmFsc2U7XG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmRlYnVnX2xpc3RfYXRuX2RlY2lzaW9ucyA9IGZhbHNlO1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kZmFfZGVidWcgPSBmYWxzZTtcblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucmV0cnlfZGVidWcgPSBmYWxzZTtcblxuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFkYXB0aXZlUHJlZGljdCA9IGZ1bmN0aW9uKGlucHV0LCBkZWNpc2lvbiwgb3V0ZXJDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGFwdGl2ZVByZWRpY3QgZGVjaXNpb24gXCIgKyBkZWNpc2lvbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgZXhlYyBMQSgxKT09XCIgKyB0aGlzLmdldExvb2thaGVhZE5hbWUoaW5wdXQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBsaW5lIFwiICsgaW5wdXQuTFQoMSkubGluZSArIFwiOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5MVCgxKS5jb2x1bW4pO1xuICAgIH1cbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuX3N0YXJ0SW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICB0aGlzLl9vdXRlckNvbnRleHQgPSBvdXRlckNvbnRleHQ7XG5cbiAgICB2YXIgZGZhID0gdGhpcy5kZWNpc2lvblRvREZBW2RlY2lzaW9uXTtcbiAgICB0aGlzLl9kZmEgPSBkZmE7XG4gICAgdmFyIG0gPSBpbnB1dC5tYXJrKCk7XG4gICAgdmFyIGluZGV4ID0gaW5wdXQuaW5kZXg7XG5cbiAgICAvLyBOb3cgd2UgYXJlIGNlcnRhaW4gdG8gaGF2ZSBhIHNwZWNpZmljIGRlY2lzaW9uJ3MgREZBXG4gICAgLy8gQnV0LCBkbyB3ZSBzdGlsbCBuZWVkIGFuIGluaXRpYWwgc3RhdGU/XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHMwO1xuICAgICAgICBpZiAoZGZhLnByZWNlZGVuY2VEZmEpIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFydCBzdGF0ZSBmb3IgYSBwcmVjZWRlbmNlIERGQSBkZXBlbmRzIG9uIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBwYXJzZXIgcHJlY2VkZW5jZSwgYW5kIGlzIHByb3ZpZGVkIGJ5IGEgREZBIG1ldGhvZC5cbiAgICAgICAgICAgIHMwID0gZGZhLmdldFByZWNlZGVuY2VTdGFydFN0YXRlKHRoaXMucGFyc2VyLmdldFByZWNlZGVuY2UoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgc3RhdGUgZm9yIGEgXCJyZWd1bGFyXCIgREZBIGlzIGp1c3QgczBcbiAgICAgICAgICAgIHMwID0gZGZhLnMwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMD09PW51bGwpIHtcbiAgICAgICAgICAgIGlmIChvdXRlckNvbnRleHQ9PT1udWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJDb250ZXh0ID0gUnVsZUNvbnRleHQuRU1QVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLmRlYnVnX2xpc3RfYXRuX2RlY2lzaW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJlZGljdEFUTiBkZWNpc2lvbiBcIiArIGRmYS5kZWNpc2lvbiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGV4ZWMgTEEoMSk9PVwiICsgdGhpcy5nZXRMb29rYWhlYWROYW1lKGlucHV0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBvdXRlckNvbnRleHQ9XCIgKyBvdXRlckNvbnRleHQudG9TdHJpbmcodGhpcy5wYXJzZXIucnVsZU5hbWVzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmdWxsQ3R4ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgczBfY2xvc3VyZSA9IHRoaXMuY29tcHV0ZVN0YXJ0U3RhdGUoZGZhLmF0blN0YXJ0U3RhdGUsIFJ1bGVDb250ZXh0LkVNUFRZLCBmdWxsQ3R4KTtcblxuICAgICAgICAgICAgaWYoIGRmYS5wcmVjZWRlbmNlRGZhKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZWNlZGVuY2UgREZBLCB3ZSB1c2UgYXBwbHlQcmVjZWRlbmNlRmlsdGVyXG4gICAgICAgICAgICAgICAgLy8gdG8gY29udmVydCB0aGUgY29tcHV0ZWQgc3RhcnQgc3RhdGUgdG8gYSBwcmVjZWRlbmNlIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gc3RhdGUuIFdlIHRoZW4gdXNlIERGQS5zZXRQcmVjZWRlbmNlU3RhcnRTdGF0ZSB0byBzZXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGUgc3RhcnQgc3RhdGUgZm9yIHRoZSBwcmVjZWRlbmNlIGxldmVsIHJhdGhlclxuICAgICAgICAgICAgICAgIC8vIHRoYW4gc2ltcGx5IHNldHRpbmcgREZBLnMwLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgZGZhLnMwLmNvbmZpZ3MgPSBzMF9jbG9zdXJlOyAvLyBub3QgdXNlZCBmb3IgcHJlZGljdGlvbiBidXQgdXNlZnVsIHRvIGtub3cgc3RhcnQgY29uZmlncyBhbnl3YXlcbiAgICAgICAgICAgICAgICBzMF9jbG9zdXJlID0gdGhpcy5hcHBseVByZWNlZGVuY2VGaWx0ZXIoczBfY2xvc3VyZSk7XG4gICAgICAgICAgICAgICAgczAgPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgbmV3IERGQVN0YXRlKG51bGwsIHMwX2Nsb3N1cmUpKTtcbiAgICAgICAgICAgICAgICBkZmEuc2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUodGhpcy5wYXJzZXIuZ2V0UHJlY2VkZW5jZSgpLCBzMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMwID0gdGhpcy5hZGRERkFTdGF0ZShkZmEsIG5ldyBERkFTdGF0ZShudWxsLCBzMF9jbG9zdXJlKSk7XG4gICAgICAgICAgICAgICAgZGZhLnMwID0gczA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsdCA9IHRoaXMuZXhlY0FUTihkZmEsIHMwLCBpbnB1dCwgaW5kZXgsIG91dGVyQ29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRGQSBhZnRlciBwcmVkaWN0QVROOiBcIiArIGRmYS50b1N0cmluZyh0aGlzLnBhcnNlci5saXRlcmFsTmFtZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2RmYSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2VDYWNoZSA9IG51bGw7IC8vIHdhY2sgY2FjaGUgYWZ0ZXIgZWFjaCBwcmVkaWN0aW9uXG4gICAgICAgIGlucHV0LnNlZWsoaW5kZXgpO1xuICAgICAgICBpbnB1dC5yZWxlYXNlKG0pO1xuICAgIH1cbn07XG4vLyBQZXJmb3JtcyBBVE4gc2ltdWxhdGlvbiB0byBjb21wdXRlIGEgcHJlZGljdGVkIGFsdGVybmF0aXZlIGJhc2VkXG4vLyAgdXBvbiB0aGUgcmVtYWluaW5nIGlucHV0LCBidXQgYWxzbyB1cGRhdGVzIHRoZSBERkEgY2FjaGUgdG8gYXZvaWRcbi8vICBoYXZpbmcgdG8gdHJhdmVyc2UgdGhlIEFUTiBhZ2FpbiBmb3IgdGhlIHNhbWUgaW5wdXQgc2VxdWVuY2UuXG5cbi8vIFRoZXJlIGFyZSBzb21lIGtleSBjb25kaXRpb25zIHdlJ3JlIGxvb2tpbmcgZm9yIGFmdGVyIGNvbXB1dGluZyBhIG5ld1xuLy8gc2V0IG9mIEFUTiBjb25maWdzIChwcm9wb3NlZCBERkEgc3RhdGUpOlxuICAgICAgLy8gaWYgdGhlIHNldCBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gdmlhYmxlIGFsdGVybmF0aXZlIGZvciBjdXJyZW50IHN5bWJvbFxuICAgICAgLy8gZG9lcyB0aGUgc3RhdGUgdW5pcXVlbHkgcHJlZGljdCBhbiBhbHRlcm5hdGl2ZT9cbiAgICAgIC8vIGRvZXMgdGhlIHN0YXRlIGhhdmUgYSBjb25mbGljdCB0aGF0IHdvdWxkIHByZXZlbnQgdXMgZnJvbVxuICAgICAgLy8gICBwdXR0aW5nIGl0IG9uIHRoZSB3b3JrIGxpc3Q/XG5cbi8vIFdlIGFsc28gaGF2ZSBzb21lIGtleSBvcGVyYXRpb25zIHRvIGRvOlxuICAgICAgLy8gYWRkIGFuIGVkZ2UgZnJvbSBwcmV2aW91cyBERkEgc3RhdGUgdG8gcG90ZW50aWFsbHkgbmV3IERGQSBzdGF0ZSwgRCxcbiAgICAgIC8vICAgdXBvbiBjdXJyZW50IHN5bWJvbCBidXQgb25seSBpZiBhZGRpbmcgdG8gd29yayBsaXN0LCB3aGljaCBtZWFucyBpbiBhbGxcbiAgICAgIC8vICAgY2FzZXMgZXhjZXB0IG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSAoYW5kIHBvc3NpYmx5IG5vbi1ncmVlZHkgZGVjaXNpb25zPylcbiAgICAgIC8vIGNvbGxlY3RpbmcgcHJlZGljYXRlcyBhbmQgYWRkaW5nIHNlbWFudGljIGNvbnRleHQgdG8gREZBIGFjY2VwdCBzdGF0ZXNcbiAgICAgIC8vIGFkZGluZyBydWxlIGNvbnRleHQgdG8gY29udGV4dC1zZW5zaXRpdmUgREZBIGFjY2VwdCBzdGF0ZXNcbiAgICAgIC8vIGNvbnN1bWluZyBhbiBpbnB1dCBzeW1ib2xcbiAgICAgIC8vIHJlcG9ydGluZyBhIGNvbmZsaWN0XG4gICAgICAvLyByZXBvcnRpbmcgYW4gYW1iaWd1aXR5XG4gICAgICAvLyByZXBvcnRpbmcgYSBjb250ZXh0IHNlbnNpdGl2aXR5XG4gICAgICAvLyByZXBvcnRpbmcgaW5zdWZmaWNpZW50IHByZWRpY2F0ZXNcblxuLy8gY292ZXIgdGhlc2UgY2FzZXM6XG4vLyAgICBkZWFkIGVuZFxuLy8gICAgc2luZ2xlIGFsdFxuLy8gICAgc2luZ2xlIGFsdCArIHByZWRzXG4vLyAgICBjb25mbGljdFxuLy8gICAgY29uZmxpY3QgKyBwcmVkc1xuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZXhlY0FUTiA9IGZ1bmN0aW9uKGRmYSwgczAsIGlucHV0LCBzdGFydEluZGV4LCBvdXRlckNvbnRleHQgKSB7XG4gICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJleGVjQVROIGRlY2lzaW9uIFwiICsgZGZhLmRlY2lzaW9uICtcbiAgICAgICAgICAgICAgICBcIiBleGVjIExBKDEpPT1cIiArIHRoaXMuZ2V0TG9va2FoZWFkTmFtZShpbnB1dCkgK1xuICAgICAgICAgICAgICAgIFwiIGxpbmUgXCIgKyBpbnB1dC5MVCgxKS5saW5lICsgXCI6XCIgKyBpbnB1dC5MVCgxKS5jb2x1bW4pO1xuICAgIH1cbiAgICB2YXIgYWx0O1xuICAgIHZhciBwcmV2aW91c0QgPSBzMDtcblxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiczAgPSBcIiArIHMwKTtcbiAgICB9XG4gICAgdmFyIHQgPSBpbnB1dC5MQSgxKTtcbiAgICB3aGlsZSh0cnVlKSB7IC8vIHdoaWxlIG1vcmUgd29ya1xuICAgICAgICB2YXIgRCA9IHRoaXMuZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShwcmV2aW91c0QsIHQpO1xuICAgICAgICBpZihEPT09bnVsbCkge1xuICAgICAgICAgICAgRCA9IHRoaXMuY29tcHV0ZVRhcmdldFN0YXRlKGRmYSwgcHJldmlvdXNELCB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZihEPT09QVROU2ltdWxhdG9yLkVSUk9SKSB7XG4gICAgICAgICAgICAvLyBpZiBhbnkgY29uZmlncyBpbiBwcmV2aW91cyBkaXBwZWQgaW50byBvdXRlciBjb250ZXh0LCB0aGF0XG4gICAgICAgICAgICAvLyBtZWFucyB0aGF0IGlucHV0IHVwIHRvIHQgYWN0dWFsbHkgZmluaXNoZWQgZW50cnkgcnVsZVxuICAgICAgICAgICAgLy8gYXQgbGVhc3QgZm9yIFNMTCBkZWNpc2lvbi4gRnVsbCBMTCBkb2Vzbid0IGRpcCBpbnRvIG91dGVyXG4gICAgICAgICAgICAvLyBzbyBkb24ndCBuZWVkIHNwZWNpYWwgY2FzZS5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgZ2V0IGFuIGVycm9yIG5vIG1hdHRlciB3aGF0IHNvIGRlbGF5IHVudGlsIGFmdGVyXG4gICAgICAgICAgICAvLyBkZWNpc2lvbjsgYmV0dGVyIGVycm9yIG1lc3NhZ2UuIEFsc28sIG5vIHJlYWNoYWJsZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIEFUTiBzdGF0ZXMgaW4gU0xMIGltcGxpZXMgTEwgd2lsbCBhbHNvIGdldCBub3doZXJlLlxuICAgICAgICAgICAgLy8gSWYgY29uZmxpY3QgaW4gc3RhdGVzIHRoYXQgZGlwIG91dCwgY2hvb3NlIG1pbiBzaW5jZSB3ZVxuICAgICAgICAgICAgLy8gd2lsbCBnZXQgZXJyb3Igbm8gbWF0dGVyIHdoYXQuXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubm9WaWFibGVBbHQoaW5wdXQsIG91dGVyQ29udGV4dCwgcHJldmlvdXNELmNvbmZpZ3MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaW5wdXQuc2VlayhzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGFsdCA9IHRoaXMuZ2V0U3luVmFsaWRPclNlbUludmFsaWRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShwcmV2aW91c0QuY29uZmlncywgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIGlmKGFsdCE9PUFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKEQucmVxdWlyZXNGdWxsQ29udGV4dCAmJiB0aGlzLnByZWRpY3Rpb25Nb2RlICE9PSBQcmVkaWN0aW9uTW9kZS5TTEwpIHtcbiAgICAgICAgICAgIC8vIElGIFBSRURTLCBNSUdIVCBSRVNPTFZFIFRPIFNJTkdMRSBBTFQgPT4gU0xMIChvciBzeW50YXggZXJyb3IpXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RpbmdBbHRzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChELnByZWRpY2F0ZXMhPT1udWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJERkEgc3RhdGUgaGFzIHByZWRzIGluIERGQSBzaW0gTEwgZmFpbG92ZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb25mbGljdEluZGV4ID0gaW5wdXQuaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYoY29uZmxpY3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25mbGljdGluZ0FsdHMgPSB0aGlzLmV2YWxTZW1hbnRpY0NvbnRleHQoRC5wcmVkaWNhdGVzLCBvdXRlckNvbnRleHQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb25mbGljdGluZ0FsdHMubGVuZ3RoPT09MSkge1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZ1bGwgTEwgYXZvaWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmxpY3RpbmdBbHRzLm1pblZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25mbGljdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGluZGV4IHNvIHJlcG9ydGluZyB0aGUgZmFsbGJhY2sgdG8gZnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250ZXh0IG9jY3VycyB3aXRoIHRoZSBpbmRleCBhdCB0aGUgY29ycmVjdCBzcG90XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnNlZWsoY29uZmxpY3RJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGZhX2RlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjdHggc2Vuc2l0aXZlIHN0YXRlIFwiICsgb3V0ZXJDb250ZXh0ICtcIiBpbiBcIiArIEQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZ1bGxDdHggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHMwX2Nsb3N1cmUgPSB0aGlzLmNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlLCBvdXRlckNvbnRleHQsIGZ1bGxDdHgpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQoZGZhLCBjb25mbGljdGluZ0FsdHMsIEQuY29uZmlncywgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgpO1xuICAgICAgICAgICAgYWx0ID0gdGhpcy5leGVjQVROV2l0aEZ1bGxDb250ZXh0KGRmYSwgRCwgczBfY2xvc3VyZSwgaW5wdXQsIHN0YXJ0SW5kZXgsIG91dGVyQ29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChELmlzQWNjZXB0U3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChELnByZWRpY2F0ZXM9PT1udWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEQucHJlZGljdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdG9wSW5kZXggPSBpbnB1dC5pbmRleDtcbiAgICAgICAgICAgIGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XG4gICAgICAgICAgICB2YXIgYWx0cyA9IHRoaXMuZXZhbFNlbWFudGljQ29udGV4dChELnByZWRpY2F0ZXMsIG91dGVyQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoYWx0cy5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBELmNvbmZpZ3MsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbHRzLmxlbmd0aD09PTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0cy5taW5WYWx1ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgYW1iaWd1aXR5IGFmdGVyIHByZWRpY2F0ZSBldmFsdWF0aW9uIHRvIG1ha2Ugc3VyZSB0aGUgY29ycmVjdCBzZXQgb2YgYW1iaWcgYWx0cyBpcyByZXBvcnRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEFtYmlndWl0eShkZmEsIEQsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZmFsc2UsIGFsdHMsIEQuY29uZmlncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsdHMubWluVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0QgPSBEO1xuXG4gICAgICAgIGlmICh0ICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIGlucHV0LmNvbnN1bWUoKTtcbiAgICAgICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vL1xuLy8gR2V0IGFuIGV4aXN0aW5nIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLiBJZiB0aGUgdGFyZ2V0IHN0YXRlXG4vLyBmb3IgdGhlIGVkZ2UgaGFzIG5vdCB5ZXQgYmVlbiBjb21wdXRlZCBvciBpcyBvdGhlcndpc2Ugbm90IGF2YWlsYWJsZSxcbi8vIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9LlxuLy9cbi8vIEBwYXJhbSBwcmV2aW91c0QgVGhlIGN1cnJlbnQgREZBIHN0YXRlXG4vLyBAcGFyYW0gdCBUaGUgbmV4dCBpbnB1dCBzeW1ib2xcbi8vIEByZXR1cm4gVGhlIGV4aXN0aW5nIHRhcmdldCBERkEgc3RhdGUgZm9yIHRoZSBnaXZlbiBpbnB1dCBzeW1ib2xcbi8vIHtAY29kZSB0fSwgb3Ige0Bjb2RlIG51bGx9IGlmIHRoZSB0YXJnZXQgc3RhdGUgZm9yIHRoaXMgZWRnZSBpcyBub3Rcbi8vIGFscmVhZHkgY2FjaGVkXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRFeGlzdGluZ1RhcmdldFN0YXRlID0gZnVuY3Rpb24ocHJldmlvdXNELCB0KSB7XG4gICAgdmFyIGVkZ2VzID0gcHJldmlvdXNELmVkZ2VzO1xuICAgIGlmIChlZGdlcz09PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzW3QgKyAxXSB8fCBudWxsO1xuICAgIH1cbn07XG4vL1xuLy8gQ29tcHV0ZSBhIHRhcmdldCBzdGF0ZSBmb3IgYW4gZWRnZSBpbiB0aGUgREZBLCBhbmQgYXR0ZW1wdCB0byBhZGQgdGhlXG4vLyBjb21wdXRlZCBzdGF0ZSBhbmQgY29ycmVzcG9uZGluZyBlZGdlIHRvIHRoZSBERkEuXG4vL1xuLy8gQHBhcmFtIGRmYSBUaGUgREZBXG4vLyBAcGFyYW0gcHJldmlvdXNEIFRoZSBjdXJyZW50IERGQSBzdGF0ZVxuLy8gQHBhcmFtIHQgVGhlIG5leHQgaW5wdXQgc3ltYm9sXG4vL1xuLy8gQHJldHVybiBUaGUgY29tcHV0ZWQgdGFyZ2V0IERGQSBzdGF0ZSBmb3IgdGhlIGdpdmVuIGlucHV0IHN5bWJvbFxuLy8ge0Bjb2RlIHR9LiBJZiB7QGNvZGUgdH0gZG9lcyBub3QgbGVhZCB0byBhIHZhbGlkIERGQSBzdGF0ZSwgdGhpcyBtZXRob2Rcbi8vIHJldHVybnMge0BsaW5rIC8vRVJST1J9LlxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY29tcHV0ZVRhcmdldFN0YXRlID0gZnVuY3Rpb24oZGZhLCBwcmV2aW91c0QsIHQpIHtcbiAgIHZhciByZWFjaCA9IHRoaXMuY29tcHV0ZVJlYWNoU2V0KHByZXZpb3VzRC5jb25maWdzLCB0LCBmYWxzZSk7XG4gICAgaWYocmVhY2g9PT1udWxsKSB7XG4gICAgICAgIHRoaXMuYWRkREZBRWRnZShkZmEsIHByZXZpb3VzRCwgdCwgQVROU2ltdWxhdG9yLkVSUk9SKTtcbiAgICAgICAgcmV0dXJuIEFUTlNpbXVsYXRvci5FUlJPUjtcbiAgICB9XG4gICAgLy8gY3JlYXRlIG5ldyB0YXJnZXQgc3RhdGU7IHdlJ2xsIGFkZCB0byBERkEgYWZ0ZXIgaXQncyBjb21wbGV0ZVxuICAgIHZhciBEID0gbmV3IERGQVN0YXRlKG51bGwsIHJlYWNoKTtcblxuICAgIHZhciBwcmVkaWN0ZWRBbHQgPSB0aGlzLmdldFVuaXF1ZUFsdChyZWFjaCk7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICB2YXIgYWx0U3ViU2V0cyA9IFByZWRpY3Rpb25Nb2RlLmdldENvbmZsaWN0aW5nQWx0U3Vic2V0cyhyZWFjaCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU0xMIGFsdFN1YlNldHM9XCIgKyBVdGlscy5hcnJheVRvU3RyaW5nKGFsdFN1YlNldHMpICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHByZXZpb3VzPVwiICsgcHJldmlvdXNELmNvbmZpZ3MgK1xuICAgICAgICAgICAgICAgICAgICBcIiwgY29uZmlncz1cIiArIHJlYWNoICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIHByZWRpY3Q9XCIgKyBwcmVkaWN0ZWRBbHQgK1xuICAgICAgICAgICAgICAgICAgICBcIiwgYWxsU3Vic2V0c0NvbmZsaWN0PVwiICtcbiAgICAgICAgICAgICAgICAgICAgUHJlZGljdGlvbk1vZGUuYWxsU3Vic2V0c0NvbmZsaWN0KGFsdFN1YlNldHMpICsgXCIsIGNvbmZsaWN0aW5nQWx0cz1cIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29uZmxpY3RpbmdBbHRzKHJlYWNoKSk7XG4gICAgfVxuICAgIGlmIChwcmVkaWN0ZWRBbHQhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIC8vIE5PIENPTkZMSUNULCBVTklRVUVMWSBQUkVESUNURUQgQUxUXG4gICAgICAgIEQuaXNBY2NlcHRTdGF0ZSA9IHRydWU7XG4gICAgICAgIEQuY29uZmlncy51bmlxdWVBbHQgPSBwcmVkaWN0ZWRBbHQ7XG4gICAgICAgIEQucHJlZGljdGlvbiA9IHByZWRpY3RlZEFsdDtcbiAgICB9IGVsc2UgaWYgKFByZWRpY3Rpb25Nb2RlLmhhc1NMTENvbmZsaWN0VGVybWluYXRpbmdQcmVkaWN0aW9uKHRoaXMucHJlZGljdGlvbk1vZGUsIHJlYWNoKSkge1xuICAgICAgICAvLyBNT1JFIFRIQU4gT05FIFZJQUJMRSBBTFRFUk5BVElWRVxuICAgICAgICBELmNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzID0gdGhpcy5nZXRDb25mbGljdGluZ0FsdHMocmVhY2gpO1xuICAgICAgICBELnJlcXVpcmVzRnVsbENvbnRleHQgPSB0cnVlO1xuICAgICAgICAvLyBpbiBTTEwtb25seSBtb2RlLCB3ZSB3aWxsIHN0b3AgYXQgdGhpcyBzdGF0ZSBhbmQgcmV0dXJuIHRoZSBtaW5pbXVtIGFsdFxuICAgICAgICBELmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuICAgICAgICBELnByZWRpY3Rpb24gPSBELmNvbmZpZ3MuY29uZmxpY3RpbmdBbHRzLm1pblZhbHVlKCk7XG4gICAgfVxuICAgIGlmIChELmlzQWNjZXB0U3RhdGUgJiYgRC5jb25maWdzLmhhc1NlbWFudGljQ29udGV4dCkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZURGQVN0YXRlKEQsIHRoaXMuYXRuLmdldERlY2lzaW9uU3RhdGUoZGZhLmRlY2lzaW9uKSk7XG4gICAgICAgIGlmKCBELnByZWRpY2F0ZXMhPT1udWxsKSB7XG4gICAgICAgICAgICBELnByZWRpY3Rpb24gPSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsbCBhZGRzIHRvIGRmYSBhcmUgZG9uZSBhZnRlciB3ZSd2ZSBjcmVhdGVkIGZ1bGwgRCBzdGF0ZVxuICAgIEQgPSB0aGlzLmFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHQsIEQpO1xuICAgIHJldHVybiBEO1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5wcmVkaWNhdGVERkFTdGF0ZSA9IGZ1bmN0aW9uKGRmYVN0YXRlLCBkZWNpc2lvblN0YXRlKSB7XG4gICAgLy8gV2UgbmVlZCB0byB0ZXN0IGFsbCBwcmVkaWNhdGVzLCBldmVuIGluIERGQSBzdGF0ZXMgdGhhdFxuICAgIC8vIHVuaXF1ZWx5IHByZWRpY3QgYWx0ZXJuYXRpdmUuXG4gICAgdmFyIG5hbHRzID0gZGVjaXNpb25TdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgLy8gVXBkYXRlIERGQSBzbyByZWFjaCBiZWNvbWVzIGFjY2VwdCBzdGF0ZSB3aXRoIChwcmVkaWNhdGUsYWx0KVxuICAgIC8vIHBhaXJzIGlmIHByZWRzIGZvdW5kIGZvciBjb25mbGljdGluZyBhbHRzXG4gICAgdmFyIGFsdHNUb0NvbGxlY3RQcmVkc0Zyb20gPSB0aGlzLmdldENvbmZsaWN0aW5nQWx0c09yVW5pcXVlQWx0KGRmYVN0YXRlLmNvbmZpZ3MpO1xuICAgIHZhciBhbHRUb1ByZWQgPSB0aGlzLmdldFByZWRzRm9yQW1iaWdBbHRzKGFsdHNUb0NvbGxlY3RQcmVkc0Zyb20sIGRmYVN0YXRlLmNvbmZpZ3MsIG5hbHRzKTtcbiAgICBpZiAoYWx0VG9QcmVkIT09bnVsbCkge1xuICAgICAgICBkZmFTdGF0ZS5wcmVkaWNhdGVzID0gdGhpcy5nZXRQcmVkaWNhdGVQcmVkaWN0aW9ucyhhbHRzVG9Db2xsZWN0UHJlZHNGcm9tLCBhbHRUb1ByZWQpO1xuICAgICAgICBkZmFTdGF0ZS5wcmVkaWN0aW9uID0gQVROLklOVkFMSURfQUxUX05VTUJFUjsgLy8gbWFrZSBzdXJlIHdlIHVzZSBwcmVkc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBwcmVkcyBpbiBjb25maWdzIGJ1dCB0aGV5IG1pZ2h0IGdvIGF3YXlcbiAgICAgICAgLy8gd2hlbiBPUidkIHRvZ2V0aGVyIGxpa2Uge3B9PyB8fCBOT05FID09IE5PTkUuIElmIG5laXRoZXJcbiAgICAgICAgLy8gYWx0IGhhcyBwcmVkcywgcmVzb2x2ZSB0byBtaW4gYWx0XG4gICAgICAgIGRmYVN0YXRlLnByZWRpY3Rpb24gPSBhbHRzVG9Db2xsZWN0UHJlZHNGcm9tLm1pblZhbHVlKCk7XG4gICAgfVxufTtcblxuLy8gY29tZXMgYmFjayB3aXRoIHJlYWNoLnVuaXF1ZUFsdCBzZXQgdG8gYSB2YWxpZCBhbHRcblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZXhlY0FUTldpdGhGdWxsQ29udGV4dCA9IGZ1bmN0aW9uKGRmYSwgRCwgLy8gaG93IGZhciB3ZSBnb3QgYmVmb3JlIGZhaWxpbmcgb3ZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZWJ1Z19saXN0X2F0bl9kZWNpc2lvbnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJleGVjQVROV2l0aEZ1bGxDb250ZXh0IFwiK3MwKTtcbiAgICB9XG4gICAgdmFyIGZ1bGxDdHggPSB0cnVlO1xuICAgIHZhciBmb3VuZEV4YWN0QW1iaWcgPSBmYWxzZTtcbiAgICB2YXIgcmVhY2ggPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IHMwO1xuICAgIGlucHV0LnNlZWsoc3RhcnRJbmRleCk7XG4gICAgdmFyIHQgPSBpbnB1dC5MQSgxKTtcbiAgICB2YXIgcHJlZGljdGVkQWx0ID0gLTE7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gd2hpbGUgbW9yZSB3b3JrXG4gICAgICAgIHJlYWNoID0gdGhpcy5jb21wdXRlUmVhY2hTZXQocHJldmlvdXMsIHQsIGZ1bGxDdHgpO1xuICAgICAgICBpZiAocmVhY2g9PT1udWxsKSB7XG4gICAgICAgICAgICAvLyBpZiBhbnkgY29uZmlncyBpbiBwcmV2aW91cyBkaXBwZWQgaW50byBvdXRlciBjb250ZXh0LCB0aGF0XG4gICAgICAgICAgICAvLyBtZWFucyB0aGF0IGlucHV0IHVwIHRvIHQgYWN0dWFsbHkgZmluaXNoZWQgZW50cnkgcnVsZVxuICAgICAgICAgICAgLy8gYXQgbGVhc3QgZm9yIExMIGRlY2lzaW9uLiBGdWxsIExMIGRvZXNuJ3QgZGlwIGludG8gb3V0ZXJcbiAgICAgICAgICAgIC8vIHNvIGRvbid0IG5lZWQgc3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBnZXQgYW4gZXJyb3Igbm8gbWF0dGVyIHdoYXQgc28gZGVsYXkgdW50aWwgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGRlY2lzaW9uOyBiZXR0ZXIgZXJyb3IgbWVzc2FnZS4gQWxzbywgbm8gcmVhY2hhYmxlIHRhcmdldFxuICAgICAgICAgICAgLy8gQVROIHN0YXRlcyBpbiBTTEwgaW1wbGllcyBMTCB3aWxsIGFsc28gZ2V0IG5vd2hlcmUuXG4gICAgICAgICAgICAvLyBJZiBjb25mbGljdCBpbiBzdGF0ZXMgdGhhdCBkaXAgb3V0LCBjaG9vc2UgbWluIHNpbmNlIHdlXG4gICAgICAgICAgICAvLyB3aWxsIGdldCBlcnJvciBubyBtYXR0ZXIgd2hhdC5cbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5ub1ZpYWJsZUFsdChpbnB1dCwgb3V0ZXJDb250ZXh0LCBwcmV2aW91cywgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpbnB1dC5zZWVrKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIGFsdCA9IHRoaXMuZ2V0U3luVmFsaWRPclNlbUludmFsaWRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShwcmV2aW91cywgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIGlmKGFsdCE9PUFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhbHRTdWJTZXRzID0gUHJlZGljdGlvbk1vZGUuZ2V0Q29uZmxpY3RpbmdBbHRTdWJzZXRzKHJlYWNoKTtcbiAgICAgICAgaWYodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMTCBhbHRTdWJTZXRzPVwiICsgYWx0U3ViU2V0cyArIFwiLCBwcmVkaWN0PVwiICtcbiAgICAgICAgICAgICAgICAgIFByZWRpY3Rpb25Nb2RlLmdldFVuaXF1ZUFsdChhbHRTdWJTZXRzKSArIFwiLCByZXNvbHZlc1RvSnVzdE9uZVZpYWJsZUFsdD1cIiArXG4gICAgICAgICAgICAgICAgICBQcmVkaWN0aW9uTW9kZS5yZXNvbHZlc1RvSnVzdE9uZVZpYWJsZUFsdChhbHRTdWJTZXRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVhY2gudW5pcXVlQWx0ID0gdGhpcy5nZXRVbmlxdWVBbHQocmVhY2gpO1xuICAgICAgICAvLyB1bmlxdWUgcHJlZGljdGlvbj9cbiAgICAgICAgaWYocmVhY2gudW5pcXVlQWx0IT09QVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgcHJlZGljdGVkQWx0ID0gcmVhY2gudW5pcXVlQWx0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVkaWN0aW9uTW9kZSAhPT0gUHJlZGljdGlvbk1vZGUuTExfRVhBQ1RfQU1CSUdfREVURUNUSU9OKSB7XG4gICAgICAgICAgICBwcmVkaWN0ZWRBbHQgPSBQcmVkaWN0aW9uTW9kZS5yZXNvbHZlc1RvSnVzdE9uZVZpYWJsZUFsdChhbHRTdWJTZXRzKTtcbiAgICAgICAgICAgIGlmKHByZWRpY3RlZEFsdCAhPT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gZXhhY3QgYW1iaWd1aXR5IG1vZGUsIHdlIG5ldmVyIHRyeSB0byB0ZXJtaW5hdGUgZWFybHkuXG4gICAgICAgICAgICAvLyBKdXN0IGtlZXBzIHNjYXJmaW5nIHVudGlsIHdlIGtub3cgd2hhdCB0aGUgY29uZmxpY3QgaXNcbiAgICAgICAgICAgIGlmIChQcmVkaWN0aW9uTW9kZS5hbGxTdWJzZXRzQ29uZmxpY3QoYWx0U3ViU2V0cykgJiYgUHJlZGljdGlvbk1vZGUuYWxsU3Vic2V0c0VxdWFsKGFsdFN1YlNldHMpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFeGFjdEFtYmlnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRBbHQgPSBQcmVkaWN0aW9uTW9kZS5nZXRTaW5nbGVWaWFibGVBbHQoYWx0U3ViU2V0cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHRoZXJlIGFyZSBtdWx0aXBsZSBub24tY29uZmxpY3Rpbmcgc3Vic2V0cyBvclxuICAgICAgICAgICAgLy8gd2UncmUgbm90IHN1cmUgd2hhdCB0aGUgYW1iaWd1aXR5IGlzIHlldC5cbiAgICAgICAgICAgIC8vIFNvLCBrZWVwIGdvaW5nLlxuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gcmVhY2g7XG4gICAgICAgIGlmKCB0ICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgIGlucHV0LmNvbnN1bWUoKTtcbiAgICAgICAgICAgIHQgPSBpbnB1dC5MQSgxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBzZXQgdW5pcXVlbHkgcHJlZGljdHMgYW4gYWx0ZXJuYXRpdmUsXG4gICAgLy8gd2l0aG91dCBjb25mbGljdCwgdGhlbiB3ZSBrbm93IHRoYXQgaXQncyBhIGZ1bGwgTEwgZGVjaXNpb25cbiAgICAvLyBub3QgU0xMLlxuICAgIGlmIChyZWFjaC51bmlxdWVBbHQgIT09IEFUTi5JTlZBTElEX0FMVF9OVU1CRVIgKSB7XG4gICAgICAgIHRoaXMucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5KGRmYSwgcHJlZGljdGVkQWx0LCByZWFjaCwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgpO1xuICAgICAgICByZXR1cm4gcHJlZGljdGVkQWx0O1xuICAgIH1cbiAgICAvLyBXZSBkbyBub3QgY2hlY2sgcHJlZGljYXRlcyBoZXJlIGJlY2F1c2Ugd2UgaGF2ZSBjaGVja2VkIHRoZW1cbiAgICAvLyBvbi10aGUtZmx5IHdoZW4gZG9pbmcgZnVsbCBjb250ZXh0IHByZWRpY3Rpb24uXG5cbiAgICAvL1xuICAgIC8vIEluIG5vbi1leGFjdCBhbWJpZ3VpdHkgZGV0ZWN0aW9uIG1vZGUsIHdlIG1pZ2h0XHRhY3R1YWxseSBiZSBhYmxlIHRvXG4gICAgLy8gZGV0ZWN0IGFuIGV4YWN0IGFtYmlndWl0eSwgYnV0IEknbSBub3QgZ29pbmcgdG8gc3BlbmQgdGhlIGN5Y2xlc1xuICAgIC8vIG5lZWRlZCB0byBjaGVjay4gV2Ugb25seSBlbWl0IGFtYmlndWl0eSB3YXJuaW5ncyBpbiBleGFjdCBhbWJpZ3VpdHlcbiAgICAvLyBtb2RlLlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHdlIG1pZ2h0IGtub3cgdGhhdCB3ZSBoYXZlIGNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb25zLlxuICAgIC8vIEJ1dCwgdGhhdCBkb2VzIG5vdCBtZWFuIHRoYXQgdGhlcmUgaXMgbm8gd2F5IGZvcndhcmQgd2l0aG91dCBhXG4gICAgLy8gY29uZmxpY3QuIEl0J3MgcG9zc2libGUgdG8gaGF2ZSBub25jb25mbGljdGluZyBhbHQgc3Vic2V0cyBhcyBpbjpcblxuICAgIC8vIGFsdFN1YlNldHM9W3sxLCAyfSwgezEsIDJ9LCB7MX0sIHsxLCAyfV1cblxuICAgIC8vIGZyb21cbiAgICAvL1xuICAgIC8vICAgIFsoMTcsMSxbNSAkXSksICgxMywxLFs1IDEwICRdKSwgKDIxLDEsWzUgMTAgJF0pLCAoMTEsMSxbJF0pLFxuICAgIC8vICAgICAoMTMsMixbNSAxMCAkXSksICgyMSwyLFs1IDEwICRdKSwgKDExLDIsWyRdKV1cbiAgICAvL1xuICAgIC8vIEluIHRoaXMgY2FzZSwgKDE3LDEsWzUgJF0pIGluZGljYXRlcyB0aGVyZSBpcyBzb21lIG5leHQgc2VxdWVuY2UgdGhhdFxuICAgIC8vIHdvdWxkIHJlc29sdmUgdGhpcyB3aXRob3V0IGNvbmZsaWN0IHRvIGFsdGVybmF0aXZlIDEuIEFueSBvdGhlciB2aWFibGVcbiAgICAvLyBuZXh0IHNlcXVlbmNlLCBob3dldmVyLCBpcyBhc3NvY2lhdGVkIHdpdGggYSBjb25mbGljdC4gIFdlIHN0b3BcbiAgICAvLyBsb29raW5nIGZvciBpbnB1dCBiZWNhdXNlIG5vIGFtb3VudCBvZiBmdXJ0aGVyIGxvb2thaGVhZCB3aWxsIGFsdGVyXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBzaG91bGQgcHJlZGljdCBhbHRlcm5hdGl2ZSAxLiAgV2UganVzdCBjYW4ndCBzYXkgZm9yXG4gICAgLy8gc3VyZSB0aGF0IHRoZXJlIGlzIGFuIGFtYmlndWl0eSB3aXRob3V0IGxvb2tpbmcgZnVydGhlci5cblxuICAgIHRoaXMucmVwb3J0QW1iaWd1aXR5KGRmYSwgRCwgc3RhcnRJbmRleCwgaW5wdXQuaW5kZXgsIGZvdW5kRXhhY3RBbWJpZywgbnVsbCwgcmVhY2gpO1xuXG4gICAgcmV0dXJuIHByZWRpY3RlZEFsdDtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY29tcHV0ZVJlYWNoU2V0ID0gZnVuY3Rpb24oY2xvc3VyZSwgdCwgZnVsbEN0eCkge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4gY29tcHV0ZVJlYWNoU2V0LCBzdGFydGluZyBjbG9zdXJlOiBcIiArIGNsb3N1cmUpO1xuICAgIH1cbiAgICBpZiggdGhpcy5tZXJnZUNhY2hlPT09bnVsbCkge1xuICAgICAgICB0aGlzLm1lcmdlQ2FjaGUgPSBuZXcgRG91YmxlRGljdCgpO1xuICAgIH1cbiAgICB2YXIgaW50ZXJtZWRpYXRlID0gbmV3IEFUTkNvbmZpZ1NldChmdWxsQ3R4KTtcblxuICAgIC8vIENvbmZpZ3VyYXRpb25zIGFscmVhZHkgaW4gYSBydWxlIHN0b3Agc3RhdGUgaW5kaWNhdGUgcmVhY2hpbmcgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBkZWNpc2lvbiBydWxlIChsb2NhbCBjb250ZXh0KSBvciBlbmQgb2YgdGhlIHN0YXJ0IHJ1bGUgKGZ1bGxcbiAgICAvLyBjb250ZXh0KS4gT25jZSByZWFjaGVkLCB0aGVzZSBjb25maWd1cmF0aW9ucyBhcmUgbmV2ZXIgdXBkYXRlZCBieSBhXG4gICAgLy8gY2xvc3VyZSBvcGVyYXRpb24sIHNvIHRoZXkgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSBmb3IgdGhlIHBlcmZvcm1hbmNlXG4gICAgLy8gYWR2YW50YWdlIG9mIGhhdmluZyBhIHNtYWxsZXIgaW50ZXJtZWRpYXRlIHNldCB3aGVuIGNhbGxpbmcgY2xvc3VyZS5cbiAgICAvL1xuICAgIC8vIEZvciBmdWxsLWNvbnRleHQgcmVhY2ggb3BlcmF0aW9ucywgc2VwYXJhdGUgaGFuZGxpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYWx0ZXJuYXRpdmUgbWF0Y2hpbmcgdGhlIGxvbmdlc3Qgb3ZlcmFsbCBzZXF1ZW5jZSBpc1xuICAgIC8vIGNob3NlbiB3aGVuIG11bHRpcGxlIHN1Y2ggY29uZmlndXJhdGlvbnMgY2FuIG1hdGNoIHRoZSBpbnB1dC5cblxuICAgIHZhciBza2lwcGVkU3RvcFN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBGaXJzdCBmaWd1cmUgb3V0IHdoZXJlIHdlIGNhbiByZWFjaCBvbiBpbnB1dCB0XG4gICAgZm9yICh2YXIgaT0wOyBpPGNsb3N1cmUuaXRlbXMubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgYyA9IGNsb3N1cmUuaXRlbXNbaV07XG4gICAgICAgIGlmKHRoaXMuZGVidWdfYWRkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlc3RpbmcgXCIgKyB0aGlzLmdldFRva2VuTmFtZSh0KSArIFwiIGF0IFwiICsgYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoZnVsbEN0eCB8fCB0ID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZFN0b3BTdGF0ZXM9PT1udWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRTdG9wU3RhdGVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXBwZWRTdG9wU3RhdGVzLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5kZWJ1Z19hZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZGRlZCBcIiArIGMgKyBcIiB0byBza2lwcGVkU3RvcFN0YXRlc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGo9MDtqPGMuc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoO2orKykge1xuICAgICAgICAgICAgdmFyIHRyYW5zID0gYy5zdGF0ZS50cmFuc2l0aW9uc1tqXTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFJlYWNoYWJsZVRhcmdldCh0cmFucywgdCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IT09bnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjZmcgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTp0YXJnZXR9LCBjKTtcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUuYWRkKGNmZywgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmRlYnVnX2FkZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImFkZGVkIFwiICsgY2ZnICsgXCIgdG8gaW50ZXJtZWRpYXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3cgZmlndXJlIG91dCB3aGVyZSB0aGUgcmVhY2ggb3BlcmF0aW9uIGNhbiB0YWtlIHVzLi4uXG4gICAgdmFyIHJlYWNoID0gbnVsbDtcblxuICAgIC8vIFRoaXMgYmxvY2sgb3B0aW1pemVzIHRoZSByZWFjaCBvcGVyYXRpb24gZm9yIGludGVybWVkaWF0ZSBzZXRzIHdoaWNoXG4gICAgLy8gdHJpdmlhbGx5IGluZGljYXRlIGEgdGVybWluYXRpb24gc3RhdGUgZm9yIHRoZSBvdmVyYWxsXG4gICAgLy8gYWRhcHRpdmVQcmVkaWN0IG9wZXJhdGlvbi5cbiAgICAvL1xuICAgIC8vIFRoZSBjb25kaXRpb25zIGFzc3VtZSB0aGF0IGludGVybWVkaWF0ZVxuICAgIC8vIGNvbnRhaW5zIGFsbCBjb25maWd1cmF0aW9ucyByZWxldmFudCB0byB0aGUgcmVhY2ggc2V0LCBidXQgdGhpc1xuICAgIC8vIGNvbmRpdGlvbiBpcyBub3QgdHJ1ZSB3aGVuIG9uZSBvciBtb3JlIGNvbmZpZ3VyYXRpb25zIGhhdmUgYmVlblxuICAgIC8vIHdpdGhoZWxkIGluIHNraXBwZWRTdG9wU3RhdGVzLCBvciB3aGVuIHRoZSBjdXJyZW50IHN5bWJvbCBpcyBFT0YuXG4gICAgLy9cbiAgICBpZiAoc2tpcHBlZFN0b3BTdGF0ZXM9PT1udWxsICYmIHQhPT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZS5pdGVtcy5sZW5ndGg9PT0xKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBwdXJzdWUgdGhlIGNsb3N1cmUgaWYgdGhlcmUgaXMganVzdCBvbmUgc3RhdGUuXG4gICAgICAgICAgICAvLyBJdCBjYW4gb25seSBoYXZlIG9uZSBhbHRlcm5hdGl2ZTsganVzdCBhZGQgdG8gcmVzdWx0XG4gICAgICAgICAgICAvLyBBbHNvIGRvbid0IHB1cnN1ZSB0aGUgY2xvc3VyZSBpZiB0aGVyZSBpcyB1bmlxdWUgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIC8vIGFtb25nIHRoZSBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICAgIHJlYWNoID0gaW50ZXJtZWRpYXRlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0VW5pcXVlQWx0KGludGVybWVkaWF0ZSkhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgICAgICAvLyBBbHNvIGRvbid0IHB1cnN1ZSB0aGUgY2xvc3VyZSBpZiB0aGVyZSBpcyB1bmlxdWUgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIC8vIGFtb25nIHRoZSBjb25maWd1cmF0aW9ucy5cbiAgICAgICAgICAgIHJlYWNoID0gaW50ZXJtZWRpYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSByZWFjaCBzZXQgY291bGQgbm90IGJlIHRyaXZpYWxseSBkZXRlcm1pbmVkLCBwZXJmb3JtIGEgY2xvc3VyZVxuICAgIC8vIG9wZXJhdGlvbiBvbiB0aGUgaW50ZXJtZWRpYXRlIHNldCB0byBjb21wdXRlIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgIC8vXG4gICAgaWYgKHJlYWNoPT09bnVsbCkge1xuICAgICAgICByZWFjaCA9IG5ldyBBVE5Db25maWdTZXQoZnVsbEN0eCk7XG4gICAgICAgIHZhciBjbG9zdXJlQnVzeSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHRyZWF0RW9mQXNFcHNpbG9uID0gdCA9PT0gVG9rZW4uRU9GO1xuICAgICAgICBmb3IgKHZhciBrPTA7IGs8aW50ZXJtZWRpYXRlLml0ZW1zLmxlbmd0aDtrKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc3VyZShpbnRlcm1lZGlhdGUuaXRlbXNba10sIHJlYWNoLCBjbG9zdXJlQnVzeSwgZmFsc2UsIGZ1bGxDdHgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodCA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgIC8vIEFmdGVyIGNvbnN1bWluZyBFT0Ygbm8gYWRkaXRpb25hbCBpbnB1dCBpcyBwb3NzaWJsZSwgc28gd2UgYXJlXG4gICAgICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBjb25maWd1cmF0aW9ucyB3aGljaCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGRlY2lzaW9uIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiB0aGUgc3RhcnQgcnVsZSAoZnVsbFxuICAgICAgICAvLyBjb250ZXh0KS4gVXBkYXRlIHJlYWNoIHRvIGNvbnRhaW4gb25seSB0aGVzZSBjb25maWd1cmF0aW9ucy4gVGhpc1xuICAgICAgICAvLyBoYW5kbGVzIGJvdGggZXhwbGljaXQgRU9GIHRyYW5zaXRpb25zIGluIHRoZSBncmFtbWFyIGFuZCBpbXBsaWNpdFxuICAgICAgICAvLyBFT0YgdHJhbnNpdGlvbnMgZm9sbG93aW5nIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIG9yIHN0YXJ0IHJ1bGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoZW4gcmVhY2g9PWludGVybWVkaWF0ZSwgbm8gY2xvc3VyZSBvcGVyYXRpb24gd2FzIHBlcmZvcm1lZC4gSW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLCByZW1vdmVBbGxDb25maWdzTm90SW5SdWxlU3RvcFN0YXRlIG5lZWRzIHRvIGNoZWNrIGZvclxuICAgICAgICAvLyByZWFjaGFibGUgcnVsZSBzdG9wIHN0YXRlcyBhcyB3ZWxsIGFzIGNvbmZpZ3VyYXRpb25zIGFscmVhZHkgaW5cbiAgICAgICAgLy8gYSBydWxlIHN0b3Agc3RhdGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgaXMgaGFuZGxlZCBiZWZvcmUgdGhlIGNvbmZpZ3VyYXRpb25zIGluIHNraXBwZWRTdG9wU3RhdGVzLFxuICAgICAgICAvLyBiZWNhdXNlIGFueSBjb25maWd1cmF0aW9ucyBwb3RlbnRpYWxseSBhZGRlZCBmcm9tIHRoYXQgbGlzdCBhcmVcbiAgICAgICAgLy8gYWxyZWFkeSBndWFyYW50ZWVkIHRvIG1lZXQgdGhpcyBjb25kaXRpb24gd2hldGhlciBvciBub3QgaXQnc1xuICAgICAgICAvLyByZXF1aXJlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmVhY2ggPSB0aGlzLnJlbW92ZUFsbENvbmZpZ3NOb3RJblJ1bGVTdG9wU3RhdGUocmVhY2gsIHJlYWNoID09PSBpbnRlcm1lZGlhdGUpO1xuICAgIH1cbiAgICAvLyBJZiBza2lwcGVkU3RvcFN0YXRlcyE9PW51bGwsIHRoZW4gaXQgY29udGFpbnMgYXQgbGVhc3Qgb25lXG4gICAgLy8gY29uZmlndXJhdGlvbi4gRm9yIGZ1bGwtY29udGV4dCByZWFjaCBvcGVyYXRpb25zLCB0aGVzZVxuICAgIC8vIGNvbmZpZ3VyYXRpb25zIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RhcnQgcnVsZSwgaW4gd2hpY2ggY2FzZSB3ZVxuICAgIC8vIG9ubHkgYWRkIHRoZW0gYmFjayB0byByZWFjaCBpZiBubyBjb25maWd1cmF0aW9uIGR1cmluZyB0aGUgY3VycmVudFxuICAgIC8vIGNsb3N1cmUgb3BlcmF0aW9uIHJlYWNoZWQgc3VjaCBhIHN0YXRlLiBUaGlzIGVuc3VyZXMgYWRhcHRpdmVQcmVkaWN0XG4gICAgLy8gY2hvb3NlcyBhbiBhbHRlcm5hdGl2ZSBtYXRjaGluZyB0aGUgbG9uZ2VzdCBvdmVyYWxsIHNlcXVlbmNlIHdoZW5cbiAgICAvLyBtdWx0aXBsZSBhbHRlcm5hdGl2ZXMgYXJlIHZpYWJsZS5cbiAgICAvL1xuICAgIGlmIChza2lwcGVkU3RvcFN0YXRlcyE9PW51bGwgJiYgKCAoISBmdWxsQ3R4KSB8fCAoISBQcmVkaWN0aW9uTW9kZS5oYXNDb25maWdJblJ1bGVTdG9wU3RhdGUocmVhY2gpKSkpIHtcbiAgICAgICAgZm9yICh2YXIgbD0wOyBsPHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aDtsKyspIHtcbiAgICAgICAgICAgIHJlYWNoLmFkZChza2lwcGVkU3RvcFN0YXRlc1tsXSwgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVhY2guaXRlbXMubGVuZ3RoPT09MCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVhY2g7XG4gICAgfVxufTtcbi8vXG4vLyBSZXR1cm4gYSBjb25maWd1cmF0aW9uIHNldCBjb250YWluaW5nIG9ubHkgdGhlIGNvbmZpZ3VyYXRpb25zIGZyb21cbi8vIHtAY29kZSBjb25maWdzfSB3aGljaCBhcmUgaW4gYSB7QGxpbmsgUnVsZVN0b3BTdGF0ZX0uIElmIGFsbFxuLy8gY29uZmlndXJhdGlvbnMgaW4ge0Bjb2RlIGNvbmZpZ3N9IGFyZSBhbHJlYWR5IGluIGEgcnVsZSBzdG9wIHN0YXRlLCB0aGlzXG4vLyBtZXRob2Qgc2ltcGx5IHJldHVybnMge0Bjb2RlIGNvbmZpZ3N9LlxuLy9cbi8vIDxwPldoZW4ge0Bjb2RlIGxvb2tUb0VuZE9mUnVsZX0gaXMgdHJ1ZSwgdGhpcyBtZXRob2QgdXNlc1xuLy8ge0BsaW5rIEFUTi8vbmV4dFRva2Vuc30gZm9yIGVhY2ggY29uZmlndXJhdGlvbiBpbiB7QGNvZGUgY29uZmlnc30gd2hpY2ggaXNcbi8vIG5vdCBhbHJlYWR5IGluIGEgcnVsZSBzdG9wIHN0YXRlIHRvIHNlZSBpZiBhIHJ1bGUgc3RvcCBzdGF0ZSBpcyByZWFjaGFibGVcbi8vIGZyb20gdGhlIGNvbmZpZ3VyYXRpb24gdmlhIGVwc2lsb24tb25seSB0cmFuc2l0aW9ucy48L3A+XG4vL1xuLy8gQHBhcmFtIGNvbmZpZ3MgdGhlIGNvbmZpZ3VyYXRpb24gc2V0IHRvIHVwZGF0ZVxuLy8gQHBhcmFtIGxvb2tUb0VuZE9mUnVsZSB3aGVuIHRydWUsIHRoaXMgbWV0aG9kIGNoZWNrcyBmb3IgcnVsZSBzdG9wIHN0YXRlc1xuLy8gcmVhY2hhYmxlIGJ5IGVwc2lsb24tb25seSB0cmFuc2l0aW9ucyBmcm9tIGVhY2ggY29uZmlndXJhdGlvbiBpblxuLy8ge0Bjb2RlIGNvbmZpZ3N9LlxuLy9cbi8vIEByZXR1cm4ge0Bjb2RlIGNvbmZpZ3N9IGlmIGFsbCBjb25maWd1cmF0aW9ucyBpbiB7QGNvZGUgY29uZmlnc30gYXJlIGluIGFcbi8vIHJ1bGUgc3RvcCBzdGF0ZSwgb3RoZXJ3aXNlIHJldHVybiBhIG5ldyBjb25maWd1cmF0aW9uIHNldCBjb250YWluaW5nIG9ubHlcbi8vIHRoZSBjb25maWd1cmF0aW9ucyBmcm9tIHtAY29kZSBjb25maWdzfSB3aGljaCBhcmUgaW4gYSBydWxlIHN0b3Agc3RhdGVcbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlbW92ZUFsbENvbmZpZ3NOb3RJblJ1bGVTdG9wU3RhdGUgPSBmdW5jdGlvbihjb25maWdzLCBsb29rVG9FbmRPZlJ1bGUpIHtcbiAgICBpZiAoUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3M7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBuZXcgQVROQ29uZmlnU2V0KGNvbmZpZ3MuZnVsbEN0eCk7XG4gICAgZm9yKHZhciBpPTA7IGk8Y29uZmlncy5pdGVtcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va1RvRW5kT2ZSdWxlICYmIGNvbmZpZy5zdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VucyA9IHRoaXMuYXRuLm5leHRUb2tlbnMoY29uZmlnLnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChuZXh0VG9rZW5zLmNvbnRhaW5zKFRva2VuLkVQU0lMT04pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE9mUnVsZVN0YXRlID0gdGhpcy5hdG4ucnVsZVRvU3RvcFN0YXRlW2NvbmZpZy5zdGF0ZS5ydWxlSW5kZXhdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQobmV3IEFUTkNvbmZpZyh7c3RhdGU6ZW5kT2ZSdWxlU3RhdGV9LCBjb25maWcpLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNvbXB1dGVTdGFydFN0YXRlID0gZnVuY3Rpb24ocCwgY3R4LCBmdWxsQ3R4KSB7XG4gICAgLy8gYWx3YXlzIGF0IGxlYXN0IHRoZSBpbXBsaWNpdCBjYWxsIHRvIHN0YXJ0IHJ1bGVcbiAgICB2YXIgaW5pdGlhbENvbnRleHQgPSBwcmVkaWN0aW9uQ29udGV4dEZyb21SdWxlQ29udGV4dCh0aGlzLmF0biwgY3R4KTtcbiAgICB2YXIgY29uZmlncyA9IG5ldyBBVE5Db25maWdTZXQoZnVsbEN0eCk7XG4gICAgZm9yKHZhciBpPTA7aTxwLnRyYW5zaXRpb25zLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHAudHJhbnNpdGlvbnNbaV0udGFyZ2V0O1xuICAgICAgICB2YXIgYyA9IG5ldyBBVE5Db25maWcoeyBzdGF0ZTp0YXJnZXQsIGFsdDppKzEsIGNvbnRleHQ6aW5pdGlhbENvbnRleHQgfSwgbnVsbCk7XG4gICAgICAgIHZhciBjbG9zdXJlQnVzeSA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jbG9zdXJlKGMsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCB0cnVlLCBmdWxsQ3R4LCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdzO1xufTtcblxuLy9cbi8vIFRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgdGhlIHN0YXJ0IHN0YXRlIGNvbXB1dGVkIGJ5XG4vLyB7QGxpbmsgLy9jb21wdXRlU3RhcnRTdGF0ZX0gdG8gdGhlIHNwZWNpYWwgc3RhcnQgc3RhdGUgdXNlZCBieSBhXG4vLyBwcmVjZWRlbmNlIERGQSBmb3IgYSBwYXJ0aWN1bGFyIHByZWNlZGVuY2UgdmFsdWUuIFRoZSB0cmFuc2Zvcm1hdGlvblxuLy8gcHJvY2VzcyBhcHBsaWVzIHRoZSBmb2xsb3dpbmcgY2hhbmdlcyB0byB0aGUgc3RhcnQgc3RhdGUncyBjb25maWd1cmF0aW9uXG4vLyBzZXQuXG4vL1xuLy8gPG9sPlxuLy8gPGxpPkV2YWx1YXRlIHRoZSBwcmVjZWRlbmNlIHByZWRpY2F0ZXMgZm9yIGVhY2ggY29uZmlndXJhdGlvbiB1c2luZ1xuLy8ge0BsaW5rIFNlbWFudGljQ29udGV4dC8vZXZhbFByZWNlZGVuY2V9LjwvbGk+XG4vLyA8bGk+UmVtb3ZlIGFsbCBjb25maWd1cmF0aW9ucyB3aGljaCBwcmVkaWN0IGFuIGFsdGVybmF0aXZlIGdyZWF0ZXIgdGhhblxuLy8gMSwgZm9yIHdoaWNoIGFub3RoZXIgY29uZmlndXJhdGlvbiB0aGF0IHByZWRpY3RzIGFsdGVybmF0aXZlIDEgaXMgaW4gdGhlXG4vLyBzYW1lIEFUTiBzdGF0ZSB3aXRoIHRoZSBzYW1lIHByZWRpY3Rpb24gY29udGV4dC4gVGhpcyB0cmFuc2Zvcm1hdGlvbiBpc1xuLy8gdmFsaWQgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcbi8vIDx1bD5cbi8vIDxsaT5UaGUgY2xvc3VyZSBibG9jayBjYW5ub3QgY29udGFpbiBhbnkgZXBzaWxvbiB0cmFuc2l0aW9ucyB3aGljaCBieXBhc3Ncbi8vIHRoZSBib2R5IG9mIHRoZSBjbG9zdXJlLCBzbyBhbGwgc3RhdGVzIHJlYWNoYWJsZSB2aWEgYWx0ZXJuYXRpdmUgMSBhcmVcbi8vIHBhcnQgb2YgdGhlIHByZWNlZGVuY2UgYWx0ZXJuYXRpdmVzIG9mIHRoZSB0cmFuc2Zvcm1lZCBsZWZ0LXJlY3Vyc2l2ZVxuLy8gcnVsZS48L2xpPlxuLy8gPGxpPlRoZSBcInByaW1hcnlcIiBwb3J0aW9uIG9mIGEgbGVmdCByZWN1cnNpdmUgcnVsZSBjYW5ub3QgY29udGFpbiBhblxuLy8gZXBzaWxvbiB0cmFuc2l0aW9uLCBzbyB0aGUgb25seSB3YXkgYW4gYWx0ZXJuYXRpdmUgb3RoZXIgdGhhbiAxIGNhbiBleGlzdFxuLy8gaW4gYSBzdGF0ZSB0aGF0IGlzIGFsc28gcmVhY2hhYmxlIHZpYSBhbHRlcm5hdGl2ZSAxIGlzIGJ5IG5lc3RpbmcgY2FsbHNcbi8vIHRvIHRoZSBsZWZ0LXJlY3Vyc2l2ZSBydWxlLCB3aXRoIHRoZSBvdXRlciBjYWxscyBub3QgYmVpbmcgYXQgdGhlXG4vLyBwcmVmZXJyZWQgcHJlY2VkZW5jZSBsZXZlbC48L2xpPlxuLy8gPC91bD5cbi8vIDwvbGk+XG4vLyA8L29sPlxuLy9cbi8vIDxwPlxuLy8gVGhlIHByZWRpY3Rpb24gY29udGV4dCBtdXN0IGJlIGNvbnNpZGVyZWQgYnkgdGhpcyBmaWx0ZXIgdG8gYWRkcmVzc1xuLy8gc2l0dWF0aW9ucyBsaWtlIHRoZSBmb2xsb3dpbmcuXG4vLyA8L3A+XG4vLyA8Y29kZT5cbi8vIDxwcmU+XG4vLyBncmFtbWFyIFRBO1xuLy8gcHJvZzogc3RhdGVtZW50KiBFT0Y7XG4vLyBzdGF0ZW1lbnQ6IGxldHRlckEgfCBzdGF0ZW1lbnQgbGV0dGVyQSAnYicgO1xuLy8gbGV0dGVyQTogJ2EnO1xuLy8gPC9wcmU+XG4vLyA8L2NvZGU+XG4vLyA8cD5cbi8vIElmIHRoZSBhYm92ZSBncmFtbWFyLCB0aGUgQVROIHN0YXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgdG9rZW5cbi8vIHJlZmVyZW5jZSB7QGNvZGUgJ2EnfSBpbiB7QGNvZGUgbGV0dGVyQX0gaXMgcmVhY2hhYmxlIGZyb20gdGhlIGxlZnQgZWRnZVxuLy8gb2YgYm90aCB0aGUgcHJpbWFyeSBhbmQgY2xvc3VyZSBibG9ja3Mgb2YgdGhlIGxlZnQtcmVjdXJzaXZlIHJ1bGVcbi8vIHtAY29kZSBzdGF0ZW1lbnR9LiBUaGUgcHJlZGljdGlvbiBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCBlYWNoIG9mIHRoZXNlXG4vLyBjb25maWd1cmF0aW9ucyBkaXN0aW5ndWlzaGVzIGJldHdlZW4gdGhlbSwgYW5kIHByZXZlbnRzIHRoZSBhbHRlcm5hdGl2ZVxuLy8gd2hpY2ggc3RlcHBlZCBvdXQgdG8ge0Bjb2RlIHByb2d9IChhbmQgdGhlbiBiYWNrIGluIHRvIHtAY29kZSBzdGF0ZW1lbnR9XG4vLyBmcm9tIGJlaW5nIGVsaW1pbmF0ZWQgYnkgdGhlIGZpbHRlci5cbi8vIDwvcD5cbi8vXG4vLyBAcGFyYW0gY29uZmlncyBUaGUgY29uZmlndXJhdGlvbiBzZXQgY29tcHV0ZWQgYnlcbi8vIHtAbGluayAvL2NvbXB1dGVTdGFydFN0YXRlfSBhcyB0aGUgc3RhcnQgc3RhdGUgZm9yIHRoZSBERkEuXG4vLyBAcmV0dXJuIFRoZSB0cmFuc2Zvcm1lZCBjb25maWd1cmF0aW9uIHNldCByZXByZXNlbnRpbmcgdGhlIHN0YXJ0IHN0YXRlXG4vLyBmb3IgYSBwcmVjZWRlbmNlIERGQSBhdCBhIHBhcnRpY3VsYXIgcHJlY2VkZW5jZSBsZXZlbCAoZGV0ZXJtaW5lZCBieVxuLy8gY2FsbGluZyB7QGxpbmsgUGFyc2VyLy9nZXRQcmVjZWRlbmNlfSkuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5hcHBseVByZWNlZGVuY2VGaWx0ZXIgPSBmdW5jdGlvbihjb25maWdzKSB7XG5cdHZhciBjb25maWc7XG5cdHZhciBzdGF0ZXNGcm9tQWx0MSA9IFtdO1xuICAgIHZhciBjb25maWdTZXQgPSBuZXcgQVROQ29uZmlnU2V0KGNvbmZpZ3MuZnVsbEN0eCk7XG4gICAgZm9yKHZhciBpPTA7IGk8Y29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25maWcgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICAvLyBoYW5kbGUgYWx0IDEgZmlyc3RcbiAgICAgICAgaWYgKGNvbmZpZy5hbHQgIT09IDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVkQ29udGV4dCA9IGNvbmZpZy5zZW1hbnRpY0NvbnRleHQuZXZhbFByZWNlZGVuY2UodGhpcy5wYXJzZXIsIHRoaXMuX291dGVyQ29udGV4dCk7XG4gICAgICAgIGlmICh1cGRhdGVkQ29udGV4dD09PW51bGwpIHtcbiAgICAgICAgICAgIC8vIHRoZSBjb25maWd1cmF0aW9uIHdhcyBlbGltaW5hdGVkXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZXNGcm9tQWx0MVtjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJdID0gY29uZmlnLmNvbnRleHQ7XG4gICAgICAgIGlmICh1cGRhdGVkQ29udGV4dCAhPT0gY29uZmlnLnNlbWFudGljQ29udGV4dCkge1xuICAgICAgICAgICAgY29uZmlnU2V0LmFkZChuZXcgQVROQ29uZmlnKHtzZW1hbnRpY0NvbnRleHQ6dXBkYXRlZENvbnRleHR9LCBjb25maWcpLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnU2V0LmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKGk9MDsgaTxjb25maWdzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgIGlmIChjb25maWcuYWx0ID09PSAxKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGhhbmRsZWRcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBmdXR1cmUsIHRoaXMgZWxpbWluYXRpb24gc3RlcCBjb3VsZCBiZSB1cGRhdGVkIHRvIGFsc29cbiAgICAgICAgLy8gZmlsdGVyIHRoZSBwcmVkaWN0aW9uIGNvbnRleHQgZm9yIGFsdGVybmF0aXZlcyBwcmVkaWN0aW5nIGFsdD4xXG4gICAgICAgIC8vIChiYXNpY2FsbHkgYSBncmFwaCBzdWJ0cmFjdGlvbiBhbGdvcml0aG0pLlxuXHRcdGlmICghY29uZmlnLnByZWNlZGVuY2VGaWx0ZXJTdXBwcmVzc2VkKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHN0YXRlc0Zyb21BbHQxW2NvbmZpZy5zdGF0ZS5zdGF0ZU51bWJlcl0gfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChjb250ZXh0IT09bnVsbCAmJiBjb250ZXh0LmVxdWFscyhjb25maWcuY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbGltaW5hdGVkXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cdFx0fVxuICAgICAgICBjb25maWdTZXQuYWRkKGNvbmZpZywgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZ1NldDtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0UmVhY2hhYmxlVGFyZ2V0ID0gZnVuY3Rpb24odHJhbnMsIHR0eXBlKSB7XG4gICAgaWYgKHRyYW5zLm1hdGNoZXModHR5cGUsIDAsIHRoaXMuYXRuLm1heFRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zLnRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFByZWRzRm9yQW1iaWdBbHRzID0gZnVuY3Rpb24oYW1iaWdBbHRzLCBjb25maWdzLCBuYWx0cykge1xuICAgIC8vIFJFQUNIPVsxfDF8W118MDowLCAxfDJ8W118MDoxXVxuICAgIC8vIGFsdFRvUHJlZCBzdGFydHMgYXMgYW4gYXJyYXkgb2YgYWxsIG51bGwgY29udGV4dHMuIFRoZSBlbnRyeSBhdCBpbmRleCBpXG4gICAgLy8gY29ycmVzcG9uZHMgdG8gYWx0ZXJuYXRpdmUgaS4gYWx0VG9QcmVkW2ldIG1heSBoYXZlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XG4gICAgLy8gICAxLiBudWxsOiBubyBBVE5Db25maWcgYyBpcyBmb3VuZCBzdWNoIHRoYXQgYy5hbHQ9PWlcbiAgICAvLyAgIDIuIFNlbWFudGljQ29udGV4dC5OT05FOiBBdCBsZWFzdCBvbmUgQVROQ29uZmlnIGMgZXhpc3RzIHN1Y2ggdGhhdFxuICAgIC8vICAgICAgYy5hbHQ9PWkgYW5kIGMuc2VtYW50aWNDb250ZXh0PT1TZW1hbnRpY0NvbnRleHQuTk9ORS4gSW4gb3RoZXIgd29yZHMsXG4gICAgLy8gICAgICBhbHQgaSBoYXMgYXQgbGVhc3Qgb25lIHVucHJlZGljYXRlZCBjb25maWcuXG4gICAgLy8gICAzLiBOb24tTk9ORSBTZW1hbnRpYyBDb250ZXh0OiBUaGVyZSBleGlzdHMgYXQgbGVhc3Qgb25lLCBhbmQgZm9yIGFsbFxuICAgIC8vICAgICAgQVROQ29uZmlnIGMgc3VjaCB0aGF0IGMuYWx0PT1pLCBjLnNlbWFudGljQ29udGV4dCE9U2VtYW50aWNDb250ZXh0Lk5PTkUuXG4gICAgLy9cbiAgICAvLyBGcm9tIHRoaXMsIGl0IGlzIGNsZWFyIHRoYXQgTk9ORXx8YW55dGhpbmc9PU5PTkUuXG4gICAgLy9cbiAgICB2YXIgYWx0VG9QcmVkID0gW107XG4gICAgZm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDtpKyspIHtcbiAgICAgICAgdmFyIGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZihhbWJpZ0FsdHMuY29udGFpbnMoIGMuYWx0ICkpIHtcbiAgICAgICAgICAgIGFsdFRvUHJlZFtjLmFsdF0gPSBTZW1hbnRpY0NvbnRleHQub3JDb250ZXh0KGFsdFRvUHJlZFtjLmFsdF0gfHwgbnVsbCwgYy5zZW1hbnRpY0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBuUHJlZEFsdHMgPSAwO1xuICAgIGZvciAoaSA9MTtpPCBuYWx0cysxO2krKykge1xuICAgICAgICB2YXIgcHJlZCA9IGFsdFRvUHJlZFtpXSB8fCBudWxsO1xuICAgICAgICBpZiAocHJlZD09PW51bGwpIHtcbiAgICAgICAgICAgIGFsdFRvUHJlZFtpXSA9IFNlbWFudGljQ29udGV4dC5OT05FO1xuICAgICAgICB9IGVsc2UgaWYgKHByZWQgIT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgICBuUHJlZEFsdHMgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBub25hbWJpZyBhbHRzIGFyZSBudWxsIGluIGFsdFRvUHJlZFxuICAgIGlmIChuUHJlZEFsdHM9PT0wKSB7XG4gICAgICAgIGFsdFRvUHJlZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0UHJlZHNGb3JBbWJpZ0FsdHMgcmVzdWx0IFwiICsgVXRpbHMuYXJyYXlUb1N0cmluZyhhbHRUb1ByZWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsdFRvUHJlZDtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0UHJlZGljYXRlUHJlZGljdGlvbnMgPSBmdW5jdGlvbihhbWJpZ0FsdHMsIGFsdFRvUHJlZCkge1xuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIHZhciBjb250YWluc1ByZWRpY2F0ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGk9MTsgaTxhbHRUb1ByZWQubGVuZ3RoO2krKykge1xuICAgICAgICB2YXIgcHJlZCA9IGFsdFRvUHJlZFtpXTtcbiAgICAgICAgLy8gdW5wcmVkaWNhdGVkIGlzIGluZGljYXRlZCBieSBTZW1hbnRpY0NvbnRleHQuTk9ORVxuICAgICAgICBpZiggYW1iaWdBbHRzIT09bnVsbCAmJiBhbWJpZ0FsdHMuY29udGFpbnMoIGkgKSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaChuZXcgUHJlZFByZWRpY3Rpb24ocHJlZCwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVkICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgICAgY29udGFpbnNQcmVkaWNhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghIGNvbnRhaW5zUHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59O1xuXG4vL1xuLy8gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBpbXByb3ZlIHRoZSBsb2NhbGl6YXRpb24gb2YgZXJyb3IgbWVzc2FnZXMgYnlcbi8vIGNob29zaW5nIGFuIGFsdGVybmF0aXZlIHJhdGhlciB0aGFuIHRocm93aW5nIGFcbi8vIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0gaW4gcGFydGljdWxhciBwcmVkaWN0aW9uIHNjZW5hcmlvcyB3aGVyZSB0aGVcbi8vIHtAbGluayAvL0VSUk9SfSBzdGF0ZSB3YXMgcmVhY2hlZCBkdXJpbmcgQVROIHNpbXVsYXRpb24uXG4vL1xuLy8gPHA+XG4vLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCB1c2VzIHRoZSBmb2xsb3dpbmdcbi8vIGFsZ29yaXRobSB0byBpZGVudGlmeSBhbiBBVE4gY29uZmlndXJhdGlvbiB3aGljaCBzdWNjZXNzZnVsbHkgcGFyc2VkIHRoZVxuLy8gZGVjaXNpb24gZW50cnkgcnVsZS4gQ2hvb3Npbmcgc3VjaCBhbiBhbHRlcm5hdGl2ZSBlbnN1cmVzIHRoYXQgdGhlXG4vLyB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHR9IHJldHVybmVkIGJ5IHRoZSBjYWxsaW5nIHJ1bGUgd2lsbCBiZSBjb21wbGV0ZVxuLy8gYW5kIHZhbGlkLCBhbmQgdGhlIHN5bnRheCBlcnJvciB3aWxsIGJlIHJlcG9ydGVkIGxhdGVyIGF0IGEgbW9yZVxuLy8gbG9jYWxpemVkIGxvY2F0aW9uLjwvcD5cbi8vXG4vLyA8dWw+XG4vLyA8bGk+SWYgYSBzeW50YWN0aWNhbGx5IHZhbGlkIHBhdGggb3IgcGF0aHMgcmVhY2ggdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSBhbmRcbi8vIHRoZXkgYXJlIHNlbWFudGljYWxseSB2YWxpZCBpZiBwcmVkaWNhdGVkLCByZXR1cm4gdGhlIG1pbiBhc3NvY2lhdGVkIGFsdC48L2xpPlxuLy8gPGxpPkVsc2UsIGlmIGEgc2VtYW50aWNhbGx5IGludmFsaWQgYnV0IHN5bnRhY3RpY2FsbHkgdmFsaWQgcGF0aCBleGlzdFxuLy8gb3IgcGF0aHMgZXhpc3QsIHJldHVybiB0aGUgbWluaW11bSBhc3NvY2lhdGVkIGFsdC5cbi8vIDwvbGk+XG4vLyA8bGk+T3RoZXJ3aXNlLCByZXR1cm4ge0BsaW5rIEFUTi8vSU5WQUxJRF9BTFRfTlVNQkVSfS48L2xpPlxuLy8gPC91bD5cbi8vXG4vLyA8cD5cbi8vIEluIHNvbWUgc2NlbmFyaW9zLCB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBhYm92ZSBjb3VsZCBwcmVkaWN0IGFuXG4vLyBhbHRlcm5hdGl2ZSB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIHtAbGluayBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb259IGluXG4vLyB0aGUgcGFyc2VyLiBTcGVjaWZpY2FsbHksIHRoaXMgY291bGQgb2NjdXIgaWYgdGhlIDxlbT5vbmx5PC9lbT4gY29uZmlndXJhdGlvblxuLy8gY2FwYWJsZSBvZiBzdWNjZXNzZnVsbHkgcGFyc2luZyB0byB0aGUgZW5kIG9mIHRoZSBkZWNpc2lvbiBydWxlIGlzXG4vLyBibG9ja2VkIGJ5IGEgc2VtYW50aWMgcHJlZGljYXRlLiBCeSBjaG9vc2luZyB0aGlzIGFsdGVybmF0aXZlIHdpdGhpblxuLy8ge0BsaW5rIC8vYWRhcHRpdmVQcmVkaWN0fSBpbnN0ZWFkIG9mIHRocm93aW5nIGFcbi8vIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0sIHRoZSByZXN1bHRpbmdcbi8vIHtAbGluayBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb259IGluIHRoZSBwYXJzZXIgd2lsbCBpZGVudGlmeSB0aGUgc3BlY2lmaWNcbi8vIHByZWRpY2F0ZSB3aGljaCBpcyBwcmV2ZW50aW5nIHRoZSBwYXJzZXIgZnJvbSBzdWNjZXNzZnVsbHkgcGFyc2luZyB0aGVcbi8vIGRlY2lzaW9uIHJ1bGUsIHdoaWNoIGhlbHBzIGRldmVsb3BlcnMgaWRlbnRpZnkgYW5kIGNvcnJlY3QgbG9naWMgZXJyb3JzXG4vLyBpbiBzZW1hbnRpYyBwcmVkaWNhdGVzLlxuLy8gPC9wPlxuLy9cbi8vIEBwYXJhbSBjb25maWdzIFRoZSBBVE4gY29uZmlndXJhdGlvbnMgd2hpY2ggd2VyZSB2YWxpZCBpbW1lZGlhdGVseSBiZWZvcmVcbi8vIHRoZSB7QGxpbmsgLy9FUlJPUn0gc3RhdGUgd2FzIHJlYWNoZWRcbi8vIEBwYXJhbSBvdXRlckNvbnRleHQgVGhlIGlzIHRoZSBcXGdhbW1hXzAgaW5pdGlhbCBwYXJzZXIgY29udGV4dCBmcm9tIHRoZSBwYXBlclxuLy8gb3IgdGhlIHBhcnNlciBzdGFjayBhdCB0aGUgaW5zdGFudCBiZWZvcmUgcHJlZGljdGlvbiBjb21tZW5jZXMuXG4vL1xuLy8gQHJldHVybiBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20ge0BsaW5rIC8vYWRhcHRpdmVQcmVkaWN0fSwgb3Jcbi8vIHtAbGluayBBVE4vL0lOVkFMSURfQUxUX05VTUJFUn0gaWYgYSBzdWl0YWJsZSBhbHRlcm5hdGl2ZSB3YXMgbm90XG4vLyBpZGVudGlmaWVkIGFuZCB7QGxpbmsgLy9hZGFwdGl2ZVByZWRpY3R9IHNob3VsZCByZXBvcnQgYW4gZXJyb3IgaW5zdGVhZC5cbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFN5blZhbGlkT3JTZW1JbnZhbGlkQWx0VGhhdEZpbmlzaGVkRGVjaXNpb25FbnRyeVJ1bGUgPSBmdW5jdGlvbihjb25maWdzLCBvdXRlckNvbnRleHQpIHtcbiAgICB2YXIgY2ZncyA9IHRoaXMuc3BsaXRBY2NvcmRpbmdUb1NlbWFudGljVmFsaWRpdHkoY29uZmlncywgb3V0ZXJDb250ZXh0KTtcbiAgICB2YXIgc2VtVmFsaWRDb25maWdzID0gY2Znc1swXTtcbiAgICB2YXIgc2VtSW52YWxpZENvbmZpZ3MgPSBjZmdzWzFdO1xuICAgIHZhciBhbHQgPSB0aGlzLmdldEFsdFRoYXRGaW5pc2hlZERlY2lzaW9uRW50cnlSdWxlKHNlbVZhbGlkQ29uZmlncyk7XG4gICAgaWYgKGFsdCE9PUFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHsgLy8gc2VtYW50aWNhbGx5L3N5bnRhY3RpY2FsbHkgdmlhYmxlIHBhdGggZXhpc3RzXG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgfVxuICAgIC8vIElzIHRoZXJlIGEgc3ludGFjdGljYWxseSB2YWxpZCBwYXRoIHdpdGggYSBmYWlsZWQgcHJlZD9cbiAgICBpZiAoc2VtSW52YWxpZENvbmZpZ3MuaXRlbXMubGVuZ3RoPjApIHtcbiAgICAgICAgYWx0ID0gdGhpcy5nZXRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZShzZW1JbnZhbGlkQ29uZmlncyk7XG4gICAgICAgIGlmIChhbHQhPT1BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7IC8vIHN5bnRhY3RpY2FsbHkgdmlhYmxlIHBhdGggZXhpc3RzXG4gICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRBbHRUaGF0RmluaXNoZWREZWNpc2lvbkVudHJ5UnVsZSA9IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICB2YXIgYWx0cyA9IFtdO1xuICAgIGZvcih2YXIgaT0wO2k8Y29uZmlncy5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNvbmZpZ3MuaXRlbXNbaV07XG4gICAgICAgIGlmIChjLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0PjAgfHwgKChjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkgJiYgYy5jb250ZXh0Lmhhc0VtcHR5UGF0aCgpKSkge1xuICAgICAgICAgICAgaWYoYWx0cy5pbmRleE9mKGMuYWx0KTwwKSB7XG4gICAgICAgICAgICAgICAgYWx0cy5wdXNoKGMuYWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0cy5sZW5ndGg9PT0wKSB7XG4gICAgICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShudWxsLCBhbHRzKTtcbiAgICB9XG59O1xuLy8gV2FsayB0aGUgbGlzdCBvZiBjb25maWd1cmF0aW9ucyBhbmQgc3BsaXQgdGhlbSBhY2NvcmRpbmcgdG9cbi8vICB0aG9zZSB0aGF0IGhhdmUgcHJlZHMgZXZhbHVhdGluZyB0byB0cnVlL2ZhbHNlLiAgSWYgbm8gcHJlZCwgYXNzdW1lXG4vLyAgdHJ1ZSBwcmVkIGFuZCBpbmNsdWRlIGluIHN1Y2NlZWRlZCBzZXQuICBSZXR1cm5zIFBhaXIgb2Ygc2V0cy5cbi8vXG4vLyAgQ3JlYXRlIGEgbmV3IHNldCBzbyBhcyBub3QgdG8gYWx0ZXIgdGhlIGluY29taW5nIHBhcmFtZXRlci5cbi8vXG4vLyAgQXNzdW1wdGlvbjogdGhlIGlucHV0IHN0cmVhbSBoYXMgYmVlbiByZXN0b3JlZCB0byB0aGUgc3RhcnRpbmcgcG9pbnRcbi8vICBwcmVkaWN0aW9uLCB3aGljaCBpcyB3aGVyZSBwcmVkaWNhdGVzIG5lZWQgdG8gZXZhbHVhdGUuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5zcGxpdEFjY29yZGluZ1RvU2VtYW50aWNWYWxpZGl0eSA9IGZ1bmN0aW9uKCBjb25maWdzLCBvdXRlckNvbnRleHQpIHtcbiAgICB2YXIgc3VjY2VlZGVkID0gbmV3IEFUTkNvbmZpZ1NldChjb25maWdzLmZ1bGxDdHgpO1xuICAgIHZhciBmYWlsZWQgPSBuZXcgQVROQ29uZmlnU2V0KGNvbmZpZ3MuZnVsbEN0eCk7XG4gICAgZm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGMuc2VtYW50aWNDb250ZXh0ICE9PSBTZW1hbnRpY0NvbnRleHQuTk9ORSkge1xuICAgICAgICAgICAgdmFyIHByZWRpY2F0ZUV2YWx1YXRpb25SZXN1bHQgPSBjLnNlbWFudGljQ29udGV4dC5ldmFsdWF0ZSh0aGlzLnBhcnNlciwgb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc3VjY2VlZGVkLmFkZChjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbGVkLmFkZChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1Y2NlZWRlZC5hZGQoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtzdWNjZWVkZWQsIGZhaWxlZF07XG59O1xuXG4vLyBMb29rIHRocm91Z2ggYSBsaXN0IG9mIHByZWRpY2F0ZS9hbHQgcGFpcnMsIHJldHVybmluZyBhbHRzIGZvciB0aGVcbi8vICBwYWlycyB0aGF0IHdpbi4gQSB7QGNvZGUgTk9ORX0gcHJlZGljYXRlIGluZGljYXRlcyBhbiBhbHQgY29udGFpbmluZyBhblxuLy8gIHVucHJlZGljYXRlZCBjb25maWcgd2hpY2ggYmVoYXZlcyBhcyBcImFsd2F5cyB0cnVlLlwiIElmICFjb21wbGV0ZVxuLy8gIHRoZW4gd2Ugc3RvcCBhdCB0aGUgZmlyc3QgcHJlZGljYXRlIHRoYXQgZXZhbHVhdGVzIHRvIHRydWUuIFRoaXNcbi8vICBpbmNsdWRlcyBwYWlycyB3aXRoIG51bGwgcHJlZGljYXRlcy5cbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmV2YWxTZW1hbnRpY0NvbnRleHQgPSBmdW5jdGlvbihwcmVkUHJlZGljdGlvbnMsIG91dGVyQ29udGV4dCwgY29tcGxldGUpIHtcbiAgICB2YXIgcHJlZGljdGlvbnMgPSBuZXcgQml0U2V0KCk7XG4gICAgZm9yKHZhciBpPTA7aTxwcmVkUHJlZGljdGlvbnMubGVuZ3RoO2krKykge1xuICAgIFx0dmFyIHBhaXIgPSBwcmVkUHJlZGljdGlvbnNbaV07XG4gICAgICAgIGlmIChwYWlyLnByZWQgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG4gICAgICAgICAgICBwcmVkaWN0aW9ucy5hZGQocGFpci5hbHQpO1xuICAgICAgICAgICAgaWYgKCEgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0ID0gcGFpci5wcmVkLmV2YWx1YXRlKHRoaXMucGFyc2VyLCBvdXRlckNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLmRmYV9kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJldmFsIHByZWQgXCIgKyBwYWlyICsgXCI9XCIgKyBwcmVkaWNhdGVFdmFsdWF0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZGljYXRlRXZhbHVhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5kZmFfZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBSRURJQ1QgXCIgKyBwYWlyLmFsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVkaWN0aW9ucy5hZGQocGFpci5hbHQpO1xuICAgICAgICAgICAgaWYgKCEgY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZGljdGlvbnM7XG59O1xuXG4vLyBUT0RPOiBJZiB3ZSBhcmUgZG9pbmcgcHJlZGljYXRlcywgdGhlcmUgaXMgbm8gcG9pbnQgaW4gcHVyc3Vpbmdcbi8vICAgICBjbG9zdXJlIG9wZXJhdGlvbnMgaWYgd2UgcmVhY2ggYSBERkEgc3RhdGUgdGhhdCB1bmlxdWVseSBwcmVkaWN0c1xuLy8gICAgIGFsdGVybmF0aXZlLiBXZSB3aWxsIG5vdCBiZSBjYWNoaW5nIHRoYXQgREZBIHN0YXRlIGFuZCBpdCBpcyBhXG4vLyAgICAgd2FzdGUgdG8gcHVyc3VlIHRoZSBjbG9zdXJlLiBNaWdodCBoYXZlIHRvIGFkdmFuY2Ugd2hlbiB3ZSBkb1xuLy8gICAgIGFtYmlnIGRldGVjdGlvbiB0aG91Z2h0IDooXG4vL1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNsb3N1cmUgPSBmdW5jdGlvbihjb25maWcsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcywgZnVsbEN0eCwgdHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICB2YXIgaW5pdGlhbERlcHRoID0gMDtcbiAgICB0aGlzLmNsb3N1cmVDaGVja2luZ1N0b3BTdGF0ZShjb25maWcsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbEN0eCwgaW5pdGlhbERlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG59O1xuXG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuY2xvc3VyZUNoZWNraW5nU3RvcFN0YXRlID0gZnVuY3Rpb24oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgIGlmICh0aGlzLmRlYnVnIHx8IHRoaXMuZGVidWdfY2xvc3VyZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNsb3N1cmUoXCIgKyBjb25maWcudG9TdHJpbmcodGhpcy5wYXJzZXIsdHJ1ZSkgKyBcIilcIik7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiY29uZmlncyhcIiArIGNvbmZpZ3MudG9TdHJpbmcoKSArIFwiKVwiKTtcbiAgICAgICAgaWYoY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0PjUwKSB7XG4gICAgICAgICAgICB0aHJvdyBcInByb2JsZW1cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkge1xuICAgICAgICAvLyBXZSBoaXQgcnVsZSBlbmQuIElmIHdlIGhhdmUgY29udGV4dCBpbmZvLCB1c2UgaXRcbiAgICAgICAgLy8gcnVuIHRocnUgYWxsIHBvc3NpYmxlIHN0YWNrIHRvcHMgaW4gY3R4XG4gICAgICAgIGlmICghIGNvbmZpZy5jb250ZXh0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPTA7IGk8Y29uZmlnLmNvbnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSkgPT09IFByZWRpY3Rpb25Db250ZXh0LkVNUFRZX1JFVFVSTl9TVEFURSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbEN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5hZGQobmV3IEFUTkNvbmZpZyh7c3RhdGU6Y29uZmlnLnN0YXRlLCBjb250ZXh0OlByZWRpY3Rpb25Db250ZXh0LkVNUFRZfSwgY29uZmlnKSwgdGhpcy5tZXJnZUNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBubyBjb250ZXh0IGluZm8sIGp1c3QgY2hhc2UgZm9sbG93IGxpbmtzIChpZiBncmVlZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRkFMTElORyBvZmYgcnVsZSBcIiArIHRoaXMuZ2V0UnVsZU5hbWUoY29uZmlnLnN0YXRlLnJ1bGVJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zdXJlXyhjb25maWcsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5TdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKV07XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBjb25maWcuY29udGV4dC5nZXRQYXJlbnQoaSk7IC8vIFwicG9wXCIgcmV0dXJuIHN0YXRlXG4gICAgICAgICAgICAgICAgdmFyIHBhcm1zID0ge3N0YXRlOnJldHVyblN0YXRlLCBhbHQ6Y29uZmlnLmFsdCwgY29udGV4dDpuZXdDb250ZXh0LCBzZW1hbnRpY0NvbnRleHQ6Y29uZmlnLnNlbWFudGljQ29udGV4dH07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQVROQ29uZmlnKHBhcm1zLCBudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBoYXZlIGNvbnRleHQgdG8gcG9wIGJhY2sgZnJvbSwgd2UgbWF5IGhhdmVcbiAgICAgICAgICAgICAgICAvLyBnb3R0ZW4gdGhhdCBjb250ZXh0IEFGVEVSIGhhdmluZyBmYWxsaW5nIG9mZiBhIHJ1bGUuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyYWNrIHRoYXQgd2UgYXJlIG5vdyBvdXQgb2YgY29udGV4dC5cbiAgICAgICAgICAgICAgICBjLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0ID0gY29uZmlnLnJlYWNoZXNJbnRvT3V0ZXJDb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc3VyZUNoZWNraW5nU3RvcFN0YXRlKGMsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcywgZnVsbEN0eCwgZGVwdGggLSAxLCB0cmVhdEVvZkFzRXBzaWxvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiggZnVsbEN0eCkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBlbmQgb2Ygc3RhcnQgcnVsZVxuICAgICAgICAgICAgY29uZmlncy5hZGQoY29uZmlnLCB0aGlzLm1lcmdlQ2FjaGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSBpZiB3ZSBoYXZlIG5vIGNvbnRleHQgaW5mbywganVzdCBjaGFzZSBmb2xsb3cgbGlua3MgKGlmIGdyZWVkeSlcbiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGQUxMSU5HIG9mZiBydWxlIFwiICsgdGhpcy5nZXRSdWxlTmFtZShjb25maWcuc3RhdGUucnVsZUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbG9zdXJlXyhjb25maWcsIGNvbmZpZ3MsIGNsb3N1cmVCdXN5LCBjb2xsZWN0UHJlZGljYXRlcywgZnVsbEN0eCwgZGVwdGgsIHRyZWF0RW9mQXNFcHNpbG9uKTtcbn07XG5cblxuLy8gRG8gdGhlIGFjdHVhbCB3b3JrIG9mIHdhbGtpbmcgZXBzaWxvbiBlZGdlcy8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNsb3N1cmVfID0gZnVuY3Rpb24oY29uZmlnLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29sbGVjdFByZWRpY2F0ZXMsIGZ1bGxDdHgsIGRlcHRoLCB0cmVhdEVvZkFzRXBzaWxvbikge1xuICAgIHZhciBwID0gY29uZmlnLnN0YXRlO1xuICAgIC8vIG9wdGltaXphdGlvblxuICAgIGlmICghIHAuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucykge1xuICAgICAgICBjb25maWdzLmFkZChjb25maWcsIHRoaXMubWVyZ2VDYWNoZSk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBub3QgcmV0dXJuIGhlcmUsIGJlY2F1c2UgRU9GIHRyYW5zaXRpb25zIGNhbiBhY3QgYXNcbiAgICAgICAgLy8gYm90aCBlcHNpbG9uIHRyYW5zaXRpb25zIGFuZCBub24tZXBzaWxvbiB0cmFuc2l0aW9ucy5cbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDtpPHAudHJhbnNpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYoaT09MCAmJiB0aGlzLmNhbkRyb3BMb29wRW50cnlFZGdlSW5MZWZ0UmVjdXJzaXZlUnVsZShjb25maWcpKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIHQgPSBwLnRyYW5zaXRpb25zW2ldO1xuICAgICAgICB2YXIgY29udGludWVDb2xsZWN0aW5nID0gY29sbGVjdFByZWRpY2F0ZXMgJiYgISh0IGluc3RhbmNlb2YgQWN0aW9uVHJhbnNpdGlvbik7XG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRFcHNpbG9uVGFyZ2V0KGNvbmZpZywgdCwgY29udGludWVDb2xsZWN0aW5nLCBkZXB0aCA9PT0gMCwgZnVsbEN0eCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICBpZiAoYyE9PW51bGwpIHtcbiAgICAgICAgICAgIHZhciBuZXdEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgaWYgKCBjb25maWcuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGZlbGwgb2ZmIGVuZCBvZiBydWxlOyBtYXJrIHJlc3VsdGluZyBjIGFzIGhhdmluZyBkaXBwZWQgaW50byBvdXRlciBjb250ZXh0XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZ2V0IGhlcmUgaWYgaW5jb21pbmcgY29uZmlnIHdhcyBydWxlIHN0b3AgYW5kIHdlIGhhZCBjb250ZXh0XG4gICAgICAgICAgICAgICAgLy8gdHJhY2sgaG93IGZhciB3ZSBkaXAgaW50byBvdXRlciBjb250ZXh0LiAgTWlnaHRcbiAgICAgICAgICAgICAgICAvLyBjb21lIGluIGhhbmR5IGFuZCB3ZSBhdm9pZCBldmFsdWF0aW5nIGNvbnRleHQgZGVwZW5kZW50XG4gICAgICAgICAgICAgICAgLy8gcHJlZHMgaWYgdGhpcyBpcyA+IDAuXG5cdFx0XHRcdGlmICh0aGlzLl9kZmEgIT09IG51bGwgJiYgdGhpcy5fZGZhLnByZWNlZGVuY2VEZmEpIHtcblx0XHRcdFx0XHRpZiAodC5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID09PSB0aGlzLl9kZmEuYXRuU3RhcnRTdGF0ZS5ydWxlSW5kZXgpIHtcblx0XHRcdFx0XHRcdGMucHJlY2VkZW5jZUZpbHRlclN1cHByZXNzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG4gICAgICAgICAgICAgICAgYy5yZWFjaGVzSW50b091dGVyQ29udGV4dCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zdXJlQnVzeS5hZGQoYykhPT1jKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvbiBmb3IgcmlnaHQtcmVjdXJzaXZlIHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWdzLmRpcHNJbnRvT3V0ZXJDb250ZXh0ID0gdHJ1ZTsgLy8gVE9ETzogY2FuIHJlbW92ZT8gb25seSBjYXJlIHdoZW4gd2UgYWRkIHRvIHNldCBwZXIgbWlkZGxlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgbmV3RGVwdGggLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImRpcHMgaW50byBvdXRlciBjdHg6IFwiICsgYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXQuaXNFcHNpbG9uICYmIGNsb3N1cmVCdXN5LmFkZChjKSE9PWMpe1xuICAgICAgICAgICAgICAgICAgICAvLyBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb24gZm9yIEVPRiogYW5kIEVPRitcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgUnVsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGF0Y2ggd2hlbiBuZXdEZXB0aCBnb2VzIG5lZ2F0aXZlIC0gb25jZSB3ZSBzdGVwIG91dCBvZiB0aGUgZW50cnkgY29udGV4dCB3ZSBjYW4ndCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RlcHRoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RlcHRoICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsb3N1cmVDaGVja2luZ1N0b3BTdGF0ZShjLCBjb25maWdzLCBjbG9zdXJlQnVzeSwgY29udGludWVDb2xsZWN0aW5nLCBmdWxsQ3R4LCBuZXdEZXB0aCwgdHJlYXRFb2ZBc0Vwc2lsb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmNhbkRyb3BMb29wRW50cnlFZGdlSW5MZWZ0UmVjdXJzaXZlUnVsZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIC8vIHJldHVybiBGYWxzZVxuICAgIHZhciBwID0gY29uZmlnLnN0YXRlO1xuICAgIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gU3Rhckxvb3BFbnRyeVN0YXRlIGdlbmVyYXRlZCBkdXJpbmdcbiAgICAvLyBsZWZ0LXJlY3Vyc2lvbiBlbGltaW5hdGlvbi4gRm9yIGVmZmljaWVuY3ksIGFsc28gY2hlY2sgaWZcbiAgICAvLyB0aGUgY29udGV4dCBoYXMgYW4gZW1wdHkgc3RhY2sgY2FzZS4gSWYgc28sIGl0IHdvdWxkIG1lYW5cbiAgICAvLyBnbG9iYWwgRk9MTE9XIHNvIHdlIGNhbid0IHBlcmZvcm0gb3B0aW1pemF0aW9uXG4gICAgLy8gQXJlIHdlIHRoZSBzcGVjaWFsIGxvb3AgZW50cnkvZXhpdCBzdGF0ZT8gb3IgU0xMIHdpbGRjYXJkXG4gICAgaWYocC5zdGF0ZVR5cGUgIT0gQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYocC5zdGF0ZVR5cGUgIT0gQVROU3RhdGUuU1RBUl9MT09QX0VOVFJZIHx8ICFwLmlzUHJlY2VkZW5jZURlY2lzaW9uIHx8XG4gICAgICAgICAgIGNvbmZpZy5jb250ZXh0LmlzRW1wdHkoKSB8fCBjb25maWcuY29udGV4dC5oYXNFbXB0eVBhdGgoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gUmVxdWlyZSBhbGwgcmV0dXJuIHN0YXRlcyB0byByZXR1cm4gYmFjayB0byB0aGUgc2FtZSBydWxlIHRoYXQgcCBpcyBpbi5cbiAgICB2YXIgbnVtQ3R4cyA9IGNvbmZpZy5jb250ZXh0Lmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaTxudW1DdHhzOyBpKyspIHsgLy8gZm9yIGVhY2ggc3RhY2sgY29udGV4dFxuICAgICAgICB2YXIgcmV0dXJuU3RhdGUgPSB0aGlzLmF0bi5zdGF0ZXNbY29uZmlnLmNvbnRleHQuZ2V0UmV0dXJuU3RhdGUoaSldO1xuICAgICAgICBpZiAocmV0dXJuU3RhdGUucnVsZUluZGV4ICE9IHAucnVsZUluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBkZWNpc2lvblN0YXJ0U3RhdGUgPSBwLnRyYW5zaXRpb25zWzBdLnRhcmdldDtcbiAgICB2YXIgYmxvY2tFbmRTdGF0ZU51bSA9IGRlY2lzaW9uU3RhcnRTdGF0ZS5lbmRTdGF0ZS5zdGF0ZU51bWJlcjtcbiAgICB2YXIgYmxvY2tFbmRTdGF0ZSA9IHRoaXMuYXRuLnN0YXRlc1tibG9ja0VuZFN0YXRlTnVtXTtcblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSB0b3Agb2YgZWFjaCBzdGFjayBjb250ZXh0IGxlYWRzIHRvIGxvb3AgZW50cnkvZXhpdFxuICAgIC8vIHN0YXRlIHRocm91Z2ggZXBzaWxvbiBlZGdlcyBhbmQgdy9vIGxlYXZpbmcgcnVsZS5cbiAgICBmb3IodmFyIGk9MDsgaTxudW1DdHhzOyBpKyspIHsgLy8gZm9yIGVhY2ggc3RhY2sgY29udGV4dFxuICAgICAgICB2YXIgcmV0dXJuU3RhdGVOdW1iZXIgPSBjb25maWcuY29udGV4dC5nZXRSZXR1cm5TdGF0ZShpKTtcbiAgICAgICAgdmFyIHJldHVyblN0YXRlID0gdGhpcy5hdG4uc3RhdGVzW3JldHVyblN0YXRlTnVtYmVyXTtcbiAgICAgICAgLy8gYWxsIHN0YXRlcyBtdXN0IGhhdmUgc2luZ2xlIG91dGdvaW5nIGVwc2lsb24gZWRnZVxuICAgICAgICBpZiAocmV0dXJuU3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoICE9IDEgfHwgIXJldHVyblN0YXRlLnRyYW5zaXRpb25zWzBdLmlzRXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBMb29rIGZvciBwcmVmaXggb3AgY2FzZSBsaWtlICdub3QgZXhwcicsICgnIHR5cGUgJyknIGV4cHJcbiAgICAgICAgdmFyIHJldHVyblN0YXRlVGFyZ2V0ID0gcmV0dXJuU3RhdGUudHJhbnNpdGlvbnNbMF0udGFyZ2V0O1xuICAgICAgICBpZiAoIHJldHVyblN0YXRlLnN0YXRlVHlwZSA9PSBBVE5TdGF0ZS5CTE9DS19FTkQgJiYgcmV0dXJuU3RhdGVUYXJnZXQgPT0gcCApXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBMb29rIGZvciAnZXhwciBvcCBleHByJyBvciBjYXNlIHdoZXJlIGV4cHIncyByZXR1cm4gc3RhdGUgaXMgYmxvY2sgZW5kXG4gICAgICAgIC8vIG9mICguLi4pKiBpbnRlcm5hbCBibG9jazsgdGhlIGJsb2NrIGVuZCBwb2ludHMgdG8gbG9vcCBiYWNrXG4gICAgICAgIC8vIHdoaWNoIHBvaW50cyB0byBwIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoYXRcbiAgICAgICAgaWYgKCByZXR1cm5TdGF0ZSA9PSBibG9ja0VuZFN0YXRlIClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIHRlcm5hcnkgZXhwciA/IGV4cHIgOiBleHByLiBUaGUgcmV0dXJuIHN0YXRlIHBvaW50cyBhdCBibG9jayBlbmQsXG4gICAgICAgIC8vIHdoaWNoIHBvaW50cyBhdCBsb29wIGVudHJ5IHN0YXRlXG4gICAgICAgIGlmICggcmV0dXJuU3RhdGVUYXJnZXQgPT0gYmxvY2tFbmRTdGF0ZSApXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAvLyBMb29rIGZvciBjb21wbGV4IHByZWZpeCAnYmV0d2VlbiBleHByIGFuZCBleHByJyBjYXNlIHdoZXJlIDJuZCBleHByJ3NcbiAgICAgICAgLy8gcmV0dXJuIHN0YXRlIHBvaW50cyBhdCBibG9jayBlbmQgc3RhdGUgb2YgKC4uLikqIGludGVybmFsIGJsb2NrXG4gICAgICAgIGlmIChyZXR1cm5TdGF0ZVRhcmdldC5zdGF0ZVR5cGUgPT0gQVROU3RhdGUuQkxPQ0tfRU5EICYmIHJldHVyblN0YXRlVGFyZ2V0LnRyYW5zaXRpb25zLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAgICAgJiYgcmV0dXJuU3RhdGVUYXJnZXQudHJhbnNpdGlvbnNbMF0uaXNFcHNpbG9uICYmIHJldHVyblN0YXRlVGFyZ2V0LnRyYW5zaXRpb25zWzBdLnRhcmdldCA9PSBwKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBhaW4ndCBjb25mb3JtaW5nXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0UnVsZU5hbWUgPSBmdW5jdGlvbiggaW5kZXgpIHtcbiAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsICYmIGluZGV4Pj0wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5ydWxlTmFtZXNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIjxydWxlIFwiICsgaW5kZXggKyBcIj5cIjtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldEVwc2lsb25UYXJnZXQgPSBmdW5jdGlvbihjb25maWcsIHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgsIHRyZWF0RW9mQXNFcHNpbG9uKSB7XG4gICAgc3dpdGNoKHQuc2VyaWFsaXphdGlvblR5cGUpIHtcbiAgICBjYXNlIFRyYW5zaXRpb24uUlVMRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucnVsZVRyYW5zaXRpb24oY29uZmlnLCB0KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uUFJFQ0VERU5DRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlY2VkZW5jZVRyYW5zaXRpb24oY29uZmlnLCB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uUFJFRElDQVRFOlxuICAgICAgICByZXR1cm4gdGhpcy5wcmVkVHJhbnNpdGlvbihjb25maWcsIHQsIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgpO1xuICAgIGNhc2UgVHJhbnNpdGlvbi5BQ1RJT046XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvblRyYW5zaXRpb24oY29uZmlnLCB0KTtcbiAgICBjYXNlIFRyYW5zaXRpb24uRVBTSUxPTjpcbiAgICAgICAgcmV0dXJuIG5ldyBBVE5Db25maWcoe3N0YXRlOnQudGFyZ2V0fSwgY29uZmlnKTtcbiAgICBjYXNlIFRyYW5zaXRpb24uQVRPTTpcbiAgICBjYXNlIFRyYW5zaXRpb24uUkFOR0U6XG4gICAgY2FzZSBUcmFuc2l0aW9uLlNFVDpcbiAgICAgICAgLy8gRU9GIHRyYW5zaXRpb25zIGFjdCBsaWtlIGVwc2lsb24gdHJhbnNpdGlvbnMgYWZ0ZXIgdGhlIGZpcnN0IEVPRlxuICAgICAgICAvLyB0cmFuc2l0aW9uIGlzIHRyYXZlcnNlZFxuICAgICAgICBpZiAodHJlYXRFb2ZBc0Vwc2lsb24pIHtcbiAgICAgICAgICAgIGlmICh0Lm1hdGNoZXMoVG9rZW4uRU9GLCAwLCAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTogdC50YXJnZXR9LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgXHRyZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFjdGlvblRyYW5zaXRpb24gPSBmdW5jdGlvbihjb25maWcsIHQpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICB2YXIgaW5kZXggPSB0LmFjdGlvbkluZGV4PT0tMSA/IDY1NTM1IDogdC5hY3Rpb25JbmRleDtcbiAgICAgICAgY29uc29sZS5sb2coXCJBQ1RJT04gZWRnZSBcIiArIHQucnVsZUluZGV4ICsgXCI6XCIgKyBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQVROQ29uZmlnKHtzdGF0ZTp0LnRhcmdldH0sIGNvbmZpZyk7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnByZWNlZGVuY2VUcmFuc2l0aW9uID0gZnVuY3Rpb24oY29uZmlnLCBwdCwgIGNvbGxlY3RQcmVkaWNhdGVzLCBpbkNvbnRleHQsIGZ1bGxDdHgpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlBSRUQgKGNvbGxlY3RQcmVkaWNhdGVzPVwiICsgY29sbGVjdFByZWRpY2F0ZXMgKyBcIikgXCIgK1xuICAgICAgICAgICAgICAgIHB0LnByZWNlZGVuY2UgKyBcIj49X3AsIGN0eCBkZXBlbmRlbnQ9dHJ1ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VyIT09bnVsbCkge1xuICAgICAgICBcdGNvbnNvbGUubG9nKFwiY29udGV4dCBzdXJyb3VuZGluZyBwcmVkIGlzIFwiICsgVXRpbHMuYXJyYXlUb1N0cmluZyh0aGlzLnBhcnNlci5nZXRSdWxlSW52b2NhdGlvblN0YWNrKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYyA9IG51bGw7XG4gICAgaWYgKGNvbGxlY3RQcmVkaWNhdGVzICYmIGluQ29udGV4dCkge1xuICAgICAgICBpZiAoZnVsbEN0eCkge1xuICAgICAgICAgICAgLy8gSW4gZnVsbCBjb250ZXh0IG1vZGUsIHdlIGNhbiBldmFsdWF0ZSBwcmVkaWNhdGVzIG9uLXRoZS1mbHlcbiAgICAgICAgICAgIC8vIGR1cmluZyBjbG9zdXJlLCB3aGljaCBkcmFtYXRpY2FsbHkgcmVkdWNlcyB0aGUgc2l6ZSBvZlxuICAgICAgICAgICAgLy8gdGhlIGNvbmZpZyBzZXRzLiBJdCBhbHNvIG9idmlhdGVzIHRoZSBuZWVkIHRvIHRlc3QgcHJlZGljYXRlc1xuICAgICAgICAgICAgLy8gbGF0ZXIgZHVyaW5nIGNvbmZsaWN0IHJlc29sdXRpb24uXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gdGhpcy5faW5wdXQuaW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC5zZWVrKHRoaXMuX3N0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIHByZWRTdWNjZWVkcyA9IHB0LmdldFByZWRpY2F0ZSgpLmV2YWx1YXRlKHRoaXMucGFyc2VyLCB0aGlzLl9vdXRlckNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuc2VlayhjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHByZWRTdWNjZWVkcykge1xuICAgICAgICAgICAgICAgIGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTpwdC50YXJnZXR9LCBjb25maWcpOyAvLyBubyBwcmVkIGNvbnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdTZW1DdHggPSBTZW1hbnRpY0NvbnRleHQuYW5kQ29udGV4dChjb25maWcuc2VtYW50aWNDb250ZXh0LCBwdC5nZXRQcmVkaWNhdGUoKSk7XG4gICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0LCBzZW1hbnRpY0NvbnRleHQ6bmV3U2VtQ3R4fSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGMgPSBuZXcgQVROQ29uZmlnKHtzdGF0ZTpwdC50YXJnZXR9LCBjb25maWcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcImNvbmZpZyBmcm9tIHByZWQgdHJhbnNpdGlvbj1cIiArIGMpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucHJlZFRyYW5zaXRpb24gPSBmdW5jdGlvbihjb25maWcsIHB0LCBjb2xsZWN0UHJlZGljYXRlcywgaW5Db250ZXh0LCBmdWxsQ3R4KSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJQUkVEIChjb2xsZWN0UHJlZGljYXRlcz1cIiArIGNvbGxlY3RQcmVkaWNhdGVzICsgXCIpIFwiICsgcHQucnVsZUluZGV4ICtcbiAgICAgICAgICAgICAgICBcIjpcIiArIHB0LnByZWRJbmRleCArIFwiLCBjdHggZGVwZW5kZW50PVwiICsgcHQuaXNDdHhEZXBlbmRlbnQpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQgc3Vycm91bmRpbmcgcHJlZCBpcyBcIiArIFV0aWxzLmFycmF5VG9TdHJpbmcodGhpcy5wYXJzZXIuZ2V0UnVsZUludm9jYXRpb25TdGFjaygpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIGlmIChjb2xsZWN0UHJlZGljYXRlcyAmJiAoKHB0LmlzQ3R4RGVwZW5kZW50ICYmIGluQ29udGV4dCkgfHwgISBwdC5pc0N0eERlcGVuZGVudCkpIHtcbiAgICAgICAgaWYgKGZ1bGxDdHgpIHtcbiAgICAgICAgICAgIC8vIEluIGZ1bGwgY29udGV4dCBtb2RlLCB3ZSBjYW4gZXZhbHVhdGUgcHJlZGljYXRlcyBvbi10aGUtZmx5XG4gICAgICAgICAgICAvLyBkdXJpbmcgY2xvc3VyZSwgd2hpY2ggZHJhbWF0aWNhbGx5IHJlZHVjZXMgdGhlIHNpemUgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBjb25maWcgc2V0cy4gSXQgYWxzbyBvYnZpYXRlcyB0aGUgbmVlZCB0byB0ZXN0IHByZWRpY2F0ZXNcbiAgICAgICAgICAgIC8vIGxhdGVyIGR1cmluZyBjb25mbGljdCByZXNvbHV0aW9uLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHRoaXMuX2lucHV0LmluZGV4O1xuICAgICAgICAgICAgdGhpcy5faW5wdXQuc2Vlayh0aGlzLl9zdGFydEluZGV4KTtcbiAgICAgICAgICAgIHZhciBwcmVkU3VjY2VlZHMgPSBwdC5nZXRQcmVkaWNhdGUoKS5ldmFsdWF0ZSh0aGlzLnBhcnNlciwgdGhpcy5fb3V0ZXJDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0LnNlZWsoY3VycmVudFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcmVkU3VjY2VlZHMpIHtcbiAgICAgICAgICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0fSwgY29uZmlnKTsgLy8gbm8gcHJlZCBjb250ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3U2VtQ3R4ID0gU2VtYW50aWNDb250ZXh0LmFuZENvbnRleHQoY29uZmlnLnNlbWFudGljQ29udGV4dCwgcHQuZ2V0UHJlZGljYXRlKCkpO1xuICAgICAgICAgICAgYyA9IG5ldyBBVE5Db25maWcoe3N0YXRlOnB0LnRhcmdldCwgc2VtYW50aWNDb250ZXh0Om5ld1NlbUN0eH0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjID0gbmV3IEFUTkNvbmZpZyh7c3RhdGU6cHQudGFyZ2V0fSwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25maWcgZnJvbSBwcmVkIHRyYW5zaXRpb249XCIgKyBjKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJ1bGVUcmFuc2l0aW9uID0gZnVuY3Rpb24oY29uZmlnLCB0KSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDQUxMIHJ1bGUgXCIgKyB0aGlzLmdldFJ1bGVOYW1lKHQudGFyZ2V0LnJ1bGVJbmRleCkgKyBcIiwgY3R4PVwiICsgY29uZmlnLmNvbnRleHQpO1xuICAgIH1cbiAgICB2YXIgcmV0dXJuU3RhdGUgPSB0LmZvbGxvd1N0YXRlO1xuICAgIHZhciBuZXdDb250ZXh0ID0gU2luZ2xldG9uUHJlZGljdGlvbkNvbnRleHQuY3JlYXRlKGNvbmZpZy5jb250ZXh0LCByZXR1cm5TdGF0ZS5zdGF0ZU51bWJlcik7XG4gICAgcmV0dXJuIG5ldyBBVE5Db25maWcoe3N0YXRlOnQudGFyZ2V0LCBjb250ZXh0Om5ld0NvbnRleHR9LCBjb25maWcgKTtcbn07XG5cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuZ2V0Q29uZmxpY3RpbmdBbHRzID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciBhbHRzZXRzID0gUHJlZGljdGlvbk1vZGUuZ2V0Q29uZmxpY3RpbmdBbHRTdWJzZXRzKGNvbmZpZ3MpO1xuICAgIHJldHVybiBQcmVkaWN0aW9uTW9kZS5nZXRBbHRzKGFsdHNldHMpO1xufTtcblxuIC8vIFNhbSBwb2ludGVkIG91dCBhIHByb2JsZW0gd2l0aCB0aGUgcHJldmlvdXMgZGVmaW5pdGlvbiwgdjMsIG9mXG4gLy8gYW1iaWd1b3VzIHN0YXRlcy4gSWYgd2UgaGF2ZSBhbm90aGVyIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCBjb25mbGljdGluZ1xuIC8vIGFsdGVybmF0aXZlcywgd2Ugc2hvdWxkIGtlZXAgZ29pbmcuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGdyYW1tYXJcbiAvL1xuIC8vIHMgOiAoSUQgfCBJRCBJRD8pICc7JyA7XG4gLy9cbiAvLyBXaGVuIHRoZSBBVE4gc2ltdWxhdGlvbiByZWFjaGVzIHRoZSBzdGF0ZSBiZWZvcmUgJzsnLCBpdCBoYXMgYSBERkFcbiAvLyBzdGF0ZSB0aGF0IGxvb2tzIGxpa2U6IFsxMnwxfFtdLCA2fDJ8W10sIDEyfDJ8W11dLiBOYXR1cmFsbHlcbiAvLyAxMnwxfFtdIGFuZCAxMnwyfFtdIGNvbmZsaWN0LCBidXQgd2UgY2Fubm90IHN0b3AgcHJvY2Vzc2luZyB0aGlzIG5vZGVcbiAvLyBiZWNhdXNlIGFsdGVybmF0aXZlIHRvIGhhcyBhbm90aGVyIHdheSB0byBjb250aW51ZSwgdmlhIFs2fDJ8W11dLlxuIC8vIFRoZSBrZXkgaXMgdGhhdCB3ZSBoYXZlIGEgc2luZ2xlIHN0YXRlIHRoYXQgaGFzIGNvbmZpZydzIG9ubHkgYXNzb2NpYXRlZFxuIC8vIHdpdGggYSBzaW5nbGUgYWx0ZXJuYXRpdmUsIDIsIGFuZCBjcnVjaWFsbHkgdGhlIHN0YXRlIHRyYW5zaXRpb25zXG4gLy8gYW1vbmcgdGhlIGNvbmZpZ3VyYXRpb25zIGFyZSBhbGwgbm9uLWVwc2lsb24gdHJhbnNpdGlvbnMuIFRoYXQgbWVhbnNcbiAvLyB3ZSBkb24ndCBjb25zaWRlciBhbnkgY29uZmxpY3RzIHRoYXQgaW5jbHVkZSBhbHRlcm5hdGl2ZSAyLiBTbywgd2VcbiAvLyBpZ25vcmUgdGhlIGNvbmZsaWN0IGJldHdlZW4gYWx0cyAxIGFuZCAyLiBXZSBpZ25vcmUgYSBzZXQgb2ZcbiAvLyBjb25mbGljdGluZyBhbHRzIHdoZW4gdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uIHdpdGggYW4gYWx0ZXJuYXRpdmVcbiAvLyBhc3NvY2lhdGVkIHdpdGggYSBzaW5nbGUgYWx0IHN0YXRlIGluIHRoZSBzdGF0ZSZyYXJyO2NvbmZpZy1saXN0IG1hcC5cbiAvL1xuIC8vIEl0J3MgYWxzbyB0aGUgY2FzZSB0aGF0IHdlIG1pZ2h0IGhhdmUgdHdvIGNvbmZsaWN0aW5nIGNvbmZpZ3VyYXRpb25zIGJ1dFxuIC8vIGFsc28gYSAzcmQgbm9uY29uZmxpY3RpbmcgY29uZmlndXJhdGlvbiBmb3IgYSBkaWZmZXJlbnQgYWx0ZXJuYXRpdmU6XG4gLy8gWzF8MXxbXSwgMXwyfFtdLCA4fDN8W11dLiBUaGlzIGNhbiBjb21lIGFib3V0IGZyb20gZ3JhbW1hcjpcbiAvL1xuIC8vIGEgOiBBIHwgQSB8IEEgQiA7XG4gLy9cbiAvLyBBZnRlciBtYXRjaGluZyBpbnB1dCBBLCB3ZSByZWFjaCB0aGUgc3RvcCBzdGF0ZSBmb3IgcnVsZSBBLCBzdGF0ZSAxLlxuIC8vIFN0YXRlIDggaXMgdGhlIHN0YXRlIHJpZ2h0IGJlZm9yZSBCLiBDbGVhcmx5IGFsdGVybmF0aXZlcyAxIGFuZCAyXG4gLy8gY29uZmxpY3QgYW5kIG5vIGFtb3VudCBvZiBmdXJ0aGVyIGxvb2thaGVhZCB3aWxsIHNlcGFyYXRlIHRoZSB0d28uXG4gLy8gSG93ZXZlciwgYWx0ZXJuYXRpdmUgMyB3aWxsIGJlIGFibGUgdG8gY29udGludWUgYW5kIHNvIHdlIGRvIG5vdFxuIC8vIHN0b3Agd29ya2luZyBvbiB0aGlzIHN0YXRlLiBJbiB0aGUgcHJldmlvdXMgZXhhbXBsZSwgd2UncmUgY29uY2VybmVkXG4gLy8gd2l0aCBzdGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBhbHRlcm5hdGl2ZXMuIEhlcmUgYWx0XG4gLy8gMyBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBjb25maWdzLCBidXQgc2luY2Ugd2UgY2FuIGNvbnRpbnVlXG4gLy8gbG9va2luZyBmb3IgaW5wdXQgcmVhc29uYWJseSwgSSBkb24ndCBkZWNsYXJlIHRoZSBzdGF0ZSBkb25lLiBXZVxuIC8vIGlnbm9yZSBhIHNldCBvZiBjb25mbGljdGluZyBhbHRzIHdoZW4gd2UgaGF2ZSBhbiBhbHRlcm5hdGl2ZVxuIC8vIHRoYXQgd2Ugc3RpbGwgbmVlZCB0byBwdXJzdWUuXG4vL1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldENvbmZsaWN0aW5nQWx0c09yVW5pcXVlQWx0ID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciBjb25mbGljdGluZ0FsdHMgPSBudWxsO1xuICAgIGlmIChjb25maWdzLnVuaXF1ZUFsdCE9PSBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XG4gICAgICAgIGNvbmZsaWN0aW5nQWx0cyA9IG5ldyBCaXRTZXQoKTtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzLmFkZChjb25maWdzLnVuaXF1ZUFsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmxpY3RpbmdBbHRzID0gY29uZmlncy5jb25mbGljdGluZ0FsdHM7XG4gICAgfVxuICAgIHJldHVybiBjb25mbGljdGluZ0FsdHM7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldFRva2VuTmFtZSA9IGZ1bmN0aW9uKCB0KSB7XG4gICAgaWYgKHQ9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgcmV0dXJuIFwiRU9GXCI7XG4gICAgfVxuICAgIGlmKCB0aGlzLnBhcnNlciE9PW51bGwgJiYgdGhpcy5wYXJzZXIubGl0ZXJhbE5hbWVzIT09bnVsbCkge1xuICAgICAgICBpZiAodCA+PSB0aGlzLnBhcnNlci5saXRlcmFsTmFtZXMubGVuZ3RoICYmIHQgPj0gdGhpcy5wYXJzZXIuc3ltYm9saWNOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXCIgKyB0ICsgXCIgdHR5cGUgb3V0IG9mIHJhbmdlOiBcIiArIHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlwiICsgdGhpcy5wYXJzZXIuZ2V0SW5wdXRTdHJlYW0oKS5nZXRUb2tlbnMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMucGFyc2VyLmxpdGVyYWxOYW1lc1t0XSB8fCB0aGlzLnBhcnNlci5zeW1ib2xpY05hbWVzW3RdO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgKyBcIjxcIiArIHQgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIHQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmdldExvb2thaGVhZE5hbWUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmdldFRva2VuTmFtZShpbnB1dC5MQSgxKSk7XG59O1xuXG4vLyBVc2VkIGZvciBkZWJ1Z2dpbmcgaW4gYWRhcHRpdmVQcmVkaWN0IGFyb3VuZCBleGVjQVROIGJ1dCBJIGN1dFxuLy8gIGl0IG91dCBmb3IgY2xhcml0eSBub3cgdGhhdCBhbGcuIHdvcmtzIHdlbGwuIFdlIGNhbiBsZWF2ZSB0aGlzXG4vLyAgXCJkZWFkXCIgY29kZSBmb3IgYSBiaXQuXG4vL1xuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5kdW1wRGVhZEVuZENvbmZpZ3MgPSBmdW5jdGlvbihudmFlKSB7XG4gICAgY29uc29sZS5sb2coXCJkZWFkIGVuZCBjb25maWdzOiBcIik7XG4gICAgdmFyIGRlY3MgPSBudmFlLmdldERlYWRFbmRDb25maWdzKCk7XG4gICAgZm9yKHZhciBpPTA7IGk8ZGVjcy5sZW5ndGg7IGkrKykge1xuICAgIFx0dmFyIGMgPSBkZWNzW2ldO1xuICAgICAgICB2YXIgdHJhbnMgPSBcIm5vIGVkZ2VzXCI7XG4gICAgICAgIGlmIChjLnN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGMuc3RhdGUudHJhbnNpdGlvbnNbMF07XG4gICAgICAgICAgICBpZiAodCBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnMgPSBcIkF0b20gXCIrIHRoaXMuZ2V0VG9rZW5OYW1lKHQubGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0IGluc3RhbmNlb2YgU2V0VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBuZWcgPSAodCBpbnN0YW5jZW9mIE5vdFNldFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRyYW5zID0gKG5lZyA/IFwiflwiIDogXCJcIikgKyBcIlNldCBcIiArIHQuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYy50b1N0cmluZyh0aGlzLnBhcnNlciwgdHJ1ZSkgKyBcIjpcIiArIHRyYW5zKTtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLm5vVmlhYmxlQWx0ID0gZnVuY3Rpb24oaW5wdXQsIG91dGVyQ29udGV4dCwgY29uZmlncywgc3RhcnRJbmRleCkge1xuICAgIHJldHVybiBuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24odGhpcy5wYXJzZXIsIGlucHV0LCBpbnB1dC5nZXQoc3RhcnRJbmRleCksIGlucHV0LkxUKDEpLCBjb25maWdzLCBvdXRlckNvbnRleHQpO1xufTtcblxuUGFyc2VyQVROU2ltdWxhdG9yLnByb3RvdHlwZS5nZXRVbmlxdWVBbHQgPSBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIGFsdCA9IEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgZm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDtpKyspIHtcbiAgICBcdHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGFsdCA9PT0gQVROLklOVkFMSURfQUxUX05VTUJFUikge1xuICAgICAgICAgICAgYWx0ID0gYy5hbHQgLy8gZm91bmQgZmlyc3QgYWx0XG4gICAgICAgIH0gZWxzZSBpZiggYy5hbHQhPT1hbHQpIHtcbiAgICAgICAgICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbHQ7XG59O1xuXG4vL1xuLy8gQWRkIGFuIGVkZ2UgdG8gdGhlIERGQSwgaWYgcG9zc2libGUuIFRoaXMgbWV0aG9kIGNhbGxzXG4vLyB7QGxpbmsgLy9hZGRERkFTdGF0ZX0gdG8gZW5zdXJlIHRoZSB7QGNvZGUgdG99IHN0YXRlIGlzIHByZXNlbnQgaW4gdGhlXG4vLyBERkEuIElmIHtAY29kZSBmcm9tfSBpcyB7QGNvZGUgbnVsbH0sIG9yIGlmIHtAY29kZSB0fSBpcyBvdXRzaWRlIHRoZVxuLy8gcmFuZ2Ugb2YgZWRnZXMgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gdGhlIERGQSB0YWJsZXMsIHRoaXMgbWV0aG9kXG4vLyByZXR1cm5zIHdpdGhvdXQgYWRkaW5nIHRoZSBlZGdlIHRvIHRoZSBERkEuXG4vL1xuLy8gPHA+SWYge0Bjb2RlIHRvfSBpcyB7QGNvZGUgbnVsbH0sIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9LlxuLy8gT3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSB7QGxpbmsgREZBU3RhdGV9IHJldHVybmVkIGJ5IGNhbGxpbmdcbi8vIHtAbGluayAvL2FkZERGQVN0YXRlfSBmb3IgdGhlIHtAY29kZSB0b30gc3RhdGUuPC9wPlxuLy9cbi8vIEBwYXJhbSBkZmEgVGhlIERGQVxuLy8gQHBhcmFtIGZyb20gVGhlIHNvdXJjZSBzdGF0ZSBmb3IgdGhlIGVkZ2Vcbi8vIEBwYXJhbSB0IFRoZSBpbnB1dCBzeW1ib2xcbi8vIEBwYXJhbSB0byBUaGUgdGFyZ2V0IHN0YXRlIGZvciB0aGUgZWRnZVxuLy9cbi8vIEByZXR1cm4gSWYge0Bjb2RlIHRvfSBpcyB7QGNvZGUgbnVsbH0sIHRoaXMgbWV0aG9kIHJldHVybnMge0Bjb2RlIG51bGx9O1xuLy8gb3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHtAbGluayAvL2FkZERGQVN0YXRlfVxuLy8gb24ge0Bjb2RlIHRvfVxuLy9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUuYWRkREZBRWRnZSA9IGZ1bmN0aW9uKGRmYSwgZnJvbV8sIHQsIHRvKSB7XG4gICAgaWYoIHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFREdFIFwiICsgZnJvbV8gKyBcIiAtPiBcIiArIHRvICsgXCIgdXBvbiBcIiArIHRoaXMuZ2V0VG9rZW5OYW1lKHQpKTtcbiAgICB9XG4gICAgaWYgKHRvPT09bnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG8gPSB0aGlzLmFkZERGQVN0YXRlKGRmYSwgdG8pOyAvLyB1c2VkIGV4aXN0aW5nIGlmIHBvc3NpYmxlIG5vdCBpbmNvbWluZ1xuICAgIGlmIChmcm9tXz09PW51bGwgfHwgdCA8IC0xIHx8IHQgPiB0aGlzLmF0bi5tYXhUb2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBpZiAoZnJvbV8uZWRnZXM9PT1udWxsKSB7XG4gICAgICAgIGZyb21fLmVkZ2VzID0gW107XG4gICAgfVxuICAgIGZyb21fLmVkZ2VzW3QrMV0gPSB0bzsgLy8gY29ubmVjdFxuXG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgdmFyIGxpdGVyYWxOYW1lcyA9IHRoaXMucGFyc2VyPT09bnVsbCA/IG51bGwgOiB0aGlzLnBhcnNlci5saXRlcmFsTmFtZXM7XG4gICAgICAgIHZhciBzeW1ib2xpY05hbWVzID0gdGhpcy5wYXJzZXI9PT1udWxsID8gbnVsbCA6IHRoaXMucGFyc2VyLnN5bWJvbGljTmFtZXM7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiREZBPVxcblwiICsgZGZhLnRvU3RyaW5nKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG87XG59O1xuLy9cbi8vIEFkZCBzdGF0ZSB7QGNvZGUgRH0gdG8gdGhlIERGQSBpZiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50LCBhbmQgcmV0dXJuXG4vLyB0aGUgYWN0dWFsIGluc3RhbmNlIHN0b3JlZCBpbiB0aGUgREZBLiBJZiBhIHN0YXRlIGVxdWl2YWxlbnQgdG8ge0Bjb2RlIER9XG4vLyBpcyBhbHJlYWR5IGluIHRoZSBERkEsIHRoZSBleGlzdGluZyBzdGF0ZSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoaXNcbi8vIG1ldGhvZCByZXR1cm5zIHtAY29kZSBEfSBhZnRlciBhZGRpbmcgaXQgdG8gdGhlIERGQS5cbi8vXG4vLyA8cD5JZiB7QGNvZGUgRH0gaXMge0BsaW5rIC8vRVJST1J9LCB0aGlzIG1ldGhvZCByZXR1cm5zIHtAbGluayAvL0VSUk9SfSBhbmRcbi8vIGRvZXMgbm90IGNoYW5nZSB0aGUgREZBLjwvcD5cbi8vXG4vLyBAcGFyYW0gZGZhIFRoZSBkZmFcbi8vIEBwYXJhbSBEIFRoZSBERkEgc3RhdGUgdG8gYWRkXG4vLyBAcmV0dXJuIFRoZSBzdGF0ZSBzdG9yZWQgaW4gdGhlIERGQS4gVGhpcyB3aWxsIGJlIGVpdGhlciB0aGUgZXhpc3Rpbmdcbi8vIHN0YXRlIGlmIHtAY29kZSBEfSBpcyBhbHJlYWR5IGluIHRoZSBERkEsIG9yIHtAY29kZSBEfSBpdHNlbGYgaWYgdGhlXG4vLyBzdGF0ZSB3YXMgbm90IGFscmVhZHkgcHJlc2VudC5cbi8vXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLmFkZERGQVN0YXRlID0gZnVuY3Rpb24oZGZhLCBEKSB7XG4gICAgaWYgKEQgPT0gQVROU2ltdWxhdG9yLkVSUk9SKSB7XG4gICAgICAgIHJldHVybiBEO1xuICAgIH1cbiAgICB2YXIgZXhpc3RpbmcgPSBkZmEuc3RhdGVzLmdldChEKTtcbiAgICBpZihleGlzdGluZyE9PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICBELnN0YXRlTnVtYmVyID0gZGZhLnN0YXRlcy5sZW5ndGg7XG4gICAgaWYgKCEgRC5jb25maWdzLnJlYWRPbmx5KSB7XG4gICAgICAgIEQuY29uZmlncy5vcHRpbWl6ZUNvbmZpZ3ModGhpcyk7XG4gICAgICAgIEQuY29uZmlncy5zZXRSZWFkb25seSh0cnVlKTtcbiAgICB9XG4gICAgZGZhLnN0YXRlcy5hZGQoRCk7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJhZGRpbmcgbmV3IERGQSBzdGF0ZTogXCIgKyBEKTtcbiAgICB9XG4gICAgcmV0dXJuIEQ7XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCA9IGZ1bmN0aW9uKGRmYSwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzLCBzdGFydEluZGV4LCBzdG9wSW5kZXgpIHtcbiAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXggKyAxKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZGVjaXNpb249XCIgKyBkZmEuZGVjaXNpb24gKyBcIjpcIiArIGNvbmZpZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGlucHV0PVwiICsgdGhpcy5wYXJzZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlciE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCkucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0KHRoaXMucGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKTtcbiAgICB9XG59O1xuXG5QYXJzZXJBVE5TaW11bGF0b3IucHJvdG90eXBlLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSA9IGZ1bmN0aW9uKGRmYSwgcHJlZGljdGlvbiwgY29uZmlncywgc3RhcnRJbmRleCwgc3RvcEluZGV4KSB7XG4gICAgaWYgKHRoaXMuZGVidWcgfHwgdGhpcy5yZXRyeV9kZWJ1Zykge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBuZXcgSW50ZXJ2YWwoc3RhcnRJbmRleCwgc3RvcEluZGV4ICsgMSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGRlY2lzaW9uPVwiICsgZGZhLmRlY2lzaW9uICsgXCI6XCIgKyBjb25maWdzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLCBpbnB1dD1cIiArIHRoaXMucGFyc2VyLmdldFRva2VuU3RyZWFtKCkuZ2V0VGV4dChpbnRlcnZhbCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJzZXIhPT1udWxsKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLmdldEVycm9yTGlzdGVuZXJEaXNwYXRjaCgpLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eSh0aGlzLnBhcnNlciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpO1xuICAgIH1cbn07XG5cbi8vIElmIGNvbnRleHQgc2Vuc2l0aXZlIHBhcnNpbmcsIHdlIGtub3cgaXQncyBhbWJpZ3VpdHkgbm90IGNvbmZsaWN0Ly9cblBhcnNlckFUTlNpbXVsYXRvci5wcm90b3R5cGUucmVwb3J0QW1iaWd1aXR5ID0gZnVuY3Rpb24oZGZhLCBELCBzdGFydEluZGV4LCBzdG9wSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyApIHtcbiAgICBpZiAodGhpcy5kZWJ1ZyB8fCB0aGlzLnJldHJ5X2RlYnVnKSB7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXggKyAxKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZXBvcnRBbWJpZ3VpdHkgXCIgKyBhbWJpZ0FsdHMgKyBcIjpcIiArIGNvbmZpZ3MgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGlucHV0PVwiICsgdGhpcy5wYXJzZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KGludGVydmFsKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlciE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RXJyb3JMaXN0ZW5lckRpc3BhdGNoKCkucmVwb3J0QW1iaWd1aXR5KHRoaXMucGFyc2VyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncyk7XG4gICAgfVxufTtcblxuZXhwb3J0cy5QYXJzZXJBVE5TaW11bGF0b3IgPSBQYXJzZXJBVE5TaW11bGF0b3I7IiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbi8vXG4vL1xuLy8gVGhpcyBlbnVtZXJhdGlvbiBkZWZpbmVzIHRoZSBwcmVkaWN0aW9uIG1vZGVzIGF2YWlsYWJsZSBpbiBBTlRMUiA0IGFsb25nIHdpdGhcbi8vIHV0aWxpdHkgbWV0aG9kcyBmb3IgYW5hbHl6aW5nIGNvbmZpZ3VyYXRpb24gc2V0cyBmb3IgY29uZmxpY3RzIGFuZC9vclxuLy8gYW1iaWd1aXRpZXMuXG5cbnZhciBTZXQgPSByZXF1aXJlKCcuLy4uL1V0aWxzJykuU2V0O1xudmFyIE1hcCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5NYXA7XG52YXIgQml0U2V0ID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLkJpdFNldDtcbnZhciBBbHREaWN0ID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLkFsdERpY3Q7XG52YXIgQVROID0gcmVxdWlyZSgnLi9BVE4nKS5BVE47XG52YXIgUnVsZVN0b3BTdGF0ZSA9IHJlcXVpcmUoJy4vQVROU3RhdGUnKS5SdWxlU3RvcFN0YXRlO1xudmFyIEFUTkNvbmZpZ1NldCA9IHJlcXVpcmUoJy4vQVROQ29uZmlnU2V0JykuQVROQ29uZmlnU2V0O1xudmFyIEFUTkNvbmZpZyA9IHJlcXVpcmUoJy4vQVROQ29uZmlnJykuQVROQ29uZmlnO1xudmFyIFNlbWFudGljQ29udGV4dCA9IHJlcXVpcmUoJy4vU2VtYW50aWNDb250ZXh0JykuU2VtYW50aWNDb250ZXh0O1xudmFyIEhhc2ggPSByZXF1aXJlKFwiLi4vVXRpbHNcIikuSGFzaDtcbnZhciBoYXNoU3R1ZmYgPSByZXF1aXJlKCcuLy4uL1V0aWxzJykuaGFzaFN0dWZmO1xudmFyIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi8uLi9VdGlscycpLmVxdWFsQXJyYXlzO1xuXG5mdW5jdGlvbiBQcmVkaWN0aW9uTW9kZSgpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cbi8vXG4vLyBUaGUgU0xMKCopIHByZWRpY3Rpb24gbW9kZS4gVGhpcyBwcmVkaWN0aW9uIG1vZGUgaWdub3JlcyB0aGUgY3VycmVudFxuLy8gcGFyc2VyIGNvbnRleHQgd2hlbiBtYWtpbmcgcHJlZGljdGlvbnMuIFRoaXMgaXMgdGhlIGZhc3Rlc3QgcHJlZGljdGlvblxuLy8gbW9kZSwgYW5kIHByb3ZpZGVzIGNvcnJlY3QgcmVzdWx0cyBmb3IgbWFueSBncmFtbWFycy4gVGhpcyBwcmVkaWN0aW9uXG4vLyBtb2RlIGlzIG1vcmUgcG93ZXJmdWwgdGhhbiB0aGUgcHJlZGljdGlvbiBtb2RlIHByb3ZpZGVkIGJ5IEFOVExSIDMsIGJ1dFxuLy8gbWF5IHJlc3VsdCBpbiBzeW50YXggZXJyb3JzIGZvciBncmFtbWFyIGFuZCBpbnB1dCBjb21iaW5hdGlvbnMgd2hpY2ggYXJlXG4vLyBub3QgU0xMLlxuLy9cbi8vIDxwPlxuLy8gV2hlbiB1c2luZyB0aGlzIHByZWRpY3Rpb24gbW9kZSwgdGhlIHBhcnNlciB3aWxsIGVpdGhlciByZXR1cm4gYSBjb3JyZWN0XG4vLyBwYXJzZSB0cmVlIChpLmUuIHRoZSBzYW1lIHBhcnNlIHRyZWUgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCB3aXRoIHRoZVxuLy8ge0BsaW5rIC8vTEx9IHByZWRpY3Rpb24gbW9kZSksIG9yIGl0IHdpbGwgcmVwb3J0IGEgc3ludGF4IGVycm9yLiBJZiBhXG4vLyBzeW50YXggZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hlbiB1c2luZyB0aGUge0BsaW5rIC8vU0xMfSBwcmVkaWN0aW9uIG1vZGUsXG4vLyBpdCBtYXkgYmUgZHVlIHRvIGVpdGhlciBhbiBhY3R1YWwgc3ludGF4IGVycm9yIGluIHRoZSBpbnB1dCBvciBpbmRpY2F0ZVxuLy8gdGhhdCB0aGUgcGFydGljdWxhciBjb21iaW5hdGlvbiBvZiBncmFtbWFyIGFuZCBpbnB1dCByZXF1aXJlcyB0aGUgbW9yZVxuLy8gcG93ZXJmdWwge0BsaW5rIC8vTEx9IHByZWRpY3Rpb24gYWJpbGl0aWVzIHRvIGNvbXBsZXRlIHN1Y2Nlc3NmdWxseS48L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGlzIHByZWRpY3Rpb24gbW9kZSBkb2VzIG5vdCBwcm92aWRlIGFueSBndWFyYW50ZWVzIGZvciBwcmVkaWN0aW9uXG4vLyBiZWhhdmlvciBmb3Igc3ludGFjdGljYWxseS1pbmNvcnJlY3QgaW5wdXRzLjwvcD5cbi8vXG5QcmVkaWN0aW9uTW9kZS5TTEwgPSAwO1xuLy9cbi8vIFRoZSBMTCgqKSBwcmVkaWN0aW9uIG1vZGUuIFRoaXMgcHJlZGljdGlvbiBtb2RlIGFsbG93cyB0aGUgY3VycmVudCBwYXJzZXJcbi8vIGNvbnRleHQgdG8gYmUgdXNlZCBmb3IgcmVzb2x2aW5nIFNMTCBjb25mbGljdHMgdGhhdCBvY2N1ciBkdXJpbmdcbi8vIHByZWRpY3Rpb24uIFRoaXMgaXMgdGhlIGZhc3Rlc3QgcHJlZGljdGlvbiBtb2RlIHRoYXQgZ3VhcmFudGVlcyBjb3JyZWN0XG4vLyBwYXJzZSByZXN1bHRzIGZvciBhbGwgY29tYmluYXRpb25zIG9mIGdyYW1tYXJzIHdpdGggc3ludGFjdGljYWxseSBjb3JyZWN0XG4vLyBpbnB1dHMuXG4vL1xuLy8gPHA+XG4vLyBXaGVuIHVzaW5nIHRoaXMgcHJlZGljdGlvbiBtb2RlLCB0aGUgcGFyc2VyIHdpbGwgbWFrZSBjb3JyZWN0IGRlY2lzaW9uc1xuLy8gZm9yIGFsbCBzeW50YWN0aWNhbGx5LWNvcnJlY3QgZ3JhbW1hciBhbmQgaW5wdXQgY29tYmluYXRpb25zLiBIb3dldmVyLCBpblxuLy8gY2FzZXMgd2hlcmUgdGhlIGdyYW1tYXIgaXMgdHJ1bHkgYW1iaWd1b3VzIHRoaXMgcHJlZGljdGlvbiBtb2RlIG1pZ2h0IG5vdFxuLy8gcmVwb3J0IGEgcHJlY2lzZSBhbnN3ZXIgZm9yIDxlbT5leGFjdGx5IHdoaWNoPC9lbT4gYWx0ZXJuYXRpdmVzIGFyZVxuLy8gYW1iaWd1b3VzLjwvcD5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgcHJlZGljdGlvbiBtb2RlIGRvZXMgbm90IHByb3ZpZGUgYW55IGd1YXJhbnRlZXMgZm9yIHByZWRpY3Rpb25cbi8vIGJlaGF2aW9yIGZvciBzeW50YWN0aWNhbGx5LWluY29ycmVjdCBpbnB1dHMuPC9wPlxuLy9cblByZWRpY3Rpb25Nb2RlLkxMID0gMTtcbi8vXG4vLyBUaGUgTEwoKikgcHJlZGljdGlvbiBtb2RlIHdpdGggZXhhY3QgYW1iaWd1aXR5IGRldGVjdGlvbi4gSW4gYWRkaXRpb24gdG9cbi8vIHRoZSBjb3JyZWN0bmVzcyBndWFyYW50ZWVzIHByb3ZpZGVkIGJ5IHRoZSB7QGxpbmsgLy9MTH0gcHJlZGljdGlvbiBtb2RlLFxuLy8gdGhpcyBwcmVkaWN0aW9uIG1vZGUgaW5zdHJ1Y3RzIHRoZSBwcmVkaWN0aW9uIGFsZ29yaXRobSB0byBkZXRlcm1pbmUgdGhlXG4vLyBjb21wbGV0ZSBhbmQgZXhhY3Qgc2V0IG9mIGFtYmlndW91cyBhbHRlcm5hdGl2ZXMgZm9yIGV2ZXJ5IGFtYmlndW91c1xuLy8gZGVjaXNpb24gZW5jb3VudGVyZWQgd2hpbGUgcGFyc2luZy5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgcHJlZGljdGlvbiBtb2RlIG1heSBiZSB1c2VkIGZvciBkaWFnbm9zaW5nIGFtYmlndWl0aWVzIGR1cmluZ1xuLy8gZ3JhbW1hciBkZXZlbG9wbWVudC4gRHVlIHRvIHRoZSBwZXJmb3JtYW5jZSBvdmVyaGVhZCBvZiBjYWxjdWxhdGluZyBzZXRzXG4vLyBvZiBhbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzLCB0aGlzIHByZWRpY3Rpb24gbW9kZSBzaG91bGQgYmUgYXZvaWRlZCB3aGVuXG4vLyB0aGUgZXhhY3QgcmVzdWx0cyBhcmUgbm90IG5lY2Vzc2FyeS48L3A+XG4vL1xuLy8gPHA+XG4vLyBUaGlzIHByZWRpY3Rpb24gbW9kZSBkb2VzIG5vdCBwcm92aWRlIGFueSBndWFyYW50ZWVzIGZvciBwcmVkaWN0aW9uXG4vLyBiZWhhdmlvciBmb3Igc3ludGFjdGljYWxseS1pbmNvcnJlY3QgaW5wdXRzLjwvcD5cbi8vXG5QcmVkaWN0aW9uTW9kZS5MTF9FWEFDVF9BTUJJR19ERVRFQ1RJT04gPSAyO1xuXG5cbi8vXG4vLyBDb21wdXRlcyB0aGUgU0xMIHByZWRpY3Rpb24gdGVybWluYXRpb24gY29uZGl0aW9uLlxuLy9cbi8vIDxwPlxuLy8gVGhpcyBtZXRob2QgY29tcHV0ZXMgdGhlIFNMTCBwcmVkaWN0aW9uIHRlcm1pbmF0aW9uIGNvbmRpdGlvbiBmb3IgYm90aCBvZlxuLy8gdGhlIGZvbGxvd2luZyBjYXNlcy48L3A+XG4vL1xuLy8gPHVsPlxuLy8gPGxpPlRoZSB1c3VhbCBTTEwrTEwgZmFsbGJhY2sgdXBvbiBTTEwgY29uZmxpY3Q8L2xpPlxuLy8gPGxpPlB1cmUgU0xMIHdpdGhvdXQgTEwgZmFsbGJhY2s8L2xpPlxuLy8gPC91bD5cbi8vXG4vLyA8cD48c3Ryb25nPkNPTUJJTkVEIFNMTCtMTCBQQVJTSU5HPC9zdHJvbmc+PC9wPlxuLy9cbi8vIDxwPldoZW4gTEwtZmFsbGJhY2sgaXMgZW5hYmxlZCB1cG9uIFNMTCBjb25mbGljdCwgY29ycmVjdCBwcmVkaWN0aW9ucyBhcmVcbi8vIGVuc3VyZWQgcmVnYXJkbGVzcyBvZiBob3cgdGhlIHRlcm1pbmF0aW9uIGNvbmRpdGlvbiBpcyBjb21wdXRlZCBieSB0aGlzXG4vLyBtZXRob2QuIER1ZSB0byB0aGUgc3Vic3RhbnRpYWxseSBoaWdoZXIgY29zdCBvZiBMTCBwcmVkaWN0aW9uLCB0aGVcbi8vIHByZWRpY3Rpb24gc2hvdWxkIG9ubHkgZmFsbCBiYWNrIHRvIExMIHdoZW4gdGhlIGFkZGl0aW9uYWwgbG9va2FoZWFkXG4vLyBjYW5ub3QgbGVhZCB0byBhIHVuaXF1ZSBTTEwgcHJlZGljdGlvbi48L3A+XG4vL1xuLy8gPHA+QXNzdW1pbmcgY29tYmluZWQgU0xMK0xMIHBhcnNpbmcsIGFuIFNMTCBjb25maWd1cmF0aW9uIHNldCB3aXRoIG9ubHlcbi8vIGNvbmZsaWN0aW5nIHN1YnNldHMgc2hvdWxkIGZhbGwgYmFjayB0byBmdWxsIExMLCBldmVuIGlmIHRoZVxuLy8gY29uZmlndXJhdGlvbiBzZXRzIGRvbid0IHJlc29sdmUgdG8gdGhlIHNhbWUgYWx0ZXJuYXRpdmUgKGUuZy5cbi8vIHtAY29kZSB7MSwyfX0gYW5kIHtAY29kZSB7Myw0fX0uIElmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBub24tY29uZmxpY3Rpbmdcbi8vIGNvbmZpZ3VyYXRpb24sIFNMTCBjb3VsZCBjb250aW51ZSB3aXRoIHRoZSBob3BlcyB0aGF0IG1vcmUgbG9va2FoZWFkIHdpbGxcbi8vIHJlc29sdmUgdmlhIG9uZSBvZiB0aG9zZSBub24tY29uZmxpY3RpbmcgY29uZmlndXJhdGlvbnMuPC9wPlxuLy9cbi8vIDxwPkhlcmUncyB0aGUgcHJlZGljdGlvbiB0ZXJtaW5hdGlvbiBydWxlIHRoZW06IFNMTCAoZm9yIFNMTCtMTCBwYXJzaW5nKVxuLy8gc3RvcHMgd2hlbiBpdCBzZWVzIG9ubHkgY29uZmxpY3RpbmcgY29uZmlndXJhdGlvbiBzdWJzZXRzLiBJbiBjb250cmFzdCxcbi8vIGZ1bGwgTEwga2VlcHMgZ29pbmcgd2hlbiB0aGVyZSBpcyB1bmNlcnRhaW50eS48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5IRVVSSVNUSUM8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+QXMgYSBoZXVyaXN0aWMsIHdlIHN0b3AgcHJlZGljdGlvbiB3aGVuIHdlIHNlZSBhbnkgY29uZmxpY3Rpbmcgc3Vic2V0XG4vLyB1bmxlc3Mgd2Ugc2VlIGEgc3RhdGUgdGhhdCBvbmx5IGhhcyBvbmUgYWx0ZXJuYXRpdmUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuLy8gVGhlIHNpbmdsZS1hbHQtc3RhdGUgdGhpbmcgbGV0cyBwcmVkaWN0aW9uIGNvbnRpbnVlIHVwb24gcnVsZXMgbGlrZVxuLy8gKG90aGVyd2lzZSwgaXQgd291bGQgYWRtaXQgZGVmZWF0IHRvbyBzb29uKTo8L3A+XG4vL1xuLy8gPHA+e0Bjb2RlIFsxMnwxfFtdLCA2fDJ8W10sIDEyfDJ8W11dLiBzIDogKElEIHwgSUQgSUQ/KSAnOycgO308L3A+XG4vL1xuLy8gPHA+V2hlbiB0aGUgQVROIHNpbXVsYXRpb24gcmVhY2hlcyB0aGUgc3RhdGUgYmVmb3JlIHtAY29kZSAnOyd9LCBpdCBoYXMgYVxuLy8gREZBIHN0YXRlIHRoYXQgbG9va3MgbGlrZToge0Bjb2RlIFsxMnwxfFtdLCA2fDJ8W10sIDEyfDJ8W11dfS4gTmF0dXJhbGx5XG4vLyB7QGNvZGUgMTJ8MXxbXX0gYW5kIHtAY29kZSAxMnwyfFtdfSBjb25mbGljdCwgYnV0IHdlIGNhbm5vdCBzdG9wXG4vLyBwcm9jZXNzaW5nIHRoaXMgbm9kZSBiZWNhdXNlIGFsdGVybmF0aXZlIHRvIGhhcyBhbm90aGVyIHdheSB0byBjb250aW51ZSxcbi8vIHZpYSB7QGNvZGUgWzZ8MnxbXV19LjwvcD5cbi8vXG4vLyA8cD5JdCBhbHNvIGxldCdzIHVzIGNvbnRpbnVlIGZvciB0aGlzIHJ1bGU6PC9wPlxuLy9cbi8vIDxwPntAY29kZSBbMXwxfFtdLCAxfDJ8W10sIDh8M3xbXV0gYSA6IEEgfCBBIHwgQSBCIDt9PC9wPlxuLy9cbi8vIDxwPkFmdGVyIG1hdGNoaW5nIGlucHV0IEEsIHdlIHJlYWNoIHRoZSBzdG9wIHN0YXRlIGZvciBydWxlIEEsIHN0YXRlIDEuXG4vLyBTdGF0ZSA4IGlzIHRoZSBzdGF0ZSByaWdodCBiZWZvcmUgQi4gQ2xlYXJseSBhbHRlcm5hdGl2ZXMgMSBhbmQgMlxuLy8gY29uZmxpY3QgYW5kIG5vIGFtb3VudCBvZiBmdXJ0aGVyIGxvb2thaGVhZCB3aWxsIHNlcGFyYXRlIHRoZSB0d28uXG4vLyBIb3dldmVyLCBhbHRlcm5hdGl2ZSAzIHdpbGwgYmUgYWJsZSB0byBjb250aW51ZSBhbmQgc28gd2UgZG8gbm90IHN0b3Bcbi8vIHdvcmtpbmcgb24gdGhpcyBzdGF0ZS4gSW4gdGhlIHByZXZpb3VzIGV4YW1wbGUsIHdlJ3JlIGNvbmNlcm5lZCB3aXRoXG4vLyBzdGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb25mbGljdGluZyBhbHRlcm5hdGl2ZXMuIEhlcmUgYWx0IDMgaXMgbm90XG4vLyBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbmZsaWN0aW5nIGNvbmZpZ3MsIGJ1dCBzaW5jZSB3ZSBjYW4gY29udGludWVcbi8vIGxvb2tpbmcgZm9yIGlucHV0IHJlYXNvbmFibHksIGRvbid0IGRlY2xhcmUgdGhlIHN0YXRlIGRvbmUuPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+UFVSRSBTTEwgUEFSU0lORzwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5UbyBoYW5kbGUgcHVyZSBTTEwgcGFyc2luZywgYWxsIHdlIGhhdmUgdG8gZG8gaXMgbWFrZSBzdXJlIHRoYXQgd2Vcbi8vIGNvbWJpbmUgc3RhY2sgY29udGV4dHMgZm9yIGNvbmZpZ3VyYXRpb25zIHRoYXQgZGlmZmVyIG9ubHkgYnkgc2VtYW50aWNcbi8vIHByZWRpY2F0ZS4gRnJvbSB0aGVyZSwgd2UgY2FuIGRvIHRoZSB1c3VhbCBTTEwgdGVybWluYXRpb24gaGV1cmlzdGljLjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPlBSRURJQ0FURVMgSU4gU0xMK0xMIFBBUlNJTkc8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+U0xMIGRlY2lzaW9ucyBkb24ndCBldmFsdWF0ZSBwcmVkaWNhdGVzIHVudGlsIGFmdGVyIHRoZXkgcmVhY2ggREZBIHN0b3Bcbi8vIHN0YXRlcyBiZWNhdXNlIHRoZXkgbmVlZCB0byBjcmVhdGUgdGhlIERGQSBjYWNoZSB0aGF0IHdvcmtzIGluIGFsbFxuLy8gc2VtYW50aWMgc2l0dWF0aW9ucy4gSW4gY29udHJhc3QsIGZ1bGwgTEwgZXZhbHVhdGVzIHByZWRpY2F0ZXMgY29sbGVjdGVkXG4vLyBkdXJpbmcgc3RhcnQgc3RhdGUgY29tcHV0YXRpb24gc28gaXQgY2FuIGlnbm9yZSBwcmVkaWNhdGVzIHRoZXJlYWZ0ZXIuXG4vLyBUaGlzIG1lYW5zIHRoYXQgU0xMIHRlcm1pbmF0aW9uIGRldGVjdGlvbiBjYW4gdG90YWxseSBpZ25vcmUgc2VtYW50aWNcbi8vIHByZWRpY2F0ZXMuPC9wPlxuLy9cbi8vIDxwPkltcGxlbWVudGF0aW9uLXdpc2UsIHtAbGluayBBVE5Db25maWdTZXR9IGNvbWJpbmVzIHN0YWNrIGNvbnRleHRzIGJ1dCBub3Rcbi8vIHNlbWFudGljIHByZWRpY2F0ZSBjb250ZXh0cyBzbyB3ZSBtaWdodCBzZWUgdHdvIGNvbmZpZ3VyYXRpb25zIGxpa2UgdGhlXG4vLyBmb2xsb3dpbmcuPC9wPlxuLy9cbi8vIDxwPntAY29kZSAocywgMSwgeCwge30pLCAocywgMSwgeCcsIHtwfSl9PC9wPlxuLy9cbi8vIDxwPkJlZm9yZSB0ZXN0aW5nIHRoZXNlIGNvbmZpZ3VyYXRpb25zIGFnYWluc3Qgb3RoZXJzLCB3ZSBoYXZlIHRvIG1lcmdlXG4vLyB7QGNvZGUgeH0gYW5kIHtAY29kZSB4J30gKHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBleGlzdGluZyBjb25maWd1cmF0aW9ucykuXG4vLyBGb3IgZXhhbXBsZSwgd2UgdGVzdCB7QGNvZGUgKHgreCcpPT14Jyd9IHdoZW4gbG9va2luZyBmb3IgY29uZmxpY3RzIGluXG4vLyB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb25zLjwvcD5cbi8vXG4vLyA8cD57QGNvZGUgKHMsIDEsIHgsIHt9KSwgKHMsIDEsIHgnLCB7cH0pLCAocywgMiwgeCcnLCB7fSl9PC9wPlxuLy9cbi8vIDxwPklmIHRoZSBjb25maWd1cmF0aW9uIHNldCBoYXMgcHJlZGljYXRlcyAoYXMgaW5kaWNhdGVkIGJ5XG4vLyB7QGxpbmsgQVROQ29uZmlnU2V0Ly9oYXNTZW1hbnRpY0NvbnRleHR9KSwgdGhpcyBhbGdvcml0aG0gbWFrZXMgYSBjb3B5IG9mXG4vLyB0aGUgY29uZmlndXJhdGlvbnMgdG8gc3RyaXAgb3V0IGFsbCBvZiB0aGUgcHJlZGljYXRlcyBzbyB0aGF0IGEgc3RhbmRhcmRcbi8vIHtAbGluayBBVE5Db25maWdTZXR9IHdpbGwgbWVyZ2UgZXZlcnl0aGluZyBpZ25vcmluZyBwcmVkaWNhdGVzLjwvcD5cbi8vXG5QcmVkaWN0aW9uTW9kZS5oYXNTTExDb25mbGljdFRlcm1pbmF0aW5nUHJlZGljdGlvbiA9IGZ1bmN0aW9uKCBtb2RlLCBjb25maWdzKSB7XG4gICAgLy8gQ29uZmlncyBpbiBydWxlIHN0b3Agc3RhdGVzIGluZGljYXRlIHJlYWNoaW5nIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uXG4gICAgLy8gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHN0YXJ0IHJ1bGUgKGZ1bGwgY29udGV4dCkuIElmIGFsbFxuICAgIC8vIGNvbmZpZ3MgbWVldCB0aGlzIGNvbmRpdGlvbiwgdGhlbiBub25lIG9mIHRoZSBjb25maWd1cmF0aW9ucyBpcyBhYmxlXG4gICAgLy8gdG8gbWF0Y2ggYWRkaXRpb25hbCBpbnB1dCBzbyB3ZSB0ZXJtaW5hdGUgcHJlZGljdGlvbi5cbiAgICAvL1xuICAgIGlmIChQcmVkaWN0aW9uTW9kZS5hbGxDb25maWdzSW5SdWxlU3RvcFN0YXRlcyhjb25maWdzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcHVyZSBTTEwgbW9kZSBwYXJzaW5nXG4gICAgaWYgKG1vZGUgPT09IFByZWRpY3Rpb25Nb2RlLlNMTCkge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgd2l0aCBjb21iaW5pbmcgY29uZmlncyBmcm9tIGRpZmZlcmVudCBzZW1hbnRpY1xuICAgICAgICAvLyBjb250ZXh0cyBpZiB3ZSBjYW4gZmFpbCBvdmVyIHRvIGZ1bGwgTEw7IGNvc3RzIG1vcmUgdGltZVxuICAgICAgICAvLyBzaW5jZSB3ZSdsbCBvZnRlbiBmYWlsIG92ZXIgYW55d2F5LlxuICAgICAgICBpZiAoY29uZmlncy5oYXNTZW1hbnRpY0NvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGR1cCBjb25maWdzLCB0b3NzaW5nIG91dCBzZW1hbnRpYyBwcmVkaWNhdGVzXG4gICAgICAgICAgICB2YXIgZHVwID0gbmV3IEFUTkNvbmZpZ1NldCgpO1xuICAgICAgICAgICAgZm9yKHZhciBpPTA7aTxjb25maWdzLml0ZW1zLmxlbmd0aDtpKyspIHtcbiAgICAgICAgICAgIFx0dmFyIGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGMgPSBuZXcgQVROQ29uZmlnKHtzZW1hbnRpY0NvbnRleHQ6U2VtYW50aWNDb250ZXh0Lk5PTkV9LCBjKTtcbiAgICAgICAgICAgICAgICBkdXAuYWRkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlncyA9IGR1cDtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgd2UgaGF2ZSBjb21iaW5lZCBjb250ZXh0cyBmb3IgY29uZmlncyB3aXRoIGRpc3NpbWlsYXIgcHJlZHNcbiAgICB9XG4gICAgLy8gcHVyZSBTTEwgb3IgY29tYmluZWQgU0xMK0xMIG1vZGUgcGFyc2luZ1xuICAgIHZhciBhbHRzZXRzID0gUHJlZGljdGlvbk1vZGUuZ2V0Q29uZmxpY3RpbmdBbHRTdWJzZXRzKGNvbmZpZ3MpO1xuICAgIHJldHVybiBQcmVkaWN0aW9uTW9kZS5oYXNDb25mbGljdGluZ0FsdFNldChhbHRzZXRzKSAmJiAhUHJlZGljdGlvbk1vZGUuaGFzU3RhdGVBc3NvY2lhdGVkV2l0aE9uZUFsdChjb25maWdzKTtcbn07XG5cbi8vIENoZWNrcyBpZiBhbnkgY29uZmlndXJhdGlvbiBpbiB7QGNvZGUgY29uZmlnc30gaXMgaW4gYVxuLy8ge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LiBDb25maWd1cmF0aW9ucyBtZWV0aW5nIHRoaXMgY29uZGl0aW9uIGhhdmUgcmVhY2hlZFxuLy8gdGhlIGVuZCBvZiB0aGUgZGVjaXNpb24gcnVsZSAobG9jYWwgY29udGV4dCkgb3IgZW5kIG9mIHN0YXJ0IHJ1bGUgKGZ1bGxcbi8vIGNvbnRleHQpLlxuLy9cbi8vIEBwYXJhbSBjb25maWdzIHRoZSBjb25maWd1cmF0aW9uIHNldCB0byB0ZXN0XG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiBhbnkgY29uZmlndXJhdGlvbiBpbiB7QGNvZGUgY29uZmlnc30gaXMgaW4gYVxuLy8ge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuUHJlZGljdGlvbk1vZGUuaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlID0gZnVuY3Rpb24oY29uZmlncykge1xuXHRmb3IodmFyIGk9MDtpPGNvbmZpZ3MuaXRlbXMubGVuZ3RoO2krKykge1xuXHRcdHZhciBjID0gY29uZmlncy5pdGVtc1tpXTtcbiAgICAgICAgaWYgKGMuc3RhdGUgaW5zdGFuY2VvZiBSdWxlU3RvcFN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXHR9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gQ2hlY2tzIGlmIGFsbCBjb25maWd1cmF0aW9ucyBpbiB7QGNvZGUgY29uZmlnc30gYXJlIGluIGFcbi8vIHtAbGluayBSdWxlU3RvcFN0YXRlfS4gQ29uZmlndXJhdGlvbnMgbWVldGluZyB0aGlzIGNvbmRpdGlvbiBoYXZlIHJlYWNoZWRcbi8vIHRoZSBlbmQgb2YgdGhlIGRlY2lzaW9uIHJ1bGUgKGxvY2FsIGNvbnRleHQpIG9yIGVuZCBvZiBzdGFydCBydWxlIChmdWxsXG4vLyBjb250ZXh0KS5cbi8vXG4vLyBAcGFyYW0gY29uZmlncyB0aGUgY29uZmlndXJhdGlvbiBzZXQgdG8gdGVzdFxuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgYWxsIGNvbmZpZ3VyYXRpb25zIGluIHtAY29kZSBjb25maWdzfSBhcmUgaW4gYVxuLy8ge0BsaW5rIFJ1bGVTdG9wU3RhdGV9LCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuUHJlZGljdGlvbk1vZGUuYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMgPSBmdW5jdGlvbihjb25maWdzKSB7XG5cdGZvcih2YXIgaT0wO2k8Y29uZmlncy5pdGVtcy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGMgPSBjb25maWdzLml0ZW1zW2ldO1xuICAgICAgICBpZiAoIShjLnN0YXRlIGluc3RhbmNlb2YgUnVsZVN0b3BTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXHR9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vL1xuLy8gRnVsbCBMTCBwcmVkaWN0aW9uIHRlcm1pbmF0aW9uLlxuLy9cbi8vIDxwPkNhbiB3ZSBzdG9wIGxvb2tpbmcgYWhlYWQgZHVyaW5nIEFUTiBzaW11bGF0aW9uIG9yIGlzIHRoZXJlIHNvbWVcbi8vIHVuY2VydGFpbnR5IGFzIHRvIHdoaWNoIGFsdGVybmF0aXZlIHdlIHdpbGwgdWx0aW1hdGVseSBwaWNrLCBhZnRlclxuLy8gY29uc3VtaW5nIG1vcmUgaW5wdXQ/IEV2ZW4gaWYgdGhlcmUgYXJlIHBhcnRpYWwgY29uZmxpY3RzLCB3ZSBtaWdodCBrbm93XG4vLyB0aGF0IGV2ZXJ5dGhpbmcgaXMgZ29pbmcgdG8gcmVzb2x2ZSB0byB0aGUgc2FtZSBtaW5pbXVtIGFsdGVybmF0aXZlLiBUaGF0XG4vLyBtZWFucyB3ZSBjYW4gc3RvcCBzaW5jZSBubyBtb3JlIGxvb2thaGVhZCB3aWxsIGNoYW5nZSB0aGF0IGZhY3QuIE9uIHRoZVxuLy8gb3RoZXIgaGFuZCwgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgY29uZmxpY3RzIHRoYXQgcmVzb2x2ZSB0byBkaWZmZXJlbnRcbi8vIG1pbmltdW1zLiBUaGF0IG1lYW5zIHdlIG5lZWQgbW9yZSBsb29rIGFoZWFkIHRvIGRlY2lkZSB3aGljaCBvZiB0aG9zZVxuLy8gYWx0ZXJuYXRpdmVzIHdlIHNob3VsZCBwcmVkaWN0LjwvcD5cbi8vXG4vLyA8cD5UaGUgYmFzaWMgaWRlYSBpcyB0byBzcGxpdCB0aGUgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIHtAY29kZSBDfSwgaW50b1xuLy8gY29uZmxpY3Rpbmcgc3Vic2V0cyB7QGNvZGUgKHMsIF8sIGN0eCwgXyl9IGFuZCBzaW5nbGV0b24gc3Vic2V0cyB3aXRoXG4vLyBub24tY29uZmxpY3RpbmcgY29uZmlndXJhdGlvbnMuIFR3byBjb25maWd1cmF0aW9ucyBjb25mbGljdCBpZiB0aGV5IGhhdmVcbi8vIGlkZW50aWNhbCB7QGxpbmsgQVROQ29uZmlnLy9zdGF0ZX0gYW5kIHtAbGluayBBVE5Db25maWcvL2NvbnRleHR9IHZhbHVlc1xuLy8gYnV0IGRpZmZlcmVudCB7QGxpbmsgQVROQ29uZmlnLy9hbHR9IHZhbHVlLCBlLmcuIHtAY29kZSAocywgaSwgY3R4LCBfKX1cbi8vIGFuZCB7QGNvZGUgKHMsIGosIGN0eCwgXyl9IGZvciB7QGNvZGUgaSE9an0uPC9wPlxuLy9cbi8vIDxwPlJlZHVjZSB0aGVzZSBjb25maWd1cmF0aW9uIHN1YnNldHMgdG8gdGhlIHNldCBvZiBwb3NzaWJsZSBhbHRlcm5hdGl2ZXMuXG4vLyBZb3UgY2FuIGNvbXB1dGUgdGhlIGFsdGVybmF0aXZlIHN1YnNldHMgaW4gb25lIHBhc3MgYXMgZm9sbG93czo8L3A+XG4vL1xuLy8gPHA+e0Bjb2RlIEFfcyxjdHggPSB7aSB8IChzLCBpLCBjdHgsIF8pfX0gZm9yIGVhY2ggY29uZmlndXJhdGlvbiBpblxuLy8ge0Bjb2RlIEN9IGhvbGRpbmcge0Bjb2RlIHN9IGFuZCB7QGNvZGUgY3R4fSBmaXhlZC48L3A+XG4vL1xuLy8gPHA+T3IgaW4gcHNldWRvLWNvZGUsIGZvciBlYWNoIGNvbmZpZ3VyYXRpb24ge0Bjb2RlIGN9IGluIHtAY29kZSBDfTo8L3A+XG4vL1xuLy8gPHByZT5cbi8vIG1hcFtjXSBVPSBjLntAbGluayBBVE5Db25maWcvL2FsdCBhbHR9IC8vIG1hcCBoYXNoL2VxdWFscyB1c2VzIHMgYW5kIHgsIG5vdFxuLy8gYWx0IGFuZCBub3QgcHJlZFxuLy8gPC9wcmU+XG4vL1xuLy8gPHA+VGhlIHZhbHVlcyBpbiB7QGNvZGUgbWFwfSBhcmUgdGhlIHNldCBvZiB7QGNvZGUgQV9zLGN0eH0gc2V0cy48L3A+XG4vL1xuLy8gPHA+SWYge0Bjb2RlIHxBX3MsY3R4fD0xfSB0aGVuIHRoZXJlIGlzIG5vIGNvbmZsaWN0IGFzc29jaWF0ZWQgd2l0aFxuLy8ge0Bjb2RlIHN9IGFuZCB7QGNvZGUgY3R4fS48L3A+XG4vL1xuLy8gPHA+UmVkdWNlIHRoZSBzdWJzZXRzIHRvIHNpbmdsZXRvbnMgYnkgY2hvb3NpbmcgYSBtaW5pbXVtIG9mIGVhY2ggc3Vic2V0LiBJZlxuLy8gdGhlIHVuaW9uIG9mIHRoZXNlIGFsdGVybmF0aXZlIHN1YnNldHMgaXMgYSBzaW5nbGV0b24sIHRoZW4gbm8gYW1vdW50IG9mXG4vLyBtb3JlIGxvb2thaGVhZCB3aWxsIGhlbHAgdXMuIFdlIHdpbGwgYWx3YXlzIHBpY2sgdGhhdCBhbHRlcm5hdGl2ZS4gSWYsXG4vLyBob3dldmVyLCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGFsdGVybmF0aXZlLCB0aGVuIHdlIGFyZSB1bmNlcnRhaW4gd2hpY2hcbi8vIGFsdGVybmF0aXZlIHRvIHByZWRpY3QgYW5kIG11c3QgY29udGludWUgbG9va2luZyBmb3IgcmVzb2x1dGlvbi4gV2UgbWF5XG4vLyBvciBtYXkgbm90IGRpc2NvdmVyIGFuIGFtYmlndWl0eSBpbiB0aGUgZnV0dXJlLCBldmVuIGlmIHRoZXJlIGFyZSBub1xuLy8gY29uZmxpY3Rpbmcgc3Vic2V0cyB0aGlzIHJvdW5kLjwvcD5cbi8vXG4vLyA8cD5UaGUgYmlnZ2VzdCBzaW4gaXMgdG8gdGVybWluYXRlIGVhcmx5IGJlY2F1c2UgaXQgbWVhbnMgd2UndmUgbWFkZSBhXG4vLyBkZWNpc2lvbiBidXQgd2VyZSB1bmNlcnRhaW4gYXMgdG8gdGhlIGV2ZW50dWFsIG91dGNvbWUuIFdlIGhhdmVuJ3QgdXNlZFxuLy8gZW5vdWdoIGxvb2thaGVhZC4gT24gdGhlIG90aGVyIGhhbmQsIGFubm91bmNpbmcgYSBjb25mbGljdCB0b28gbGF0ZSBpcyBub1xuLy8gYmlnIGRlYWw7IHlvdSB3aWxsIHN0aWxsIGhhdmUgdGhlIGNvbmZsaWN0LiBJdCdzIGp1c3QgaW5lZmZpY2llbnQuIEl0XG4vLyBtaWdodCBldmVuIGxvb2sgdW50aWwgdGhlIGVuZCBvZiBmaWxlLjwvcD5cbi8vXG4vLyA8cD5ObyBzcGVjaWFsIGNvbnNpZGVyYXRpb24gZm9yIHNlbWFudGljIHByZWRpY2F0ZXMgaXMgcmVxdWlyZWQgYmVjYXVzZVxuLy8gcHJlZGljYXRlcyBhcmUgZXZhbHVhdGVkIG9uLXRoZS1mbHkgZm9yIGZ1bGwgTEwgcHJlZGljdGlvbiwgZW5zdXJpbmcgdGhhdFxuLy8gbm8gY29uZmlndXJhdGlvbiBjb250YWlucyBhIHNlbWFudGljIGNvbnRleHQgZHVyaW5nIHRoZSB0ZXJtaW5hdGlvblxuLy8gY2hlY2suPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+Q09ORkxJQ1RJTkcgQ09ORklHUzwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5Ud28gY29uZmlndXJhdGlvbnMge0Bjb2RlIChzLCBpLCB4KX0gYW5kIHtAY29kZSAocywgaiwgeCcpfSwgY29uZmxpY3Rcbi8vIHdoZW4ge0Bjb2RlIGkhPWp9IGJ1dCB7QGNvZGUgeD14J30uIEJlY2F1c2Ugd2UgbWVyZ2UgYWxsXG4vLyB7QGNvZGUgKHMsIGksIF8pfSBjb25maWd1cmF0aW9ucyB0b2dldGhlciwgdGhhdCBtZWFucyB0aGF0IHRoZXJlIGFyZSBhdFxuLy8gbW9zdCB7QGNvZGUgbn0gY29uZmlndXJhdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHN0YXRlIHtAY29kZSBzfSBmb3Jcbi8vIHtAY29kZSBufSBwb3NzaWJsZSBhbHRlcm5hdGl2ZXMgaW4gdGhlIGRlY2lzaW9uLiBUaGUgbWVyZ2VkIHN0YWNrc1xuLy8gY29tcGxpY2F0ZSB0aGUgY29tcGFyaXNvbiBvZiBjb25maWd1cmF0aW9uIGNvbnRleHRzIHtAY29kZSB4fSBhbmRcbi8vIHtAY29kZSB4J30uIFNhbSBjaGVja3MgdG8gc2VlIGlmIG9uZSBpcyBhIHN1YnNldCBvZiB0aGUgb3RoZXIgYnkgY2FsbGluZ1xuLy8gbWVyZ2UgYW5kIGNoZWNraW5nIHRvIHNlZSBpZiB0aGUgbWVyZ2VkIHJlc3VsdCBpcyBlaXRoZXIge0Bjb2RlIHh9IG9yXG4vLyB7QGNvZGUgeCd9LiBJZiB0aGUge0Bjb2RlIHh9IGFzc29jaWF0ZWQgd2l0aCBsb3dlc3QgYWx0ZXJuYXRpdmUge0Bjb2RlIGl9XG4vLyBpcyB0aGUgc3VwZXJzZXQsIHRoZW4ge0Bjb2RlIGl9IGlzIHRoZSBvbmx5IHBvc3NpYmxlIHByZWRpY3Rpb24gc2luY2UgdGhlXG4vLyBvdGhlcnMgcmVzb2x2ZSB0byB7QGNvZGUgbWluKGkpfSBhcyB3ZWxsLiBIb3dldmVyLCBpZiB7QGNvZGUgeH0gaXNcbi8vIGFzc29jaWF0ZWQgd2l0aCB7QGNvZGUgaj5pfSB0aGVuIGF0IGxlYXN0IG9uZSBzdGFjayBjb25maWd1cmF0aW9uIGZvclxuLy8ge0Bjb2RlIGp9IGlzIG5vdCBpbiBjb25mbGljdCB3aXRoIGFsdGVybmF0aXZlIHtAY29kZSBpfS4gVGhlIGFsZ29yaXRobVxuLy8gc2hvdWxkIGtlZXAgZ29pbmcsIGxvb2tpbmcgZm9yIG1vcmUgbG9va2FoZWFkIGR1ZSB0byB0aGUgdW5jZXJ0YWludHkuPC9wPlxuLy9cbi8vIDxwPkZvciBzaW1wbGljaXR5LCBJJ20gZG9pbmcgYSBlcXVhbGl0eSBjaGVjayBiZXR3ZWVuIHtAY29kZSB4fSBhbmRcbi8vIHtAY29kZSB4J30gdGhhdCBsZXRzIHRoZSBhbGdvcml0aG0gY29udGludWUgdG8gY29uc3VtZSBsb29rYWhlYWQgbG9uZ2VyXG4vLyB0aGFuIG5lY2Vzc2FyeS4gVGhlIHJlYXNvbiBJIGxpa2UgdGhlIGVxdWFsaXR5IGlzIG9mIGNvdXJzZSB0aGVcbi8vIHNpbXBsaWNpdHkgYnV0IGFsc28gYmVjYXVzZSB0aGF0IGlzIHRoZSB0ZXN0IHlvdSBuZWVkIHRvIGRldGVjdCB0aGVcbi8vIGFsdGVybmF0aXZlcyB0aGF0IGFyZSBhY3R1YWxseSBpbiBjb25mbGljdC48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5DT05USU5VRS9TVE9QIFJVTEU8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+Q29udGludWUgaWYgdW5pb24gb2YgcmVzb2x2ZWQgYWx0ZXJuYXRpdmUgc2V0cyBmcm9tIG5vbi1jb25mbGljdGluZyBhbmRcbi8vIGNvbmZsaWN0aW5nIGFsdGVybmF0aXZlIHN1YnNldHMgaGFzIG1vcmUgdGhhbiBvbmUgYWx0ZXJuYXRpdmUuIFdlIGFyZVxuLy8gdW5jZXJ0YWluIGFib3V0IHdoaWNoIGFsdGVybmF0aXZlIHRvIHByZWRpY3QuPC9wPlxuLy9cbi8vIDxwPlRoZSBjb21wbGV0ZSBzZXQgb2YgYWx0ZXJuYXRpdmVzLCB7QGNvZGUgW2kgZm9yIChfLGksXyldfSwgdGVsbHMgdXMgd2hpY2hcbi8vIGFsdGVybmF0aXZlcyBhcmUgc3RpbGwgaW4gdGhlIHJ1bm5pbmcgZm9yIHRoZSBhbW91bnQgb2YgaW5wdXQgd2UndmVcbi8vIGNvbnN1bWVkIGF0IHRoaXMgcG9pbnQuIFRoZSBjb25mbGljdGluZyBzZXRzIGxldCB1cyB0byBzdHJpcCBhd2F5XG4vLyBjb25maWd1cmF0aW9ucyB0aGF0IHdvbid0IGxlYWQgdG8gbW9yZSBzdGF0ZXMgYmVjYXVzZSB3ZSByZXNvbHZlXG4vLyBjb25mbGljdHMgdG8gdGhlIGNvbmZpZ3VyYXRpb24gd2l0aCBhIG1pbmltdW0gYWx0ZXJuYXRlIGZvciB0aGVcbi8vIGNvbmZsaWN0aW5nIHNldC48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5DQVNFUzwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8dWw+XG4vL1xuLy8gPGxpPm5vIGNvbmZsaWN0cyBhbmQgbW9yZSB0aGFuIDEgYWx0ZXJuYXRpdmUgaW4gc2V0ID0mZ3Q7IGNvbnRpbnVlPC9saT5cbi8vXG4vLyA8bGk+IHtAY29kZSAocywgMSwgeCl9LCB7QGNvZGUgKHMsIDIsIHgpfSwge0Bjb2RlIChzLCAzLCB6KX0sXG4vLyB7QGNvZGUgKHMnLCAxLCB5KX0sIHtAY29kZSAocycsIDIsIHkpfSB5aWVsZHMgbm9uLWNvbmZsaWN0aW5nIHNldFxuLy8ge0Bjb2RlIHszfX0gVSBjb25mbGljdGluZyBzZXRzIHtAY29kZSBtaW4oezEsMn0pfSBVIHtAY29kZSBtaW4oezEsMn0pfSA9XG4vLyB7QGNvZGUgezEsM319ID0mZ3Q7IGNvbnRpbnVlXG4vLyA8L2xpPlxuLy9cbi8vIDxsaT57QGNvZGUgKHMsIDEsIHgpfSwge0Bjb2RlIChzLCAyLCB4KX0sIHtAY29kZSAocycsIDEsIHkpfSxcbi8vIHtAY29kZSAocycsIDIsIHkpfSwge0Bjb2RlIChzJycsIDEsIHopfSB5aWVsZHMgbm9uLWNvbmZsaWN0aW5nIHNldFxuLy8ge0Bjb2RlIHsxfX0gVSBjb25mbGljdGluZyBzZXRzIHtAY29kZSBtaW4oezEsMn0pfSBVIHtAY29kZSBtaW4oezEsMn0pfSA9XG4vLyB7QGNvZGUgezF9fSA9Jmd0OyBzdG9wIGFuZCBwcmVkaWN0IDE8L2xpPlxuLy9cbi8vIDxsaT57QGNvZGUgKHMsIDEsIHgpfSwge0Bjb2RlIChzLCAyLCB4KX0sIHtAY29kZSAocycsIDEsIHkpfSxcbi8vIHtAY29kZSAocycsIDIsIHkpfSB5aWVsZHMgY29uZmxpY3RpbmcsIHJlZHVjZWQgc2V0cyB7QGNvZGUgezF9fSBVXG4vLyB7QGNvZGUgezF9fSA9IHtAY29kZSB7MX19ID0mZ3Q7IHN0b3AgYW5kIHByZWRpY3QgMSwgY2FuIGFubm91bmNlXG4vLyBhbWJpZ3VpdHkge0Bjb2RlIHsxLDJ9fTwvbGk+XG4vL1xuLy8gPGxpPntAY29kZSAocywgMSwgeCl9LCB7QGNvZGUgKHMsIDIsIHgpfSwge0Bjb2RlIChzJywgMiwgeSl9LFxuLy8ge0Bjb2RlIChzJywgMywgeSl9IHlpZWxkcyBjb25mbGljdGluZywgcmVkdWNlZCBzZXRzIHtAY29kZSB7MX19IFVcbi8vIHtAY29kZSB7Mn19ID0ge0Bjb2RlIHsxLDJ9fSA9Jmd0OyBjb250aW51ZTwvbGk+XG4vL1xuLy8gPGxpPntAY29kZSAocywgMSwgeCl9LCB7QGNvZGUgKHMsIDIsIHgpfSwge0Bjb2RlIChzJywgMywgeSl9LFxuLy8ge0Bjb2RlIChzJywgNCwgeSl9IHlpZWxkcyBjb25mbGljdGluZywgcmVkdWNlZCBzZXRzIHtAY29kZSB7MX19IFVcbi8vIHtAY29kZSB7M319ID0ge0Bjb2RlIHsxLDN9fSA9Jmd0OyBjb250aW51ZTwvbGk+XG4vL1xuLy8gPC91bD5cbi8vXG4vLyA8cD48c3Ryb25nPkVYQUNUIEFNQklHVUlUWSBERVRFQ1RJT048L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+SWYgYWxsIHN0YXRlcyByZXBvcnQgdGhlIHNhbWUgY29uZmxpY3Rpbmcgc2V0IG9mIGFsdGVybmF0aXZlcywgdGhlbiB3ZVxuLy8ga25vdyB3ZSBoYXZlIHRoZSBleGFjdCBhbWJpZ3VpdHkgc2V0LjwvcD5cbi8vXG4vLyA8cD48Y29kZT58QV88ZW0+aTwvZW0+fCZndDsxPC9jb2RlPiBhbmRcbi8vIDxjb2RlPkFfPGVtPmk8L2VtPiA9IEFfPGVtPmo8L2VtPjwvY29kZT4gZm9yIGFsbCA8ZW0+aTwvZW0+LCA8ZW0+ajwvZW0+LjwvcD5cbi8vXG4vLyA8cD5JbiBvdGhlciB3b3Jkcywgd2UgY29udGludWUgZXhhbWluaW5nIGxvb2thaGVhZCB1bnRpbCBhbGwge0Bjb2RlIEFfaX1cbi8vIGhhdmUgbW9yZSB0aGFuIG9uZSBhbHRlcm5hdGl2ZSBhbmQgYWxsIHtAY29kZSBBX2l9IGFyZSB0aGUgc2FtZS4gSWZcbi8vIHtAY29kZSBBPXt7MSwyfSwgezEsM319fSwgdGhlbiByZWd1bGFyIExMIHByZWRpY3Rpb24gd291bGQgdGVybWluYXRlXG4vLyBiZWNhdXNlIHRoZSByZXNvbHZlZCBzZXQgaXMge0Bjb2RlIHsxfX0uIFRvIGRldGVybWluZSB3aGF0IHRoZSByZWFsXG4vLyBhbWJpZ3VpdHkgaXMsIHdlIGhhdmUgdG8ga25vdyB3aGV0aGVyIHRoZSBhbWJpZ3VpdHkgaXMgYmV0d2VlbiBvbmUgYW5kXG4vLyB0d28gb3Igb25lIGFuZCB0aHJlZSBzbyB3ZSBrZWVwIGdvaW5nLiBXZSBjYW4gb25seSBzdG9wIHByZWRpY3Rpb24gd2hlblxuLy8gd2UgbmVlZCBleGFjdCBhbWJpZ3VpdHkgZGV0ZWN0aW9uIHdoZW4gdGhlIHNldHMgbG9vayBsaWtlXG4vLyB7QGNvZGUgQT17ezEsMn19fSBvciB7QGNvZGUge3sxLDJ9LHsxLDJ9fX0sIGV0Yy4uLjwvcD5cbi8vXG5QcmVkaWN0aW9uTW9kZS5yZXNvbHZlc1RvSnVzdE9uZVZpYWJsZUFsdCA9IGZ1bmN0aW9uKGFsdHNldHMpIHtcbiAgICByZXR1cm4gUHJlZGljdGlvbk1vZGUuZ2V0U2luZ2xlVmlhYmxlQWx0KGFsdHNldHMpO1xufTtcblxuLy9cbi8vIERldGVybWluZXMgaWYgZXZlcnkgYWx0ZXJuYXRpdmUgc3Vic2V0IGluIHtAY29kZSBhbHRzZXRzfSBjb250YWlucyBtb3JlXG4vLyB0aGFuIG9uZSBhbHRlcm5hdGl2ZS5cbi8vXG4vLyBAcGFyYW0gYWx0c2V0cyBhIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgc3Vic2V0c1xuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYgZXZlcnkge0BsaW5rIEJpdFNldH0gaW4ge0Bjb2RlIGFsdHNldHN9IGhhc1xuLy8ge0BsaW5rIEJpdFNldC8vY2FyZGluYWxpdHkgY2FyZGluYWxpdHl9ICZndDsgMSwgb3RoZXJ3aXNlIHtAY29kZSBmYWxzZX1cbi8vXG5QcmVkaWN0aW9uTW9kZS5hbGxTdWJzZXRzQ29uZmxpY3QgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgcmV0dXJuICEgUHJlZGljdGlvbk1vZGUuaGFzTm9uQ29uZmxpY3RpbmdBbHRTZXQoYWx0c2V0cyk7XG59O1xuLy9cbi8vIERldGVybWluZXMgaWYgYW55IHNpbmdsZSBhbHRlcm5hdGl2ZSBzdWJzZXQgaW4ge0Bjb2RlIGFsdHNldHN9IGNvbnRhaW5zXG4vLyBleGFjdGx5IG9uZSBhbHRlcm5hdGl2ZS5cbi8vXG4vLyBAcGFyYW0gYWx0c2V0cyBhIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgc3Vic2V0c1xuLy8gQHJldHVybiB7QGNvZGUgdHJ1ZX0gaWYge0Bjb2RlIGFsdHNldHN9IGNvbnRhaW5zIGEge0BsaW5rIEJpdFNldH0gd2l0aFxuLy8ge0BsaW5rIEJpdFNldC8vY2FyZGluYWxpdHkgY2FyZGluYWxpdHl9IDEsIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9XG4vL1xuUHJlZGljdGlvbk1vZGUuaGFzTm9uQ29uZmxpY3RpbmdBbHRTZXQgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG5cdGZvcih2YXIgaT0wO2k8YWx0c2V0cy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGFsdHMgPSBhbHRzZXRzW2ldO1xuICAgICAgICBpZiAoYWx0cy5sZW5ndGg9PT0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXHR9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy9cbi8vIERldGVybWluZXMgaWYgYW55IHNpbmdsZSBhbHRlcm5hdGl2ZSBzdWJzZXQgaW4ge0Bjb2RlIGFsdHNldHN9IGNvbnRhaW5zXG4vLyBtb3JlIHRoYW4gb25lIGFsdGVybmF0aXZlLlxuLy9cbi8vIEBwYXJhbSBhbHRzZXRzIGEgY29sbGVjdGlvbiBvZiBhbHRlcm5hdGl2ZSBzdWJzZXRzXG4vLyBAcmV0dXJuIHtAY29kZSB0cnVlfSBpZiB7QGNvZGUgYWx0c2V0c30gY29udGFpbnMgYSB7QGxpbmsgQml0U2V0fSB3aXRoXG4vLyB7QGxpbmsgQml0U2V0Ly9jYXJkaW5hbGl0eSBjYXJkaW5hbGl0eX0gJmd0OyAxLCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuLy9cblByZWRpY3Rpb25Nb2RlLmhhc0NvbmZsaWN0aW5nQWx0U2V0ID0gZnVuY3Rpb24oYWx0c2V0cykge1xuXHRmb3IodmFyIGk9MDtpPGFsdHNldHMubGVuZ3RoO2krKykge1xuXHRcdHZhciBhbHRzID0gYWx0c2V0c1tpXTtcbiAgICAgICAgaWYgKGFsdHMubGVuZ3RoPjEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cdH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vL1xuLy8gRGV0ZXJtaW5lcyBpZiBldmVyeSBhbHRlcm5hdGl2ZSBzdWJzZXQgaW4ge0Bjb2RlIGFsdHNldHN9IGlzIGVxdWl2YWxlbnQuXG4vL1xuLy8gQHBhcmFtIGFsdHNldHMgYSBjb2xsZWN0aW9uIG9mIGFsdGVybmF0aXZlIHN1YnNldHNcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIGV2ZXJ5IG1lbWJlciBvZiB7QGNvZGUgYWx0c2V0c30gaXMgZXF1YWwgdG8gdGhlXG4vLyBvdGhlcnMsIG90aGVyd2lzZSB7QGNvZGUgZmFsc2V9XG4vL1xuUHJlZGljdGlvbk1vZGUuYWxsU3Vic2V0c0VxdWFsID0gZnVuY3Rpb24oYWx0c2V0cykge1xuICAgIHZhciBmaXJzdCA9IG51bGw7XG5cdGZvcih2YXIgaT0wO2k8YWx0c2V0cy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGFsdHMgPSBhbHRzZXRzW2ldO1xuICAgICAgICBpZiAoZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gYWx0cztcbiAgICAgICAgfSBlbHNlIGlmIChhbHRzIT09Zmlyc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXHR9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vL1xuLy8gUmV0dXJucyB0aGUgdW5pcXVlIGFsdGVybmF0aXZlIHByZWRpY3RlZCBieSBhbGwgYWx0ZXJuYXRpdmUgc3Vic2V0cyBpblxuLy8ge0Bjb2RlIGFsdHNldHN9LiBJZiBubyBzdWNoIGFsdGVybmF0aXZlIGV4aXN0cywgdGhpcyBtZXRob2QgcmV0dXJuc1xuLy8ge0BsaW5rIEFUTi8vSU5WQUxJRF9BTFRfTlVNQkVSfS5cbi8vXG4vLyBAcGFyYW0gYWx0c2V0cyBhIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgc3Vic2V0c1xuLy9cblByZWRpY3Rpb25Nb2RlLmdldFVuaXF1ZUFsdCA9IGZ1bmN0aW9uKGFsdHNldHMpIHtcbiAgICB2YXIgYWxsID0gUHJlZGljdGlvbk1vZGUuZ2V0QWx0cyhhbHRzZXRzKTtcbiAgICBpZiAoYWxsLmxlbmd0aD09PTEpIHtcbiAgICAgICAgcmV0dXJuIGFsbC5taW5WYWx1ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBBVE4uSU5WQUxJRF9BTFRfTlVNQkVSO1xuICAgIH1cbn07XG5cbi8vIEdldHMgdGhlIGNvbXBsZXRlIHNldCBvZiByZXByZXNlbnRlZCBhbHRlcm5hdGl2ZXMgZm9yIGEgY29sbGVjdGlvbiBvZlxuLy8gYWx0ZXJuYXRpdmUgc3Vic2V0cy4gVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdW5pb24gb2YgZWFjaCB7QGxpbmsgQml0U2V0fVxuLy8gaW4ge0Bjb2RlIGFsdHNldHN9LlxuLy9cbi8vIEBwYXJhbSBhbHRzZXRzIGEgY29sbGVjdGlvbiBvZiBhbHRlcm5hdGl2ZSBzdWJzZXRzXG4vLyBAcmV0dXJuIHRoZSBzZXQgb2YgcmVwcmVzZW50ZWQgYWx0ZXJuYXRpdmVzIGluIHtAY29kZSBhbHRzZXRzfVxuLy9cblByZWRpY3Rpb25Nb2RlLmdldEFsdHMgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgdmFyIGFsbCA9IG5ldyBCaXRTZXQoKTtcbiAgICBhbHRzZXRzLm1hcCggZnVuY3Rpb24oYWx0cykgeyBhbGwub3IoYWx0cyk7IH0pO1xuICAgIHJldHVybiBhbGw7XG59O1xuXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBjb25mbGljdGluZyBhbHQgc3Vic2V0cyBmcm9tIGEgY29uZmlndXJhdGlvbiBzZXQuXG4vLyBGb3IgZWFjaCBjb25maWd1cmF0aW9uIHtAY29kZSBjfSBpbiB7QGNvZGUgY29uZmlnc306XG4vL1xuLy8gPHByZT5cbi8vIG1hcFtjXSBVPSBjLntAbGluayBBVE5Db25maWcvL2FsdCBhbHR9IC8vIG1hcCBoYXNoL2VxdWFscyB1c2VzIHMgYW5kIHgsIG5vdFxuLy8gYWx0IGFuZCBub3QgcHJlZFxuLy8gPC9wcmU+XG5cblByZWRpY3Rpb25Nb2RlLmdldENvbmZsaWN0aW5nQWx0U3Vic2V0cyA9IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICB2YXIgY29uZmlnVG9BbHRzID0gbmV3IE1hcCgpO1xuICAgIGNvbmZpZ1RvQWx0cy5oYXNoRnVuY3Rpb24gPSBmdW5jdGlvbihjZmcpIHsgaGFzaFN0dWZmKGNmZy5zdGF0ZS5zdGF0ZU51bWJlciwgY2ZnLmNvbnRleHQpOyB9O1xuICAgIGNvbmZpZ1RvQWx0cy5lcXVhbHNGdW5jdGlvbiA9IGZ1bmN0aW9uKGMxLCBjMikgeyByZXR1cm4gYzEuc3RhdGUuc3RhdGVOdW1iZXI9PWMyLnN0YXRlLnN0YXRlTnVtYmVyICYmIGMxLmNvbnRleHQuZXF1YWxzKGMyLmNvbnRleHQpO31cbiAgICBjb25maWdzLml0ZW1zLm1hcChmdW5jdGlvbihjZmcpIHtcbiAgICAgICAgdmFyIGFsdHMgPSBjb25maWdUb0FsdHMuZ2V0KGNmZyk7XG4gICAgICAgIGlmIChhbHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRzID0gbmV3IEJpdFNldCgpO1xuICAgICAgICAgICAgY29uZmlnVG9BbHRzLnB1dChjZmcsIGFsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGFsdHMuYWRkKGNmZy5hbHQpO1xuXHR9KTtcbiAgICByZXR1cm4gY29uZmlnVG9BbHRzLmdldFZhbHVlcygpO1xufTtcblxuLy9cbi8vIEdldCBhIG1hcCBmcm9tIHN0YXRlIHRvIGFsdCBzdWJzZXQgZnJvbSBhIGNvbmZpZ3VyYXRpb24gc2V0LiBGb3IgZWFjaFxuLy8gY29uZmlndXJhdGlvbiB7QGNvZGUgY30gaW4ge0Bjb2RlIGNvbmZpZ3N9OlxuLy9cbi8vIDxwcmU+XG4vLyBtYXBbYy57QGxpbmsgQVROQ29uZmlnLy9zdGF0ZSBzdGF0ZX1dIFU9IGMue0BsaW5rIEFUTkNvbmZpZy8vYWx0IGFsdH1cbi8vIDwvcHJlPlxuLy9cblByZWRpY3Rpb25Nb2RlLmdldFN0YXRlVG9BbHRNYXAgPSBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIG0gPSBuZXcgQWx0RGljdCgpO1xuICAgIGNvbmZpZ3MuaXRlbXMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIGFsdHMgPSBtLmdldChjLnN0YXRlKTtcbiAgICAgICAgaWYgKGFsdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdHMgPSBuZXcgQml0U2V0KCk7XG4gICAgICAgICAgICBtLnB1dChjLnN0YXRlLCBhbHRzKTtcbiAgICAgICAgfVxuICAgICAgICBhbHRzLmFkZChjLmFsdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG07XG59O1xuXG5QcmVkaWN0aW9uTW9kZS5oYXNTdGF0ZUFzc29jaWF0ZWRXaXRoT25lQWx0ID0gZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciB2YWx1ZXMgPSBQcmVkaWN0aW9uTW9kZS5nZXRTdGF0ZVRvQWx0TWFwKGNvbmZpZ3MpLnZhbHVlcygpO1xuICAgIGZvcih2YXIgaT0wO2k8dmFsdWVzLmxlbmd0aDtpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXS5sZW5ndGg9PT0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5QcmVkaWN0aW9uTW9kZS5nZXRTaW5nbGVWaWFibGVBbHQgPSBmdW5jdGlvbihhbHRzZXRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cdGZvcih2YXIgaT0wO2k8YWx0c2V0cy5sZW5ndGg7aSsrKSB7XG5cdFx0dmFyIGFsdHMgPSBhbHRzZXRzW2ldO1xuICAgICAgICB2YXIgbWluQWx0ID0gYWx0cy5taW5WYWx1ZSgpO1xuICAgICAgICBpZihyZXN1bHQ9PT1udWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtaW5BbHQ7XG4gICAgICAgIH0gZWxzZSBpZihyZXN1bHQhPT1taW5BbHQpIHsgLy8gbW9yZSB0aGFuIDEgdmlhYmxlIGFsdFxuICAgICAgICAgICAgcmV0dXJuIEFUTi5JTlZBTElEX0FMVF9OVU1CRVI7XG4gICAgICAgIH1cblx0fVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLlByZWRpY3Rpb25Nb2RlID0gUHJlZGljdGlvbk1vZGU7XG4iLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy8gQSB0cmVlIHN0cnVjdHVyZSB1c2VkIHRvIHJlY29yZCB0aGUgc2VtYW50aWMgY29udGV4dCBpbiB3aGljaFxuLy8gIGFuIEFUTiBjb25maWd1cmF0aW9uIGlzIHZhbGlkLiAgSXQncyBlaXRoZXIgYSBzaW5nbGUgcHJlZGljYXRlLFxuLy8gIGEgY29uanVuY3Rpb24ge0Bjb2RlIHAxJiZwMn0sIG9yIGEgc3VtIG9mIHByb2R1Y3RzIHtAY29kZSBwMXx8cDJ9LlxuLy9cbi8vICA8cD5JIGhhdmUgc2NvcGVkIHRoZSB7QGxpbmsgQU5EfSwge0BsaW5rIE9SfSwgYW5kIHtAbGluayBQcmVkaWNhdGV9IHN1YmNsYXNzZXMgb2Zcbi8vICB7QGxpbmsgU2VtYW50aWNDb250ZXh0fSB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoaXMgb3V0ZXIgY2xhc3MuPC9wPlxuLy9cblxudmFyIFNldCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5TZXQ7XG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5IYXNoO1xuXG5mdW5jdGlvbiBTZW1hbnRpY0NvbnRleHQoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5TZW1hbnRpY0NvbnRleHQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuICAgIHRoaXMudXBkYXRlSGFzaENvZGUoaGFzaCk7XG4gICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG59O1xuXG4vLyBGb3IgY29udGV4dCBpbmRlcGVuZGVudCBwcmVkaWNhdGVzLCB3ZSBldmFsdWF0ZSB0aGVtIHdpdGhvdXQgYSBsb2NhbFxuLy8gY29udGV4dCAoaS5lLiwgbnVsbCBjb250ZXh0KS4gVGhhdCB3YXksIHdlIGNhbiBldmFsdWF0ZSB0aGVtIHdpdGhvdXRcbi8vIGhhdmluZyB0byBjcmVhdGUgcHJvcGVyIHJ1bGUtc3BlY2lmaWMgY29udGV4dCBkdXJpbmcgcHJlZGljdGlvbiAoYXNcbi8vIG9wcG9zZWQgdG8gdGhlIHBhcnNlciwgd2hpY2ggY3JlYXRlcyB0aGVtIG5hdHVyYWxseSkuIEluIGEgcHJhY3RpY2FsXG4vLyBzZW5zZSwgdGhpcyBhdm9pZHMgYSBjYXN0IGV4Y2VwdGlvbiBmcm9tIFJ1bGVDb250ZXh0IHRvIG15cnVsZUNvbnRleHQuXG4vL1xuLy8gPHA+Rm9yIGNvbnRleHQgZGVwZW5kZW50IHByZWRpY2F0ZXMsIHdlIG11c3QgcGFzcyBpbiBhIGxvY2FsIGNvbnRleHQgc28gdGhhdFxuLy8gcmVmZXJlbmNlcyBzdWNoIGFzICRhcmcgZXZhbHVhdGUgcHJvcGVybHkgYXMgX2xvY2FsY3R4LmFyZy4gV2Ugb25seVxuLy8gY2FwdHVyZSBjb250ZXh0IGRlcGVuZGVudCBwcmVkaWNhdGVzIGluIHRoZSBjb250ZXh0IGluIHdoaWNoIHdlIGJlZ2luXG4vLyBwcmVkaWN0aW9uLCBzbyB3ZSBwYXNzZWQgaW4gdGhlIG91dGVyIGNvbnRleHQgaGVyZSBpbiBjYXNlIG9mIGNvbnRleHRcbi8vIGRlcGVuZGVudCBwcmVkaWNhdGUgZXZhbHVhdGlvbi48L3A+XG4vL1xuU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG59O1xuXG4vL1xuLy8gRXZhbHVhdGUgdGhlIHByZWNlZGVuY2UgcHJlZGljYXRlcyBmb3IgdGhlIGNvbnRleHQgYW5kIHJlZHVjZSB0aGUgcmVzdWx0LlxuLy9cbi8vIEBwYXJhbSBwYXJzZXIgVGhlIHBhcnNlciBpbnN0YW5jZS5cbi8vIEBwYXJhbSBvdXRlckNvbnRleHQgVGhlIGN1cnJlbnQgcGFyc2VyIGNvbnRleHQgb2JqZWN0LlxuLy8gQHJldHVybiBUaGUgc2ltcGxpZmllZCBzZW1hbnRpYyBjb250ZXh0IGFmdGVyIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmVcbi8vIGV2YWx1YXRlZCwgd2hpY2ggd2lsbCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXMuXG4vLyA8dWw+XG4vLyA8bGk+e0BsaW5rIC8vTk9ORX06IGlmIHRoZSBwcmVkaWNhdGUgc2ltcGxpZmllcyB0byB7QGNvZGUgdHJ1ZX0gYWZ0ZXJcbi8vIHByZWNlZGVuY2UgcHJlZGljYXRlcyBhcmUgZXZhbHVhdGVkLjwvbGk+XG4vLyA8bGk+e0Bjb2RlIG51bGx9OiBpZiB0aGUgcHJlZGljYXRlIHNpbXBsaWZpZXMgdG8ge0Bjb2RlIGZhbHNlfSBhZnRlclxuLy8gcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuPC9saT5cbi8vIDxsaT57QGNvZGUgdGhpc306IGlmIHRoZSBzZW1hbnRpYyBjb250ZXh0IGlzIG5vdCBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mXG4vLyBwcmVjZWRlbmNlIHByZWRpY2F0ZSBldmFsdWF0aW9uLjwvbGk+XG4vLyA8bGk+QSBub24te0Bjb2RlIG51bGx9IHtAbGluayBTZW1hbnRpY0NvbnRleHR9OiB0aGUgbmV3IHNpbXBsaWZpZWRcbi8vIHNlbWFudGljIGNvbnRleHQgYWZ0ZXIgcHJlY2VkZW5jZSBwcmVkaWNhdGVzIGFyZSBldmFsdWF0ZWQuPC9saT5cbi8vIDwvdWw+XG4vL1xuU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHJldHVybiB0aGlzO1xufTtcblxuU2VtYW50aWNDb250ZXh0LmFuZENvbnRleHQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChhID09PSBudWxsIHx8IGEgPT09IFNlbWFudGljQ29udGV4dC5OT05FKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKGIgPT09IG51bGwgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRyZXR1cm4gYTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gbmV3IEFORChhLCBiKTtcblx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gcmVzdWx0Lm9wbmRzWzBdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cblNlbWFudGljQ29udGV4dC5vckNvbnRleHQgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChhID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGI7XG5cdH1cblx0aWYgKGIgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gYTtcblx0fVxuXHRpZiAoYSA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUgfHwgYiA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRyZXR1cm4gU2VtYW50aWNDb250ZXh0Lk5PTkU7XG5cdH1cblx0dmFyIHJlc3VsdCA9IG5ldyBPUihhLCBiKTtcblx0aWYgKHJlc3VsdC5vcG5kcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gcmVzdWx0Lm9wbmRzWzBdO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIFByZWRpY2F0ZShydWxlSW5kZXgsIHByZWRJbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4ID09PSB1bmRlZmluZWQgPyAtMSA6IHJ1bGVJbmRleDtcblx0dGhpcy5wcmVkSW5kZXggPSBwcmVkSW5kZXggPT09IHVuZGVmaW5lZCA/IC0xIDogcHJlZEluZGV4O1xuXHR0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogaXNDdHhEZXBlbmRlbnQ7IC8vIGUuZy4sICRpIHJlZiBpbiBwcmVkXG5cdHJldHVybiB0aGlzO1xufVxuXG5QcmVkaWNhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTZW1hbnRpY0NvbnRleHQucHJvdG90eXBlKTtcblByZWRpY2F0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVkaWNhdGU7XG5cbi8vVGhlIGRlZmF1bHQge0BsaW5rIFNlbWFudGljQ29udGV4dH0sIHdoaWNoIGlzIHNlbWFudGljYWxseSBlcXVpdmFsZW50IHRvXG4vL2EgcHJlZGljYXRlIG9mIHRoZSBmb3JtIHtAY29kZSB7dHJ1ZX0/fS5cbi8vXG5TZW1hbnRpY0NvbnRleHQuTk9ORSA9IG5ldyBQcmVkaWNhdGUoKTtcblxuXG5QcmVkaWNhdGUucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24ocGFyc2VyLCBvdXRlckNvbnRleHQpIHtcblx0dmFyIGxvY2FsY3R4ID0gdGhpcy5pc0N0eERlcGVuZGVudCA/IG91dGVyQ29udGV4dCA6IG51bGw7XG5cdHJldHVybiBwYXJzZXIuc2VtcHJlZChsb2NhbGN0eCwgdGhpcy5ydWxlSW5kZXgsIHRoaXMucHJlZEluZGV4KTtcbn07XG5cblByZWRpY2F0ZS5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG5cdGhhc2gudXBkYXRlKHRoaXMucnVsZUluZGV4LCB0aGlzLnByZWRJbmRleCwgdGhpcy5pc0N0eERlcGVuZGVudCk7XG59O1xuXG5QcmVkaWNhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQcmVkaWNhdGUpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLnJ1bGVJbmRleCA9PT0gb3RoZXIucnVsZUluZGV4ICYmXG5cdFx0XHRcdHRoaXMucHJlZEluZGV4ID09PSBvdGhlci5wcmVkSW5kZXggJiZcblx0XHRcdFx0dGhpcy5pc0N0eERlcGVuZGVudCA9PT0gb3RoZXIuaXNDdHhEZXBlbmRlbnQ7XG5cdH1cbn07XG5cblByZWRpY2F0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwie1wiICsgdGhpcy5ydWxlSW5kZXggKyBcIjpcIiArIHRoaXMucHJlZEluZGV4ICsgXCJ9P1wiO1xufTtcblxuZnVuY3Rpb24gUHJlY2VkZW5jZVByZWRpY2F0ZShwcmVjZWRlbmNlKSB7XG5cdFNlbWFudGljQ29udGV4dC5jYWxsKHRoaXMpO1xuXHR0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlID09PSB1bmRlZmluZWQgPyAwIDogcHJlY2VkZW5jZTtcbn1cblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNlbWFudGljQ29udGV4dC5wcm90b3R5cGUpO1xuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVjZWRlbmNlUHJlZGljYXRlO1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHJldHVybiBwYXJzZXIucHJlY3ByZWQob3V0ZXJDb250ZXh0LCB0aGlzLnByZWNlZGVuY2UpO1xufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuZXZhbFByZWNlZGVuY2UgPSBmdW5jdGlvbihwYXJzZXIsIG91dGVyQ29udGV4dCkge1xuXHRpZiAocGFyc2VyLnByZWNwcmVkKG91dGVyQ29udGV4dCwgdGhpcy5wcmVjZWRlbmNlKSkge1xuXHRcdHJldHVybiBTZW1hbnRpY0NvbnRleHQuTk9ORTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24ob3RoZXIpIHtcblx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSAtIG90aGVyLnByZWNlZGVuY2U7XG59O1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSgzMSk7XG59O1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHRpZiAodGhpcyA9PT0gb3RoZXIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJlY2VkZW5jZVByZWRpY2F0ZSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlY2VkZW5jZSA9PT0gb3RoZXIucHJlY2VkZW5jZTtcblx0fVxufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwie1wiK3RoaXMucHJlY2VkZW5jZStcIj49cHJlY30/XCI7XG59O1xuXG5cblxuUHJlY2VkZW5jZVByZWRpY2F0ZS5maWx0ZXJQcmVjZWRlbmNlUHJlZGljYXRlcyA9IGZ1bmN0aW9uKHNldCkge1xuXHR2YXIgcmVzdWx0ID0gW107XG5cdHNldC52YWx1ZXMoKS5tYXAoIGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHRpZiAoY29udGV4dCBpbnN0YW5jZW9mIFByZWNlZGVuY2VQcmVkaWNhdGUpIHtcblx0XHRcdHJlc3VsdC5wdXNoKGNvbnRleHQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8vIEEgc2VtYW50aWMgY29udGV4dCB3aGljaCBpcyB0cnVlIHdoZW5ldmVyIG5vbmUgb2YgdGhlIGNvbnRhaW5lZCBjb250ZXh0c1xuLy8gaXMgZmFsc2UuXG4vL1xuZnVuY3Rpb24gQU5EKGEsIGIpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHZhciBvcGVyYW5kcyA9IG5ldyBTZXQoKTtcblx0aWYgKGEgaW5zdGFuY2VvZiBBTkQpIHtcblx0XHRhLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0XHRvcGVyYW5kcy5hZGQobyk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3BlcmFuZHMuYWRkKGEpO1xuXHR9XG5cdGlmIChiIGluc3RhbmNlb2YgQU5EKSB7XG5cdFx0Yi5vcG5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdFx0b3BlcmFuZHMuYWRkKG8pO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG9wZXJhbmRzLmFkZChiKTtcblx0fVxuXHR2YXIgcHJlY2VkZW5jZVByZWRpY2F0ZXMgPSBQcmVjZWRlbmNlUHJlZGljYXRlLmZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKG9wZXJhbmRzKTtcblx0aWYgKHByZWNlZGVuY2VQcmVkaWNhdGVzLmxlbmd0aCA+IDApIHtcblx0XHQvLyBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIGxvd2VzdCBwcmVjZWRlbmNlXG5cdFx0dmFyIHJlZHVjZWQgPSBudWxsO1xuXHRcdHByZWNlZGVuY2VQcmVkaWNhdGVzLm1hcCggZnVuY3Rpb24ocCkge1xuXHRcdFx0aWYocmVkdWNlZD09PW51bGwgfHwgcC5wcmVjZWRlbmNlPHJlZHVjZWQucHJlY2VkZW5jZSkge1xuXHRcdFx0XHRyZWR1Y2VkID0gcDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRvcGVyYW5kcy5hZGQocmVkdWNlZCk7XG5cdH1cblx0dGhpcy5vcG5kcyA9IG9wZXJhbmRzLnZhbHVlcygpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQU5ELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2VtYW50aWNDb250ZXh0LnByb3RvdHlwZSk7XG5BTkQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQU5EO1xuXG5BTkQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBBTkQpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLm9wbmRzID09PSBvdGhlci5vcG5kcztcblx0fVxufTtcblxuQU5ELnByb3RvdHlwZS51cGRhdGVIYXNoQ29kZSA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLnVwZGF0ZSh0aGlzLm9wbmRzLCBcIkFORFwiKTtcbn07XG4vL1xuLy8ge0Bpbmhlcml0RG9jfVxuLy9cbi8vIDxwPlxuLy8gVGhlIGV2YWx1YXRpb24gb2YgcHJlZGljYXRlcyBieSB0aGlzIGNvbnRleHQgaXMgc2hvcnQtY2lyY3VpdGluZywgYnV0XG4vLyB1bm9yZGVyZWQuPC9wPlxuLy9cbkFORC5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbihwYXJzZXIsIG91dGVyQ29udGV4dCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIXRoaXMub3BuZHNbaV0uZXZhbHVhdGUocGFyc2VyLCBvdXRlckNvbnRleHQpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufTtcblxuQU5ELnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHZhciBkaWZmZXJzID0gZmFsc2U7XG5cdHZhciBvcGVyYW5kcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXMub3BuZHNbaV07XG5cdFx0dmFyIGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpO1xuXHRcdGRpZmZlcnMgfD0gKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XG5cdFx0aWYgKGV2YWx1YXRlZCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gVGhlIEFORCBjb250ZXh0IGlzIGZhbHNlIGlmIGFueSBlbGVtZW50IGlzIGZhbHNlXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9IGVsc2UgaWYgKGV2YWx1YXRlZCAhPT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRcdC8vIFJlZHVjZSB0aGUgcmVzdWx0IGJ5IHNraXBwaW5nIHRydWUgZWxlbWVudHNcblx0XHRcdG9wZXJhbmRzLnB1c2goZXZhbHVhdGVkKTtcblx0XHR9XG5cdH1cblx0aWYgKCFkaWZmZXJzKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0aWYgKG9wZXJhbmRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdC8vIGFsbCBlbGVtZW50cyB3ZXJlIHRydWUsIHNvIHRoZSBBTkQgY29udGV4dCBpcyB0cnVlXG5cdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xuXHR9XG5cdHZhciByZXN1bHQgPSBudWxsO1xuXHRvcGVyYW5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdHJlc3VsdCA9IHJlc3VsdCA9PT0gbnVsbCA/IG8gOiBTZW1hbnRpY0NvbnRleHQuYW5kQ29udGV4dChyZXN1bHQsIG8pO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbkFORC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0dmFyIHMgPSBcIlwiO1xuXHR0aGlzLm9wbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0cyArPSBcIiYmIFwiICsgby50b1N0cmluZygpO1xuXHR9KTtcblx0cmV0dXJuIHMubGVuZ3RoID4gMyA/IHMuc2xpY2UoMykgOiBzO1xufTtcblxuLy9cbi8vIEEgc2VtYW50aWMgY29udGV4dCB3aGljaCBpcyB0cnVlIHdoZW5ldmVyIGF0IGxlYXN0IG9uZSBvZiB0aGUgY29udGFpbmVkXG4vLyBjb250ZXh0cyBpcyB0cnVlLlxuLy9cbmZ1bmN0aW9uIE9SKGEsIGIpIHtcblx0U2VtYW50aWNDb250ZXh0LmNhbGwodGhpcyk7XG5cdHZhciBvcGVyYW5kcyA9IG5ldyBTZXQoKTtcblx0aWYgKGEgaW5zdGFuY2VvZiBPUikge1xuXHRcdGEub3BuZHMubWFwKGZ1bmN0aW9uKG8pIHtcblx0XHRcdG9wZXJhbmRzLmFkZChvKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvcGVyYW5kcy5hZGQoYSk7XG5cdH1cblx0aWYgKGIgaW5zdGFuY2VvZiBPUikge1xuXHRcdGIub3BuZHMubWFwKGZ1bmN0aW9uKG8pIHtcblx0XHRcdG9wZXJhbmRzLmFkZChvKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvcGVyYW5kcy5hZGQoYik7XG5cdH1cblxuXHR2YXIgcHJlY2VkZW5jZVByZWRpY2F0ZXMgPSBQcmVjZWRlbmNlUHJlZGljYXRlLmZpbHRlclByZWNlZGVuY2VQcmVkaWNhdGVzKG9wZXJhbmRzKTtcblx0aWYgKHByZWNlZGVuY2VQcmVkaWNhdGVzLmxlbmd0aCA+IDApIHtcblx0XHQvLyBpbnRlcmVzdGVkIGluIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIGhpZ2hlc3QgcHJlY2VkZW5jZVxuXHRcdHZhciBzID0gcHJlY2VkZW5jZVByZWRpY2F0ZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYS5jb21wYXJlVG8oYik7XG5cdFx0fSk7XG5cdFx0dmFyIHJlZHVjZWQgPSBzW3MubGVuZ3RoLTFdO1xuXHRcdG9wZXJhbmRzLmFkZChyZWR1Y2VkKTtcblx0fVxuXHR0aGlzLm9wbmRzID0gb3BlcmFuZHMudmFsdWVzKCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5PUi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNlbWFudGljQ29udGV4dC5wcm90b3R5cGUpO1xuT1IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT1I7XG5cbk9SLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKG90aGVyKSB7XG5cdGlmICh0aGlzID09PSBvdGhlcikge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGVsc2UgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBPUikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMub3BuZHMgPT09IG90aGVyLm9wbmRzO1xuXHR9XG59O1xuXG5PUi5wcm90b3R5cGUudXBkYXRlSGFzaENvZGUgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC51cGRhdGUodGhpcy5vcG5kcywgXCJPUlwiKTtcbn07XG5cbi8vIDxwPlxuLy8gVGhlIGV2YWx1YXRpb24gb2YgcHJlZGljYXRlcyBieSB0aGlzIGNvbnRleHQgaXMgc2hvcnQtY2lyY3VpdGluZywgYnV0XG4vLyB1bm9yZGVyZWQuPC9wPlxuLy9cbk9SLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcG5kcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0aGlzLm9wbmRzW2ldLmV2YWx1YXRlKHBhcnNlciwgb3V0ZXJDb250ZXh0KSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbk9SLnByb3RvdHlwZS5ldmFsUHJlY2VkZW5jZSA9IGZ1bmN0aW9uKHBhcnNlciwgb3V0ZXJDb250ZXh0KSB7XG5cdHZhciBkaWZmZXJzID0gZmFsc2U7XG5cdHZhciBvcGVyYW5kcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3BuZHMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXMub3BuZHNbaV07XG5cdFx0dmFyIGV2YWx1YXRlZCA9IGNvbnRleHQuZXZhbFByZWNlZGVuY2UocGFyc2VyLCBvdXRlckNvbnRleHQpO1xuXHRcdGRpZmZlcnMgfD0gKGV2YWx1YXRlZCAhPT0gY29udGV4dCk7XG5cdFx0aWYgKGV2YWx1YXRlZCA9PT0gU2VtYW50aWNDb250ZXh0Lk5PTkUpIHtcblx0XHRcdC8vIFRoZSBPUiBjb250ZXh0IGlzIHRydWUgaWYgYW55IGVsZW1lbnQgaXMgdHJ1ZVxuXHRcdFx0cmV0dXJuIFNlbWFudGljQ29udGV4dC5OT05FO1xuXHRcdH0gZWxzZSBpZiAoZXZhbHVhdGVkICE9PSBudWxsKSB7XG5cdFx0XHQvLyBSZWR1Y2UgdGhlIHJlc3VsdCBieSBza2lwcGluZyBmYWxzZSBlbGVtZW50c1xuXHRcdFx0b3BlcmFuZHMucHVzaChldmFsdWF0ZWQpO1xuXHRcdH1cblx0fVxuXHRpZiAoIWRpZmZlcnMpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHRpZiAob3BlcmFuZHMubGVuZ3RoID09PSAwKSB7XG5cdFx0Ly8gYWxsIGVsZW1lbnRzIHdlcmUgZmFsc2UsIHNvIHRoZSBPUiBjb250ZXh0IGlzIGZhbHNlXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIHJlc3VsdCA9IG51bGw7XG5cdG9wZXJhbmRzLm1hcChmdW5jdGlvbihvKSB7XG5cdFx0cmV0dXJuIHJlc3VsdCA9PT0gbnVsbCA/IG8gOiBTZW1hbnRpY0NvbnRleHQub3JDb250ZXh0KHJlc3VsdCwgbyk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuT1IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzID0gXCJcIjtcblx0dGhpcy5vcG5kcy5tYXAoZnVuY3Rpb24obykge1xuXHRcdHMgKz0gXCJ8fCBcIiArIG8udG9TdHJpbmcoKTtcblx0fSk7XG5cdHJldHVybiBzLmxlbmd0aCA+IDMgPyBzLnNsaWNlKDMpIDogcztcbn07XG5cbmV4cG9ydHMuU2VtYW50aWNDb250ZXh0ID0gU2VtYW50aWNDb250ZXh0O1xuZXhwb3J0cy5QcmVjZWRlbmNlUHJlZGljYXRlID0gUHJlY2VkZW5jZVByZWRpY2F0ZTtcbmV4cG9ydHMuUHJlZGljYXRlID0gUHJlZGljYXRlO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxuLy8gIEFuIEFUTiB0cmFuc2l0aW9uIGJldHdlZW4gYW55IHR3byBBVE4gc3RhdGVzLiAgU3ViY2xhc3NlcyBkZWZpbmVcbi8vICBhdG9tLCBzZXQsIGVwc2lsb24sIGFjdGlvbiwgcHJlZGljYXRlLCBydWxlIHRyYW5zaXRpb25zLlxuLy9cbi8vICA8cD5UaGlzIGlzIGEgb25lIHdheSBsaW5rLiAgSXQgZW1hbmF0ZXMgZnJvbSBhIHN0YXRlICh1c3VhbGx5IHZpYSBhIGxpc3Qgb2Zcbi8vICB0cmFuc2l0aW9ucykgYW5kIGhhcyBhIHRhcmdldCBzdGF0ZS48L3A+XG4vL1xuLy8gIDxwPlNpbmNlIHdlIG5ldmVyIGhhdmUgdG8gY2hhbmdlIHRoZSBBVE4gdHJhbnNpdGlvbnMgb25jZSB3ZSBjb25zdHJ1Y3QgaXQsXG4vLyAgd2UgY2FuIGZpeCB0aGVzZSB0cmFuc2l0aW9ucyBhcyBzcGVjaWZpYyBjbGFzc2VzLiBUaGUgREZBIHRyYW5zaXRpb25zXG4vLyAgb24gdGhlIG90aGVyIGhhbmQgbmVlZCB0byB1cGRhdGUgdGhlIGxhYmVscyBhcyBpdCBhZGRzIHRyYW5zaXRpb25zIHRvXG4vLyAgdGhlIHN0YXRlcy4gV2UnbGwgdXNlIHRoZSB0ZXJtIEVkZ2UgZm9yIHRoZSBERkEgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tXG4vLyAgQVROIHRyYW5zaXRpb25zLjwvcD5cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIEludGVydmFsU2V0ID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsU2V0O1xudmFyIFByZWRpY2F0ZSA9IHJlcXVpcmUoJy4vU2VtYW50aWNDb250ZXh0JykuUHJlZGljYXRlO1xudmFyIFByZWNlZGVuY2VQcmVkaWNhdGUgPSByZXF1aXJlKCcuL1NlbWFudGljQ29udGV4dCcpLlByZWNlZGVuY2VQcmVkaWNhdGU7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24gKHRhcmdldCkge1xuICAgIC8vIFRoZSB0YXJnZXQgb2YgdGhpcyB0cmFuc2l0aW9uLlxuICAgIGlmICh0YXJnZXQ9PT11bmRlZmluZWQgfHwgdGFyZ2V0PT09bnVsbCkge1xuICAgICAgICB0aHJvdyBcInRhcmdldCBjYW5ub3QgYmUgbnVsbC5cIjtcbiAgICB9XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgLy8gQXJlIHdlIGVwc2lsb24sIGFjdGlvbiwgc2VtcHJlZD9cbiAgICB0aGlzLmlzRXBzaWxvbiA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufVxuICAgIC8vIGNvbnN0YW50cyBmb3Igc2VyaWFsaXphdGlvblxuVHJhbnNpdGlvbi5FUFNJTE9OID0gMTtcblRyYW5zaXRpb24uUkFOR0UgPSAyO1xuVHJhbnNpdGlvbi5SVUxFID0gMztcblRyYW5zaXRpb24uUFJFRElDQVRFID0gNDsgLy8gZS5nLiwge2lzVHlwZShpbnB1dC5MVCgxKSl9P1xuVHJhbnNpdGlvbi5BVE9NID0gNTtcblRyYW5zaXRpb24uQUNUSU9OID0gNjtcblRyYW5zaXRpb24uU0VUID0gNzsgLy8gfihBfEIpIG9yIH5hdG9tLCB3aWxkY2FyZCwgd2hpY2ggY29udmVydCB0byBuZXh0IDJcblRyYW5zaXRpb24uTk9UX1NFVCA9IDg7XG5UcmFuc2l0aW9uLldJTERDQVJEID0gOTtcblRyYW5zaXRpb24uUFJFQ0VERU5DRSA9IDEwO1xuXG5UcmFuc2l0aW9uLnNlcmlhbGl6YXRpb25OYW1lcyA9IFtcbiAgICAgICAgICAgIFwiSU5WQUxJRFwiLFxuICAgICAgICAgICAgXCJFUFNJTE9OXCIsXG4gICAgICAgICAgICBcIlJBTkdFXCIsXG4gICAgICAgICAgICBcIlJVTEVcIixcbiAgICAgICAgICAgIFwiUFJFRElDQVRFXCIsXG4gICAgICAgICAgICBcIkFUT01cIixcbiAgICAgICAgICAgIFwiQUNUSU9OXCIsXG4gICAgICAgICAgICBcIlNFVFwiLFxuICAgICAgICAgICAgXCJOT1RfU0VUXCIsXG4gICAgICAgICAgICBcIldJTERDQVJEXCIsXG4gICAgICAgICAgICBcIlBSRUNFREVOQ0VcIlxuICAgICAgICBdO1xuXG5UcmFuc2l0aW9uLnNlcmlhbGl6YXRpb25UeXBlcyA9IHtcbiAgICAgICAgRXBzaWxvblRyYW5zaXRpb246IFRyYW5zaXRpb24uRVBTSUxPTixcbiAgICAgICAgUmFuZ2VUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLlJBTkdFLFxuICAgICAgICBSdWxlVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5SVUxFLFxuICAgICAgICBQcmVkaWNhdGVUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLlBSRURJQ0FURSxcbiAgICAgICAgQXRvbVRyYW5zaXRpb246IFRyYW5zaXRpb24uQVRPTSxcbiAgICAgICAgQWN0aW9uVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5BQ1RJT04sXG4gICAgICAgIFNldFRyYW5zaXRpb246IFRyYW5zaXRpb24uU0VULFxuICAgICAgICBOb3RTZXRUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLk5PVF9TRVQsXG4gICAgICAgIFdpbGRjYXJkVHJhbnNpdGlvbjogVHJhbnNpdGlvbi5XSUxEQ0FSRCxcbiAgICAgICAgUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb246IFRyYW5zaXRpb24uUFJFQ0VERU5DRVxuICAgIH07XG5cblxuLy8gVE9ETzogbWFrZSBhbGwgdHJhbnNpdGlvbnMgc2V0cz8gbm8sIHNob3VsZCByZW1vdmUgc2V0IGVkZ2VzXG5mdW5jdGlvbiBBdG9tVHJhbnNpdGlvbih0YXJnZXQsIGxhYmVsKSB7XG5cdFRyYW5zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHR0aGlzLmxhYmVsXyA9IGxhYmVsOyAvLyBUaGUgdG9rZW4gdHlwZSBvciBjaGFyYWN0ZXIgdmFsdWU7IG9yLCBzaWduaWZpZXMgc3BlY2lhbCBsYWJlbC5cbiAgICB0aGlzLmxhYmVsID0gdGhpcy5tYWtlTGFiZWwoKTtcbiAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5BVE9NO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5BdG9tVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zaXRpb24ucHJvdG90eXBlKTtcbkF0b21UcmFuc2l0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF0b21UcmFuc2l0aW9uO1xuXG5BdG9tVHJhbnNpdGlvbi5wcm90b3R5cGUubWFrZUxhYmVsID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgcy5hZGRPbmUodGhpcy5sYWJlbF8pO1xuICAgIHJldHVybiBzO1xufTtcblxuQXRvbVRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiggc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWxfID09PSBzeW1ib2w7XG59O1xuXG5BdG9tVHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubGFiZWxfO1xufTtcblxuZnVuY3Rpb24gUnVsZVRyYW5zaXRpb24ocnVsZVN0YXJ0LCBydWxlSW5kZXgsIHByZWNlZGVuY2UsIGZvbGxvd1N0YXRlKSB7XG5cdFRyYW5zaXRpb24uY2FsbCh0aGlzLCBydWxlU3RhcnQpO1xuICAgIHRoaXMucnVsZUluZGV4ID0gcnVsZUluZGV4OyAvLyBwdHIgdG8gdGhlIHJ1bGUgZGVmaW5pdGlvbiBvYmplY3QgZm9yIHRoaXMgcnVsZSByZWZcbiAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgIHRoaXMuZm9sbG93U3RhdGUgPSBmb2xsb3dTdGF0ZTsgLy8gd2hhdCBub2RlIHRvIGJlZ2luIGNvbXB1dGF0aW9ucyBmb2xsb3dpbmcgcmVmIHRvIHJ1bGVcbiAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5SVUxFO1xuICAgIHRoaXMuaXNFcHNpbG9uID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUnVsZVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5SdWxlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdWxlVHJhbnNpdGlvbjtcblxuUnVsZVRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCAgbWF4Vm9jYWJTeW1ib2wpIHtcblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5mdW5jdGlvbiBFcHNpbG9uVHJhbnNpdGlvbih0YXJnZXQsIG91dGVybW9zdFByZWNlZGVuY2VSZXR1cm4pIHtcblx0VHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uRVBTSUxPTjtcbiAgICB0aGlzLmlzRXBzaWxvbiA9IHRydWU7XG4gICAgdGhpcy5vdXRlcm1vc3RQcmVjZWRlbmNlUmV0dXJuID0gb3V0ZXJtb3N0UHJlY2VkZW5jZVJldHVybjtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5FcHNpbG9uVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcHNpbG9uVHJhbnNpdGlvbjtcblxuRXBzaWxvblRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiggc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkVwc2lsb25UcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCJlcHNpbG9uXCI7XG59O1xuXG5mdW5jdGlvbiBSYW5nZVRyYW5zaXRpb24odGFyZ2V0LCBzdGFydCwgc3RvcCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0dGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uUkFOR0U7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuc3RvcCA9IHN0b3A7XG4gICAgdGhpcy5sYWJlbCA9IHRoaXMubWFrZUxhYmVsKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblJhbmdlVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zaXRpb24ucHJvdG90eXBlKTtcblJhbmdlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYW5nZVRyYW5zaXRpb247XG5cblJhbmdlVHJhbnNpdGlvbi5wcm90b3R5cGUubWFrZUxhYmVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHMgPSBuZXcgSW50ZXJ2YWxTZXQoKTtcbiAgICBzLmFkZFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuc3RvcCk7XG4gICAgcmV0dXJuIHM7XG59O1xuXG5SYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbihzeW1ib2wsIG1pblZvY2FiU3ltYm9sLCAgbWF4Vm9jYWJTeW1ib2wpIHtcblx0cmV0dXJuIHN5bWJvbCA+PSB0aGlzLnN0YXJ0ICYmIHN5bWJvbCA8PSB0aGlzLnN0b3A7XG59O1xuXG5SYW5nZVRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcIidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5zdGFydCkgKyBcIicuLidcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5zdG9wKSArIFwiJ1wiO1xufTtcblxuZnVuY3Rpb24gQWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uKHRhcmdldCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zaXRpb24ucHJvdG90eXBlKTtcbkFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb247XG5cbmZ1bmN0aW9uIFByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBydWxlSW5kZXgsIHByZWRJbmRleCwgaXNDdHhEZXBlbmRlbnQpIHtcblx0QWJzdHJhY3RQcmVkaWNhdGVUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5QUkVESUNBVEU7XG4gICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgdGhpcy5wcmVkSW5kZXggPSBwcmVkSW5kZXg7XG4gICAgdGhpcy5pc0N0eERlcGVuZGVudCA9IGlzQ3R4RGVwZW5kZW50OyAvLyBlLmcuLCAkaSByZWYgaW4gcHJlZFxuICAgIHRoaXMuaXNFcHNpbG9uID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG5QcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cblByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLmdldFByZWRpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IFByZWRpY2F0ZSh0aGlzLnJ1bGVJbmRleCwgdGhpcy5wcmVkSW5kZXgsIHRoaXMuaXNDdHhEZXBlbmRlbnQpO1xufTtcblxuUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwicHJlZF9cIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLnByZWRJbmRleDtcbn07XG5cbmZ1bmN0aW9uIEFjdGlvblRyYW5zaXRpb24odGFyZ2V0LCBydWxlSW5kZXgsIGFjdGlvbkluZGV4LCBpc0N0eERlcGVuZGVudCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICB0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5BQ1RJT047XG4gICAgdGhpcy5ydWxlSW5kZXggPSBydWxlSW5kZXg7XG4gICAgdGhpcy5hY3Rpb25JbmRleCA9IGFjdGlvbkluZGV4PT09dW5kZWZpbmVkID8gLTEgOiBhY3Rpb25JbmRleDtcbiAgICB0aGlzLmlzQ3R4RGVwZW5kZW50ID0gaXNDdHhEZXBlbmRlbnQ9PT11bmRlZmluZWQgPyBmYWxzZSA6IGlzQ3R4RGVwZW5kZW50OyAvLyBlLmcuLCAkaSByZWYgaW4gcHJlZFxuICAgIHRoaXMuaXNFcHNpbG9uID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQWN0aW9uVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRyYW5zaXRpb24ucHJvdG90eXBlKTtcbkFjdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWN0aW9uVHJhbnNpdGlvbjtcblxuXG5BY3Rpb25UcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBmYWxzZTtcbn07XG5cbkFjdGlvblRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBcImFjdGlvbl9cIiArIHRoaXMucnVsZUluZGV4ICsgXCI6XCIgKyB0aGlzLmFjdGlvbkluZGV4O1xufTtcblxuXG4vLyBBIHRyYW5zaXRpb24gY29udGFpbmluZyBhIHNldCBvZiB2YWx1ZXMuXG5mdW5jdGlvbiBTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0KSB7XG5cdFRyYW5zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHR0aGlzLnNlcmlhbGl6YXRpb25UeXBlID0gVHJhbnNpdGlvbi5TRVQ7XG4gICAgaWYgKHNldCAhPT11bmRlZmluZWQgJiYgc2V0ICE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9IHNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhYmVsID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIHRoaXMubGFiZWwuYWRkT25lKFRva2VuLklOVkFMSURfVFlQRSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5TZXRUcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZXRUcmFuc2l0aW9uO1xuXG5TZXRUcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiB0aGlzLmxhYmVsLmNvbnRhaW5zKHN5bWJvbCk7XG59O1xuXG5cblNldFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmxhYmVsLnRvU3RyaW5nKCk7XG59O1xuXG5mdW5jdGlvbiBOb3RTZXRUcmFuc2l0aW9uKHRhcmdldCwgc2V0KSB7XG5cdFNldFRyYW5zaXRpb24uY2FsbCh0aGlzLCB0YXJnZXQsIHNldCk7XG5cdHRoaXMuc2VyaWFsaXphdGlvblR5cGUgPSBUcmFuc2l0aW9uLk5PVF9TRVQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5Ob3RTZXRUcmFuc2l0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUpO1xuTm90U2V0VHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb3RTZXRUcmFuc2l0aW9uO1xuXG5Ob3RTZXRUcmFuc2l0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24oc3ltYm9sLCBtaW5Wb2NhYlN5bWJvbCwgIG1heFZvY2FiU3ltYm9sKSB7XG5cdHJldHVybiBzeW1ib2wgPj0gbWluVm9jYWJTeW1ib2wgJiYgc3ltYm9sIDw9IG1heFZvY2FiU3ltYm9sICYmXG5cdFx0XHQhU2V0VHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcy5jYWxsKHRoaXMsIHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsIG1heFZvY2FiU3ltYm9sKTtcbn07XG5cbk5vdFNldFRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAnficgKyBTZXRUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xufTtcblxuZnVuY3Rpb24gV2lsZGNhcmRUcmFuc2l0aW9uKHRhcmdldCkge1xuXHRUcmFuc2l0aW9uLmNhbGwodGhpcywgdGFyZ2V0KTtcblx0dGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uV0lMRENBUkQ7XG5cdHJldHVybiB0aGlzO1xufVxuXG5XaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmFuc2l0aW9uLnByb3RvdHlwZSk7XG5XaWxkY2FyZFRyYW5zaXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lsZGNhcmRUcmFuc2l0aW9uO1xuXG5cbldpbGRjYXJkVHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gc3ltYm9sID49IG1pblZvY2FiU3ltYm9sICYmIHN5bWJvbCA8PSBtYXhWb2NhYlN5bWJvbDtcbn07XG5cbldpbGRjYXJkVHJhbnNpdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFwiLlwiO1xufTtcblxuZnVuY3Rpb24gUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24odGFyZ2V0LCBwcmVjZWRlbmNlKSB7XG5cdEFic3RyYWN0UHJlZGljYXRlVHJhbnNpdGlvbi5jYWxsKHRoaXMsIHRhcmdldCk7XG4gICAgdGhpcy5zZXJpYWxpemF0aW9uVHlwZSA9IFRyYW5zaXRpb24uUFJFQ0VERU5DRTtcbiAgICB0aGlzLnByZWNlZGVuY2UgPSBwcmVjZWRlbmNlO1xuICAgIHRoaXMuaXNFcHNpbG9uID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlKTtcblByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uO1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uKHN5bWJvbCwgbWluVm9jYWJTeW1ib2wsICBtYXhWb2NhYlN5bWJvbCkge1xuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0UHJlZGljYXRlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBuZXcgUHJlY2VkZW5jZVByZWRpY2F0ZSh0aGlzLnByZWNlZGVuY2UpO1xufTtcblxuUHJlY2VkZW5jZVByZWRpY2F0ZVRyYW5zaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnByZWNlZGVuY2UgKyBcIiA+PSBfcFwiO1xufTtcblxuZXhwb3J0cy5UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcbmV4cG9ydHMuQXRvbVRyYW5zaXRpb24gPSBBdG9tVHJhbnNpdGlvbjtcbmV4cG9ydHMuU2V0VHJhbnNpdGlvbiA9IFNldFRyYW5zaXRpb247XG5leHBvcnRzLk5vdFNldFRyYW5zaXRpb24gPSBOb3RTZXRUcmFuc2l0aW9uO1xuZXhwb3J0cy5SdWxlVHJhbnNpdGlvbiA9IFJ1bGVUcmFuc2l0aW9uO1xuZXhwb3J0cy5BY3Rpb25UcmFuc2l0aW9uID0gQWN0aW9uVHJhbnNpdGlvbjtcbmV4cG9ydHMuRXBzaWxvblRyYW5zaXRpb24gPSBFcHNpbG9uVHJhbnNpdGlvbjtcbmV4cG9ydHMuUmFuZ2VUcmFuc2l0aW9uID0gUmFuZ2VUcmFuc2l0aW9uO1xuZXhwb3J0cy5XaWxkY2FyZFRyYW5zaXRpb24gPSBXaWxkY2FyZFRyYW5zaXRpb247XG5leHBvcnRzLlByZWRpY2F0ZVRyYW5zaXRpb24gPSBQcmVkaWNhdGVUcmFuc2l0aW9uO1xuZXhwb3J0cy5QcmVjZWRlbmNlUHJlZGljYXRlVHJhbnNpdGlvbiA9IFByZWNlZGVuY2VQcmVkaWNhdGVUcmFuc2l0aW9uO1xuZXhwb3J0cy5BYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb24gPSBBYnN0cmFjdFByZWRpY2F0ZVRyYW5zaXRpb247IiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG5leHBvcnRzLkFUTiA9IHJlcXVpcmUoJy4vQVROJykuQVROO1xuZXhwb3J0cy5BVE5EZXNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL0FUTkRlc2VyaWFsaXplcicpLkFUTkRlc2VyaWFsaXplcjtcbmV4cG9ydHMuTGV4ZXJBVE5TaW11bGF0b3IgPSByZXF1aXJlKCcuL0xleGVyQVROU2ltdWxhdG9yJykuTGV4ZXJBVE5TaW11bGF0b3I7XG5leHBvcnRzLlBhcnNlckFUTlNpbXVsYXRvciA9IHJlcXVpcmUoJy4vUGFyc2VyQVROU2ltdWxhdG9yJykuUGFyc2VyQVROU2ltdWxhdG9yO1xuZXhwb3J0cy5QcmVkaWN0aW9uTW9kZSA9IHJlcXVpcmUoJy4vUHJlZGljdGlvbk1vZGUnKS5QcmVkaWN0aW9uTW9kZTtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBTZXQgPSByZXF1aXJlKFwiLi4vVXRpbHNcIikuU2V0O1xudmFyIERGQVN0YXRlID0gcmVxdWlyZSgnLi9ERkFTdGF0ZScpLkRGQVN0YXRlO1xudmFyIFN0YXJMb29wRW50cnlTdGF0ZSA9IHJlcXVpcmUoJy4uL2F0bi9BVE5TdGF0ZScpLlN0YXJMb29wRW50cnlTdGF0ZTtcbnZhciBBVE5Db25maWdTZXQgPSByZXF1aXJlKCcuLy4uL2F0bi9BVE5Db25maWdTZXQnKS5BVE5Db25maWdTZXQ7XG52YXIgREZBU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vREZBU2VyaWFsaXplcicpLkRGQVNlcmlhbGl6ZXI7XG52YXIgTGV4ZXJERkFTZXJpYWxpemVyID0gcmVxdWlyZSgnLi9ERkFTZXJpYWxpemVyJykuTGV4ZXJERkFTZXJpYWxpemVyO1xuXG5cblxuZnVuY3Rpb24gREZBKGF0blN0YXJ0U3RhdGUsIGRlY2lzaW9uKSB7XG5cdGlmIChkZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0ZGVjaXNpb24gPSAwO1xuXHR9XG5cdC8vIEZyb20gd2hpY2ggQVROIHN0YXRlIGRpZCB3ZSBjcmVhdGUgdGhpcyBERkE/XG5cdHRoaXMuYXRuU3RhcnRTdGF0ZSA9IGF0blN0YXJ0U3RhdGU7XG5cdHRoaXMuZGVjaXNpb24gPSBkZWNpc2lvbjtcblx0Ly8gQSBzZXQgb2YgYWxsIERGQSBzdGF0ZXMuIFVzZSB7QGxpbmsgTWFwfSBzbyB3ZSBjYW4gZ2V0IG9sZCBzdGF0ZSBiYWNrXG5cdC8vICh7QGxpbmsgU2V0fSBvbmx5IGFsbG93cyB5b3UgdG8gc2VlIGlmIGl0J3MgdGhlcmUpLlxuXHR0aGlzLl9zdGF0ZXMgPSBuZXcgU2V0KCk7XG5cdHRoaXMuczAgPSBudWxsO1xuXHQvLyB7QGNvZGUgdHJ1ZX0gaWYgdGhpcyBERkEgaXMgZm9yIGEgcHJlY2VkZW5jZSBkZWNpc2lvbjsgb3RoZXJ3aXNlLFxuXHQvLyB7QGNvZGUgZmFsc2V9LiBUaGlzIGlzIHRoZSBiYWNraW5nIGZpZWxkIGZvciB7QGxpbmsgLy9pc1ByZWNlZGVuY2VEZmF9LFxuXHQvLyB7QGxpbmsgLy9zZXRQcmVjZWRlbmNlRGZhfS5cblx0dGhpcy5wcmVjZWRlbmNlRGZhID0gZmFsc2U7XG4gICAgaWYgKGF0blN0YXJ0U3RhdGUgaW5zdGFuY2VvZiBTdGFyTG9vcEVudHJ5U3RhdGUpXG4gICAge1xuICAgICAgICBpZiAoYXRuU3RhcnRTdGF0ZS5pc1ByZWNlZGVuY2VEZWNpc2lvbikge1xuICAgICAgICAgICAgdGhpcy5wcmVjZWRlbmNlRGZhID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwcmVjZWRlbmNlU3RhdGUgPSBuZXcgREZBU3RhdGUobnVsbCwgbmV3IEFUTkNvbmZpZ1NldCgpKTtcbiAgICAgICAgICAgIHByZWNlZGVuY2VTdGF0ZS5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgcHJlY2VkZW5jZVN0YXRlLmlzQWNjZXB0U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHByZWNlZGVuY2VTdGF0ZS5yZXF1aXJlc0Z1bGxDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnMwID0gcHJlY2VkZW5jZVN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuXHRyZXR1cm4gdGhpcztcbn1cblxuLy8gR2V0IHRoZSBzdGFydCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcmVjZWRlbmNlIHZhbHVlLlxuLy9cbi8vIEBwYXJhbSBwcmVjZWRlbmNlIFRoZSBjdXJyZW50IHByZWNlZGVuY2UuXG4vLyBAcmV0dXJuIFRoZSBzdGFydCBzdGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWQgcHJlY2VkZW5jZSwgb3Jcbi8vIHtAY29kZSBudWxsfSBpZiBubyBzdGFydCBzdGF0ZSBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJlY2VkZW5jZS5cbi8vXG4vLyBAdGhyb3dzIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbiBpZiB0aGlzIGlzIG5vdCBhIHByZWNlZGVuY2UgREZBLlxuLy8gQHNlZSAvL2lzUHJlY2VkZW5jZURmYSgpXG5cbkRGQS5wcm90b3R5cGUuZ2V0UHJlY2VkZW5jZVN0YXJ0U3RhdGUgPSBmdW5jdGlvbihwcmVjZWRlbmNlKSB7XG5cdGlmICghKHRoaXMucHJlY2VkZW5jZURmYSkpIHtcblx0XHR0aHJvdyAoXCJPbmx5IHByZWNlZGVuY2UgREZBcyBtYXkgY29udGFpbiBhIHByZWNlZGVuY2Ugc3RhcnQgc3RhdGUuXCIpO1xuXHR9XG5cdC8vIHMwLmVkZ2VzIGlzIG5ldmVyIG51bGwgZm9yIGEgcHJlY2VkZW5jZSBERkFcblx0aWYgKHByZWNlZGVuY2UgPCAwIHx8IHByZWNlZGVuY2UgPj0gdGhpcy5zMC5lZGdlcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gdGhpcy5zMC5lZGdlc1twcmVjZWRlbmNlXSB8fCBudWxsO1xufTtcblxuLy8gU2V0IHRoZSBzdGFydCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcmVjZWRlbmNlIHZhbHVlLlxuLy9cbi8vIEBwYXJhbSBwcmVjZWRlbmNlIFRoZSBjdXJyZW50IHByZWNlZGVuY2UuXG4vLyBAcGFyYW0gc3RhcnRTdGF0ZSBUaGUgc3RhcnQgc3RhdGUgY29ycmVzcG9uZGluZyB0byB0aGUgc3BlY2lmaWVkXG4vLyBwcmVjZWRlbmNlLlxuLy9cbi8vIEB0aHJvd3MgSWxsZWdhbFN0YXRlRXhjZXB0aW9uIGlmIHRoaXMgaXMgbm90IGEgcHJlY2VkZW5jZSBERkEuXG4vLyBAc2VlIC8vaXNQcmVjZWRlbmNlRGZhKClcbi8vXG5ERkEucHJvdG90eXBlLnNldFByZWNlZGVuY2VTdGFydFN0YXRlID0gZnVuY3Rpb24ocHJlY2VkZW5jZSwgc3RhcnRTdGF0ZSkge1xuXHRpZiAoISh0aGlzLnByZWNlZGVuY2VEZmEpKSB7XG5cdFx0dGhyb3cgKFwiT25seSBwcmVjZWRlbmNlIERGQXMgbWF5IGNvbnRhaW4gYSBwcmVjZWRlbmNlIHN0YXJ0IHN0YXRlLlwiKTtcblx0fVxuXHRpZiAocHJlY2VkZW5jZSA8IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBzeW5jaHJvbml6YXRpb24gb24gczAgaGVyZSBpcyBvay4gd2hlbiB0aGUgREZBIGlzIHR1cm5lZCBpbnRvIGFcblx0Ly8gcHJlY2VkZW5jZSBERkEsIHMwIHdpbGwgYmUgaW5pdGlhbGl6ZWQgb25jZSBhbmQgbm90IHVwZGF0ZWQgYWdhaW5cblx0Ly8gczAuZWRnZXMgaXMgbmV2ZXIgbnVsbCBmb3IgYSBwcmVjZWRlbmNlIERGQVxuXHR0aGlzLnMwLmVkZ2VzW3ByZWNlZGVuY2VdID0gc3RhcnRTdGF0ZTtcbn07XG5cbi8vXG4vLyBTZXRzIHdoZXRoZXIgdGhpcyBpcyBhIHByZWNlZGVuY2UgREZBLiBJZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGRpZmZlcnNcbi8vIGZyb20gdGhlIGN1cnJlbnQgREZBIGNvbmZpZ3VyYXRpb24sIHRoZSBmb2xsb3dpbmcgYWN0aW9ucyBhcmUgdGFrZW47XG4vLyBvdGhlcndpc2Ugbm8gY2hhbmdlcyBhcmUgbWFkZSB0byB0aGUgY3VycmVudCBERkEuXG4vL1xuLy8gPHVsPlxuLy8gPGxpPlRoZSB7QGxpbmsgLy9zdGF0ZXN9IG1hcCBpcyBjbGVhcmVkPC9saT5cbi8vIDxsaT5JZiB7QGNvZGUgcHJlY2VkZW5jZURmYX0gaXMge0Bjb2RlIGZhbHNlfSwgdGhlIGluaXRpYWwgc3RhdGVcbi8vIHtAbGluayAvL3MwfSBpcyBzZXQgdG8ge0Bjb2RlIG51bGx9OyBvdGhlcndpc2UsIGl0IGlzIGluaXRpYWxpemVkIHRvIGEgbmV3XG4vLyB7QGxpbmsgREZBU3RhdGV9IHdpdGggYW4gZW1wdHkgb3V0Z29pbmcge0BsaW5rIERGQVN0YXRlLy9lZGdlc30gYXJyYXkgdG9cbi8vIHN0b3JlIHRoZSBzdGFydCBzdGF0ZXMgZm9yIGluZGl2aWR1YWwgcHJlY2VkZW5jZSB2YWx1ZXMuPC9saT5cbi8vIDxsaT5UaGUge0BsaW5rIC8vcHJlY2VkZW5jZURmYX0gZmllbGQgaXMgdXBkYXRlZDwvbGk+XG4vLyA8L3VsPlxuLy9cbi8vIEBwYXJhbSBwcmVjZWRlbmNlRGZhIHtAY29kZSB0cnVlfSBpZiB0aGlzIGlzIGEgcHJlY2VkZW5jZSBERkE7IG90aGVyd2lzZSxcbi8vIHtAY29kZSBmYWxzZX1cblxuREZBLnByb3RvdHlwZS5zZXRQcmVjZWRlbmNlRGZhID0gZnVuY3Rpb24ocHJlY2VkZW5jZURmYSkge1xuXHRpZiAodGhpcy5wcmVjZWRlbmNlRGZhIT09cHJlY2VkZW5jZURmYSkge1xuXHRcdHRoaXMuX3N0YXRlcyA9IG5ldyBERkFTdGF0ZXNTZXQoKTtcblx0XHRpZiAocHJlY2VkZW5jZURmYSkge1xuXHRcdFx0dmFyIHByZWNlZGVuY2VTdGF0ZSA9IG5ldyBERkFTdGF0ZShudWxsLCBuZXcgQVROQ29uZmlnU2V0KCkpO1xuXHRcdFx0cHJlY2VkZW5jZVN0YXRlLmVkZ2VzID0gW107XG5cdFx0XHRwcmVjZWRlbmNlU3RhdGUuaXNBY2NlcHRTdGF0ZSA9IGZhbHNlO1xuXHRcdFx0cHJlY2VkZW5jZVN0YXRlLnJlcXVpcmVzRnVsbENvbnRleHQgPSBmYWxzZTtcblx0XHRcdHRoaXMuczAgPSBwcmVjZWRlbmNlU3RhdGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuczAgPSBudWxsO1xuXHRcdH1cblx0XHR0aGlzLnByZWNlZGVuY2VEZmEgPSBwcmVjZWRlbmNlRGZhO1xuXHR9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoREZBLnByb3RvdHlwZSwgXCJzdGF0ZXNcIiwge1xuXHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhdGVzO1xuXHR9XG59KTtcblxuLy8gUmV0dXJuIGEgbGlzdCBvZiBhbGwgc3RhdGVzIGluIHRoaXMgREZBLCBvcmRlcmVkIGJ5IHN0YXRlIG51bWJlci5cbkRGQS5wcm90b3R5cGUuc29ydGVkU3RhdGVzID0gZnVuY3Rpb24oKSB7XG5cdHZhciBsaXN0ID0gdGhpcy5fc3RhdGVzLnZhbHVlcygpO1xuXHRyZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRyZXR1cm4gYS5zdGF0ZU51bWJlciAtIGIuc3RhdGVOdW1iZXI7XG5cdH0pO1xufTtcblxuREZBLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcykge1xuXHRsaXRlcmFsTmFtZXMgPSBsaXRlcmFsTmFtZXMgfHwgbnVsbDtcblx0c3ltYm9saWNOYW1lcyA9IHN5bWJvbGljTmFtZXMgfHwgbnVsbDtcblx0aWYgKHRoaXMuczAgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXHR2YXIgc2VyaWFsaXplciA9IG5ldyBERkFTZXJpYWxpemVyKHRoaXMsIGxpdGVyYWxOYW1lcywgc3ltYm9saWNOYW1lcyk7XG5cdHJldHVybiBzZXJpYWxpemVyLnRvU3RyaW5nKCk7XG59O1xuXG5ERkEucHJvdG90eXBlLnRvTGV4ZXJTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuczAgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXHR2YXIgc2VyaWFsaXplciA9IG5ldyBMZXhlckRGQVNlcmlhbGl6ZXIodGhpcyk7XG5cdHJldHVybiBzZXJpYWxpemVyLnRvU3RyaW5nKCk7XG59O1xuXG5leHBvcnRzLkRGQSA9IERGQTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLy8gQSBERkEgd2Fsa2VyIHRoYXQga25vd3MgaG93IHRvIGR1bXAgdGhlbSB0byBzZXJpYWxpemVkIHN0cmluZ3MuIy9cblxuXG5mdW5jdGlvbiBERkFTZXJpYWxpemVyKGRmYSwgbGl0ZXJhbE5hbWVzLCBzeW1ib2xpY05hbWVzKSB7XG5cdHRoaXMuZGZhID0gZGZhO1xuXHR0aGlzLmxpdGVyYWxOYW1lcyA9IGxpdGVyYWxOYW1lcyB8fCBbXTtcblx0dGhpcy5zeW1ib2xpY05hbWVzID0gc3ltYm9saWNOYW1lcyB8fCBbXTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICBpZih0aGlzLmRmYS5zMCA9PT0gbnVsbCkge1xuICAgICAgIHJldHVybiBudWxsO1xuICAgfVxuICAgdmFyIGJ1ZiA9IFwiXCI7XG4gICB2YXIgc3RhdGVzID0gdGhpcy5kZmEuc29ydGVkU3RhdGVzKCk7XG4gICBmb3IodmFyIGk9MDtpPHN0YXRlcy5sZW5ndGg7aSsrKSB7XG4gICAgICAgdmFyIHMgPSBzdGF0ZXNbaV07XG4gICAgICAgaWYocy5lZGdlcyE9PW51bGwpIHtcbiAgICAgICAgICAgIHZhciBuID0gcy5lZGdlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IodmFyIGo9MDtqPG47aisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBzLmVkZ2VzW2pdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYodCE9PW51bGwgJiYgdC5zdGF0ZU51bWJlciAhPT0gMHg3RkZGRkZGRikge1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KHRoaXMuZ2V0U3RhdGVTdHJpbmcocykpO1xuICAgICAgICAgICAgICAgICAgICBidWYgPSBidWYuY29uY2F0KFwiLVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmLmNvbmNhdCh0aGlzLmdldEVkZ2VMYWJlbChqKSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5jb25jYXQoXCItPlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmLmNvbmNhdCh0aGlzLmdldFN0YXRlU3RyaW5nKHQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmID0gYnVmLmNvbmNhdCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgIH1cbiAgIH1cbiAgIHJldHVybiBidWYubGVuZ3RoPT09MCA/IG51bGwgOiBidWY7XG59O1xuXG5ERkFTZXJpYWxpemVyLnByb3RvdHlwZS5nZXRFZGdlTGFiZWwgPSBmdW5jdGlvbihpKSB7XG4gICAgaWYgKGk9PT0wKSB7XG4gICAgICAgIHJldHVybiBcIkVPRlwiO1xuICAgIH0gZWxzZSBpZih0aGlzLmxpdGVyYWxOYW1lcyAhPT1udWxsIHx8IHRoaXMuc3ltYm9saWNOYW1lcyE9PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbE5hbWVzW2ktMV0gfHwgdGhpcy5zeW1ib2xpY05hbWVzW2ktMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaS0xKTtcbiAgICB9XG59O1xuXG5ERkFTZXJpYWxpemVyLnByb3RvdHlwZS5nZXRTdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgYmFzZVN0YXRlU3RyID0gKCBzLmlzQWNjZXB0U3RhdGUgPyBcIjpcIiA6IFwiXCIpICsgXCJzXCIgKyBzLnN0YXRlTnVtYmVyICsgKCBzLnJlcXVpcmVzRnVsbENvbnRleHQgPyBcIl5cIiA6IFwiXCIpO1xuICAgIGlmKHMuaXNBY2NlcHRTdGF0ZSkge1xuICAgICAgICBpZiAocy5wcmVkaWNhdGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVN0YXRlU3RyICsgXCI9PlwiICsgcy5wcmVkaWNhdGVzLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVN0YXRlU3RyICsgXCI9PlwiICsgcy5wcmVkaWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZVN0YXRlU3RyO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIExleGVyREZBU2VyaWFsaXplcihkZmEpIHtcblx0REZBU2VyaWFsaXplci5jYWxsKHRoaXMsIGRmYSwgbnVsbCk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5MZXhlckRGQVNlcmlhbGl6ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShERkFTZXJpYWxpemVyLnByb3RvdHlwZSk7XG5MZXhlckRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJERkFTZXJpYWxpemVyO1xuXG5MZXhlckRGQVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldEVkZ2VMYWJlbCA9IGZ1bmN0aW9uKGkpIHtcblx0cmV0dXJuIFwiJ1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKSArIFwiJ1wiO1xufTtcblxuZXhwb3J0cy5ERkFTZXJpYWxpemVyID0gREZBU2VyaWFsaXplcjtcbmV4cG9ydHMuTGV4ZXJERkFTZXJpYWxpemVyID0gTGV4ZXJERkFTZXJpYWxpemVyO1xuXG4iLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy8vXG5cbnZhciBBVE5Db25maWdTZXQgPSByZXF1aXJlKCcuLy4uL2F0bi9BVE5Db25maWdTZXQnKS5BVE5Db25maWdTZXQ7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLy4uL1V0aWxzJyk7XG52YXIgSGFzaCA9IFV0aWxzLkhhc2g7XG52YXIgU2V0ID0gVXRpbHMuU2V0O1xuXG4vLyBNYXAgYSBwcmVkaWNhdGUgdG8gYSBwcmVkaWN0ZWQgYWx0ZXJuYXRpdmUuLy8vXG5cbmZ1bmN0aW9uIFByZWRQcmVkaWN0aW9uKHByZWQsIGFsdCkge1xuXHR0aGlzLmFsdCA9IGFsdDtcblx0dGhpcy5wcmVkID0gcHJlZDtcblx0cmV0dXJuIHRoaXM7XG59XG5cblByZWRQcmVkaWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gXCIoXCIgKyB0aGlzLnByZWQgKyBcIiwgXCIgKyB0aGlzLmFsdCArIFwiKVwiO1xufTtcblxuLy8gQSBERkEgc3RhdGUgcmVwcmVzZW50cyBhIHNldCBvZiBwb3NzaWJsZSBBVE4gY29uZmlndXJhdGlvbnMuXG4vLyBBcyBBaG8sIFNldGhpLCBVbGxtYW4gcC4gMTE3IHNheXMgXCJUaGUgREZBIHVzZXMgaXRzIHN0YXRlXG4vLyB0byBrZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBzdGF0ZXMgdGhlIEFUTiBjYW4gYmUgaW4gYWZ0ZXJcbi8vIHJlYWRpbmcgZWFjaCBpbnB1dCBzeW1ib2wuIFRoYXQgaXMgdG8gc2F5LCBhZnRlciByZWFkaW5nXG4vLyBpbnB1dCBhMWEyLi5hbiwgdGhlIERGQSBpcyBpbiBhIHN0YXRlIHRoYXQgcmVwcmVzZW50cyB0aGVcbi8vIHN1YnNldCBUIG9mIHRoZSBzdGF0ZXMgb2YgdGhlIEFUTiB0aGF0IGFyZSByZWFjaGFibGUgZnJvbSB0aGVcbi8vIEFUTidzIHN0YXJ0IHN0YXRlIGFsb25nIHNvbWUgcGF0aCBsYWJlbGVkIGExYTIuLmFuLlwiXG4vLyBJbiBjb252ZW50aW9uYWwgTkZBJnJhcnI7REZBIGNvbnZlcnNpb24sIHRoZXJlZm9yZSwgdGhlIHN1YnNldCBUXG4vLyB3b3VsZCBiZSBhIGJpdHNldCByZXByZXNlbnRpbmcgdGhlIHNldCBvZiBzdGF0ZXMgdGhlXG4vLyBBVE4gY291bGQgYmUgaW4uIFdlIG5lZWQgdG8gdHJhY2sgdGhlIGFsdCBwcmVkaWN0ZWQgYnkgZWFjaFxuLy8gc3RhdGUgYXMgd2VsbCwgaG93ZXZlci4gTW9yZSBpbXBvcnRhbnRseSwgd2UgbmVlZCB0byBtYWludGFpblxuLy8gYSBzdGFjayBvZiBzdGF0ZXMsIHRyYWNraW5nIHRoZSBjbG9zdXJlIG9wZXJhdGlvbnMgYXMgdGhleVxuLy8ganVtcCBmcm9tIHJ1bGUgdG8gcnVsZSwgZW11bGF0aW5nIHJ1bGUgaW52b2NhdGlvbnMgKG1ldGhvZCBjYWxscykuXG4vLyBJIGhhdmUgdG8gYWRkIGEgc3RhY2sgdG8gc2ltdWxhdGUgdGhlIHByb3BlciBsb29rYWhlYWQgc2VxdWVuY2VzIGZvclxuLy8gdGhlIHVuZGVybHlpbmcgTEwgZ3JhbW1hciBmcm9tIHdoaWNoIHRoZSBBVE4gd2FzIGRlcml2ZWQuXG4vL1xuLy8gPHA+SSB1c2UgYSBzZXQgb2YgQVROQ29uZmlnIG9iamVjdHMgbm90IHNpbXBsZSBzdGF0ZXMuIEFuIEFUTkNvbmZpZ1xuLy8gaXMgYm90aCBhIHN0YXRlIChhbGEgbm9ybWFsIGNvbnZlcnNpb24pIGFuZCBhIFJ1bGVDb250ZXh0IGRlc2NyaWJpbmdcbi8vIHRoZSBjaGFpbiBvZiBydWxlcyAoaWYgYW55KSBmb2xsb3dlZCB0byBhcnJpdmUgYXQgdGhhdCBzdGF0ZS48L3A+XG4vL1xuLy8gPHA+QSBERkEgc3RhdGUgbWF5IGhhdmUgbXVsdGlwbGUgcmVmZXJlbmNlcyB0byBhIHBhcnRpY3VsYXIgc3RhdGUsXG4vLyBidXQgd2l0aCBkaWZmZXJlbnQgQVROIGNvbnRleHRzICh3aXRoIHNhbWUgb3IgZGlmZmVyZW50IGFsdHMpXG4vLyBtZWFuaW5nIHRoYXQgc3RhdGUgd2FzIHJlYWNoZWQgdmlhIGEgZGlmZmVyZW50IHNldCBvZiBydWxlIGludm9jYXRpb25zLjwvcD5cbi8vIC9cblxuZnVuY3Rpb24gREZBU3RhdGUoc3RhdGVOdW1iZXIsIGNvbmZpZ3MpIHtcblx0aWYgKHN0YXRlTnVtYmVyID09PSBudWxsKSB7XG5cdFx0c3RhdGVOdW1iZXIgPSAtMTtcblx0fVxuXHRpZiAoY29uZmlncyA9PT0gbnVsbCkge1xuXHRcdGNvbmZpZ3MgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG5cdH1cblx0dGhpcy5zdGF0ZU51bWJlciA9IHN0YXRlTnVtYmVyO1xuXHR0aGlzLmNvbmZpZ3MgPSBjb25maWdzO1xuXHQvLyB7QGNvZGUgZWRnZXNbc3ltYm9sXX0gcG9pbnRzIHRvIHRhcmdldCBvZiBzeW1ib2wuIFNoaWZ0IHVwIGJ5IDEgc28gKC0xKVxuXHQvLyB7QGxpbmsgVG9rZW4vL0VPRn0gbWFwcyB0byB7QGNvZGUgZWRnZXNbMF19LlxuXHR0aGlzLmVkZ2VzID0gbnVsbDtcblx0dGhpcy5pc0FjY2VwdFN0YXRlID0gZmFsc2U7XG5cdC8vIGlmIGFjY2VwdCBzdGF0ZSwgd2hhdCB0dHlwZSBkbyB3ZSBtYXRjaCBvciBhbHQgZG8gd2UgcHJlZGljdD9cblx0Ly8gVGhpcyBpcyBzZXQgdG8ge0BsaW5rIEFUTi8vSU5WQUxJRF9BTFRfTlVNQkVSfSB3aGVuIHtAbGlua1xuXHQvLyAvL3ByZWRpY2F0ZXN9e0Bjb2RlICE9bnVsbH0gb3Jcblx0Ly8ge0BsaW5rIC8vcmVxdWlyZXNGdWxsQ29udGV4dH0uXG5cdHRoaXMucHJlZGljdGlvbiA9IDA7XG5cdHRoaXMubGV4ZXJBY3Rpb25FeGVjdXRvciA9IG51bGw7XG5cdC8vIEluZGljYXRlcyB0aGF0IHRoaXMgc3RhdGUgd2FzIGNyZWF0ZWQgZHVyaW5nIFNMTCBwcmVkaWN0aW9uIHRoYXRcblx0Ly8gZGlzY292ZXJlZCBhIGNvbmZsaWN0IGJldHdlZW4gdGhlIGNvbmZpZ3VyYXRpb25zIGluIHRoZSBzdGF0ZS4gRnV0dXJlXG5cdC8vIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IvL2V4ZWNBVE59IGludm9jYXRpb25zIGltbWVkaWF0ZWx5IGp1bXBlZCBkb2luZ1xuXHQvLyBmdWxsIGNvbnRleHQgcHJlZGljdGlvbiBpZiB0aGlzIGZpZWxkIGlzIHRydWUuXG5cdHRoaXMucmVxdWlyZXNGdWxsQ29udGV4dCA9IGZhbHNlO1xuXHQvLyBEdXJpbmcgU0xMIHBhcnNpbmcsIHRoaXMgaXMgYSBsaXN0IG9mIHByZWRpY2F0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuXHQvLyBBVE4gY29uZmlndXJhdGlvbnMgb2YgdGhlIERGQSBzdGF0ZS4gV2hlbiB3ZSBoYXZlIHByZWRpY2F0ZXMsXG5cdC8vIHtAbGluayAvL3JlcXVpcmVzRnVsbENvbnRleHR9IGlzIHtAY29kZSBmYWxzZX0gc2luY2UgZnVsbCBjb250ZXh0XG5cdC8vIHByZWRpY3Rpb24gZXZhbHVhdGVzIHByZWRpY2F0ZXNcblx0Ly8gb24tdGhlLWZseS4gSWYgdGhpcyBpcyBub3QgbnVsbCwgdGhlbiB7QGxpbmsgLy9wcmVkaWN0aW9ufSBpc1xuXHQvLyB7QGxpbmsgQVROLy9JTlZBTElEX0FMVF9OVU1CRVJ9LlxuXHQvL1xuXHQvLyA8cD5XZSBvbmx5IHVzZSB0aGVzZSBmb3Igbm9uLXtAbGluayAvL3JlcXVpcmVzRnVsbENvbnRleHR9IGJ1dFxuXHQvLyBjb25mbGljdGluZyBzdGF0ZXMuIFRoYXRcblx0Ly8gbWVhbnMgd2Uga25vdyBmcm9tIHRoZSBjb250ZXh0IChpdCdzICQgb3Igd2UgZG9uJ3QgZGlwIGludG8gb3V0ZXJcblx0Ly8gY29udGV4dCkgdGhhdCBpdCdzIGFuIGFtYmlndWl0eSBub3QgYSBjb25mbGljdC48L3A+XG5cdC8vXG5cdC8vIDxwPlRoaXMgbGlzdCBpcyBjb21wdXRlZCBieSB7QGxpbmtcblx0Ly8gUGFyc2VyQVROU2ltdWxhdG9yLy9wcmVkaWNhdGVERkFTdGF0ZX0uPC9wPlxuXHR0aGlzLnByZWRpY2F0ZXMgPSBudWxsO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuLy8gR2V0IHRoZSBzZXQgb2YgYWxsIGFsdHMgbWVudGlvbmVkIGJ5IGFsbCBBVE4gY29uZmlndXJhdGlvbnMgaW4gdGhpc1xuLy8gREZBIHN0YXRlLlxuREZBU3RhdGUucHJvdG90eXBlLmdldEFsdFNldCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYWx0cyA9IG5ldyBTZXQoKTtcblx0aWYgKHRoaXMuY29uZmlncyAhPT0gbnVsbCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYyA9IHRoaXMuY29uZmlnc1tpXTtcblx0XHRcdGFsdHMuYWRkKGMuYWx0KTtcblx0XHR9XG5cdH1cblx0aWYgKGFsdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGFsdHM7XG5cdH1cbn07XG5cbi8vIFR3byB7QGxpbmsgREZBU3RhdGV9IGluc3RhbmNlcyBhcmUgZXF1YWwgaWYgdGhlaXIgQVROIGNvbmZpZ3VyYXRpb24gc2V0c1xuLy8gYXJlIHRoZSBzYW1lLiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNlZSBpZiBhIHN0YXRlIGFscmVhZHkgZXhpc3RzLlxuLy9cbi8vIDxwPkJlY2F1c2UgdGhlIG51bWJlciBvZiBhbHRlcm5hdGl2ZXMgYW5kIG51bWJlciBvZiBBVE4gY29uZmlndXJhdGlvbnMgYXJlXG4vLyBmaW5pdGUsIHRoZXJlIGlzIGEgZmluaXRlIG51bWJlciBvZiBERkEgc3RhdGVzIHRoYXQgY2FuIGJlIHByb2Nlc3NlZC5cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHNob3cgdGhhdCB0aGUgYWxnb3JpdGhtIHRlcm1pbmF0ZXMuPC9wPlxuLy9cbi8vIDxwPkNhbm5vdCB0ZXN0IHRoZSBERkEgc3RhdGUgbnVtYmVycyBoZXJlIGJlY2F1c2UgaW5cbi8vIHtAbGluayBQYXJzZXJBVE5TaW11bGF0b3IvL2FkZERGQVN0YXRlfSB3ZSBuZWVkIHRvIGtub3cgaWYgYW55IG90aGVyIHN0YXRlXG4vLyBleGlzdHMgdGhhdCBoYXMgdGhpcyBleGFjdCBzZXQgb2YgQVROIGNvbmZpZ3VyYXRpb25zLiBUaGVcbi8vIHtAbGluayAvL3N0YXRlTnVtYmVyfSBpcyBpcnJlbGV2YW50LjwvcD5cbkRGQVN0YXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuXHQvLyBjb21wYXJlIHNldCBvZiBBVE4gY29uZmlndXJhdGlvbnMgaW4gdGhpcyBzZXQgd2l0aCBvdGhlclxuXHRyZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHxcblx0XHRcdChvdGhlciBpbnN0YW5jZW9mIERGQVN0YXRlICYmXG5cdFx0XHRcdHRoaXMuY29uZmlncy5lcXVhbHMob3RoZXIuY29uZmlncykpO1xufTtcblxuREZBU3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdHZhciBzID0gXCJcIiArIHRoaXMuc3RhdGVOdW1iZXIgKyBcIjpcIiArIHRoaXMuY29uZmlncztcblx0aWYodGhpcy5pc0FjY2VwdFN0YXRlKSB7XG4gICAgICAgIHMgPSBzICsgXCI9PlwiO1xuICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGVzICE9PSBudWxsKVxuICAgICAgICAgICAgcyA9IHMgKyB0aGlzLnByZWRpY2F0ZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHMgPSBzICsgdGhpcy5wcmVkaWN0aW9uO1xuICAgIH1cblx0cmV0dXJuIHM7XG59O1xuXG5ERkFTdGF0ZS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcblx0dmFyIGhhc2ggPSBuZXcgSGFzaCgpO1xuXHRoYXNoLnVwZGF0ZSh0aGlzLmNvbmZpZ3MpO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaCgpO1xufTtcblxuZXhwb3J0cy5ERkFTdGF0ZSA9IERGQVN0YXRlO1xuZXhwb3J0cy5QcmVkUHJlZGljdGlvbiA9IFByZWRQcmVkaWN0aW9uO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG5leHBvcnRzLkRGQSA9IHJlcXVpcmUoJy4vREZBJykuREZBO1xuZXhwb3J0cy5ERkFTZXJpYWxpemVyID0gcmVxdWlyZSgnLi9ERkFTZXJpYWxpemVyJykuREZBU2VyaWFsaXplcjtcbmV4cG9ydHMuTGV4ZXJERkFTZXJpYWxpemVyID0gcmVxdWlyZSgnLi9ERkFTZXJpYWxpemVyJykuTGV4ZXJERkFTZXJpYWxpemVyO1xuZXhwb3J0cy5QcmVkUHJlZGljdGlvbiA9IHJlcXVpcmUoJy4vREZBU3RhdGUnKS5QcmVkUHJlZGljdGlvbjtcbiIsIi8vXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vL1xuXG4vL1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvckxpc3RlbmVyfSBjYW4gYmUgdXNlZCB0byBpZGVudGlmeVxuLy8gY2VydGFpbiBwb3RlbnRpYWwgY29ycmVjdG5lc3MgYW5kIHBlcmZvcm1hbmNlIHByb2JsZW1zIGluIGdyYW1tYXJzLiBcIlJlcG9ydHNcIlxuLy8gYXJlIG1hZGUgYnkgY2FsbGluZyB7QGxpbmsgUGFyc2VyLy9ub3RpZnlFcnJvckxpc3RlbmVyc30gd2l0aCB0aGUgYXBwcm9wcmlhdGVcbi8vIG1lc3NhZ2UuXG4vL1xuLy8gPHVsPlxuLy8gPGxpPjxiPkFtYmlndWl0aWVzPC9iPjogVGhlc2UgYXJlIGNhc2VzIHdoZXJlIG1vcmUgdGhhbiBvbmUgcGF0aCB0aHJvdWdoIHRoZVxuLy8gZ3JhbW1hciBjYW4gbWF0Y2ggdGhlIGlucHV0LjwvbGk+XG4vLyA8bGk+PGI+V2VhayBjb250ZXh0IHNlbnNpdGl2aXR5PC9iPjogVGhlc2UgYXJlIGNhc2VzIHdoZXJlIGZ1bGwtY29udGV4dFxuLy8gcHJlZGljdGlvbiByZXNvbHZlZCBhbiBTTEwgY29uZmxpY3QgdG8gYSB1bmlxdWUgYWx0ZXJuYXRpdmUgd2hpY2ggZXF1YWxlZCB0aGVcbi8vIG1pbmltdW0gYWx0ZXJuYXRpdmUgb2YgdGhlIFNMTCBjb25mbGljdC48L2xpPlxuLy8gPGxpPjxiPlN0cm9uZyAoZm9yY2VkKSBjb250ZXh0IHNlbnNpdGl2aXR5PC9iPjogVGhlc2UgYXJlIGNhc2VzIHdoZXJlIHRoZVxuLy8gZnVsbC1jb250ZXh0IHByZWRpY3Rpb24gcmVzb2x2ZWQgYW4gU0xMIGNvbmZsaWN0IHRvIGEgdW5pcXVlIGFsdGVybmF0aXZlLFxuLy8gPGVtPmFuZDwvZW0+IHRoZSBtaW5pbXVtIGFsdGVybmF0aXZlIG9mIHRoZSBTTEwgY29uZmxpY3Qgd2FzIGZvdW5kIHRvIG5vdCBiZVxuLy8gYSB0cnVseSB2aWFibGUgYWx0ZXJuYXRpdmUuIFR3by1zdGFnZSBwYXJzaW5nIGNhbm5vdCBiZSB1c2VkIGZvciBpbnB1dHMgd2hlcmVcbi8vIHRoaXMgc2l0dWF0aW9uIG9jY3Vycy48L2xpPlxuLy8gPC91bD5cblxudmFyIEJpdFNldCA9IHJlcXVpcmUoJy4vLi4vVXRpbHMnKS5CaXRTZXQ7XG52YXIgRXJyb3JMaXN0ZW5lciA9IHJlcXVpcmUoJy4vRXJyb3JMaXN0ZW5lcicpLkVycm9yTGlzdGVuZXI7XG52YXIgSW50ZXJ2YWwgPSByZXF1aXJlKCcuLy4uL0ludGVydmFsU2V0JykuSW50ZXJ2YWw7XG5cbmZ1bmN0aW9uIERpYWdub3N0aWNFcnJvckxpc3RlbmVyKGV4YWN0T25seSkge1xuXHRFcnJvckxpc3RlbmVyLmNhbGwodGhpcyk7XG5cdGV4YWN0T25seSA9IGV4YWN0T25seSB8fCB0cnVlO1xuXHQvLyB3aGV0aGVyIGFsbCBhbWJpZ3VpdGllcyBvciBvbmx5IGV4YWN0IGFtYmlndWl0aWVzIGFyZSByZXBvcnRlZC5cblx0dGhpcy5leGFjdE9ubHkgPSBleGFjdE9ubHk7XG5cdHJldHVybiB0aGlzO1xufVxuXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yTGlzdGVuZXIucHJvdG90eXBlKTtcbkRpYWdub3N0aWNFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpYWdub3N0aWNFcnJvckxpc3RlbmVyO1xuXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0QW1iaWd1aXR5ID0gZnVuY3Rpb24ocmVjb2duaXplciwgZGZhLFxuXHRcdHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncykge1xuXHRpZiAodGhpcy5leGFjdE9ubHkgJiYgIWV4YWN0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhciBtc2cgPSBcInJlcG9ydEFtYmlndWl0eSBkPVwiICtcblx0XHRcdHRoaXMuZ2V0RGVjaXNpb25EZXNjcmlwdGlvbihyZWNvZ25pemVyLCBkZmEpICtcblx0XHRcdFwiOiBhbWJpZ0FsdHM9XCIgK1xuXHRcdFx0dGhpcy5nZXRDb25mbGljdGluZ0FsdHMoYW1iaWdBbHRzLCBjb25maWdzKSArXG5cdFx0XHRcIiwgaW5wdXQ9J1wiICtcblx0XHRcdHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXgpKSArIFwiJ1wiO1xuXHRyZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZyk7XG59O1xuXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0QXR0ZW1wdGluZ0Z1bGxDb250ZXh0ID0gZnVuY3Rpb24oXG5cdFx0cmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncykge1xuXHR2YXIgbXNnID0gXCJyZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgZD1cIiArXG5cdFx0XHR0aGlzLmdldERlY2lzaW9uRGVzY3JpcHRpb24ocmVjb2duaXplciwgZGZhKSArXG5cdFx0XHRcIiwgaW5wdXQ9J1wiICtcblx0XHRcdHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5nZXRUZXh0KG5ldyBJbnRlcnZhbChzdGFydEluZGV4LCBzdG9wSW5kZXgpKSArIFwiJ1wiO1xuXHRyZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZyk7XG59O1xuXG5EaWFnbm9zdGljRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUucmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5ID0gZnVuY3Rpb24oXG5cdFx0cmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIHByZWRpY3Rpb24sIGNvbmZpZ3MpIHtcblx0dmFyIG1zZyA9IFwicmVwb3J0Q29udGV4dFNlbnNpdGl2aXR5IGQ9XCIgK1xuXHRcdFx0dGhpcy5nZXREZWNpc2lvbkRlc2NyaXB0aW9uKHJlY29nbml6ZXIsIGRmYSkgK1xuXHRcdFx0XCIsIGlucHV0PSdcIiArXG5cdFx0XHRyZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuZ2V0VGV4dChuZXcgSW50ZXJ2YWwoc3RhcnRJbmRleCwgc3RvcEluZGV4KSkgKyBcIidcIjtcblx0cmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2cpO1xufTtcblxuRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLmdldERlY2lzaW9uRGVzY3JpcHRpb24gPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEpIHtcblx0dmFyIGRlY2lzaW9uID0gZGZhLmRlY2lzaW9uO1xuXHR2YXIgcnVsZUluZGV4ID0gZGZhLmF0blN0YXJ0U3RhdGUucnVsZUluZGV4O1xuXG5cdHZhciBydWxlTmFtZXMgPSByZWNvZ25pemVyLnJ1bGVOYW1lcztcblx0aWYgKHJ1bGVJbmRleCA8IDAgfHwgcnVsZUluZGV4ID49IHJ1bGVOYW1lcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gXCJcIiArIGRlY2lzaW9uO1xuXHR9XG5cdHZhciBydWxlTmFtZSA9IHJ1bGVOYW1lc1tydWxlSW5kZXhdIHx8IG51bGw7XG5cdGlmIChydWxlTmFtZSA9PT0gbnVsbCB8fCBydWxlTmFtZS5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gXCJcIiArIGRlY2lzaW9uO1xuXHR9XG5cdHJldHVybiBcIlwiICsgZGVjaXNpb24gKyBcIiAoXCIgKyBydWxlTmFtZSArIFwiKVwiO1xufTtcblxuLy9cbi8vIENvbXB1dGVzIHRoZSBzZXQgb2YgY29uZmxpY3Rpbmcgb3IgYW1iaWd1b3VzIGFsdGVybmF0aXZlcyBmcm9tIGFcbi8vIGNvbmZpZ3VyYXRpb24gc2V0LCBpZiB0aGF0IGluZm9ybWF0aW9uIHdhcyBub3QgYWxyZWFkeSBwcm92aWRlZCBieSB0aGVcbi8vIHBhcnNlci5cbi8vXG4vLyBAcGFyYW0gcmVwb3J0ZWRBbHRzIFRoZSBzZXQgb2YgY29uZmxpY3Rpbmcgb3IgYW1iaWd1b3VzIGFsdGVybmF0aXZlcywgYXNcbi8vIHJlcG9ydGVkIGJ5IHRoZSBwYXJzZXIuXG4vLyBAcGFyYW0gY29uZmlncyBUaGUgY29uZmxpY3Rpbmcgb3IgYW1iaWd1b3VzIGNvbmZpZ3VyYXRpb24gc2V0LlxuLy8gQHJldHVybiBSZXR1cm5zIHtAY29kZSByZXBvcnRlZEFsdHN9IGlmIGl0IGlzIG5vdCB7QGNvZGUgbnVsbH0sIG90aGVyd2lzZVxuLy8gcmV0dXJucyB0aGUgc2V0IG9mIGFsdGVybmF0aXZlcyByZXByZXNlbnRlZCBpbiB7QGNvZGUgY29uZmlnc30uXG4vL1xuRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXIucHJvdG90eXBlLmdldENvbmZsaWN0aW5nQWx0cyA9IGZ1bmN0aW9uKHJlcG9ydGVkQWx0cywgY29uZmlncykge1xuXHRpZiAocmVwb3J0ZWRBbHRzICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIHJlcG9ydGVkQWx0cztcblx0fVxuXHR2YXIgcmVzdWx0ID0gbmV3IEJpdFNldCgpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZ3MuaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZXN1bHQuYWRkKGNvbmZpZ3MuaXRlbXNbaV0uYWx0KTtcblx0fVxuXHRyZXR1cm4gXCJ7XCIgKyByZXN1bHQudmFsdWVzKCkuam9pbihcIiwgXCIpICsgXCJ9XCI7XG59O1xuXG5leHBvcnRzLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyID0gRGlhZ25vc3RpY0Vycm9yTGlzdGVuZXI7IiwiLy9cbi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLy8gUHJvdmlkZXMgYW4gZW1wdHkgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvckxpc3RlbmVyfS4gVGhlXG4vLyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kIGRvZXMgbm90aGluZywgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGFzXG4vLyBuZWNlc3NhcnkuXG5cbmZ1bmN0aW9uIEVycm9yTGlzdGVuZXIoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5FcnJvckxpc3RlbmVyLnByb3RvdHlwZS5zeW50YXhFcnJvciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIG9mZmVuZGluZ1N5bWJvbCwgbGluZSwgY29sdW1uLCBtc2csIGUpIHtcbn07XG5cbkVycm9yTGlzdGVuZXIucHJvdG90eXBlLnJlcG9ydEFtYmlndWl0eSA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKSB7XG59O1xuXG5FcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgY29uZmxpY3RpbmdBbHRzLCBjb25maWdzKSB7XG59O1xuXG5FcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgY29uZmlncykge1xufTtcblxuZnVuY3Rpb24gQ29uc29sZUVycm9yTGlzdGVuZXIoKSB7XG5cdEVycm9yTGlzdGVuZXIuY2FsbCh0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cbkNvbnNvbGVFcnJvckxpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3JMaXN0ZW5lci5wcm90b3R5cGUpO1xuQ29uc29sZUVycm9yTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc29sZUVycm9yTGlzdGVuZXI7XG5cbi8vXG4vLyBQcm92aWRlcyBhIGRlZmF1bHQgaW5zdGFuY2Ugb2Yge0BsaW5rIENvbnNvbGVFcnJvckxpc3RlbmVyfS5cbi8vXG5Db25zb2xlRXJyb3JMaXN0ZW5lci5JTlNUQU5DRSA9IG5ldyBDb25zb2xlRXJyb3JMaXN0ZW5lcigpO1xuXG4vL1xuLy8ge0Bpbmhlcml0RG9jfVxuLy9cbi8vIDxwPlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBwcmludHMgbWVzc2FnZXMgdG8ge0BsaW5rIFN5c3RlbS8vZXJyfSBjb250YWluaW5nIHRoZVxuLy8gdmFsdWVzIG9mIHtAY29kZSBsaW5lfSwge0Bjb2RlIGNoYXJQb3NpdGlvbkluTGluZX0sIGFuZCB7QGNvZGUgbXNnfSB1c2luZ1xuLy8gdGhlIGZvbGxvd2luZyBmb3JtYXQuPC9wPlxuLy9cbi8vIDxwcmU+XG4vLyBsaW5lIDxlbT5saW5lPC9lbT46PGVtPmNoYXJQb3NpdGlvbkluTGluZTwvZW0+IDxlbT5tc2c8L2VtPlxuLy8gPC9wcmU+XG4vL1xuQ29uc29sZUVycm9yTGlzdGVuZXIucHJvdG90eXBlLnN5bnRheEVycm9yID0gZnVuY3Rpb24ocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjb2x1bW4sIG1zZywgZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJsaW5lIFwiICsgbGluZSArIFwiOlwiICsgY29sdW1uICsgXCIgXCIgKyBtc2cpO1xufTtcblxuZnVuY3Rpb24gUHJveHlFcnJvckxpc3RlbmVyKGRlbGVnYXRlcykge1xuXHRFcnJvckxpc3RlbmVyLmNhbGwodGhpcyk7XG4gICAgaWYgKGRlbGVnYXRlcz09PW51bGwpIHtcbiAgICAgICAgdGhyb3cgXCJkZWxlZ2F0ZXNcIjtcbiAgICB9XG4gICAgdGhpcy5kZWxlZ2F0ZXMgPSBkZWxlZ2F0ZXM7XG5cdHJldHVybiB0aGlzO1xufVxuXG5Qcm94eUVycm9yTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvckxpc3RlbmVyLnByb3RvdHlwZSk7XG5Qcm94eUVycm9yTGlzdGVuZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJveHlFcnJvckxpc3RlbmVyO1xuXG5Qcm94eUVycm9yTGlzdGVuZXIucHJvdG90eXBlLnN5bnRheEVycm9yID0gZnVuY3Rpb24ocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjb2x1bW4sIG1zZywgZSkge1xuICAgIHRoaXMuZGVsZWdhdGVzLm1hcChmdW5jdGlvbihkKSB7IGQuc3ludGF4RXJyb3IocmVjb2duaXplciwgb2ZmZW5kaW5nU3ltYm9sLCBsaW5lLCBjb2x1bW4sIG1zZywgZSk7IH0pO1xufTtcblxuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRBbWJpZ3VpdHkgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgZXhhY3QsIGFtYmlnQWx0cywgY29uZmlncykge1xuICAgIHRoaXMuZGVsZWdhdGVzLm1hcChmdW5jdGlvbihkKSB7IGQucmVwb3J0QW1iaWd1aXR5KHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBleGFjdCwgYW1iaWdBbHRzLCBjb25maWdzKTsgfSk7XG59O1xuXG5Qcm94eUVycm9yTGlzdGVuZXIucHJvdG90eXBlLnJlcG9ydEF0dGVtcHRpbmdGdWxsQ29udGV4dCA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGRmYSwgc3RhcnRJbmRleCwgc3RvcEluZGV4LCBjb25mbGljdGluZ0FsdHMsIGNvbmZpZ3MpIHtcblx0dGhpcy5kZWxlZ2F0ZXMubWFwKGZ1bmN0aW9uKGQpIHsgZC5yZXBvcnRBdHRlbXB0aW5nRnVsbENvbnRleHQocmVjb2duaXplciwgZGZhLCBzdGFydEluZGV4LCBzdG9wSW5kZXgsIGNvbmZsaWN0aW5nQWx0cywgY29uZmlncyk7IH0pO1xufTtcblxuUHJveHlFcnJvckxpc3RlbmVyLnByb3RvdHlwZS5yZXBvcnRDb250ZXh0U2Vuc2l0aXZpdHkgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgY29uZmlncykge1xuXHR0aGlzLmRlbGVnYXRlcy5tYXAoZnVuY3Rpb24oZCkgeyBkLnJlcG9ydENvbnRleHRTZW5zaXRpdml0eShyZWNvZ25pemVyLCBkZmEsIHN0YXJ0SW5kZXgsIHN0b3BJbmRleCwgcHJlZGljdGlvbiwgY29uZmlncyk7IH0pO1xufTtcblxuZXhwb3J0cy5FcnJvckxpc3RlbmVyID0gRXJyb3JMaXN0ZW5lcjtcbmV4cG9ydHMuQ29uc29sZUVycm9yTGlzdGVuZXIgPSBDb25zb2xlRXJyb3JMaXN0ZW5lcjtcbmV4cG9ydHMuUHJveHlFcnJvckxpc3RlbmVyID0gUHJveHlFcnJvckxpc3RlbmVyO1xuXG4iLCIvL1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xudmFyIEVycm9ycyA9IHJlcXVpcmUoJy4vRXJyb3JzJyk7XG52YXIgTm9WaWFibGVBbHRFeGNlcHRpb24gPSBFcnJvcnMuTm9WaWFibGVBbHRFeGNlcHRpb247XG52YXIgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IEVycm9ycy5JbnB1dE1pc21hdGNoRXhjZXB0aW9uO1xudmFyIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiA9IEVycm9ycy5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb247XG52YXIgUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gPSBFcnJvcnMuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb247XG52YXIgQVROU3RhdGUgPSByZXF1aXJlKCcuLy4uL2F0bi9BVE5TdGF0ZScpLkFUTlN0YXRlO1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIEludGVydmFsU2V0ID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsU2V0O1xuXG5mdW5jdGlvbiBFcnJvclN0cmF0ZWd5KCkge1xuXG59XG5cbkVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24ocmVjb2duaXplcil7XG59O1xuXG5FcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZWNvdmVySW5saW5lID0gZnVuY3Rpb24ocmVjb2duaXplcil7XG59O1xuXG5FcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZWNvdmVyID0gZnVuY3Rpb24ocmVjb2duaXplciwgZSl7XG59O1xuXG5FcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24ocmVjb2duaXplcil7XG59O1xuXG5FcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5pbkVycm9yUmVjb3ZlcnlNb2RlID0gZnVuY3Rpb24ocmVjb2duaXplcil7XG59O1xuXG5FcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpe1xufTtcblxuXG5cbi8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIEFOVExSRXJyb3JTdHJhdGVneX0gdXNlZCBmb3Jcbi8vIGVycm9yIHJlcG9ydGluZyBhbmQgcmVjb3ZlcnkgaW4gQU5UTFIgcGFyc2Vycy5cbi8vXG5mdW5jdGlvbiBEZWZhdWx0RXJyb3JTdHJhdGVneSgpIHtcblx0RXJyb3JTdHJhdGVneS5jYWxsKHRoaXMpO1xuICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlcnJvciBzdHJhdGVneSBpcyBjdXJyZW50bHkgXCJyZWNvdmVyaW5nIGZyb20gYW5cbiAgICAvLyBlcnJvclwiLiBUaGlzIGlzIHVzZWQgdG8gc3VwcHJlc3MgcmVwb3J0aW5nIG11bHRpcGxlIGVycm9yIG1lc3NhZ2VzIHdoaWxlXG4gICAgLy8gYXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gYSBkZXRlY3RlZCBzeW50YXggZXJyb3IuXG4gICAgLy9cbiAgICAvLyBAc2VlIC8vaW5FcnJvclJlY292ZXJ5TW9kZVxuICAgIC8vXG4gICAgdGhpcy5lcnJvclJlY292ZXJ5TW9kZSA9IGZhbHNlO1xuXG4gICAgLy8gVGhlIGluZGV4IGludG8gdGhlIGlucHV0IHN0cmVhbSB3aGVyZSB0aGUgbGFzdCBlcnJvciBvY2N1cnJlZC5cbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcyB3aGVyZSBhbiBlcnJvciBpcyBmb3VuZFxuICAgIC8vIGJ1dCBubyB0b2tlbiBpcyBjb25zdW1lZCBkdXJpbmcgcmVjb3ZlcnkuLi5hbm90aGVyIGVycm9yIGlzIGZvdW5kLFxuICAgIC8vIGFkIG5hdXNldW0uIFRoaXMgaXMgYSBmYWlsc2FmZSBtZWNoYW5pc20gdG8gZ3VhcmFudGVlIHRoYXQgYXQgbGVhc3RcbiAgICAvLyBvbmUgdG9rZW4vdHJlZSBub2RlIGlzIGNvbnN1bWVkIGZvciB0d28gZXJyb3JzLlxuICAgIC8vXG4gICAgdGhpcy5sYXN0RXJyb3JJbmRleCA9IC0xO1xuICAgIHRoaXMubGFzdEVycm9yU3RhdGVzID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvclN0cmF0ZWd5LnByb3RvdHlwZSk7XG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZWZhdWx0RXJyb3JTdHJhdGVneTtcblxuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNhbGxzIHtAbGluayAvL2VuZEVycm9yQ29uZGl0aW9ufSB0b1xuLy8gZW5zdXJlIHRoYXQgdGhlIGhhbmRsZXIgaXMgbm90IGluIGVycm9yIHJlY292ZXJ5IG1vZGUuPC9wPlxuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHRoaXMuZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XG59O1xuXG4vL1xuLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUgd2hlbiBhIHJlY29nbml0aW9uXG4vLyBleGNlcHRpb24gaXMgcmVwb3J0ZWQuXG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5iZWdpbkVycm9yQ29uZGl0aW9uID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHRoaXMuZXJyb3JSZWNvdmVyeU1vZGUgPSB0cnVlO1xufTtcblxuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmluRXJyb3JSZWNvdmVyeU1vZGUgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JSZWNvdmVyeU1vZGU7XG59O1xuXG4vL1xuLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGxlYXZlIGVycm9yIHJlY292ZXJ5IG1vZGUgYWZ0ZXIgcmVjb3ZlcmluZyBmcm9tXG4vLyBhIHJlY29nbml0aW9uIGV4Y2VwdGlvbi5cbi8vXG4vLyBAcGFyYW0gcmVjb2duaXplclxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5lbmRFcnJvckNvbmRpdGlvbiA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICB0aGlzLmVycm9yUmVjb3ZlcnlNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBudWxsO1xuICAgIHRoaXMubGFzdEVycm9ySW5kZXggPSAtMTtcbn07XG5cbi8vXG4vLyB7QGluaGVyaXREb2N9XG4vL1xuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2ltcGx5IGNhbGxzIHtAbGluayAvL2VuZEVycm9yQ29uZGl0aW9ufS48L3A+XG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydE1hdGNoID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHRoaXMuZW5kRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XG59O1xuXG4vL1xuLy8ge0Bpbmhlcml0RG9jfVxuLy9cbi8vIDxwPlRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgaW1tZWRpYXRlbHkgaWYgdGhlIGhhbmRsZXIgaXMgYWxyZWFkeVxuLy8gaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS4gT3RoZXJ3aXNlLCBpdCBjYWxscyB7QGxpbmsgLy9iZWdpbkVycm9yQ29uZGl0aW9ufVxuLy8gYW5kIGRpc3BhdGNoZXMgdGhlIHJlcG9ydGluZyB0YXNrIGJhc2VkIG9uIHRoZSBydW50aW1lIHR5cGUgb2Yge0Bjb2RlIGV9XG4vLyBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyB0YWJsZS48L3A+XG4vL1xuLy8gPHVsPlxuLy8gPGxpPntAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn06IERpc3BhdGNoZXMgdGhlIGNhbGwgdG9cbi8vIHtAbGluayAvL3JlcG9ydE5vVmlhYmxlQWx0ZXJuYXRpdmV9PC9saT5cbi8vIDxsaT57QGxpbmsgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbn06IERpc3BhdGNoZXMgdGhlIGNhbGwgdG9cbi8vIHtAbGluayAvL3JlcG9ydElucHV0TWlzbWF0Y2h9PC9saT5cbi8vIDxsaT57QGxpbmsgRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9ufTogRGlzcGF0Y2hlcyB0aGUgY2FsbCB0b1xuLy8ge0BsaW5rIC8vcmVwb3J0RmFpbGVkUHJlZGljYXRlfTwvbGk+XG4vLyA8bGk+QWxsIG90aGVyIHR5cGVzOiBjYWxscyB7QGxpbmsgUGFyc2VyLy9ub3RpZnlFcnJvckxpc3RlbmVyc30gdG8gcmVwb3J0XG4vLyB0aGUgZXhjZXB0aW9uPC9saT5cbi8vIDwvdWw+XG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24ocmVjb2duaXplciwgZSkge1xuICAgLy8gaWYgd2UndmUgYWxyZWFkeSByZXBvcnRlZCBhbiBlcnJvciBhbmQgaGF2ZSBub3QgbWF0Y2hlZCBhIHRva2VuXG4gICAvLyB5ZXQgc3VjY2Vzc2Z1bGx5LCBkb24ndCByZXBvcnQgYW55IGVycm9ycy5cbiAgICBpZih0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkb24ndCByZXBvcnQgc3B1cmlvdXMgZXJyb3JzXG4gICAgfVxuICAgIHRoaXMuYmVnaW5FcnJvckNvbmRpdGlvbihyZWNvZ25pemVyKTtcbiAgICBpZiAoIGUgaW5zdGFuY2VvZiBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiApIHtcbiAgICAgICAgdGhpcy5yZXBvcnROb1ZpYWJsZUFsdGVybmF0aXZlKHJlY29nbml6ZXIsIGUpO1xuICAgIH0gZWxzZSBpZiAoIGUgaW5zdGFuY2VvZiBJbnB1dE1pc21hdGNoRXhjZXB0aW9uICkge1xuICAgICAgICB0aGlzLnJlcG9ydElucHV0TWlzbWF0Y2gocmVjb2duaXplciwgZSk7XG4gICAgfSBlbHNlIGlmICggZSBpbnN0YW5jZW9mIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiApIHtcbiAgICAgICAgdGhpcy5yZXBvcnRGYWlsZWRQcmVkaWNhdGUocmVjb2duaXplciwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIHJlY29nbml0aW9uIGVycm9yIHR5cGU6IFwiICsgZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayk7XG4gICAgICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMoZS5nZXRPZmZlbmRpbmdUb2tlbigpLCBlLmdldE1lc3NhZ2UoKSwgZSk7XG4gICAgfVxufTtcbi8vXG4vLyB7QGluaGVyaXREb2N9XG4vL1xuLy8gPHA+VGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmVzeW5jaHJvbml6ZXMgdGhlIHBhcnNlciBieSBjb25zdW1pbmcgdG9rZW5zXG4vLyB1bnRpbCB3ZSBmaW5kIG9uZSBpbiB0aGUgcmVzeW5jaHJvbml6YXRpb24gc2V0LS1sb29zZWx5IHRoZSBzZXQgb2YgdG9rZW5zXG4vLyB0aGF0IGNhbiBmb2xsb3cgdGhlIGN1cnJlbnQgcnVsZS48L3A+XG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnJlY292ZXIgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKSB7XG4gICAgaWYgKHRoaXMubGFzdEVycm9ySW5kZXg9PT1yZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCkuaW5kZXggJiZcbiAgICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgIT09IG51bGwgJiYgdGhpcy5sYXN0RXJyb3JTdGF0ZXMuaW5kZXhPZihyZWNvZ25pemVyLnN0YXRlKT49MCkge1xuXHRcdC8vIHVoIG9oLCBhbm90aGVyIGVycm9yIGF0IHNhbWUgdG9rZW4gaW5kZXggYW5kIHByZXZpb3VzbHktdmlzaXRlZFxuXHRcdC8vIHN0YXRlIGluIEFUTjsgbXVzdCBiZSBhIGNhc2Ugd2hlcmUgTFQoMSkgaXMgaW4gdGhlIHJlY292ZXJ5XG5cdFx0Ly8gdG9rZW4gc2V0IHNvIG5vdGhpbmcgZ290IGNvbnN1bWVkLiBDb25zdW1lIGEgc2luZ2xlIHRva2VuXG5cdFx0Ly8gYXQgbGVhc3QgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wOyB0aGlzIGlzIGEgZmFpbHNhZmUuXG5cdFx0cmVjb2duaXplci5jb25zdW1lKCk7XG4gICAgfVxuICAgIHRoaXMubGFzdEVycm9ySW5kZXggPSByZWNvZ25pemVyLl9pbnB1dC5pbmRleDtcbiAgICBpZiAodGhpcy5sYXN0RXJyb3JTdGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5sYXN0RXJyb3JTdGF0ZXMucHVzaChyZWNvZ25pemVyLnN0YXRlKTtcbiAgICB2YXIgZm9sbG93U2V0ID0gdGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpO1xuICAgIHRoaXMuY29uc3VtZVVudGlsKHJlY29nbml6ZXIsIGZvbGxvd1NldCk7XG59O1xuXG4vLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5Ly9zeW5jfSBtYWtlcyBzdXJlXG4vLyB0aGF0IHRoZSBjdXJyZW50IGxvb2thaGVhZCBzeW1ib2wgaXMgY29uc2lzdGVudCB3aXRoIHdoYXQgd2VyZSBleHBlY3Rpbmdcbi8vIGF0IHRoaXMgcG9pbnQgaW4gdGhlIEFUTi4gWW91IGNhbiBjYWxsIHRoaXMgYW55dGltZSBidXQgQU5UTFIgb25seVxuLy8gZ2VuZXJhdGVzIGNvZGUgdG8gY2hlY2sgYmVmb3JlIHN1YnJ1bGVzL2xvb3BzIGFuZCBlYWNoIGl0ZXJhdGlvbi5cbi8vXG4vLyA8cD5JbXBsZW1lbnRzIEppbSBJZGxlJ3MgbWFnaWMgc3luYyBtZWNoYW5pc20gaW4gY2xvc3VyZXMgYW5kIG9wdGlvbmFsXG4vLyBzdWJydWxlcy4gRS5nLiw8L3A+XG4vL1xuLy8gPHByZT5cbi8vIGEgOiBzeW5jICggc3R1ZmYgc3luYyApKiA7XG4vLyBzeW5jIDoge2NvbnN1bWUgdG8gd2hhdCBjYW4gZm9sbG93IHN5bmN9IDtcbi8vIDwvcHJlPlxuLy9cbi8vIEF0IHRoZSBzdGFydCBvZiBhIHN1YiBydWxlIHVwb24gZXJyb3IsIHtAbGluayAvL3N5bmN9IHBlcmZvcm1zIHNpbmdsZVxuLy8gdG9rZW4gZGVsZXRpb24sIGlmIHBvc3NpYmxlLiBJZiBpdCBjYW4ndCBkbyB0aGF0LCBpdCBiYWlscyBvbiB0aGUgY3VycmVudFxuLy8gcnVsZSBhbmQgdXNlcyB0aGUgZGVmYXVsdCBlcnJvciByZWNvdmVyeSwgd2hpY2ggY29uc3VtZXMgdW50aWwgdGhlXG4vLyByZXN5bmNocm9uaXphdGlvbiBzZXQgb2YgdGhlIGN1cnJlbnQgcnVsZS5cbi8vXG4vLyA8cD5JZiB0aGUgc3ViIHJ1bGUgaXMgb3B0aW9uYWwgKHtAY29kZSAoLi4uKT99LCB7QGNvZGUgKC4uLikqfSwgb3IgYmxvY2tcbi8vIHdpdGggYW4gZW1wdHkgYWx0ZXJuYXRpdmUpLCB0aGVuIHRoZSBleHBlY3RlZCBzZXQgaW5jbHVkZXMgd2hhdCBmb2xsb3dzXG4vLyB0aGUgc3VicnVsZS48L3A+XG4vL1xuLy8gPHA+RHVyaW5nIGxvb3AgaXRlcmF0aW9uLCBpdCBjb25zdW1lcyB1bnRpbCBpdCBzZWVzIGEgdG9rZW4gdGhhdCBjYW4gc3RhcnQgYVxuLy8gc3ViIHJ1bGUgb3Igd2hhdCBmb2xsb3dzIGxvb3AuIFllcywgdGhhdCBpcyBwcmV0dHkgYWdncmVzc2l2ZS4gV2Ugb3B0IHRvXG4vLyBzdGF5IGluIHRoZSBsb29wIGFzIGxvbmcgYXMgcG9zc2libGUuPC9wPlxuLy9cbi8vIDxwPjxzdHJvbmc+T1JJR0lOUzwvc3Ryb25nPjwvcD5cbi8vXG4vLyA8cD5QcmV2aW91cyB2ZXJzaW9ucyBvZiBBTlRMUiBkaWQgYSBwb29yIGpvYiBvZiB0aGVpciByZWNvdmVyeSB3aXRoaW4gbG9vcHMuXG4vLyBBIHNpbmdsZSBtaXNtYXRjaCB0b2tlbiBvciBtaXNzaW5nIHRva2VuIHdvdWxkIGZvcmNlIHRoZSBwYXJzZXIgdG8gYmFpbFxuLy8gb3V0IG9mIHRoZSBlbnRpcmUgcnVsZXMgc3Vycm91bmRpbmcgdGhlIGxvb3AuIFNvLCBmb3IgcnVsZTwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gY2xhc3NEZWYgOiAnY2xhc3MnIElEICd7JyBtZW1iZXIqICd9J1xuLy8gPC9wcmU+XG4vL1xuLy8gaW5wdXQgd2l0aCBhbiBleHRyYSB0b2tlbiBiZXR3ZWVuIG1lbWJlcnMgd291bGQgZm9yY2UgdGhlIHBhcnNlciB0b1xuLy8gY29uc3VtZSB1bnRpbCBpdCBmb3VuZCB0aGUgbmV4dCBjbGFzcyBkZWZpbml0aW9uIHJhdGhlciB0aGFuIHRoZSBuZXh0XG4vLyBtZW1iZXIgZGVmaW5pdGlvbiBvZiB0aGUgY3VycmVudCBjbGFzcy5cbi8vXG4vLyA8cD5UaGlzIGZ1bmN0aW9uYWxpdHkgY29zdCBhIGxpdHRsZSBiaXQgb2YgZWZmb3J0IGJlY2F1c2UgdGhlIHBhcnNlciBoYXMgdG9cbi8vIGNvbXBhcmUgdG9rZW4gc2V0IGF0IHRoZSBzdGFydCBvZiB0aGUgbG9vcCBhbmQgYXQgZWFjaCBpdGVyYXRpb24uIElmIGZvclxuLy8gc29tZSByZWFzb24gc3BlZWQgaXMgc3VmZmVyaW5nIGZvciB5b3UsIHlvdSBjYW4gdHVybiBvZmYgdGhpc1xuLy8gZnVuY3Rpb25hbGl0eSBieSBzaW1wbHkgb3ZlcnJpZGluZyB0aGlzIG1ldGhvZCBhcyBhIGJsYW5rIHsgfS48L3A+XG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgLy8gSWYgYWxyZWFkeSByZWNvdmVyaW5nLCBkb24ndCB0cnkgdG8gc3luY1xuICAgIGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcyA9IHJlY29nbml6ZXIuX2ludGVycC5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xuICAgIHZhciBsYSA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MQSgxKTtcbiAgICAvLyB0cnkgY2hlYXBlciBzdWJzZXQgZmlyc3Q7IG1pZ2h0IGdldCBsdWNreS4gc2VlbXMgdG8gc2hhdmUgYSB3ZWUgYml0IG9mZlxuICAgIHZhciBuZXh0VG9rZW5zID0gcmVjb2duaXplci5hdG4ubmV4dFRva2VucyhzKTtcbiAgICBpZiAobmV4dFRva2Vucy5jb250YWlucyhUb2tlbi5FUFNJTE9OKSB8fCBuZXh0VG9rZW5zLmNvbnRhaW5zKGxhKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocy5zdGF0ZVR5cGUpIHtcbiAgICBjYXNlIEFUTlN0YXRlLkJMT0NLX1NUQVJUOlxuICAgIGNhc2UgQVROU3RhdGUuU1RBUl9CTE9DS19TVEFSVDpcbiAgICBjYXNlIEFUTlN0YXRlLlBMVVNfQkxPQ0tfU1RBUlQ6XG4gICAgY2FzZSBBVE5TdGF0ZS5TVEFSX0xPT1BfRU5UUlk6XG4gICAgICAgLy8gcmVwb3J0IGVycm9yIGFuZCByZWNvdmVyIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmKCB0aGlzLnNpbmdsZVRva2VuRGVsZXRpb24ocmVjb2duaXplcikgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgQVROU3RhdGUuUExVU19MT09QX0JBQ0s6XG4gICAgY2FzZSBBVE5TdGF0ZS5TVEFSX0xPT1BfQkFDSzpcbiAgICAgICAgdGhpcy5yZXBvcnRVbndhbnRlZFRva2VuKHJlY29nbml6ZXIpO1xuICAgICAgICB2YXIgZXhwZWN0aW5nID0gbmV3IEludGVydmFsU2V0KCk7XG4gICAgICAgIGV4cGVjdGluZy5hZGRTZXQocmVjb2duaXplci5nZXRFeHBlY3RlZFRva2VucygpKTtcbiAgICAgICAgdmFyIHdoYXRGb2xsb3dzTG9vcEl0ZXJhdGlvbk9yUnVsZSA9IGV4cGVjdGluZy5hZGRTZXQodGhpcy5nZXRFcnJvclJlY292ZXJ5U2V0KHJlY29nbml6ZXIpKTtcbiAgICAgICAgdGhpcy5jb25zdW1lVW50aWwocmVjb2duaXplciwgd2hhdEZvbGxvd3NMb29wSXRlcmF0aW9uT3JSdWxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZG8gbm90aGluZyBpZiB3ZSBjYW4ndCBpZGVudGlmeSB0aGUgZXhhY3Qga2luZCBvZiBBVE4gc3RhdGVcbiAgICB9XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB7QGxpbmsgLy9yZXBvcnRFcnJvcn0gd2hlbiB0aGUgZXhjZXB0aW9uIGlzIGFcbi8vIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0uXG4vL1xuLy8gQHNlZSAvL3JlcG9ydEVycm9yXG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy8gQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvblxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnROb1ZpYWJsZUFsdGVybmF0aXZlID0gZnVuY3Rpb24ocmVjb2duaXplciwgZSkge1xuICAgIHZhciB0b2tlbnMgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCk7XG4gICAgdmFyIGlucHV0O1xuICAgIGlmKHRva2VucyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZS5zdGFydFRva2VuLnR5cGU9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCI8RU9GPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSB0b2tlbnMuZ2V0VGV4dChuZXcgSW50ZXJ2YWwoZS5zdGFydFRva2VuLnRva2VuSW5kZXgsIGUub2ZmZW5kaW5nVG9rZW4udG9rZW5JbmRleCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQgPSBcIjx1bmtub3duIGlucHV0PlwiO1xuICAgIH1cbiAgICB2YXIgbXNnID0gXCJubyB2aWFibGUgYWx0ZXJuYXRpdmUgYXQgaW5wdXQgXCIgKyB0aGlzLmVzY2FwZVdTQW5kUXVvdGUoaW5wdXQpO1xuICAgIHJlY29nbml6ZXIubm90aWZ5RXJyb3JMaXN0ZW5lcnMobXNnLCBlLm9mZmVuZGluZ1Rva2VuLCBlKTtcbn07XG5cbi8vXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB7QGxpbmsgLy9yZXBvcnRFcnJvcn0gd2hlbiB0aGUgZXhjZXB0aW9uIGlzIGFuXG4vLyB7QGxpbmsgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbn0uXG4vL1xuLy8gQHNlZSAvL3JlcG9ydEVycm9yXG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy8gQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvblxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnRJbnB1dE1pc21hdGNoID0gZnVuY3Rpb24ocmVjb2duaXplciwgZSkge1xuICAgIHZhciBtc2cgPSBcIm1pc21hdGNoZWQgaW5wdXQgXCIgKyB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KGUub2ZmZW5kaW5nVG9rZW4pICtcbiAgICAgICAgICBcIiBleHBlY3RpbmcgXCIgKyBlLmdldEV4cGVjdGVkVG9rZW5zKCkudG9TdHJpbmcocmVjb2duaXplci5saXRlcmFsTmFtZXMsIHJlY29nbml6ZXIuc3ltYm9saWNOYW1lcyk7XG4gICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIGUub2ZmZW5kaW5nVG9rZW4sIGUpO1xufTtcblxuLy9cbi8vIFRoaXMgaXMgY2FsbGVkIGJ5IHtAbGluayAvL3JlcG9ydEVycm9yfSB3aGVuIHRoZSBleGNlcHRpb24gaXMgYVxuLy8ge0BsaW5rIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbn0uXG4vL1xuLy8gQHNlZSAvL3JlcG9ydEVycm9yXG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy8gQHBhcmFtIGUgdGhlIHJlY29nbml0aW9uIGV4Y2VwdGlvblxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnRGYWlsZWRQcmVkaWNhdGUgPSBmdW5jdGlvbihyZWNvZ25pemVyLCBlKSB7XG4gICAgdmFyIHJ1bGVOYW1lID0gcmVjb2duaXplci5ydWxlTmFtZXNbcmVjb2duaXplci5fY3R4LnJ1bGVJbmRleF07XG4gICAgdmFyIG1zZyA9IFwicnVsZSBcIiArIHJ1bGVOYW1lICsgXCIgXCIgKyBlLm1lc3NhZ2U7XG4gICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIGUub2ZmZW5kaW5nVG9rZW4sIGUpO1xufTtcblxuLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIHJlcG9ydCBhIHN5bnRheCBlcnJvciB3aGljaCByZXF1aXJlcyB0aGUgcmVtb3ZhbFxuLy8gb2YgYSB0b2tlbiBmcm9tIHRoZSBpbnB1dCBzdHJlYW0uIEF0IHRoZSB0aW1lIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlXG4vLyBlcnJvbmVvdXMgc3ltYm9sIGlzIGN1cnJlbnQge0Bjb2RlIExUKDEpfSBzeW1ib2wgYW5kIGhhcyBub3QgeWV0IGJlZW5cbi8vIHJlbW92ZWQgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLiBXaGVuIHRoaXMgbWV0aG9kIHJldHVybnMsXG4vLyB7QGNvZGUgcmVjb2duaXplcn0gaXMgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZS5cbi8vXG4vLyA8cD5UaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB7QGxpbmsgLy9zaW5nbGVUb2tlbkRlbGV0aW9ufSBpZGVudGlmaWVzXG4vLyBzaW5nbGUtdG9rZW4gZGVsZXRpb24gYXMgYSB2aWFibGUgcmVjb3Zlcnkgc3RyYXRlZ3kgZm9yIGEgbWlzbWF0Y2hlZFxuLy8gaW5wdXQgZXJyb3IuPC9wPlxuLy9cbi8vIDxwPlRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSByZXR1cm5zIGlmIHRoZSBoYW5kbGVyIGlzIGFscmVhZHkgaW5cbi8vIGVycm9yIHJlY292ZXJ5IG1vZGUuIE90aGVyd2lzZSwgaXQgY2FsbHMge0BsaW5rIC8vYmVnaW5FcnJvckNvbmRpdGlvbn0gdG9cbi8vIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUsIGZvbGxvd2VkIGJ5IGNhbGxpbmdcbi8vIHtAbGluayBQYXJzZXIvL25vdGlmeUVycm9yTGlzdGVuZXJzfS48L3A+XG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnRVbndhbnRlZFRva2VuID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIGlmICh0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XG4gICAgdmFyIHQgPSByZWNvZ25pemVyLmdldEN1cnJlbnRUb2tlbigpO1xuICAgIHZhciB0b2tlbk5hbWUgPSB0aGlzLmdldFRva2VuRXJyb3JEaXNwbGF5KHQpO1xuICAgIHZhciBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgIHZhciBtc2cgPSBcImV4dHJhbmVvdXMgaW5wdXQgXCIgKyB0b2tlbk5hbWUgKyBcIiBleHBlY3RpbmcgXCIgK1xuICAgICAgICBleHBlY3RpbmcudG9TdHJpbmcocmVjb2duaXplci5saXRlcmFsTmFtZXMsIHJlY29nbml6ZXIuc3ltYm9saWNOYW1lcyk7XG4gICAgcmVjb2duaXplci5ub3RpZnlFcnJvckxpc3RlbmVycyhtc2csIHQsIG51bGwpO1xufTtcbi8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byByZXBvcnQgYSBzeW50YXggZXJyb3Igd2hpY2ggcmVxdWlyZXMgdGhlXG4vLyBpbnNlcnRpb24gb2YgYSBtaXNzaW5nIHRva2VuIGludG8gdGhlIGlucHV0IHN0cmVhbS4gQXQgdGhlIHRpbWUgdGhpc1xuLy8gbWV0aG9kIGlzIGNhbGxlZCwgdGhlIG1pc3NpbmcgdG9rZW4gaGFzIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZC4gV2hlbiB0aGlzXG4vLyBtZXRob2QgcmV0dXJucywge0Bjb2RlIHJlY29nbml6ZXJ9IGlzIGluIGVycm9yIHJlY292ZXJ5IG1vZGUuXG4vL1xuLy8gPHA+VGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4ge0BsaW5rIC8vc2luZ2xlVG9rZW5JbnNlcnRpb259IGlkZW50aWZpZXNcbi8vIHNpbmdsZS10b2tlbiBpbnNlcnRpb24gYXMgYSB2aWFibGUgcmVjb3Zlcnkgc3RyYXRlZ3kgZm9yIGEgbWlzbWF0Y2hlZFxuLy8gaW5wdXQgZXJyb3IuPC9wPlxuLy9cbi8vIDxwPlRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNpbXBseSByZXR1cm5zIGlmIHRoZSBoYW5kbGVyIGlzIGFscmVhZHkgaW5cbi8vIGVycm9yIHJlY292ZXJ5IG1vZGUuIE90aGVyd2lzZSwgaXQgY2FsbHMge0BsaW5rIC8vYmVnaW5FcnJvckNvbmRpdGlvbn0gdG9cbi8vIGVudGVyIGVycm9yIHJlY292ZXJ5IG1vZGUsIGZvbGxvd2VkIGJ5IGNhbGxpbmdcbi8vIHtAbGluayBQYXJzZXIvL25vdGlmeUVycm9yTGlzdGVuZXJzfS48L3A+XG4vL1xuLy8gQHBhcmFtIHJlY29nbml6ZXIgdGhlIHBhcnNlciBpbnN0YW5jZVxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZXBvcnRNaXNzaW5nVG9rZW4gPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgaWYgKCB0aGlzLmluRXJyb3JSZWNvdmVyeU1vZGUocmVjb2duaXplcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJlZ2luRXJyb3JDb25kaXRpb24ocmVjb2duaXplcik7XG4gICAgdmFyIHQgPSByZWNvZ25pemVyLmdldEN1cnJlbnRUb2tlbigpO1xuICAgIHZhciBleHBlY3RpbmcgPSB0aGlzLmdldEV4cGVjdGVkVG9rZW5zKHJlY29nbml6ZXIpO1xuICAgIHZhciBtc2cgPSBcIm1pc3NpbmcgXCIgKyBleHBlY3RpbmcudG9TdHJpbmcocmVjb2duaXplci5saXRlcmFsTmFtZXMsIHJlY29nbml6ZXIuc3ltYm9saWNOYW1lcykgK1xuICAgICAgICAgIFwiIGF0IFwiICsgdGhpcy5nZXRUb2tlbkVycm9yRGlzcGxheSh0KTtcbiAgICByZWNvZ25pemVyLm5vdGlmeUVycm9yTGlzdGVuZXJzKG1zZywgdCwgbnVsbCk7XG59O1xuXG4vLyA8cD5UaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBhdHRlbXB0cyB0byByZWNvdmVyIGZyb20gdGhlIG1pc21hdGNoZWQgaW5wdXRcbi8vIGJ5IHVzaW5nIHNpbmdsZSB0b2tlbiBpbnNlcnRpb24gYW5kIGRlbGV0aW9uIGFzIGRlc2NyaWJlZCBiZWxvdy4gSWYgdGhlXG4vLyByZWNvdmVyeSBhdHRlbXB0IGZhaWxzLCB0aGlzIG1ldGhvZCB0aHJvd3MgYW5cbi8vIHtAbGluayBJbnB1dE1pc21hdGNoRXhjZXB0aW9ufS48L3A+XG4vL1xuLy8gPHA+PHN0cm9uZz5FWFRSQSBUT0tFTjwvc3Ryb25nPiAoc2luZ2xlIHRva2VuIGRlbGV0aW9uKTwvcD5cbi8vXG4vLyA8cD57QGNvZGUgTEEoMSl9IGlzIG5vdCB3aGF0IHdlIGFyZSBsb29raW5nIGZvci4gSWYge0Bjb2RlIExBKDIpfSBoYXMgdGhlXG4vLyByaWdodCB0b2tlbiwgaG93ZXZlciwgdGhlbiBhc3N1bWUge0Bjb2RlIExBKDEpfSBpcyBzb21lIGV4dHJhIHNwdXJpb3VzXG4vLyB0b2tlbiBhbmQgZGVsZXRlIGl0LiBUaGVuIGNvbnN1bWUgYW5kIHJldHVybiB0aGUgbmV4dCB0b2tlbiAod2hpY2ggd2FzXG4vLyB0aGUge0Bjb2RlIExBKDIpfSB0b2tlbikgYXMgdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIHRoZSBtYXRjaCBvcGVyYXRpb24uPC9wPlxuLy9cbi8vIDxwPlRoaXMgcmVjb3Zlcnkgc3RyYXRlZ3kgaXMgaW1wbGVtZW50ZWQgYnkge0BsaW5rXG4vLyAvL3NpbmdsZVRva2VuRGVsZXRpb259LjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPk1JU1NJTkcgVE9LRU48L3N0cm9uZz4gKHNpbmdsZSB0b2tlbiBpbnNlcnRpb24pPC9wPlxuLy9cbi8vIDxwPklmIGN1cnJlbnQgdG9rZW4gKGF0IHtAY29kZSBMQSgxKX0pIGlzIGNvbnNpc3RlbnQgd2l0aCB3aGF0IGNvdWxkIGNvbWVcbi8vIGFmdGVyIHRoZSBleHBlY3RlZCB7QGNvZGUgTEEoMSl9IHRva2VuLCB0aGVuIGFzc3VtZSB0aGUgdG9rZW4gaXMgbWlzc2luZ1xuLy8gYW5kIHVzZSB0aGUgcGFyc2VyJ3Mge0BsaW5rIFRva2VuRmFjdG9yeX0gdG8gY3JlYXRlIGl0IG9uIHRoZSBmbHkuIFRoZVxuLy8gXCJpbnNlcnRpb25cIiBpcyBwZXJmb3JtZWQgYnkgcmV0dXJuaW5nIHRoZSBjcmVhdGVkIHRva2VuIGFzIHRoZSBzdWNjZXNzZnVsXG4vLyByZXN1bHQgb2YgdGhlIG1hdGNoIG9wZXJhdGlvbi48L3A+XG4vL1xuLy8gPHA+VGhpcyByZWNvdmVyeSBzdHJhdGVneSBpcyBpbXBsZW1lbnRlZCBieSB7QGxpbmtcbi8vIC8vc2luZ2xlVG9rZW5JbnNlcnRpb259LjwvcD5cbi8vXG4vLyA8cD48c3Ryb25nPkVYQU1QTEU8L3N0cm9uZz48L3A+XG4vL1xuLy8gPHA+Rm9yIGV4YW1wbGUsIElucHV0IHtAY29kZSBpPSgzO30gaXMgY2xlYXJseSBtaXNzaW5nIHRoZSB7QGNvZGUgJyknfS4gV2hlblxuLy8gdGhlIHBhcnNlciByZXR1cm5zIGZyb20gdGhlIG5lc3RlZCBjYWxsIHRvIHtAY29kZSBleHByfSwgaXQgd2lsbCBoYXZlXG4vLyBjYWxsIGNoYWluOjwvcD5cbi8vXG4vLyA8cHJlPlxuLy8gc3RhdCAmcmFycjsgZXhwciAmcmFycjsgYXRvbVxuLy8gPC9wcmU+XG4vL1xuLy8gYW5kIGl0IHdpbGwgYmUgdHJ5aW5nIHRvIG1hdGNoIHRoZSB7QGNvZGUgJyknfSBhdCB0aGlzIHBvaW50IGluIHRoZVxuLy8gZGVyaXZhdGlvbjpcbi8vXG4vLyA8cHJlPlxuLy8gPSZndDsgSUQgJz0nICcoJyBJTlQgJyknICgnKycgYXRvbSkqICc7J1xuLy8gXlxuLy8gPC9wcmU+XG4vL1xuLy8gVGhlIGF0dGVtcHQgdG8gbWF0Y2gge0Bjb2RlICcpJ30gd2lsbCBmYWlsIHdoZW4gaXQgc2VlcyB7QGNvZGUgJzsnfSBhbmRcbi8vIGNhbGwge0BsaW5rIC8vcmVjb3ZlcklubGluZX0uIFRvIHJlY292ZXIsIGl0IHNlZXMgdGhhdCB7QGNvZGUgTEEoMSk9PSc7J31cbi8vIGlzIGluIHRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuIGZvbGxvdyB0aGUge0Bjb2RlICcpJ30gdG9rZW4gcmVmZXJlbmNlXG4vLyBpbiBydWxlIHtAY29kZSBhdG9tfS4gSXQgY2FuIGFzc3VtZSB0aGF0IHlvdSBmb3Jnb3QgdGhlIHtAY29kZSAnKSd9LlxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZWNvdmVySW5saW5lID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIC8vIFNJTkdMRSBUT0tFTiBERUxFVElPTlxuICAgIHZhciBtYXRjaGVkU3ltYm9sID0gdGhpcy5zaW5nbGVUb2tlbkRlbGV0aW9uKHJlY29nbml6ZXIpO1xuICAgIGlmIChtYXRjaGVkU3ltYm9sICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgZGVsZXRlZCB0aGUgZXh0cmEgdG9rZW4uXG4gICAgICAgIC8vIG5vdywgbW92ZSBwYXN0IHR0eXBlIHRva2VuIGFzIGlmIGFsbCB3ZXJlIG9rXG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFN5bWJvbDtcbiAgICB9XG4gICAgLy8gU0lOR0xFIFRPS0VOIElOU0VSVElPTlxuICAgIGlmICh0aGlzLnNpbmdsZVRva2VuSW5zZXJ0aW9uKHJlY29nbml6ZXIpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1pc3NpbmdTeW1ib2wocmVjb2duaXplcik7XG4gICAgfVxuICAgIC8vIGV2ZW4gdGhhdCBkaWRuJ3Qgd29yazsgbXVzdCB0aHJvdyB0aGUgZXhjZXB0aW9uXG4gICAgdGhyb3cgbmV3IElucHV0TWlzbWF0Y2hFeGNlcHRpb24ocmVjb2duaXplcik7XG59O1xuXG4vL1xuLy8gVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgc2luZ2xlLXRva2VuIGluc2VydGlvbiBpbmxpbmUgZXJyb3IgcmVjb3Zlcnlcbi8vIHN0cmF0ZWd5LiBJdCBpcyBjYWxsZWQgYnkge0BsaW5rIC8vcmVjb3ZlcklubGluZX0gaWYgdGhlIHNpbmdsZS10b2tlblxuLy8gZGVsZXRpb24gc3RyYXRlZ3kgZmFpbHMgdG8gcmVjb3ZlciBmcm9tIHRoZSBtaXNtYXRjaGVkIGlucHV0LiBJZiB0aGlzXG4vLyBtZXRob2QgcmV0dXJucyB7QGNvZGUgdHJ1ZX0sIHtAY29kZSByZWNvZ25pemVyfSB3aWxsIGJlIGluIGVycm9yIHJlY292ZXJ5XG4vLyBtb2RlLlxuLy9cbi8vIDxwPlRoaXMgbWV0aG9kIGRldGVybWluZXMgd2hldGhlciBvciBub3Qgc2luZ2xlLXRva2VuIGluc2VydGlvbiBpcyB2aWFibGUgYnlcbi8vIGNoZWNraW5nIGlmIHRoZSB7QGNvZGUgTEEoMSl9IGlucHV0IHN5bWJvbCBjb3VsZCBiZSBzdWNjZXNzZnVsbHkgbWF0Y2hlZFxuLy8gaWYgaXQgd2VyZSBpbnN0ZWFkIHRoZSB7QGNvZGUgTEEoMil9IHN5bWJvbC4gSWYgdGhpcyBtZXRob2QgcmV0dXJuc1xuLy8ge0Bjb2RlIHRydWV9LCB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBhbmQgaW5zZXJ0aW5nIGFcbi8vIHRva2VuIHdpdGggdGhlIGNvcnJlY3QgdHlwZSB0byBwcm9kdWNlIHRoaXMgYmVoYXZpb3IuPC9wPlxuLy9cbi8vIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2Vcbi8vIEByZXR1cm4ge0Bjb2RlIHRydWV9IGlmIHNpbmdsZS10b2tlbiBpbnNlcnRpb24gaXMgYSB2aWFibGUgcmVjb3Zlcnlcbi8vIHN0cmF0ZWd5IGZvciB0aGUgY3VycmVudCBtaXNtYXRjaGVkIGlucHV0LCBvdGhlcndpc2Uge0Bjb2RlIGZhbHNlfVxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5zaW5nbGVUb2tlbkluc2VydGlvbiA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICB2YXIgY3VycmVudFN5bWJvbFR5cGUgPSByZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTEEoMSk7XG4gICAgLy8gaWYgY3VycmVudCB0b2tlbiBpcyBjb25zaXN0ZW50IHdpdGggd2hhdCBjb3VsZCBjb21lIGFmdGVyIGN1cnJlbnRcbiAgICAvLyBBVE4gc3RhdGUsIHRoZW4gd2Uga25vdyB3ZSdyZSBtaXNzaW5nIGEgdG9rZW47IGVycm9yIHJlY292ZXJ5XG4gICAgLy8gaXMgZnJlZSB0byBjb25qdXJlIHVwIGFuZCBpbnNlcnQgdGhlIG1pc3NpbmcgdG9rZW5cbiAgICB2YXIgYXRuID0gcmVjb2duaXplci5faW50ZXJwLmF0bjtcbiAgICB2YXIgY3VycmVudFN0YXRlID0gYXRuLnN0YXRlc1tyZWNvZ25pemVyLnN0YXRlXTtcbiAgICB2YXIgbmV4dCA9IGN1cnJlbnRTdGF0ZS50cmFuc2l0aW9uc1swXS50YXJnZXQ7XG4gICAgdmFyIGV4cGVjdGluZ0F0TEwyID0gYXRuLm5leHRUb2tlbnMobmV4dCwgcmVjb2duaXplci5fY3R4KTtcbiAgICBpZiAoZXhwZWN0aW5nQXRMTDIuY29udGFpbnMoY3VycmVudFN5bWJvbFR5cGUpICl7XG4gICAgICAgIHRoaXMucmVwb3J0TWlzc2luZ1Rva2VuKHJlY29nbml6ZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLy8gVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgc2luZ2xlLXRva2VuIGRlbGV0aW9uIGlubGluZSBlcnJvciByZWNvdmVyeVxuLy8gc3RyYXRlZ3kuIEl0IGlzIGNhbGxlZCBieSB7QGxpbmsgLy9yZWNvdmVySW5saW5lfSB0byBhdHRlbXB0IHRvIHJlY292ZXJcbi8vIGZyb20gbWlzbWF0Y2hlZCBpbnB1dC4gSWYgdGhpcyBtZXRob2QgcmV0dXJucyBudWxsLCB0aGUgcGFyc2VyIGFuZCBlcnJvclxuLy8gaGFuZGxlciBzdGF0ZSB3aWxsIG5vdCBoYXZlIGNoYW5nZWQuIElmIHRoaXMgbWV0aG9kIHJldHVybnMgbm9uLW51bGwsXG4vLyB7QGNvZGUgcmVjb2duaXplcn0gd2lsbCA8ZW0+bm90PC9lbT4gYmUgaW4gZXJyb3IgcmVjb3ZlcnkgbW9kZSBzaW5jZSB0aGVcbi8vIHJldHVybmVkIHRva2VuIHdhcyBhIHN1Y2Nlc3NmdWwgbWF0Y2guXG4vL1xuLy8gPHA+SWYgdGhlIHNpbmdsZS10b2tlbiBkZWxldGlvbiBpcyBzdWNjZXNzZnVsLCB0aGlzIG1ldGhvZCBjYWxsc1xuLy8ge0BsaW5rIC8vcmVwb3J0VW53YW50ZWRUb2tlbn0gdG8gcmVwb3J0IHRoZSBlcnJvciwgZm9sbG93ZWQgYnlcbi8vIHtAbGluayBQYXJzZXIvL2NvbnN1bWV9IHRvIGFjdHVhbGx5IFwiZGVsZXRlXCIgdGhlIGV4dHJhbmVvdXMgdG9rZW4uIFRoZW4sXG4vLyBiZWZvcmUgcmV0dXJuaW5nIHtAbGluayAvL3JlcG9ydE1hdGNofSBpcyBjYWxsZWQgdG8gc2lnbmFsIGEgc3VjY2Vzc2Z1bFxuLy8gbWF0Y2guPC9wPlxuLy9cbi8vIEBwYXJhbSByZWNvZ25pemVyIHRoZSBwYXJzZXIgaW5zdGFuY2Vcbi8vIEByZXR1cm4gdGhlIHN1Y2Nlc3NmdWxseSBtYXRjaGVkIHtAbGluayBUb2tlbn0gaW5zdGFuY2UgaWYgc2luZ2xlLXRva2VuXG4vLyBkZWxldGlvbiBzdWNjZXNzZnVsbHkgcmVjb3ZlcnMgZnJvbSB0aGUgbWlzbWF0Y2hlZCBpbnB1dCwgb3RoZXJ3aXNlXG4vLyB7QGNvZGUgbnVsbH1cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuc2luZ2xlVG9rZW5EZWxldGlvbiA9IGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICB2YXIgbmV4dFRva2VuVHlwZSA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MQSgyKTtcbiAgICB2YXIgZXhwZWN0aW5nID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcbiAgICBpZiAoZXhwZWN0aW5nLmNvbnRhaW5zKG5leHRUb2tlblR5cGUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0VW53YW50ZWRUb2tlbihyZWNvZ25pemVyKTtcbiAgICAgICAgLy8gcHJpbnQoXCJyZWNvdmVyRnJvbU1pc21hdGNoZWRUb2tlbiBkZWxldGluZyBcIiBcXFxuICAgICAgICAvLyArIHN0cihyZWNvZ25pemVyLmdldFRva2VuU3RyZWFtKCkuTFQoMSkpIFxcXG4gICAgICAgIC8vICsgXCIgc2luY2UgXCIgKyBzdHIocmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxUKDIpKSBcXFxuICAgICAgICAvLyArIFwiIGlzIHdoYXQgd2Ugd2FudFwiLCBmaWxlPXN5cy5zdGRlcnIpXG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpOyAvLyBzaW1wbHkgZGVsZXRlIGV4dHJhIHRva2VuXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSB0b2tlbiB3ZSdyZSBhY3R1YWxseSBtYXRjaGluZ1xuICAgICAgICB2YXIgbWF0Y2hlZFN5bWJvbCA9IHJlY29nbml6ZXIuZ2V0Q3VycmVudFRva2VuKCk7XG4gICAgICAgIHRoaXMucmVwb3J0TWF0Y2gocmVjb2duaXplcik7IC8vIHdlIGtub3cgY3VycmVudCB0b2tlbiBpcyBjb3JyZWN0XG4gICAgICAgIHJldHVybiBtYXRjaGVkU3ltYm9sO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vIENvbmp1cmUgdXAgYSBtaXNzaW5nIHRva2VuIGR1cmluZyBlcnJvciByZWNvdmVyeS5cbi8vXG4vLyBUaGUgcmVjb2duaXplciBhdHRlbXB0cyB0byByZWNvdmVyIGZyb20gc2luZ2xlIG1pc3Npbmdcbi8vIHN5bWJvbHMuIEJ1dCwgYWN0aW9ucyBtaWdodCByZWZlciB0byB0aGF0IG1pc3Npbmcgc3ltYm9sLlxuLy8gRm9yIGV4YW1wbGUsIHg9SUQge2YoJHgpO30uIFRoZSBhY3Rpb24gY2xlYXJseSBhc3N1bWVzXG4vLyB0aGF0IHRoZXJlIGhhcyBiZWVuIGFuIGlkZW50aWZpZXIgbWF0Y2hlZCBwcmV2aW91c2x5IGFuZCB0aGF0XG4vLyAkeCBwb2ludHMgYXQgdGhhdCB0b2tlbi4gSWYgdGhhdCB0b2tlbiBpcyBtaXNzaW5nLCBidXRcbi8vIHRoZSBuZXh0IHRva2VuIGluIHRoZSBzdHJlYW0gaXMgd2hhdCB3ZSB3YW50IHdlIGFzc3VtZSB0aGF0XG4vLyB0aGlzIHRva2VuIGlzIG1pc3NpbmcgYW5kIHdlIGtlZXAgZ29pbmcuIEJlY2F1c2Ugd2Vcbi8vIGhhdmUgdG8gcmV0dXJuIHNvbWUgdG9rZW4gdG8gcmVwbGFjZSB0aGUgbWlzc2luZyB0b2tlbixcbi8vIHdlIGhhdmUgdG8gY29uanVyZSBvbmUgdXAuIFRoaXMgbWV0aG9kIGdpdmVzIHRoZSB1c2VyIGNvbnRyb2xcbi8vIG92ZXIgdGhlIHRva2VucyByZXR1cm5lZCBmb3IgbWlzc2luZyB0b2tlbnMuIE1vc3RseSxcbi8vIHlvdSB3aWxsIHdhbnQgdG8gY3JlYXRlIHNvbWV0aGluZyBzcGVjaWFsIGZvciBpZGVudGlmaWVyXG4vLyB0b2tlbnMuIEZvciBsaXRlcmFscyBzdWNoIGFzICd7JyBhbmQgJywnLCB0aGUgZGVmYXVsdFxuLy8gYWN0aW9uIGluIHRoZSBwYXJzZXIgb3IgdHJlZSBwYXJzZXIgd29ya3MuIEl0IHNpbXBseSBjcmVhdGVzXG4vLyBhIENvbW1vblRva2VuIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlLiBUaGUgdGV4dCB3aWxsIGJlIHRoZSB0b2tlbi5cbi8vIElmIHlvdSBjaGFuZ2Ugd2hhdCB0b2tlbnMgbXVzdCBiZSBjcmVhdGVkIGJ5IHRoZSBsZXhlcixcbi8vIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgdG9rZW5zLlxuLy9cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5nZXRNaXNzaW5nU3ltYm9sID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHZhciBjdXJyZW50U3ltYm9sID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICB2YXIgZXhwZWN0aW5nID0gdGhpcy5nZXRFeHBlY3RlZFRva2VucyhyZWNvZ25pemVyKTtcbiAgICB2YXIgZXhwZWN0ZWRUb2tlblR5cGUgPSBleHBlY3RpbmcuZmlyc3QoKTsgLy8gZ2V0IGFueSBlbGVtZW50XG4gICAgdmFyIHRva2VuVGV4dDtcbiAgICBpZiAoZXhwZWN0ZWRUb2tlblR5cGU9PT1Ub2tlbi5FT0YpIHtcbiAgICAgICAgdG9rZW5UZXh0ID0gXCI8bWlzc2luZyBFT0Y+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW5UZXh0ID0gXCI8bWlzc2luZyBcIiArIHJlY29nbml6ZXIubGl0ZXJhbE5hbWVzW2V4cGVjdGVkVG9rZW5UeXBlXSArIFwiPlwiO1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRTeW1ib2w7XG4gICAgdmFyIGxvb2tiYWNrID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxUKC0xKTtcbiAgICBpZiAoY3VycmVudC50eXBlPT09VG9rZW4uRU9GICYmIGxvb2tiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnQgPSBsb29rYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIHJlY29nbml6ZXIuZ2V0VG9rZW5GYWN0b3J5KCkuY3JlYXRlKGN1cnJlbnQuc291cmNlLFxuICAgICAgICBleHBlY3RlZFRva2VuVHlwZSwgdG9rZW5UZXh0LCBUb2tlbi5ERUZBVUxUX0NIQU5ORUwsXG4gICAgICAgIC0xLCAtMSwgY3VycmVudC5saW5lLCBjdXJyZW50LmNvbHVtbik7XG59O1xuXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuZ2V0RXhwZWN0ZWRUb2tlbnMgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgcmV0dXJuIHJlY29nbml6ZXIuZ2V0RXhwZWN0ZWRUb2tlbnMoKTtcbn07XG5cbi8vIEhvdyBzaG91bGQgYSB0b2tlbiBiZSBkaXNwbGF5ZWQgaW4gYW4gZXJyb3IgbWVzc2FnZT8gVGhlIGRlZmF1bHRcbi8vIGlzIHRvIGRpc3BsYXkganVzdCB0aGUgdGV4dCwgYnV0IGR1cmluZyBkZXZlbG9wbWVudCB5b3UgbWlnaHRcbi8vIHdhbnQgdG8gaGF2ZSBhIGxvdCBvZiBpbmZvcm1hdGlvbiBzcGl0IG91dC4gT3ZlcnJpZGUgaW4gdGhhdCBjYXNlXG4vLyB0byB1c2UgdC50b1N0cmluZygpICh3aGljaCwgZm9yIENvbW1vblRva2VuLCBkdW1wcyBldmVyeXRoaW5nIGFib3V0XG4vLyB0aGUgdG9rZW4pLiBUaGlzIGlzIGJldHRlciB0aGFuIGZvcmNpbmcgeW91IHRvIG92ZXJyaWRlIGEgbWV0aG9kIGluXG4vLyB5b3VyIHRva2VuIG9iamVjdHMgYmVjYXVzZSB5b3UgZG9uJ3QgaGF2ZSB0byBnbyBtb2RpZnkgeW91ciBsZXhlclxuLy8gc28gdGhhdCBpdCBjcmVhdGVzIGEgbmV3IEphdmEgdHlwZS5cbi8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuZ2V0VG9rZW5FcnJvckRpc3BsYXkgPSBmdW5jdGlvbih0KSB7XG4gICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiPG5vIHRva2VuPlwiO1xuICAgIH1cbiAgICB2YXIgcyA9IHQudGV4dDtcbiAgICBpZiAocyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAodC50eXBlPT09VG9rZW4uRU9GKSB7XG4gICAgICAgICAgICBzID0gXCI8RU9GPlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IFwiPFwiICsgdC50eXBlICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXNjYXBlV1NBbmRRdW90ZShzKTtcbn07XG5cbkRlZmF1bHRFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5lc2NhcGVXU0FuZFF1b3RlID0gZnVuY3Rpb24ocykge1xuICAgIHMgPSBzLnJlcGxhY2UoL1xcbi9nLFwiXFxcXG5cIik7XG4gICAgcyA9IHMucmVwbGFjZSgvXFxyL2csXCJcXFxcclwiKTtcbiAgICBzID0gcy5yZXBsYWNlKC9cXHQvZyxcIlxcXFx0XCIpO1xuICAgIHJldHVybiBcIidcIiArIHMgKyBcIidcIjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGVycm9yIHJlY292ZXJ5IHNldCBmb3IgdGhlIGN1cnJlbnQgcnVsZS4gRHVyaW5nXG4vLyBydWxlIGludm9jYXRpb24sIHRoZSBwYXJzZXIgcHVzaGVzIHRoZSBzZXQgb2YgdG9rZW5zIHRoYXQgY2FuXG4vLyBmb2xsb3cgdGhhdCBydWxlIHJlZmVyZW5jZSBvbiB0aGUgc3RhY2s7IHRoaXMgYW1vdW50cyB0b1xuLy8gY29tcHV0aW5nIEZJUlNUIG9mIHdoYXQgZm9sbG93cyB0aGUgcnVsZSByZWZlcmVuY2UgaW4gdGhlXG4vLyBlbmNsb3NpbmcgcnVsZS4gU2VlIExpbmVhckFwcHJveGltYXRvci5GSVJTVCgpLlxuLy8gVGhpcyBsb2NhbCBmb2xsb3cgc2V0IG9ubHkgaW5jbHVkZXMgdG9rZW5zXG4vLyBmcm9tIHdpdGhpbiB0aGUgcnVsZTsgaS5lLiwgdGhlIEZJUlNUIGNvbXB1dGF0aW9uIGRvbmUgYnlcbi8vIEFOVExSIHN0b3BzIGF0IHRoZSBlbmQgb2YgYSBydWxlLlxuLy9cbi8vIEVYQU1QTEVcbi8vXG4vLyBXaGVuIHlvdSBmaW5kIGEgXCJubyB2aWFibGUgYWx0IGV4Y2VwdGlvblwiLCB0aGUgaW5wdXQgaXMgbm90XG4vLyBjb25zaXN0ZW50IHdpdGggYW55IG9mIHRoZSBhbHRlcm5hdGl2ZXMgZm9yIHJ1bGUgci4gVGhlIGJlc3Rcbi8vIHRoaW5nIHRvIGRvIGlzIHRvIGNvbnN1bWUgdG9rZW5zIHVudGlsIHlvdSBzZWUgc29tZXRoaW5nIHRoYXRcbi8vIGNhbiBsZWdhbGx5IGZvbGxvdyBhIGNhbGwgdG8gci8vb3IqIGFueSBydWxlIHRoYXQgY2FsbGVkIHIuXG4vLyBZb3UgZG9uJ3Qgd2FudCB0aGUgZXhhY3Qgc2V0IG9mIHZpYWJsZSBuZXh0IHRva2VucyBiZWNhdXNlIHRoZVxuLy8gaW5wdXQgbWlnaHQganVzdCBiZSBtaXNzaW5nIGEgdG9rZW4tLXlvdSBtaWdodCBjb25zdW1lIHRoZVxuLy8gcmVzdCBvZiB0aGUgaW5wdXQgbG9va2luZyBmb3Igb25lIG9mIHRoZSBtaXNzaW5nIHRva2Vucy5cbi8vXG4vLyBDb25zaWRlciBncmFtbWFyOlxuLy9cbi8vIGEgOiAnWycgYiAnXSdcbi8vIHwgJygnIGIgJyknXG4vLyA7XG4vLyBiIDogYyAnXicgSU5UIDtcbi8vIGMgOiBJRFxuLy8gfCBJTlRcbi8vIDtcbi8vXG4vLyBBdCBlYWNoIHJ1bGUgaW52b2NhdGlvbiwgdGhlIHNldCBvZiB0b2tlbnMgdGhhdCBjb3VsZCBmb2xsb3dcbi8vIHRoYXQgcnVsZSBpcyBwdXNoZWQgb24gYSBzdGFjay4gSGVyZSBhcmUgdGhlIHZhcmlvdXNcbi8vIGNvbnRleHQtc2Vuc2l0aXZlIGZvbGxvdyBzZXRzOlxuLy9cbi8vIEZPTExPVyhiMV9pbl9hKSA9IEZJUlNUKCddJykgPSAnXSdcbi8vIEZPTExPVyhiMl9pbl9hKSA9IEZJUlNUKCcpJykgPSAnKSdcbi8vIEZPTExPVyhjX2luX2IpID0gRklSU1QoJ14nKSA9ICdeJ1xuLy9cbi8vIFVwb24gZXJyb25lb3VzIGlucHV0IFwiW11cIiwgdGhlIGNhbGwgY2hhaW4gaXNcbi8vXG4vLyBhIC0+IGIgLT4gY1xuLy9cbi8vIGFuZCwgaGVuY2UsIHRoZSBmb2xsb3cgY29udGV4dCBzdGFjayBpczpcbi8vXG4vLyBkZXB0aCBmb2xsb3cgc2V0IHN0YXJ0IG9mIHJ1bGUgZXhlY3V0aW9uXG4vLyAwIDxFT0Y+IGEgKGZyb20gbWFpbigpKVxuLy8gMSAnXScgYlxuLy8gMiAnXicgY1xuLy9cbi8vIE5vdGljZSB0aGF0ICcpJyBpcyBub3QgaW5jbHVkZWQsIGJlY2F1c2UgYiB3b3VsZCBoYXZlIHRvIGhhdmVcbi8vIGJlZW4gY2FsbGVkIGZyb20gYSBkaWZmZXJlbnQgY29udGV4dCBpbiBydWxlIGEgZm9yICcpJyB0byBiZVxuLy8gaW5jbHVkZWQuXG4vL1xuLy8gRm9yIGVycm9yIHJlY292ZXJ5LCB3ZSBjYW5ub3QgY29uc2lkZXIgRk9MTE9XKGMpXG4vLyAoY29udGV4dC1zZW5zaXRpdmUgb3Igb3RoZXJ3aXNlKS4gV2UgbmVlZCB0aGUgY29tYmluZWQgc2V0IG9mXG4vLyBhbGwgY29udGV4dC1zZW5zaXRpdmUgRk9MTE9XIHNldHMtLXRoZSBzZXQgb2YgYWxsIHRva2VucyB0aGF0XG4vLyBjb3VsZCBmb2xsb3cgYW55IHJlZmVyZW5jZSBpbiB0aGUgY2FsbCBjaGFpbi4gV2UgbmVlZCB0b1xuLy8gcmVzeW5jIHRvIG9uZSBvZiB0aG9zZSB0b2tlbnMuIE5vdGUgdGhhdCBGT0xMT1coYyk9J14nIGFuZCBpZlxuLy8gd2UgcmVzeW5jJ2QgdG8gdGhhdCB0b2tlbiwgd2UnZCBjb25zdW1lIHVudGlsIEVPRi4gV2UgbmVlZCB0b1xuLy8gc3luYyB0byBjb250ZXh0LXNlbnNpdGl2ZSBGT0xMT1dzIGZvciBhLCBiLCBhbmQgYzogeyddJywnXid9LlxuLy8gSW4gdGhpcyBjYXNlLCBmb3IgaW5wdXQgXCJbXVwiLCBMQSgxKSBpcyAnXScgYW5kIGluIHRoZSBzZXQsIHNvIHdlIHdvdWxkXG4vLyBub3QgY29uc3VtZSBhbnl0aGluZy4gQWZ0ZXIgcHJpbnRpbmcgYW4gZXJyb3IsIHJ1bGUgYyB3b3VsZFxuLy8gcmV0dXJuIG5vcm1hbGx5LiBSdWxlIGIgd291bGQgbm90IGZpbmQgdGhlIHJlcXVpcmVkICdeJyB0aG91Z2guXG4vLyBBdCB0aGlzIHBvaW50LCBpdCBnZXRzIGEgbWlzbWF0Y2hlZCB0b2tlbiBlcnJvciBhbmQgdGhyb3dzIGFuXG4vLyBleGNlcHRpb24gKHNpbmNlIExBKDEpIGlzIG5vdCBpbiB0aGUgdmlhYmxlIGZvbGxvd2luZyB0b2tlblxuLy8gc2V0KS4gVGhlIHJ1bGUgZXhjZXB0aW9uIGhhbmRsZXIgdHJpZXMgdG8gcmVjb3ZlciwgYnV0IGZpbmRzXG4vLyB0aGUgc2FtZSByZWNvdmVyeSBzZXQgYW5kIGRvZXNuJ3QgY29uc3VtZSBhbnl0aGluZy4gUnVsZSBiXG4vLyBleGl0cyBub3JtYWxseSByZXR1cm5pbmcgdG8gcnVsZSBhLiBOb3cgaXQgZmluZHMgdGhlICddJyAoYW5kXG4vLyB3aXRoIHRoZSBzdWNjZXNzZnVsIG1hdGNoIGV4aXRzIGVycm9yUmVjb3ZlcnkgbW9kZSkuXG4vL1xuLy8gU28sIHlvdSBjYW4gc2VlIHRoYXQgdGhlIHBhcnNlciB3YWxrcyB1cCB0aGUgY2FsbCBjaGFpbiBsb29raW5nXG4vLyBmb3IgdGhlIHRva2VuIHRoYXQgd2FzIGEgbWVtYmVyIG9mIHRoZSByZWNvdmVyeSBzZXQuXG4vL1xuLy8gRXJyb3JzIGFyZSBub3QgZ2VuZXJhdGVkIGluIGVycm9yUmVjb3ZlcnkgbW9kZS5cbi8vXG4vLyBBTlRMUidzIGVycm9yIHJlY292ZXJ5IG1lY2hhbmlzbSBpcyBiYXNlZCB1cG9uIG9yaWdpbmFsIGlkZWFzOlxuLy9cbi8vIFwiQWxnb3JpdGhtcyArIERhdGEgU3RydWN0dXJlcyA9IFByb2dyYW1zXCIgYnkgTmlrbGF1cyBXaXJ0aFxuLy9cbi8vIGFuZFxuLy9cbi8vIFwiQSBub3RlIG9uIGVycm9yIHJlY292ZXJ5IGluIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlcnNcIjpcbi8vIGh0dHA6Ly9wb3J0YWwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9OTQ3OTAyLjk0NzkwNVxuLy9cbi8vIExhdGVyLCBKb3NlZiBHcm9zY2ggaGFkIHNvbWUgZ29vZCBpZGVhczpcbi8vXG4vLyBcIkVmZmljaWVudCBhbmQgQ29tZm9ydGFibGUgRXJyb3IgUmVjb3ZlcnkgaW4gUmVjdXJzaXZlIERlc2NlbnRcbi8vIFBhcnNlcnNcIjpcbi8vIGZ0cDovL3d3dy5jb2NvbGFiLmNvbS9wcm9kdWN0cy9jb2NrdGFpbC9kb2NhNC5wcy9lbGwucHMuemlwXG4vL1xuLy8gTGlrZSBHcm9zY2ggSSBpbXBsZW1lbnQgY29udGV4dC1zZW5zaXRpdmUgRk9MTE9XIHNldHMgdGhhdCBhcmUgY29tYmluZWRcbi8vIGF0IHJ1bi10aW1lIHVwb24gZXJyb3IgdG8gYXZvaWQgb3ZlcmhlYWQgZHVyaW5nIHBhcnNpbmcuXG4vL1xuRGVmYXVsdEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmdldEVycm9yUmVjb3ZlcnlTZXQgPSBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgdmFyIGF0biA9IHJlY29nbml6ZXIuX2ludGVycC5hdG47XG4gICAgdmFyIGN0eCA9IHJlY29nbml6ZXIuX2N0eDtcbiAgICB2YXIgcmVjb3ZlclNldCA9IG5ldyBJbnRlcnZhbFNldCgpO1xuICAgIHdoaWxlIChjdHggIT09IG51bGwgJiYgY3R4Lmludm9raW5nU3RhdGU+PTApIHtcbiAgICAgICAgLy8gY29tcHV0ZSB3aGF0IGZvbGxvd3Mgd2hvIGludm9rZWQgdXNcbiAgICAgICAgdmFyIGludm9raW5nU3RhdGUgPSBhdG4uc3RhdGVzW2N0eC5pbnZva2luZ1N0YXRlXTtcbiAgICAgICAgdmFyIHJ0ID0gaW52b2tpbmdTdGF0ZS50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgdmFyIGZvbGxvdyA9IGF0bi5uZXh0VG9rZW5zKHJ0LmZvbGxvd1N0YXRlKTtcbiAgICAgICAgcmVjb3ZlclNldC5hZGRTZXQoZm9sbG93KTtcbiAgICAgICAgY3R4ID0gY3R4LnBhcmVudEN0eDtcbiAgICB9XG4gICAgcmVjb3ZlclNldC5yZW1vdmVPbmUoVG9rZW4uRVBTSUxPTik7XG4gICAgcmV0dXJuIHJlY292ZXJTZXQ7XG59O1xuXG4vLyBDb25zdW1lIHRva2VucyB1bnRpbCBvbmUgbWF0Y2hlcyB0aGUgZ2l2ZW4gdG9rZW4gc2V0Li8vXG5EZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUuY29uc3VtZVVudGlsID0gZnVuY3Rpb24ocmVjb2duaXplciwgc2V0KSB7XG4gICAgdmFyIHR0eXBlID0gcmVjb2duaXplci5nZXRUb2tlblN0cmVhbSgpLkxBKDEpO1xuICAgIHdoaWxlKCB0dHlwZSAhPT0gVG9rZW4uRU9GICYmICFzZXQuY29udGFpbnModHR5cGUpKSB7XG4gICAgICAgIHJlY29nbml6ZXIuY29uc3VtZSgpO1xuICAgICAgICB0dHlwZSA9IHJlY29nbml6ZXIuZ2V0VG9rZW5TdHJlYW0oKS5MQSgxKTtcbiAgICB9XG59O1xuXG4vL1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQU5UTFJFcnJvclN0cmF0ZWd5fSByZXNwb25kcyB0byBzeW50YXggZXJyb3JzXG4vLyBieSBpbW1lZGlhdGVseSBjYW5jZWxpbmcgdGhlIHBhcnNlIG9wZXJhdGlvbiB3aXRoIGFcbi8vIHtAbGluayBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbn0uIFRoZSBpbXBsZW1lbnRhdGlvbiBlbnN1cmVzIHRoYXQgdGhlXG4vLyB7QGxpbmsgUGFyc2VyUnVsZUNvbnRleHQvL2V4Y2VwdGlvbn0gZmllbGQgaXMgc2V0IGZvciBhbGwgcGFyc2UgdHJlZSBub2Rlc1xuLy8gdGhhdCB3ZXJlIG5vdCBjb21wbGV0ZWQgcHJpb3IgdG8gZW5jb3VudGVyaW5nIHRoZSBlcnJvci5cbi8vXG4vLyA8cD5cbi8vIFRoaXMgZXJyb3Igc3RyYXRlZ3kgaXMgdXNlZnVsIGluIHRoZSBmb2xsb3dpbmcgc2NlbmFyaW9zLjwvcD5cbi8vXG4vLyA8dWw+XG4vLyA8bGk+PHN0cm9uZz5Ud28tc3RhZ2UgcGFyc2luZzo8L3N0cm9uZz4gVGhpcyBlcnJvciBzdHJhdGVneSBhbGxvd3MgdGhlIGZpcnN0XG4vLyBzdGFnZSBvZiB0d28tc3RhZ2UgcGFyc2luZyB0byBpbW1lZGlhdGVseSB0ZXJtaW5hdGUgaWYgYW4gZXJyb3IgaXNcbi8vIGVuY291bnRlcmVkLCBhbmQgaW1tZWRpYXRlbHkgZmFsbCBiYWNrIHRvIHRoZSBzZWNvbmQgc3RhZ2UuIEluIGFkZGl0aW9uIHRvXG4vLyBhdm9pZGluZyB3YXN0ZWQgd29yayBieSBhdHRlbXB0aW5nIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMgaGVyZSwgdGhlIGVtcHR5XG4vLyBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgQmFpbEVycm9yU3RyYXRlZ3kvL3N5bmN9IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSBvZlxuLy8gdGhlIGZpcnN0IHN0YWdlLjwvbGk+XG4vLyA8bGk+PHN0cm9uZz5TaWxlbnQgdmFsaWRhdGlvbjo8L3N0cm9uZz4gV2hlbiBzeW50YXggZXJyb3JzIGFyZSBub3QgYmVpbmdcbi8vIHJlcG9ydGVkIG9yIGxvZ2dlZCwgYW5kIHRoZSBwYXJzZSByZXN1bHQgaXMgc2ltcGx5IGlnbm9yZWQgaWYgZXJyb3JzIG9jY3VyLFxuLy8gdGhlIHtAbGluayBCYWlsRXJyb3JTdHJhdGVneX0gYXZvaWRzIHdhc3Rpbmcgd29yayBvbiByZWNvdmVyaW5nIGZyb20gZXJyb3JzXG4vLyB3aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBpZ25vcmVkIGVpdGhlciB3YXkuPC9saT5cbi8vIDwvdWw+XG4vL1xuLy8gPHA+XG4vLyB7QGNvZGUgbXlwYXJzZXIuc2V0RXJyb3JIYW5kbGVyKG5ldyBCYWlsRXJyb3JTdHJhdGVneSgpKTt9PC9wPlxuLy9cbi8vIEBzZWUgUGFyc2VyLy9zZXRFcnJvckhhbmRsZXIoQU5UTFJFcnJvclN0cmF0ZWd5KVxuLy9cbmZ1bmN0aW9uIEJhaWxFcnJvclN0cmF0ZWd5KCkge1xuXHREZWZhdWx0RXJyb3JTdHJhdGVneS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuQmFpbEVycm9yU3RyYXRlZ3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZWZhdWx0RXJyb3JTdHJhdGVneS5wcm90b3R5cGUpO1xuQmFpbEVycm9yU3RyYXRlZ3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmFpbEVycm9yU3RyYXRlZ3k7XG5cbi8vIEluc3RlYWQgb2YgcmVjb3ZlcmluZyBmcm9tIGV4Y2VwdGlvbiB7QGNvZGUgZX0sIHJlLXRocm93IGl0IHdyYXBwZWRcbi8vIGluIGEge0BsaW5rIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9ufSBzbyBpdCBpcyBub3QgY2F1Z2h0IGJ5IHRoZVxuLy8gcnVsZSBmdW5jdGlvbiBjYXRjaGVzLiBVc2Uge0BsaW5rIEV4Y2VwdGlvbi8vZ2V0Q2F1c2UoKX0gdG8gZ2V0IHRoZVxuLy8gb3JpZ2luYWwge0BsaW5rIFJlY29nbml0aW9uRXhjZXB0aW9ufS5cbi8vXG5CYWlsRXJyb3JTdHJhdGVneS5wcm90b3R5cGUucmVjb3ZlciA9IGZ1bmN0aW9uKHJlY29nbml6ZXIsIGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlY29nbml6ZXIuX2N0eDtcbiAgICB3aGlsZSAoY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0LmV4Y2VwdGlvbiA9IGU7XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudEN0eDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uKGUpO1xufTtcblxuLy8gTWFrZSBzdXJlIHdlIGRvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBpbmxpbmU7IGlmIHRoZSBwYXJzZXJcbi8vIHN1Y2Nlc3NmdWxseSByZWNvdmVycywgaXQgd29uJ3QgdGhyb3cgYW4gZXhjZXB0aW9uLlxuLy9cbkJhaWxFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5yZWNvdmVySW5saW5lID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIHRoaXMucmVjb3ZlcihyZWNvZ25pemVyLCBuZXcgSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbihyZWNvZ25pemVyKSk7XG59O1xuXG4vLyBNYWtlIHN1cmUgd2UgZG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gcHJvYmxlbXMgaW4gc3VicnVsZXMuLy9cbkJhaWxFcnJvclN0cmF0ZWd5LnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24ocmVjb2duaXplcikge1xuICAgIC8vIHBhc3Ncbn07XG5cbmV4cG9ydHMuQmFpbEVycm9yU3RyYXRlZ3kgPSBCYWlsRXJyb3JTdHJhdGVneTtcbmV4cG9ydHMuRGVmYXVsdEVycm9yU3RyYXRlZ3kgPSBEZWZhdWx0RXJyb3JTdHJhdGVneTtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuLy8gVGhlIHJvb3Qgb2YgdGhlIEFOVExSIGV4Y2VwdGlvbiBoaWVyYXJjaHkuIEluIGdlbmVyYWwsIEFOVExSIHRyYWNrcyBqdXN0XG4vLyAgMyBraW5kcyBvZiBlcnJvcnM6IHByZWRpY3Rpb24gZXJyb3JzLCBmYWlsZWQgcHJlZGljYXRlIGVycm9ycywgYW5kXG4vLyAgbWlzbWF0Y2hlZCBpbnB1dCBlcnJvcnMuIEluIGVhY2ggY2FzZSwgdGhlIHBhcnNlciBrbm93cyB3aGVyZSBpdCBpc1xuLy8gIGluIHRoZSBpbnB1dCwgd2hlcmUgaXQgaXMgaW4gdGhlIEFUTiwgdGhlIHJ1bGUgaW52b2NhdGlvbiBzdGFjayxcbi8vICBhbmQgd2hhdCBraW5kIG9mIHByb2JsZW0gb2NjdXJyZWQuXG5cbnZhciBQcmVkaWNhdGVUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi8uLi9hdG4vVHJhbnNpdGlvbicpLlByZWRpY2F0ZVRyYW5zaXRpb247XG5cbmZ1bmN0aW9uIFJlY29nbml0aW9uRXhjZXB0aW9uKHBhcmFtcykge1xuXHRFcnJvci5jYWxsKHRoaXMpO1xuXHRpZiAoISFFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZWNvZ25pdGlvbkV4Y2VwdGlvbik7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG5cdH1cblx0dGhpcy5tZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2U7XG4gICAgdGhpcy5yZWNvZ25pemVyID0gcGFyYW1zLnJlY29nbml6ZXI7XG4gICAgdGhpcy5pbnB1dCA9IHBhcmFtcy5pbnB1dDtcbiAgICB0aGlzLmN0eCA9IHBhcmFtcy5jdHg7XG4gICAgLy8gVGhlIGN1cnJlbnQge0BsaW5rIFRva2VufSB3aGVuIGFuIGVycm9yIG9jY3VycmVkLiBTaW5jZSBub3QgYWxsIHN0cmVhbXNcbiAgICAvLyBzdXBwb3J0IGFjY2Vzc2luZyBzeW1ib2xzIGJ5IGluZGV4LCB3ZSBoYXZlIHRvIHRyYWNrIHRoZSB7QGxpbmsgVG9rZW59XG4gICAgLy8gaW5zdGFuY2UgaXRzZWxmLlxuICAgIHRoaXMub2ZmZW5kaW5nVG9rZW4gPSBudWxsO1xuICAgIC8vIEdldCB0aGUgQVROIHN0YXRlIG51bWJlciB0aGUgcGFyc2VyIHdhcyBpbiBhdCB0aGUgdGltZSB0aGUgZXJyb3JcbiAgICAvLyBvY2N1cnJlZC4gRm9yIHtAbGluayBOb1ZpYWJsZUFsdEV4Y2VwdGlvbn0gYW5kXG4gICAgLy8ge0BsaW5rIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb259IGV4Y2VwdGlvbnMsIHRoaXMgaXMgdGhlXG4gICAgLy8ge0BsaW5rIERlY2lzaW9uU3RhdGV9IG51bWJlci4gRm9yIG90aGVycywgaXQgaXMgdGhlIHN0YXRlIHdob3NlIG91dGdvaW5nXG4gICAgLy8gZWRnZSB3ZSBjb3VsZG4ndCBtYXRjaC5cbiAgICB0aGlzLm9mZmVuZGluZ1N0YXRlID0gLTE7XG4gICAgaWYgKHRoaXMucmVjb2duaXplciE9PW51bGwpIHtcbiAgICAgICAgdGhpcy5vZmZlbmRpbmdTdGF0ZSA9IHRoaXMucmVjb2duaXplci5zdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cblJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblJlY29nbml0aW9uRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlY29nbml0aW9uRXhjZXB0aW9uO1xuXG4vLyA8cD5JZiB0aGUgc3RhdGUgbnVtYmVyIGlzIG5vdCBrbm93biwgdGhpcyBtZXRob2QgcmV0dXJucyAtMS48L3A+XG5cbi8vXG4vLyBHZXRzIHRoZSBzZXQgb2YgaW5wdXQgc3ltYm9scyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBmb2xsb3cgdGhlXG4vLyBwcmV2aW91c2x5IG1hdGNoZWQgc3ltYm9sIGF0IHRoZSB0aW1lIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4vL1xuLy8gPHA+SWYgdGhlIHNldCBvZiBleHBlY3RlZCB0b2tlbnMgaXMgbm90IGtub3duIGFuZCBjb3VsZCBub3QgYmUgY29tcHV0ZWQsXG4vLyB0aGlzIG1ldGhvZCByZXR1cm5zIHtAY29kZSBudWxsfS48L3A+XG4vL1xuLy8gQHJldHVybiBUaGUgc2V0IG9mIHRva2VuIHR5cGVzIHRoYXQgY291bGQgcG90ZW50aWFsbHkgZm9sbG93IHRoZSBjdXJyZW50XG4vLyBzdGF0ZSBpbiB0aGUgQVROLCBvciB7QGNvZGUgbnVsbH0gaWYgdGhlIGluZm9ybWF0aW9uIGlzIG5vdCBhdmFpbGFibGUuXG4vLyAvXG5SZWNvZ25pdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0RXhwZWN0ZWRUb2tlbnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZWNvZ25pemVyIT09bnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNvZ25pemVyLmF0bi5nZXRFeHBlY3RlZFRva2Vucyh0aGlzLm9mZmVuZGluZ1N0YXRlLCB0aGlzLmN0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbn07XG5cbmZ1bmN0aW9uIExleGVyTm9WaWFibGVBbHRFeGNlcHRpb24obGV4ZXIsIGlucHV0LCBzdGFydEluZGV4LCBkZWFkRW5kQ29uZmlncykge1xuXHRSZWNvZ25pdGlvbkV4Y2VwdGlvbi5jYWxsKHRoaXMsIHttZXNzYWdlOlwiXCIsIHJlY29nbml6ZXI6bGV4ZXIsIGlucHV0OmlucHV0LCBjdHg6bnVsbH0pO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgdGhpcy5kZWFkRW5kQ29uZmlncyA9IGRlYWRFbmRDb25maWdzO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlKTtcbkxleGVyTm9WaWFibGVBbHRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcblxuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3ltYm9sID0gXCJcIjtcbiAgICBpZiAodGhpcy5zdGFydEluZGV4ID49IDAgJiYgdGhpcy5zdGFydEluZGV4IDwgdGhpcy5pbnB1dC5zaXplKSB7XG4gICAgICAgIHN5bWJvbCA9IHRoaXMuaW5wdXQuZ2V0VGV4dCgodGhpcy5zdGFydEluZGV4LHRoaXMuc3RhcnRJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gXCJMZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uXCIgKyBzeW1ib2w7XG59O1xuXG4vLyBJbmRpY2F0ZXMgdGhhdCB0aGUgcGFyc2VyIGNvdWxkIG5vdCBkZWNpZGUgd2hpY2ggb2YgdHdvIG9yIG1vcmUgcGF0aHNcbi8vIHRvIHRha2UgYmFzZWQgdXBvbiB0aGUgcmVtYWluaW5nIGlucHV0LiBJdCB0cmFja3MgdGhlIHN0YXJ0aW5nIHRva2VuXG4vLyBvZiB0aGUgb2ZmZW5kaW5nIGlucHV0IGFuZCBhbHNvIGtub3dzIHdoZXJlIHRoZSBwYXJzZXIgd2FzXG4vLyBpbiB0aGUgdmFyaW91cyBwYXRocyB3aGVuIHRoZSBlcnJvci4gUmVwb3J0ZWQgYnkgcmVwb3J0Tm9WaWFibGVBbHRlcm5hdGl2ZSgpXG4vL1xuZnVuY3Rpb24gTm9WaWFibGVBbHRFeGNlcHRpb24ocmVjb2duaXplciwgaW5wdXQsIHN0YXJ0VG9rZW4sIG9mZmVuZGluZ1Rva2VuLCBkZWFkRW5kQ29uZmlncywgY3R4KSB7XG5cdGN0eCA9IGN0eCB8fCByZWNvZ25pemVyLl9jdHg7XG5cdG9mZmVuZGluZ1Rva2VuID0gb2ZmZW5kaW5nVG9rZW4gfHwgcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcblx0c3RhcnRUb2tlbiA9IHN0YXJ0VG9rZW4gfHwgcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcblx0aW5wdXQgPSBpbnB1dCB8fCByZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCk7XG5cdFJlY29nbml0aW9uRXhjZXB0aW9uLmNhbGwodGhpcywge21lc3NhZ2U6XCJcIiwgcmVjb2duaXplcjpyZWNvZ25pemVyLCBpbnB1dDppbnB1dCwgY3R4OmN0eH0pO1xuICAgIC8vIFdoaWNoIGNvbmZpZ3VyYXRpb25zIGRpZCB3ZSB0cnkgYXQgaW5wdXQuaW5kZXgoKSB0aGF0IGNvdWxkbid0IG1hdGNoXG5cdC8vIGlucHV0LkxUKDEpPy8vXG4gICAgdGhpcy5kZWFkRW5kQ29uZmlncyA9IGRlYWRFbmRDb25maWdzO1xuICAgIC8vIFRoZSB0b2tlbiBvYmplY3QgYXQgdGhlIHN0YXJ0IGluZGV4OyB0aGUgaW5wdXQgc3RyZWFtIG1pZ2h0XG4gICAgLy8gbm90IGJlIGJ1ZmZlcmluZyB0b2tlbnMgc28gZ2V0IGEgcmVmZXJlbmNlIHRvIGl0LiAoQXQgdGhlXG4gICAgLy8gdGltZSB0aGUgZXJyb3Igb2NjdXJyZWQsIG9mIGNvdXJzZSB0aGUgc3RyZWFtIG5lZWRzIHRvIGtlZXAgYVxuICAgIC8vIGJ1ZmZlciBhbGwgb2YgdGhlIHRva2VucyBidXQgbGF0ZXIgd2UgbWlnaHQgbm90IGhhdmUgYWNjZXNzIHRvIHRob3NlLilcbiAgICB0aGlzLnN0YXJ0VG9rZW4gPSBzdGFydFRva2VuO1xuICAgIHRoaXMub2ZmZW5kaW5nVG9rZW4gPSBvZmZlbmRpbmdUb2tlbjtcbn1cblxuTm9WaWFibGVBbHRFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvZ25pdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUpO1xuTm9WaWFibGVBbHRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9WaWFibGVBbHRFeGNlcHRpb247XG5cbi8vIFRoaXMgc2lnbmlmaWVzIGFueSBraW5kIG9mIG1pc21hdGNoZWQgaW5wdXQgZXhjZXB0aW9ucyBzdWNoIGFzXG4vLyB3aGVuIHRoZSBjdXJyZW50IGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCB0b2tlbi5cbi8vXG5mdW5jdGlvbiBJbnB1dE1pc21hdGNoRXhjZXB0aW9uKHJlY29nbml6ZXIpIHtcblx0UmVjb2duaXRpb25FeGNlcHRpb24uY2FsbCh0aGlzLCB7bWVzc2FnZTpcIlwiLCByZWNvZ25pemVyOnJlY29nbml6ZXIsIGlucHV0OnJlY29nbml6ZXIuZ2V0SW5wdXRTdHJlYW0oKSwgY3R4OnJlY29nbml6ZXIuX2N0eH0pO1xuICAgIHRoaXMub2ZmZW5kaW5nVG9rZW4gPSByZWNvZ25pemVyLmdldEN1cnJlbnRUb2tlbigpO1xufVxuXG5JbnB1dE1pc21hdGNoRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlKTtcbklucHV0TWlzbWF0Y2hFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbjtcblxuLy8gQSBzZW1hbnRpYyBwcmVkaWNhdGUgZmFpbGVkIGR1cmluZyB2YWxpZGF0aW9uLiBWYWxpZGF0aW9uIG9mIHByZWRpY2F0ZXNcbi8vIG9jY3VycyB3aGVuIG5vcm1hbGx5IHBhcnNpbmcgdGhlIGFsdGVybmF0aXZlIGp1c3QgbGlrZSBtYXRjaGluZyBhIHRva2VuLlxuLy8gRGlzYW1iaWd1YXRpbmcgcHJlZGljYXRlIGV2YWx1YXRpb24gb2NjdXJzIHdoZW4gd2UgdGVzdCBhIHByZWRpY2F0ZSBkdXJpbmdcbi8vIHByZWRpY3Rpb24uXG5cbmZ1bmN0aW9uIEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbihyZWNvZ25pemVyLCBwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcblx0UmVjb2duaXRpb25FeGNlcHRpb24uY2FsbCh0aGlzLCB7bWVzc2FnZTp0aGlzLmZvcm1hdE1lc3NhZ2UocHJlZGljYXRlLG1lc3NhZ2UgfHwgbnVsbCksIHJlY29nbml6ZXI6cmVjb2duaXplcixcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDpyZWNvZ25pemVyLmdldElucHV0U3RyZWFtKCksIGN0eDpyZWNvZ25pemVyLl9jdHh9KTtcbiAgICB2YXIgcyA9IHJlY29nbml6ZXIuX2ludGVycC5hdG4uc3RhdGVzW3JlY29nbml6ZXIuc3RhdGVdO1xuICAgIHZhciB0cmFucyA9IHMudHJhbnNpdGlvbnNbMF07XG4gICAgaWYgKHRyYW5zIGluc3RhbmNlb2YgUHJlZGljYXRlVHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IHRyYW5zLnJ1bGVJbmRleDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVJbmRleCA9IHRyYW5zLnByZWRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bGVJbmRleCA9IDA7XG4gICAgICAgIHRoaXMucHJlZGljYXRlSW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLm9mZmVuZGluZ1Rva2VuID0gcmVjb2duaXplci5nZXRDdXJyZW50VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVjb2duaXRpb25FeGNlcHRpb24ucHJvdG90eXBlKTtcbkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGYWlsZWRQcmVkaWNhdGVFeGNlcHRpb247XG5cbkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbi5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlICE9PW51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiZmFpbGVkIHByZWRpY2F0ZToge1wiICsgcHJlZGljYXRlICsgXCJ9P1wiO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIFBhcnNlQ2FuY2VsbGF0aW9uRXhjZXB0aW9uKCkge1xuXHRFcnJvci5jYWxsKHRoaXMpO1xuXHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbik7XG5cdHJldHVybiB0aGlzO1xufVxuXG5QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5QYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbjtcblxuZXhwb3J0cy5SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IFJlY29nbml0aW9uRXhjZXB0aW9uO1xuZXhwb3J0cy5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IE5vVmlhYmxlQWx0RXhjZXB0aW9uO1xuZXhwb3J0cy5MZXhlck5vVmlhYmxlQWx0RXhjZXB0aW9uID0gTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IElucHV0TWlzbWF0Y2hFeGNlcHRpb247XG5leHBvcnRzLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbiA9IEZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbjtcbmV4cG9ydHMuUGFyc2VDYW5jZWxsYXRpb25FeGNlcHRpb24gPSBQYXJzZUNhbmNlbGxhdGlvbkV4Y2VwdGlvbjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cblxuZXhwb3J0cy5SZWNvZ25pdGlvbkV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuUmVjb2duaXRpb25FeGNlcHRpb247XG5leHBvcnRzLk5vVmlhYmxlQWx0RXhjZXB0aW9uID0gcmVxdWlyZSgnLi9FcnJvcnMnKS5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuTGV4ZXJOb1ZpYWJsZUFsdEV4Y2VwdGlvbjtcbmV4cG9ydHMuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbiA9IHJlcXVpcmUoJy4vRXJyb3JzJykuSW5wdXRNaXNtYXRjaEV4Y2VwdGlvbjtcbmV4cG9ydHMuRmFpbGVkUHJlZGljYXRlRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9FcnJvcnMnKS5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb247XG5leHBvcnRzLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyID0gcmVxdWlyZSgnLi9EaWFnbm9zdGljRXJyb3JMaXN0ZW5lcicpLkRpYWdub3N0aWNFcnJvckxpc3RlbmVyO1xuZXhwb3J0cy5CYWlsRXJyb3JTdHJhdGVneSA9IHJlcXVpcmUoJy4vRXJyb3JTdHJhdGVneScpLkJhaWxFcnJvclN0cmF0ZWd5O1xuZXhwb3J0cy5FcnJvckxpc3RlbmVyID0gcmVxdWlyZSgnLi9FcnJvckxpc3RlbmVyJykuRXJyb3JMaXN0ZW5lcjtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxMi0yMDE3IFRoZSBBTlRMUiBQcm9qZWN0LiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVXNlIG9mIHRoaXMgZmlsZSBpcyBnb3Zlcm5lZCBieSB0aGUgQlNEIDMtY2xhdXNlIGxpY2Vuc2UgdGhhdFxuICogY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFLnR4dCBmaWxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKi9cbmV4cG9ydHMuYXRuID0gcmVxdWlyZSgnLi9hdG4vaW5kZXgnKTtcbmV4cG9ydHMuY29kZXBvaW50YXQgPSByZXF1aXJlKCcuL3BvbHlmaWxscy9jb2RlcG9pbnRhdCcpO1xuZXhwb3J0cy5kZmEgPSByZXF1aXJlKCcuL2RmYS9pbmRleCcpO1xuZXhwb3J0cy5mcm9tY29kZXBvaW50ID0gcmVxdWlyZSgnLi9wb2x5ZmlsbHMvZnJvbWNvZGVwb2ludCcpO1xuZXhwb3J0cy50cmVlID0gcmVxdWlyZSgnLi90cmVlL2luZGV4Jyk7XG5leHBvcnRzLmVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuZXhwb3J0cy5Ub2tlbiA9IHJlcXVpcmUoJy4vVG9rZW4nKS5Ub2tlbjtcbmV4cG9ydHMuQ2hhclN0cmVhbXMgPSByZXF1aXJlKCcuL0NoYXJTdHJlYW1zJykuQ2hhclN0cmVhbXM7XG5leHBvcnRzLkNvbW1vblRva2VuID0gcmVxdWlyZSgnLi9Ub2tlbicpLkNvbW1vblRva2VuO1xuZXhwb3J0cy5JbnB1dFN0cmVhbSA9IHJlcXVpcmUoJy4vSW5wdXRTdHJlYW0nKS5JbnB1dFN0cmVhbTtcbmV4cG9ydHMuRmlsZVN0cmVhbSA9IHJlcXVpcmUoJy4vRmlsZVN0cmVhbScpLkZpbGVTdHJlYW07XG5leHBvcnRzLkNvbW1vblRva2VuU3RyZWFtID0gcmVxdWlyZSgnLi9Db21tb25Ub2tlblN0cmVhbScpLkNvbW1vblRva2VuU3RyZWFtO1xuZXhwb3J0cy5MZXhlciA9IHJlcXVpcmUoJy4vTGV4ZXInKS5MZXhlcjtcbmV4cG9ydHMuUGFyc2VyID0gcmVxdWlyZSgnLi9QYXJzZXInKS5QYXJzZXI7XG52YXIgcGMgPSByZXF1aXJlKCcuL1ByZWRpY3Rpb25Db250ZXh0Jyk7XG5leHBvcnRzLlByZWRpY3Rpb25Db250ZXh0Q2FjaGUgPSBwYy5QcmVkaWN0aW9uQ29udGV4dENhY2hlO1xuZXhwb3J0cy5QYXJzZXJSdWxlQ29udGV4dCA9IHJlcXVpcmUoJy4vUGFyc2VyUnVsZUNvbnRleHQnKS5QYXJzZXJSdWxlQ29udGV4dDtcbmV4cG9ydHMuSW50ZXJ2YWwgPSByZXF1aXJlKCcuL0ludGVydmFsU2V0JykuSW50ZXJ2YWw7XG5leHBvcnRzLlV0aWxzID0gcmVxdWlyZSgnLi9VdGlscycpO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9jb2RlcG9pbnRhdCB2MC4yLjAgYnkgQG1hdGhpYXMgKi9cbmlmICghU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCkge1xuXHQoZnVuY3Rpb24oKSB7XG5cdFx0J3VzZSBzdHJpY3QnOyAvLyBuZWVkZWQgdG8gc3VwcG9ydCBgYXBwbHlgL2BjYWxsYCB3aXRoIGB1bmRlZmluZWRgL2BudWxsYFxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0XHRcdC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdFx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9KCkpO1xuXHRcdHZhciBjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0XHRpZiAodGhpcyA9PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcblx0XHRcdHZhciBzaXplID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdC8vIGBUb0ludGVnZXJgXG5cdFx0XHR2YXIgaW5kZXggPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xuXHRcdFx0aWYgKGluZGV4ICE9IGluZGV4KSB7IC8vIGJldHRlciBgaXNOYU5gXG5cdFx0XHRcdGluZGV4ID0gMDtcblx0XHRcdH1cblx0XHRcdC8vIEFjY291bnQgZm9yIG91dC1vZi1ib3VuZHMgaW5kaWNlczpcblx0XHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Ly8gR2V0IHRoZSBmaXJzdCBjb2RlIHVuaXRcblx0XHRcdHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcblx0XHRcdHZhciBzZWNvbmQ7XG5cdFx0XHRpZiAoIC8vIGNoZWNrIGlmIGl04oCZcyB0aGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRmaXJzdCA+PSAweEQ4MDAgJiYgZmlyc3QgPD0gMHhEQkZGICYmIC8vIGhpZ2ggc3Vycm9nYXRlXG5cdFx0XHRcdHNpemUgPiBpbmRleCArIDEgLy8gdGhlcmUgaXMgYSBuZXh0IGNvZGUgdW5pdFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cdFx0XHRcdGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRcdHJldHVybiAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlyc3Q7XG5cdFx0fTtcblx0XHRpZiAoZGVmaW5lUHJvcGVydHkpIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdjb2RlUG9pbnRBdCcsIHtcblx0XHRcdFx0J3ZhbHVlJzogY29kZVBvaW50QXQsXG5cdFx0XHRcdCdjb25maWd1cmFibGUnOiB0cnVlLFxuXHRcdFx0XHQnd3JpdGFibGUnOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0U3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCA9IGNvZGVQb2ludEF0O1xuXHRcdH1cblx0fSgpKTtcbn1cbiIsIi8qISBodHRwczovL210aHMuYmUvZnJvbWNvZGVwb2ludCB2MC4yLjEgYnkgQG1hdGhpYXMgKi9cbmlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcblx0KGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcblx0XHRcdC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdFx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9KCkpO1xuXHRcdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXHRcdHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cdFx0dmFyIGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbihfKSB7XG5cdFx0XHR2YXIgTUFYX1NJWkUgPSAweDQwMDA7XG5cdFx0XHR2YXIgY29kZVVuaXRzID0gW107XG5cdFx0XHR2YXIgaGlnaFN1cnJvZ2F0ZTtcblx0XHRcdHZhciBsb3dTdXJyb2dhdGU7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0aWYgKCFsZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0dmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcblx0XHRcdFx0XHRjb2RlUG9pbnQgPCAwIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0XHRcdGNvZGVQb2ludCA+IDB4MTBGRkZGIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuXHRcdFx0XHRcdGZsb29yKGNvZGVQb2ludCkgIT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludDogJyArIGNvZGVQb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNvZGVQb2ludCA8PSAweEZGRkYpIHsgLy8gQk1QIGNvZGUgcG9pbnRcblx0XHRcdFx0XHRjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBBc3RyYWwgY29kZSBwb2ludDsgc3BsaXQgaW4gc3Vycm9nYXRlIGhhbHZlc1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuXHRcdFx0XHRcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHRcdFx0XHRcdGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMDtcblx0XHRcdFx0XHRsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhEQzAwO1xuXHRcdFx0XHRcdGNvZGVVbml0cy5wdXNoKGhpZ2hTdXJyb2dhdGUsIGxvd1N1cnJvZ2F0ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluZGV4ICsgMSA9PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG5cdFx0XHRcdFx0cmVzdWx0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlVW5pdHMpO1xuXHRcdFx0XHRcdGNvZGVVbml0cy5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0aWYgKGRlZmluZVByb3BlcnR5KSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eShTdHJpbmcsICdmcm9tQ29kZVBvaW50Jywge1xuXHRcdFx0XHQndmFsdWUnOiBmcm9tQ29kZVBvaW50LFxuXHRcdFx0XHQnY29uZmlndXJhYmxlJzogdHJ1ZSxcblx0XHRcdFx0J3dyaXRhYmxlJzogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludDtcblx0XHR9XG5cdH0oKSk7XG59XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG4vLy9cblxuLy8gVGhlIGJhc2ljIG5vdGlvbiBvZiBhIHRyZWUgaGFzIGEgcGFyZW50LCBhIHBheWxvYWQsIGFuZCBhIGxpc3Qgb2YgY2hpbGRyZW4uXG4vLyAgSXQgaXMgdGhlIG1vc3QgYWJzdHJhY3QgaW50ZXJmYWNlIGZvciBhbGwgdGhlIHRyZWVzIHVzZWQgYnkgQU5UTFIuXG4vLy9cblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi8uLi9Ub2tlbicpLlRva2VuO1xudmFyIEludGVydmFsID0gcmVxdWlyZSgnLi8uLi9JbnRlcnZhbFNldCcpLkludGVydmFsO1xudmFyIElOVkFMSURfSU5URVJWQUwgPSBuZXcgSW50ZXJ2YWwoLTEsIC0yKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL1V0aWxzLmpzJyk7XG5cblxuZnVuY3Rpb24gVHJlZSgpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIFN5bnRheFRyZWUoKSB7XG5cdFRyZWUuY2FsbCh0aGlzKTtcblx0cmV0dXJuIHRoaXM7XG59XG5cblN5bnRheFRyZWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmVlLnByb3RvdHlwZSk7XG5TeW50YXhUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bnRheFRyZWU7XG5cbmZ1bmN0aW9uIFBhcnNlVHJlZSgpIHtcblx0U3ludGF4VHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VUcmVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3ludGF4VHJlZS5wcm90b3R5cGUpO1xuUGFyc2VUcmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcnNlVHJlZTtcblxuZnVuY3Rpb24gUnVsZU5vZGUoKSB7XG5cdFBhcnNlVHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUnVsZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJzZVRyZWUucHJvdG90eXBlKTtcblJ1bGVOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJ1bGVOb2RlO1xuXG5mdW5jdGlvbiBUZXJtaW5hbE5vZGUoKSB7XG5cdFBhcnNlVHJlZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuVGVybWluYWxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyc2VUcmVlLnByb3RvdHlwZSk7XG5UZXJtaW5hbE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVybWluYWxOb2RlO1xuXG5mdW5jdGlvbiBFcnJvck5vZGUoKSB7XG5cdFRlcm1pbmFsTm9kZS5jYWxsKHRoaXMpO1xuXHRyZXR1cm4gdGhpcztcbn1cblxuRXJyb3JOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGVybWluYWxOb2RlLnByb3RvdHlwZSk7XG5FcnJvck5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXJyb3JOb2RlO1xuXG5mdW5jdGlvbiBQYXJzZVRyZWVWaXNpdG9yKCkge1xuXHRyZXR1cm4gdGhpcztcbn1cblxuUGFyc2VUcmVlVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbihjdHgpIHtcbiBcdGlmIChBcnJheS5pc0FycmF5KGN0eCkpIHtcblx0XHRyZXR1cm4gY3R4Lm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmFjY2VwdCh0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGN0eC5hY2NlcHQodGhpcyk7XG5cdH1cbn07XG5cblBhcnNlVHJlZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q2hpbGRyZW4gPSBmdW5jdGlvbihjdHgpIHtcblx0aWYgKGN0eC5jaGlsZHJlbikge1xuXHRcdHJldHVybiB0aGlzLnZpc2l0KGN0eC5jaGlsZHJlbik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuUGFyc2VUcmVlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXJtaW5hbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbn07XG5cblBhcnNlVHJlZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXJyb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuXG5mdW5jdGlvbiBQYXJzZVRyZWVMaXN0ZW5lcigpIHtcblx0cmV0dXJuIHRoaXM7XG59XG5cblBhcnNlVHJlZUxpc3RlbmVyLnByb3RvdHlwZS52aXNpdFRlcm1pbmFsID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLnZpc2l0RXJyb3JOb2RlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLmVudGVyRXZlcnlSdWxlID0gZnVuY3Rpb24obm9kZSkge1xufTtcblxuUGFyc2VUcmVlTGlzdGVuZXIucHJvdG90eXBlLmV4aXRFdmVyeVJ1bGUgPSBmdW5jdGlvbihub2RlKSB7XG59O1xuXG5mdW5jdGlvbiBUZXJtaW5hbE5vZGVJbXBsKHN5bWJvbCkge1xuXHRUZXJtaW5hbE5vZGUuY2FsbCh0aGlzKTtcblx0dGhpcy5wYXJlbnRDdHggPSBudWxsO1xuXHR0aGlzLnN5bWJvbCA9IHN5bWJvbDtcblx0cmV0dXJuIHRoaXM7XG59XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUZXJtaW5hbE5vZGUucHJvdG90eXBlKTtcblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVybWluYWxOb2RlSW1wbDtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbihpKSB7XG5cdHJldHVybiBudWxsO1xufTtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUuZ2V0U3ltYm9sID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbDtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5wYXJlbnRDdHg7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5nZXRQYXlsb2FkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbDtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldFNvdXJjZUludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLnN5bWJvbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBJTlZBTElEX0lOVEVSVkFMO1xuXHR9XG5cdHZhciB0b2tlbkluZGV4ID0gdGhpcy5zeW1ib2wudG9rZW5JbmRleDtcblx0cmV0dXJuIG5ldyBJbnRlcnZhbCh0b2tlbkluZGV4LCB0b2tlbkluZGV4KTtcbn07XG5cblRlcm1pbmFsTm9kZUltcGwucHJvdG90eXBlLmdldENoaWxkQ291bnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIDA7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XG5cdHJldHVybiB2aXNpdG9yLnZpc2l0VGVybWluYWwodGhpcyk7XG59O1xuXG5UZXJtaW5hbE5vZGVJbXBsLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN5bWJvbC50ZXh0O1xufTtcblxuVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0aWYgKHRoaXMuc3ltYm9sLnR5cGUgPT09IFRva2VuLkVPRikge1xuXHRcdHJldHVybiBcIjxFT0Y+XCI7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuc3ltYm9sLnRleHQ7XG5cdH1cbn07XG5cbi8vIFJlcHJlc2VudHMgYSB0b2tlbiB0aGF0IHdhcyBjb25zdW1lZCBkdXJpbmcgcmVzeW5jaHJvbml6YXRpb25cbi8vIHJhdGhlciB0aGFuIGR1cmluZyBhIHZhbGlkIG1hdGNoIG9wZXJhdGlvbi4gRm9yIGV4YW1wbGUsXG4vLyB3ZSB3aWxsIGNyZWF0ZSB0aGlzIGtpbmQgb2YgYSBub2RlIGR1cmluZyBzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uXG4vLyBhbmQgZGVsZXRpb24gYXMgd2VsbCBhcyBkdXJpbmcgXCJjb25zdW1lIHVudGlsIGVycm9yIHJlY292ZXJ5IHNldFwiXG4vLyB1cG9uIG5vIHZpYWJsZSBhbHRlcm5hdGl2ZSBleGNlcHRpb25zLlxuXG5mdW5jdGlvbiBFcnJvck5vZGVJbXBsKHRva2VuKSB7XG5cdFRlcm1pbmFsTm9kZUltcGwuY2FsbCh0aGlzLCB0b2tlbik7XG5cdHJldHVybiB0aGlzO1xufVxuXG5FcnJvck5vZGVJbXBsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGVybWluYWxOb2RlSW1wbC5wcm90b3R5cGUpO1xuRXJyb3JOb2RlSW1wbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcnJvck5vZGVJbXBsO1xuXG5FcnJvck5vZGVJbXBsLnByb3RvdHlwZS5pc0Vycm9yTm9kZSA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkVycm9yTm9kZUltcGwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcblx0cmV0dXJuIHZpc2l0b3IudmlzaXRFcnJvck5vZGUodGhpcyk7XG59O1xuXG5mdW5jdGlvbiBQYXJzZVRyZWVXYWxrZXIoKSB7XG5cdHJldHVybiB0aGlzO1xufVxuXG5QYXJzZVRyZWVXYWxrZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbihsaXN0ZW5lciwgdCkge1xuXHR2YXIgZXJyb3JOb2RlID0gdCBpbnN0YW5jZW9mIEVycm9yTm9kZSB8fFxuXHRcdFx0KHQuaXNFcnJvck5vZGUgIT09IHVuZGVmaW5lZCAmJiB0LmlzRXJyb3JOb2RlKCkpO1xuXHRpZiAoZXJyb3JOb2RlKSB7XG5cdFx0bGlzdGVuZXIudmlzaXRFcnJvck5vZGUodCk7XG5cdH0gZWxzZSBpZiAodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuXHRcdGxpc3RlbmVyLnZpc2l0VGVybWluYWwodCk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5lbnRlclJ1bGUobGlzdGVuZXIsIHQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdC5nZXRDaGlsZENvdW50KCk7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gdC5nZXRDaGlsZChpKTtcblx0XHRcdHRoaXMud2FsayhsaXN0ZW5lciwgY2hpbGQpO1xuXHRcdH1cblx0XHR0aGlzLmV4aXRSdWxlKGxpc3RlbmVyLCB0KTtcblx0fVxufTtcbi8vXG4vLyBUaGUgZGlzY292ZXJ5IG9mIGEgcnVsZSBub2RlLCBpbnZvbHZlcyBzZW5kaW5nIHR3byBldmVudHM6IHRoZSBnZW5lcmljXG4vLyB7QGxpbmsgUGFyc2VUcmVlTGlzdGVuZXIvL2VudGVyRXZlcnlSdWxlfSBhbmQgYVxuLy8ge0BsaW5rIFJ1bGVDb250ZXh0fS1zcGVjaWZpYyBldmVudC4gRmlyc3Qgd2UgdHJpZ2dlciB0aGUgZ2VuZXJpYyBhbmQgdGhlblxuLy8gdGhlIHJ1bGUgc3BlY2lmaWMuIFdlIHRvIHRoZW0gaW4gcmV2ZXJzZSBvcmRlciB1cG9uIGZpbmlzaGluZyB0aGUgbm9kZS5cbi8vXG5QYXJzZVRyZWVXYWxrZXIucHJvdG90eXBlLmVudGVyUnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyLCByKSB7XG5cdHZhciBjdHggPSByLmdldFJ1bGVDb250ZXh0KCk7XG5cdGxpc3RlbmVyLmVudGVyRXZlcnlSdWxlKGN0eCk7XG5cdGN0eC5lbnRlclJ1bGUobGlzdGVuZXIpO1xufTtcblxuUGFyc2VUcmVlV2Fsa2VyLnByb3RvdHlwZS5leGl0UnVsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyLCByKSB7XG5cdHZhciBjdHggPSByLmdldFJ1bGVDb250ZXh0KCk7XG5cdGN0eC5leGl0UnVsZShsaXN0ZW5lcik7XG5cdGxpc3RlbmVyLmV4aXRFdmVyeVJ1bGUoY3R4KTtcbn07XG5cblBhcnNlVHJlZVdhbGtlci5ERUZBVUxUID0gbmV3IFBhcnNlVHJlZVdhbGtlcigpO1xuXG5leHBvcnRzLlJ1bGVOb2RlID0gUnVsZU5vZGU7XG5leHBvcnRzLkVycm9yTm9kZSA9IEVycm9yTm9kZTtcbmV4cG9ydHMuVGVybWluYWxOb2RlID0gVGVybWluYWxOb2RlO1xuZXhwb3J0cy5FcnJvck5vZGVJbXBsID0gRXJyb3JOb2RlSW1wbDtcbmV4cG9ydHMuVGVybWluYWxOb2RlSW1wbCA9IFRlcm1pbmFsTm9kZUltcGw7XG5leHBvcnRzLlBhcnNlVHJlZUxpc3RlbmVyID0gUGFyc2VUcmVlTGlzdGVuZXI7XG5leHBvcnRzLlBhcnNlVHJlZVZpc2l0b3IgPSBQYXJzZVRyZWVWaXNpdG9yO1xuZXhwb3J0cy5QYXJzZVRyZWVXYWxrZXIgPSBQYXJzZVRyZWVXYWxrZXI7XG5leHBvcnRzLklOVkFMSURfSU5URVJWQUwgPSBJTlZBTElEX0lOVEVSVkFMO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTcgVGhlIEFOVExSIFByb2plY3QuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBVc2Ugb2YgdGhpcyBmaWxlIGlzIGdvdmVybmVkIGJ5IHRoZSBCU0QgMy1jbGF1c2UgbGljZW5zZSB0aGF0XG4gKiBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UudHh0IGZpbGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqL1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLy4uL1V0aWxzJyk7XG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLy4uL1Rva2VuJykuVG9rZW47XG52YXIgUnVsZU5vZGUgPSByZXF1aXJlKCcuL1RyZWUnKS5SdWxlTm9kZTtcbnZhciBFcnJvck5vZGUgPSByZXF1aXJlKCcuL1RyZWUnKS5FcnJvck5vZGU7XG52YXIgVGVybWluYWxOb2RlID0gcmVxdWlyZSgnLi9UcmVlJykuVGVybWluYWxOb2RlO1xudmFyIFBhcnNlclJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi8uLi9QYXJzZXJSdWxlQ29udGV4dCcpLlBhcnNlclJ1bGVDb250ZXh0O1xudmFyIFJ1bGVDb250ZXh0ID0gcmVxdWlyZSgnLi8uLi9SdWxlQ29udGV4dCcpLlJ1bGVDb250ZXh0O1xudmFyIElOVkFMSURfQUxUX05VTUJFUiA9IHJlcXVpcmUoJy4vLi4vYXRuL0FUTicpLklOVkFMSURfQUxUX05VTUJFUjtcblxuXG4vKiogQSBzZXQgb2YgdXRpbGl0eSByb3V0aW5lcyB1c2VmdWwgZm9yIGFsbCBraW5kcyBvZiBBTlRMUiB0cmVlcy4gKi9cbmZ1bmN0aW9uIFRyZWVzKCkge1xufVxuXG4vLyBQcmludCBvdXQgYSB3aG9sZSB0cmVlIGluIExJU1AgZm9ybS4ge0BsaW5rIC8vZ2V0Tm9kZVRleHR9IGlzIHVzZWQgb24gdGhlXG4vLyAgbm9kZSBwYXlsb2FkcyB0byBnZXQgdGhlIHRleHQgZm9yIHRoZSBub2Rlcy4gIERldGVjdFxuLy8gIHBhcnNlIHRyZWVzIGFuZCBleHRyYWN0IGRhdGEgYXBwcm9wcmlhdGVseS5cblRyZWVzLnRvU3RyaW5nVHJlZSA9IGZ1bmN0aW9uKHRyZWUsIHJ1bGVOYW1lcywgcmVjb2cpIHtcblx0cnVsZU5hbWVzID0gcnVsZU5hbWVzIHx8IG51bGw7XG5cdHJlY29nID0gcmVjb2cgfHwgbnVsbDtcbiAgICBpZihyZWNvZyE9PW51bGwpIHtcbiAgICAgICBydWxlTmFtZXMgPSByZWNvZy5ydWxlTmFtZXM7XG4gICAgfVxuICAgIHZhciBzID0gVHJlZXMuZ2V0Tm9kZVRleHQodHJlZSwgcnVsZU5hbWVzKTtcbiAgICBzID0gVXRpbHMuZXNjYXBlV2hpdGVzcGFjZShzLCBmYWxzZSk7XG4gICAgdmFyIGMgPSB0cmVlLmdldENoaWxkQ291bnQoKTtcbiAgICBpZihjPT09MCkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgdmFyIHJlcyA9IFwiKFwiICsgcyArICcgJztcbiAgICBpZihjPjApIHtcbiAgICAgICAgcyA9IFRyZWVzLnRvU3RyaW5nVHJlZSh0cmVlLmdldENoaWxkKDApLCBydWxlTmFtZXMpO1xuICAgICAgICByZXMgPSByZXMuY29uY2F0KHMpO1xuICAgIH1cbiAgICBmb3IodmFyIGk9MTtpPGM7aSsrKSB7XG4gICAgICAgIHMgPSBUcmVlcy50b1N0cmluZ1RyZWUodHJlZS5nZXRDaGlsZChpKSwgcnVsZU5hbWVzKTtcbiAgICAgICAgcmVzID0gcmVzLmNvbmNhdCgnICcgKyBzKTtcbiAgICB9XG4gICAgcmVzID0gcmVzLmNvbmNhdChcIilcIik7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cblRyZWVzLmdldE5vZGVUZXh0ID0gZnVuY3Rpb24odCwgcnVsZU5hbWVzLCByZWNvZykge1xuXHRydWxlTmFtZXMgPSBydWxlTmFtZXMgfHwgbnVsbDtcblx0cmVjb2cgPSByZWNvZyB8fCBudWxsO1xuICAgIGlmKHJlY29nIT09bnVsbCkge1xuICAgICAgICBydWxlTmFtZXMgPSByZWNvZy5ydWxlTmFtZXM7XG4gICAgfVxuICAgIGlmKHJ1bGVOYW1lcyE9PW51bGwpIHtcbiAgICAgICBpZiAodCBpbnN0YW5jZW9mIFJ1bGVDb250ZXh0KSB7XG4gICAgICAgICAgIHZhciBhbHROdW1iZXIgPSB0LmdldEFsdE51bWJlcigpO1xuICAgICAgICAgICBpZiAoIGFsdE51bWJlciE9SU5WQUxJRF9BTFRfTlVNQkVSICkge1xuICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGVOYW1lc1t0LnJ1bGVJbmRleF0rXCI6XCIrYWx0TnVtYmVyO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiBydWxlTmFtZXNbdC5ydWxlSW5kZXhdO1xuICAgICAgIH0gZWxzZSBpZiAoIHQgaW5zdGFuY2VvZiBFcnJvck5vZGUpIHtcbiAgICAgICAgICAgcmV0dXJuIHQudG9TdHJpbmcoKTtcbiAgICAgICB9IGVsc2UgaWYodCBpbnN0YW5jZW9mIFRlcm1pbmFsTm9kZSkge1xuICAgICAgICAgICBpZih0LnN5bWJvbCE9PW51bGwpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0LnN5bWJvbC50ZXh0O1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgIH1cbiAgICAvLyBubyByZWNvZyBmb3IgcnVsZSBuYW1lc1xuICAgIHZhciBwYXlsb2FkID0gdC5nZXRQYXlsb2FkKCk7XG4gICAgaWYgKHBheWxvYWQgaW5zdGFuY2VvZiBUb2tlbiApIHtcbiAgICAgICByZXR1cm4gcGF5bG9hZC50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdC5nZXRQYXlsb2FkKCkudG9TdHJpbmcoKTtcbn07XG5cblxuLy8gUmV0dXJuIG9yZGVyZWQgbGlzdCBvZiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBub2RlXG5UcmVlcy5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKHQpIHtcblx0dmFyIGxpc3QgPSBbXTtcblx0Zm9yKHZhciBpPTA7aTx0LmdldENoaWxkQ291bnQoKTtpKyspIHtcblx0XHRsaXN0LnB1c2godC5nZXRDaGlsZChpKSk7XG5cdH1cblx0cmV0dXJuIGxpc3Q7XG59O1xuXG4vLyBSZXR1cm4gYSBsaXN0IG9mIGFsbCBhbmNlc3RvcnMgb2YgdGhpcyBub2RlLiAgVGhlIGZpcnN0IG5vZGUgb2Zcbi8vICBsaXN0IGlzIHRoZSByb290IGFuZCB0aGUgbGFzdCBpcyB0aGUgcGFyZW50IG9mIHRoaXMgbm9kZS5cbi8vXG5UcmVlcy5nZXRBbmNlc3RvcnMgPSBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHQgPSB0LmdldFBhcmVudCgpO1xuICAgIHdoaWxlKHQhPT1udWxsKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IFt0XS5jb25jYXQoYW5jZXN0b3JzKTtcbiAgICAgICAgdCA9IHQuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBhbmNlc3RvcnM7XG59O1xuXG5UcmVlcy5maW5kQWxsVG9rZW5Ob2RlcyA9IGZ1bmN0aW9uKHQsIHR0eXBlKSB7XG4gICAgcmV0dXJuIFRyZWVzLmZpbmRBbGxOb2Rlcyh0LCB0dHlwZSwgdHJ1ZSk7XG59O1xuXG5UcmVlcy5maW5kQWxsUnVsZU5vZGVzID0gZnVuY3Rpb24odCwgcnVsZUluZGV4KSB7XG5cdHJldHVybiBUcmVlcy5maW5kQWxsTm9kZXModCwgcnVsZUluZGV4LCBmYWxzZSk7XG59O1xuXG5UcmVlcy5maW5kQWxsTm9kZXMgPSBmdW5jdGlvbih0LCBpbmRleCwgZmluZFRva2Vucykge1xuXHR2YXIgbm9kZXMgPSBbXTtcblx0VHJlZXMuX2ZpbmRBbGxOb2Rlcyh0LCBpbmRleCwgZmluZFRva2Vucywgbm9kZXMpO1xuXHRyZXR1cm4gbm9kZXM7XG59O1xuXG5UcmVlcy5fZmluZEFsbE5vZGVzID0gZnVuY3Rpb24odCwgaW5kZXgsIGZpbmRUb2tlbnMsIG5vZGVzKSB7XG5cdC8vIGNoZWNrIHRoaXMgbm9kZSAodGhlIHJvb3QpIGZpcnN0XG5cdGlmKGZpbmRUb2tlbnMgJiYgKHQgaW5zdGFuY2VvZiBUZXJtaW5hbE5vZGUpKSB7XG5cdFx0aWYodC5zeW1ib2wudHlwZT09PWluZGV4KSB7XG5cdFx0XHRub2Rlcy5wdXNoKHQpO1xuXHRcdH1cblx0fSBlbHNlIGlmKCFmaW5kVG9rZW5zICYmICh0IGluc3RhbmNlb2YgUGFyc2VyUnVsZUNvbnRleHQpKSB7XG5cdFx0aWYodC5ydWxlSW5kZXg9PT1pbmRleCkge1xuXHRcdFx0bm9kZXMucHVzaCh0KTtcblx0XHR9XG5cdH1cblx0Ly8gY2hlY2sgY2hpbGRyZW5cblx0Zm9yKHZhciBpPTA7aTx0LmdldENoaWxkQ291bnQoKTtpKyspIHtcblx0XHRUcmVlcy5fZmluZEFsbE5vZGVzKHQuZ2V0Q2hpbGQoaSksIGluZGV4LCBmaW5kVG9rZW5zLCBub2Rlcyk7XG5cdH1cbn07XG5cblRyZWVzLmRlc2NlbmRhbnRzID0gZnVuY3Rpb24odCkge1xuXHR2YXIgbm9kZXMgPSBbdF07XG4gICAgZm9yKHZhciBpPTA7aTx0LmdldENoaWxkQ291bnQoKTtpKyspIHtcbiAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoVHJlZXMuZGVzY2VuZGFudHModC5nZXRDaGlsZChpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG59O1xuXG5cbmV4cG9ydHMuVHJlZXMgPSBUcmVlczsiLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBUaGUgQU5UTFIgUHJvamVjdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFVzZSBvZiB0aGlzIGZpbGUgaXMgZ292ZXJuZWQgYnkgdGhlIEJTRCAzLWNsYXVzZSBsaWNlbnNlIHRoYXRcbiAqIGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRS50eHQgZmlsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICovXG5cbnZhciBUcmVlID0gcmVxdWlyZSgnLi9UcmVlJyk7XG5leHBvcnRzLlRyZWVzID0gcmVxdWlyZSgnLi9UcmVlcycpLlRyZWVzO1xuZXhwb3J0cy5SdWxlTm9kZSA9IFRyZWUuUnVsZU5vZGU7XG5leHBvcnRzLlBhcnNlVHJlZUxpc3RlbmVyID0gVHJlZS5QYXJzZVRyZWVMaXN0ZW5lcjtcbmV4cG9ydHMuUGFyc2VUcmVlVmlzaXRvciA9IFRyZWUuUGFyc2VUcmVlVmlzaXRvcjtcbmV4cG9ydHMuUGFyc2VUcmVlV2Fsa2VyID0gVHJlZS5QYXJzZVRyZWVXYWxrZXI7XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy41LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjAtMDMtMTRcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxuXHQvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG5cdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcblx0Ly8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRyZXR1cm4gdHlwZW9mIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZSBmaWVsZHNldCBkaXZcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuXHR9ICk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbIFwiVEFHXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kWyBcIkNMQVNTXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuXHRcdFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiXFxcXFxcZlwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbXFxcXHJcXFxcblxcXFxmXVwiICk7XG5cdFx0fSApO1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjplbmFibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAoIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGIgPSBiLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRyZXR1cm4gYSA9PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbIGkgXSwgYnBbIGkgXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRhcFsgaSBdID09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcblx0XHRcdFx0bWF0Y2hbIDUgXSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwclsgXCJDSElMRFwiIF0udGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcdFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiYgY2xhc3NDYWNoZShcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuXHRcdFx0XHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbIFwiZW1wdHlcIiBdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbIFwibnRoXCIgXSA9IEV4cHIucHNldWRvc1sgXCJlcVwiIF07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoXG5cdFx0XHRcdHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuXHRcdFx0XHRbXVxuXHRcdFx0KSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHR0b2tlbnNcblx0XHRcdFx0XHRcdC5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcblx0XHQpO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbIFwiSURcIiBdKCB0b2tlbi5tYXRjaGVzWyAwIF1cblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByWyBcIm5lZWRzQ29udGV4dFwiIF0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKSA9PT0gXCIjXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9ICk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0gKSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4XCI7XG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0ICkgPiAzO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IChcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJiBqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMudG9wID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy50b3AgKz0gXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMubGVmdCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cHJvcHMubGVmdCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiIsIi8vVE9ET1xyXG5leHBvcnQgY29uc3QgTm9kZVR5cGUgPSB7XHJcbiAgICBfRXF1YXRpb246MixcclxuICAgIF9NYWNyb0RlZmluaXRpb246MyxcclxuICAgIF9Db25zdGFudDo0LFxyXG4gICAgX0luaXRpYWxDb25kaXRpb246NSxcclxuICAgIF9WYXJJZGVudGlmaWVyOjYsXHJcbiAgICBfTG9vcDo3LFxyXG4gICAgX0NvbmRpdGlvbjo4LFxyXG4gICAgX0Z1bmN0aW9uOjksXHJcbiAgICBfQ29uc3RhbnRTdGF0ZW1lbnQ6MTAsXHJcbiAgICBfU2V0dGVyOjExLFxyXG4gICAgX0Rlcml2YXRpdmU6MTIsXHJcbiAgICBfQWRkaXRpb246MTMsXHJcbiAgICBfU3VidHJhY3Rpb246MTQsXHJcbiAgICBfTXVsdGlwbGljYXRpb246MTUsXHJcbiAgICBfRGl2aXNpb246MTYsXHJcbiAgICBfTmVnYXRpb246MTcsXHJcbiAgICBfU3VtbWF0aW9uOjE4LFxyXG4gICAgX0xlc3M6MTksXHJcbiAgICBfTGVzc0VxdWFsOjIwLFxyXG4gICAgX0dyZWF0ZXI6MjEsXHJcbiAgICBfR3JlYXRlckVxdWFsOjIyLFxyXG4gICAgX0VxdWFsOjIzLFxyXG4gICAgX05vdEVxdWFsOjI0LFxyXG4gICAgX0FuZDoyNSxcclxuICAgIF9PcjoyNixcclxuICAgIF9Ob3Q6MjcsXHJcbiAgICBfU3RhdGU6MjgsXHJcbiAgICBfTWFjcm86MjksXHJcbiAgICBfVHJhbnNpdGlvbjozMCxcclxuICAgIF9Cb29sQ29uc3RhbnQ6MzEsXHJcbiAgICBfVGVybmFyeTozMlxyXG59O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRleHRQb3NpdGlvbntcclxuICAgIHJlYWRvbmx5IGxpbmU6bnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgY29sdW1uOm51bWJlcjtcclxuICAgIHJlYWRvbmx5IHN0YXJ0Om51bWJlcjtcclxuICAgIHJlYWRvbmx5IHN0b3A6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3IobGluZTpudW1iZXIsY29sdW1uOm51bWJlcixzdGFydDpudW1iZXIsc3RvcDpudW1iZXIpe1xyXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XHJcbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuc3RvcCA9IHN0b3A7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW52YWxpZCgpOlRleHRQb3NpdGlvbntcclxuICAgICAgICByZXR1cm4gbmV3IFRleHRQb3NpdGlvbigtMSwtMSwtMSwtMSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBU1ROb2Rle1xyXG4gICAgdHlwZTpudW1iZXI7XHJcbiAgICB0ZXh0UG9zOlRleHRQb3NpdGlvbjtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGU6bnVtYmVyKXtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudGV4dFBvcyA9IFRleHRQb3NpdGlvbi5pbnZhbGlkKCk7XHJcbiAgICB9XHJcbiAgICBzZXRUZXh0UG9zKHRleHRQb3M6VGV4dFBvc2l0aW9uKXtcclxuICAgICAgICB0aGlzLnRleHRQb3MgPSB0ZXh0UG9zO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTeXN0ZW1EZWZpbml0aW9ue1xyXG4gICAgc3RhdGVtZW50czpTdGF0ZW1lbnROb2RlW107XHJcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZW1lbnRzOlN0YXRlbWVudE5vZGVbXSl7XHJcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzPXN0YXRlbWVudHM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0YXRlbWVudE5vZGUgZXh0ZW5kcyBBU1ROb2Rle1xyXG4gICAgY29uc3RydWN0b3IodHlwZTpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHR5cGUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFcXVhdGlvbk5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2Rle1xyXG4gICAgbGFiZWw6VmFySWRlbnRpZmllck5vZGV8bnVsbDtcclxuICAgIGxlZnQ6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGxhYmVsOlZhcklkZW50aWZpZXJOb2RlfG51bGwsbGVmdDpFeHByZXNzaW9uTm9kZSxyaWdodDpFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0VxdWF0aW9uKTtcclxuICAgICAgICB0aGlzLmxhYmVsID0gbGFiZWw7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE1hY3JvU3RhdGVtZW50Tm9kZSBleHRlbmRzIFN0YXRlbWVudE5vZGV7XHJcbiAgICBpZDpWYXJJZGVudGlmaWVyTm9kZTtcclxuICAgIGFyZ3M6c3RyaW5nW107XHJcbiAgICBleHByZXNzaW9uOkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IoaWQ6VmFySWRlbnRpZmllck5vZGUsYXJnczpzdHJpbmdbXSxleHByZXNzaW9uOkV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fTWFjcm9EZWZpbml0aW9uKTtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUcmFuc2l0aW9uTm9kZSBleHRlbmRzIEFTVE5vZGV7XHJcbiAgICBwcmV2U3RhdGVzOnN0cmluZ1tdO1xyXG4gICAgY29uZGl0aW9uOkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKHByZXZTdGF0ZXM6c3RyaW5nW10sY29uZGl0aW9uOkJvb2xFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX1RyYW5zaXRpb24pO1xyXG4gICAgICAgIHRoaXMucHJldlN0YXRlcyA9IHByZXZTdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFN0YXRlTm9kZSBleHRlbmRzIFN0YXRlbWVudE5vZGV7XHJcbiAgICBpZDpzdHJpbmc7XHJcbiAgICBpc1Rlcm1pbmFsOmJvb2xlYW47XHJcbiAgICBzdGF0ZVRyYW5zaXRpb25zOlRyYW5zaXRpb25Ob2RlW107XHJcbiAgICBzdGF0ZW1lbnRzOlN0YXRlbWVudE5vZGVbXTtcclxuICAgIGNvbnN0cnVjdG9yKGlkOnN0cmluZyxpc1Rlcm1pbmFsOmJvb2xlYW4sc3RhdGVUcmFuc2l0aW9uczpUcmFuc2l0aW9uTm9kZVtdLHN0YXRlbWVudHM6U3RhdGVtZW50Tm9kZVtdKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fU3RhdGUpO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmlzVGVybWluYWwgPSBpc1Rlcm1pbmFsO1xyXG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9ucyA9IHN0YXRlVHJhbnNpdGlvbnM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSW5pdGlhbENvbmRpdGlvbk5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2Rle1xyXG4gICAgaWQ6VmFySWRlbnRpZmllck5vZGU7XHJcbiAgICBleHByZXNzaW9uOkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IoaWQ6VmFySWRlbnRpZmllck5vZGUsZXhwcmVzc2lvbjpFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0luaXRpYWxDb25kaXRpb24pO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDb25zdGFudFN0YXRlbWVudE5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2Rle1xyXG4gICAgLyppc0xvY2FsOmJvb2xlYW47Ki9cclxuICAgIGlkOlZhcklkZW50aWZpZXJOb2RlO1xyXG4gICAgZXhwcmVzc2lvbjpFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGlkOlZhcklkZW50aWZpZXJOb2RlLGV4cHJlc3Npb246RXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9Db25zdGFudFN0YXRlbWVudCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFNldHRlck5vZGUgZXh0ZW5kcyBBU1ROb2Rle1xyXG4gICAgaWQ6VmFySWRlbnRpZmllck5vZGU7XHJcbiAgICBleHByZXNzaW9uOkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IoaWQ6VmFySWRlbnRpZmllck5vZGUsZXhwcmVzc2lvbjpFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX1NldHRlcik7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEJvdW5kc3tcclxuICAgIGw6bnVtYmVyO1xyXG4gICAgcjpudW1iZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihsOm51bWJlcixyOm51bWJlcil7XHJcbiAgICAgICAgdGhpcy5sID0gbDtcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBMb29wU3RhdGVtZW50Tm9kZSBleHRlbmRzIFN0YXRlbWVudE5vZGV7XHJcbiAgICBpdGVyYXRvcjpzdHJpbmc7XHJcbiAgICBib3VuZHM6Qm91bmRzW107XHJcbiAgICBzdGF0ZW1lbnRzOlN0YXRlbWVudE5vZGVbXTtcclxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yOnN0cmluZyxib3VuZHM6Qm91bmRzW10sc3RhdGVtZW50czpTdGF0ZW1lbnROb2RlW10pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9Mb29wKTtcclxuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XHJcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcclxuICAgIH07XHJcbn1cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJvb2xFeHByZXNzaW9uTm9kZSBleHRlbmRzIEFTVE5vZGV7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIodHlwZSk7XHJcbiAgICB9XHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOkJvb2xFeHByZXNzaW9uTm9kZTtcclxufVxyXG5leHBvcnQgY2xhc3MgQm9vbE5lZ2F0aW9uTm9kZSBleHRlbmRzIEJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgIGlubmVyOkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGlubmVyOkJvb2xFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX05lZ2F0aW9uKTtcclxuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQm9vbE5lZ2F0aW9uTm9kZSh0aGlzLmlubmVyLmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sTE5vZGUgZXh0ZW5kcyBCb29sRXhwcmVzc2lvbk5vZGV7XHJcbiAgICBsZWZ0OkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIHJpZ2h0OkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGxlZnQ6Qm9vbEV4cHJlc3Npb25Ob2RlLHJpZ2h0OkJvb2xFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0xlc3MpO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IEJvb2xMTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sTEVOb2RlIGV4dGVuZHMgQm9vbEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgbGVmdDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkJvb2xFeHByZXNzaW9uTm9kZSxyaWdodDpCb29sRXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9MZXNzRXF1YWwpO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IEJvb2xMRU5vZGUodGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgQm9vbEdOb2RlIGV4dGVuZHMgQm9vbEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgbGVmdDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkJvb2xFeHByZXNzaW9uTm9kZSxyaWdodDpCb29sRXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9HcmVhdGVyKTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sR05vZGUodGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgQm9vbEdFTm9kZSBleHRlbmRzIEJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgIGxlZnQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgcmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpCb29sRXhwcmVzc2lvbk5vZGUscmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fR3JlYXRlckVxdWFsKTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sR0VOb2RlKHRoaXMubGVmdC5jbG9uZSgpLHRoaXMucmlnaHQuY2xvbmUoKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEJvb2xFTm9kZSBleHRlbmRzIEJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgIGxlZnQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgcmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpCb29sRXhwcmVzc2lvbk5vZGUscmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fRXF1YWwpO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IEJvb2xFTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sTkVOb2RlIGV4dGVuZHMgQm9vbEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgbGVmdDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkJvb2xFeHByZXNzaW9uTm9kZSxyaWdodDpCb29sRXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9Ob3RFcXVhbCk7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQm9vbE5FTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sQW5kTm9kZSBleHRlbmRzIEJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgIGxlZnQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgcmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpCb29sRXhwcmVzc2lvbk5vZGUscmlnaHQ6Qm9vbEV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fQW5kKTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sQW5kTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sT3JOb2RlIGV4dGVuZHMgQm9vbEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgbGVmdDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkJvb2xFeHByZXNzaW9uTm9kZSxyaWdodDpCb29sRXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9Pcik7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQm9vbE9yTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBCb29sQ29uc3RhbnROb2RlIGV4dGVuZHMgQm9vbEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgdmFsdWU6Ym9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlOmJvb2xlYW4pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9Cb29sQ29uc3RhbnQpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sQ29uc3RhbnROb2RlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFeHByZXNzaW9uTm9kZSBleHRlbmRzIEFTVE5vZGV7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIodHlwZSk7XHJcbiAgICB9XHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOkV4cHJlc3Npb25Ob2RlXHJcbn1cclxuZXhwb3J0IGNsYXNzIFN1bUV4cHJlc3Npb25Ob2RlIGV4dGVuZHMgRXhwcmVzc2lvbk5vZGV7XHJcbiAgICBpdGVyYXRvcjpzdHJpbmc7XHJcbiAgICBib3VuZHM6Qm91bmRzO1xyXG4gICAgZXhwcmVzc2lvbjpFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yOnN0cmluZyxib3VuZHM6Qm91bmRzLGV4cHJlc3Npb246RXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9TdW1tYXRpb24pO1xyXG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcclxuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKTpFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICByZXR1cm4gbmV3IFN1bUV4cHJlc3Npb25Ob2RlKHRoaXMuaXRlcmF0b3IsbmV3IEJvdW5kcyh0aGlzLmJvdW5kcy5sLHRoaXMuYm91bmRzLnIpLHRoaXMuZXhwcmVzc2lvbi5jbG9uZSgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTWFjcm9FeHByZXNzaW9uTm9kZSBleHRlbmRzIEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgaWQ6VmFySWRlbnRpZmllck5vZGU7XHJcbiAgICBhcmdzOkV4cHJlc3Npb25Ob2RlW107XHJcbiAgICBjb25zdHJ1Y3RvcihpZDpWYXJJZGVudGlmaWVyTm9kZSxhcmdzOkV4cHJlc3Npb25Ob2RlW10pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9NYWNybyk7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgTWFjcm9FeHByZXNzaW9uTm9kZSh0aGlzLmlkLHRoaXMuYXJncy5tYXAoZnVuY3Rpb24oaXRlbSl7cmV0dXJuIGl0ZW0uY2xvbmUoKX0pKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgVmFySWRlbnRpZmllck5vZGUgZXh0ZW5kcyBFeHByZXNzaW9uTm9kZXtcclxuICAgIGlkOnN0cmluZztcclxuICAgIGluZGljaWVzOkV4cHJlc3Npb25Ob2RlW107XHJcbiAgICBjb25zdHJ1Y3RvcihpZDpzdHJpbmcsaW5kaWNpZXM6RXhwcmVzc2lvbk5vZGVbXSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX1ZhcklkZW50aWZpZXIpO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmluZGljaWVzID0gaW5kaWNpZXM7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgVmFySWRlbnRpZmllck5vZGUodGhpcy5pZCx0aGlzLmluZGljaWVzLm1hcChmdW5jdGlvbihpdGVtKXtyZXR1cm4gaXRlbS5jbG9uZSgpfSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBDb25zdGFudE5vZGUgZXh0ZW5kcyBFeHByZXNzaW9uTm9kZXtcclxuICAgIHZhbHVlOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0NvbnN0YW50KTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBEZXJpdmF0aXZlTm9kZSBleHRlbmRzIEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgaWQ6VmFySWRlbnRpZmllck5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihpZDpWYXJJZGVudGlmaWVyTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0Rlcml2YXRpdmUpO1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZXJpdmF0aXZlTm9kZSh0aGlzLmlkLmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBGdW5jdGlvbk5vZGUgZXh0ZW5kcyBFeHByZXNzaW9uTm9kZXtcclxuICAgIG5hbWU6c3RyaW5nO1xyXG4gICAgYXJnczpFeHByZXNzaW9uTm9kZVtdO1xyXG4gICAgY29uc3RydWN0b3IobmFtZTpzdHJpbmcsYXJnczpFeHByZXNzaW9uTm9kZVtdKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fRnVuY3Rpb24pO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk5vZGUodGhpcy5uYW1lLHRoaXMuYXJncy5tYXAoZnVuY3Rpb24oaXRlbSl7cmV0dXJuIGl0ZW0uY2xvbmUoKX0pKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgQWRkaXRpb25Ob2RlIGV4dGVuZHMgRXhwcmVzc2lvbk5vZGV7XHJcbiAgICBsZWZ0OkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgcmlnaHQ6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkV4cHJlc3Npb25Ob2RlLHJpZ2h0OkV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fQWRkaXRpb24pO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IEFkZGl0aW9uTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBNdWx0aXBsaWNhdGlvbk5vZGUgZXh0ZW5kcyBFeHByZXNzaW9uTm9kZXtcclxuICAgIGxlZnQ6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICByaWdodDpFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGxlZnQ6RXhwcmVzc2lvbk5vZGUscmlnaHQ6RXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9NdWx0aXBsaWNhdGlvbik7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlwbGljYXRpb25Ob2RlKHRoaXMubGVmdC5jbG9uZSgpLHRoaXMucmlnaHQuY2xvbmUoKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFN1YnRyYWN0aW9uTm9kZSBleHRlbmRzIEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgbGVmdDpFeHByZXNzaW9uTm9kZTtcclxuICAgIHJpZ2h0OkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpFeHByZXNzaW9uTm9kZSxyaWdodDpFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX1N1YnRyYWN0aW9uKTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJ0cmFjdGlvbk5vZGUodGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRGl2aXNpb25Ob2RlIGV4dGVuZHMgRXhwcmVzc2lvbk5vZGV7XHJcbiAgICBsZWZ0OkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgcmlnaHQ6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkV4cHJlc3Npb25Ob2RlLHJpZ2h0OkV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fRGl2aXNpb24pO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IERpdmlzaW9uTm9kZSh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUZXJuYXJ5T3BlcmF0b3JOb2RlIGV4dGVuZHMgRXhwcmVzc2lvbk5vZGV7XHJcbiAgICBjb25kaXRpb246Qm9vbEV4cHJlc3Npb25Ob2RlO1xyXG4gICAgdHJ1ZTpFeHByZXNzaW9uTm9kZTtcclxuICAgIGZhbHNlOkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgY29uc3RydWN0b3IoY29uZDpCb29sRXhwcmVzc2lvbk5vZGUsdHI6RXhwcmVzc2lvbk5vZGUsZmxzOkV4cHJlc3Npb25Ob2RlKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fVGVybmFyeSk7XHJcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kO1xyXG4gICAgICAgIHRoaXMudHJ1ZSA9IHRyO1xyXG4gICAgICAgIHRoaXMuZmFsc2UgPSBmbHM7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgVGVybmFyeU9wZXJhdG9yTm9kZSh0aGlzLmNvbmRpdGlvbi5jbG9uZSgpLHRoaXMudHJ1ZS5jbG9uZSgpLHRoaXMuZmFsc2UuY2xvbmUoKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE5lZ2F0aW9uTm9kZSBleHRlbmRzIEV4cHJlc3Npb25Ob2Rle1xyXG4gICAgaW5uZXI6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcjpFeHByZXNzaW9uTm9kZSl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX05lZ2F0aW9uKTtcclxuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgTmVnYXRpb25Ob2RlKHRoaXMuaW5uZXIuY2xvbmUoKSk7XHJcbiAgICB9fVxyXG5cclxuLypjbGFzcyBDb25kaXRpb25hbFN0YXRlbWVudE5vZGUgZXh0ZW5kcyBTdGF0ZW1lbnROb2Rle1xyXG4gICAgY29uZGl0aW9uOkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIGlmOkNvbmRpdGlvbmFsQm9keU5vZGU7XHJcbiAgICBlbHNlOkNvbmRpdGlvbmFsQm9keU5vZGV8bnVsbDtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX0NvbmRpdGlvbkJvZHkpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbmRpdGlvbmFsQm9keU5vZGUgZXh0ZW5kcyBBU1ROb2Rle1xyXG4gICAgZXF1YXRpb25zOkVxdWF0aW9uTm9kZTtcclxuICAgIHNldHRlcnM6U2V0dGVyTm9kZTtcclxufSovXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IEJvb2xFeHByZXNzaW9uTm9kZSwgTWFjcm9TdGF0ZW1lbnROb2RlLCBOb2RlVHlwZSwgU3RhdGVtZW50Tm9kZSwgTG9vcFN0YXRlbWVudE5vZGUsIEVxdWF0aW9uTm9kZSwgSW5pdGlhbENvbmRpdGlvbk5vZGUsIFZhcklkZW50aWZpZXJOb2RlLCBFeHByZXNzaW9uTm9kZSwgQ29uc3RhbnROb2RlLCBDb25zdGFudFN0YXRlbWVudE5vZGUsIFN1bUV4cHJlc3Npb25Ob2RlLCBEZXJpdmF0aXZlTm9kZSwgTWFjcm9FeHByZXNzaW9uTm9kZSwgQWRkaXRpb25Ob2RlLCBNdWx0aXBsaWNhdGlvbk5vZGUsIEZ1bmN0aW9uTm9kZSwgU3VidHJhY3Rpb25Ob2RlLCBEaXZpc2lvbk5vZGUsIE5lZ2F0aW9uTm9kZSwgQm9vbEFuZE5vZGUsIEJvb2xPck5vZGUsIEJvb2xOZWdhdGlvbk5vZGUsIEJvb2xHTm9kZSwgQm9vbEdFTm9kZSwgQm9vbExOb2RlLCBCb29sQ29uc3RhbnROb2RlLCBCb29sTEVOb2RlLCBCb29sTkVOb2RlLCBCb29sRU5vZGUsIFRlcm5hcnlPcGVyYXRvck5vZGUsIEFTVE5vZGUsIFRleHRQb3NpdGlvbiB9IGZyb20gXCIuL2FzdE5vZGVcIjtcclxuaW1wb3J0IFZpc2l0b3IgZnJvbSBcIi4vdmlzaXRvclwiO1xyXG5pbXBvcnQgYW50bHI0LCB7IExleGVyLCBQYXJzZXIgfSBmcm9tIFwiYW50bHI0L2luZGV4XCI7XHJcbmltcG9ydCBvZGVHcmFtbWFyTGV4ZXIgZnJvbSBcIi4uL2dyYW1tYXIvYW50bHJPdXRwdXQvb2RlR3JhbW1hckxleGVyLmpzXCI7XHJcbmltcG9ydCBvZGVHcmFtbWFyUGFyc2VyIGZyb20gXCIuLi9ncmFtbWFyL2FudGxyT3V0cHV0L29kZUdyYW1tYXJQYXJzZXIuanNcIjtcclxuaW1wb3J0IEVycm9yTGlzdGVuZXIgZnJvbSBcIi4vZXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgRXJyb3JNZXNzYWdlIGZyb20gXCIuL2Vycm9yXCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24sIERpdmlzaW9ufSBmcm9tIFwiLi9leHByZXNzaW9uXCI7XHJcbmltcG9ydCB7IEN1c3RvbUVEQUVTeXN0ZW0gfSBmcm9tIFwiLi4vZGFlL2N1c3RvbUVEQUVTeXN0ZW1cIjtcclxuaW1wb3J0IHtDdXN0b21JREFFU3lzdGVtfSBmcm9tIFwiLi4vZGFlL2N1c3RvbUlEQUVTeXN0ZW1cIjtcclxuaW1wb3J0IHt2ZWN0b3J9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBFeHBDb21waWxlckNvbnRleHQsIGNvbXBpbGVFeHByZXNzaW9uLCBoYXNEZXJpdmF0aXZlIH0gZnJvbSBcIi4vZXhwcmVzc2lvbkNvbXBpbGVyXCI7XHJcbmltcG9ydCB7IENvbXBpbGVyQ29udGV4dCwgTWFjcm9Db250ZXh0LCBMb29wQ29udGV4dCB9IGZyb20gXCIuL2NvbXBpbGVyQ29udGV4dFwiO1xyXG5pbXBvcnQgeyBDb21waWxlckVycm9yIH0gZnJvbSBcIi4vY29tcGlsZXJFcnJvclwiO1xyXG5cclxuXHJcbmNsYXNzIFZhcmlhYmxlRW50cnl7XHJcbiAgICBuYW1lOnN0cmluZztcclxuICAgIGluaXRpYWxWYWx1ZTpudW1iZXI7XHJcbiAgICBpc0FsZ2VicmFpYzpib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IobmFtZTpzdHJpbmcsaXNBbGdlYnJhaWM6Ym9vbGVhbixpbml0aWFsVmFsdWU6bnVtYmVyID0gMCl7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICB0aGlzLmlzQWxnZWJyYWljID0gaXNBbGdlYnJhaWM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXF1YXRpb25FbnRyeXtcclxuICAgIGV4cHJlc3Npb246RXhwcmVzc2lvbk5vZGU7XHJcbiAgICBpc0FsZ2VicmFpYzpib29sZWFuO1xyXG4gICAgcmVhZG9ubHkgdGV4UG94OlRleHRQb3NpdGlvbjtcclxuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb246RXhwcmVzc2lvbk5vZGUsaXNBbGdlYnJhaWM6Ym9vbGVhbix0ZXhQb3M6VGV4dFBvc2l0aW9uKXtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgICAgIHRoaXMuaXNBbGdlYnJhaWMgPSBpc0FsZ2VicmFpYztcclxuICAgICAgICB0aGlzLnRleFBveCA9IHRleFBvcztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBEQUVDb21waWxlcntcclxuICAgIGNvbnN0YW50czpSZWNvcmQ8c3RyaW5nLG51bWJlcj47XHJcbiAgICB2YXJpYWJsZXM6UmVjb3JkPHN0cmluZyxWYXJpYWJsZUVudHJ5PjtcclxuICAgIG1hY3JvczpSZWNvcmQ8c3RyaW5nLE1hY3JvU3RhdGVtZW50Tm9kZT47XHJcbiAgICBlcXVhdGlvbnM6UmVjb3JkPHN0cmluZyxFcXVhdGlvbkVudHJ5PjtcclxuICAgIGVycm9yczpFcnJvck1lc3NhZ2VbXTtcclxuICAgIGNvbnRleHQ6IENvbXBpbGVyQ29udGV4dHxudWxsO1xyXG4gICAgZXBzaWxvbjpudW1iZXIgPSAwLjAwMTtcclxuICAgIGlzRXhwbGljaXQ6Ym9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKCl7ICAgICAgICBcclxuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hY3JvcyA9IHt9O1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVzID0ge307XHJcbiAgICAgICAgdGhpcy5jb25zdGFudHMgPSB7fTtcclxuICAgIH1cclxuICAgIGNvbXBpbGVFeHBsaWNpdCh0ZXh0OnN0cmluZyk6e3N5c3RlbTpDdXN0b21FREFFU3lzdGVtLHgwOnZlY3Rvcix4OnN0cmluZ1tdLHo6c3RyaW5nW119e1xyXG5cclxuICAgICAgICB0aGlzLmlzRXhwbGljaXQgPSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgY2hhcnMgPSBuZXcgYW50bHI0LklucHV0U3RyZWFtKHRleHQpO1xyXG4gICAgICAgIHZhciBsZXhlciA9IG5ldyBvZGVHcmFtbWFyTGV4ZXIub2RlR3JhbW1hckxleGVyKGNoYXJzKTtcclxuICAgICAgICAobGV4ZXIgYXMgdW5rbm93biBhcyBMZXhlcikucmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTtcclxuICAgICAgICB2YXIgbGlzdGVuZXIgPSBuZXcgRXJyb3JMaXN0ZW5lcih0aGlzLmVycm9ycyk7XHJcbiAgICAgICAgKGxleGVyIGFzIHVua25vd24gYXMgTGV4ZXIpLmFkZEVycm9yTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIGxleGVyLnN0cmljdE1vZGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgdG9rZW5zID0gbmV3IGFudGxyNC5Db21tb25Ub2tlblN0cmVhbShsZXhlciBhcyB1bmtub3duIGFzIExleGVyKTtcclxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IG9kZUdyYW1tYXJQYXJzZXIub2RlR3JhbW1hclBhcnNlcih0b2tlbnMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIChwYXJzZXIgYXMgdW5rbm93biBhcyBQYXJzZXIpLnJlbW92ZUVycm9yTGlzdGVuZXJzKCk7XHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikuYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgdmFyIHZpc2l0b3IgPSBuZXcgVmlzaXRvcigpO1xyXG4gICAgICAgIChwYXJzZXIgYXMgdW5rbm93biBhcyBQYXJzZXIpLmJ1aWxkUGFyc2VUcmVlcyA9IHRydWU7XHJcbiAgICAgICAgdmFyIHRyZWUgPSBwYXJzZXIuZGFlKCk7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0cmVlLnRvU3RyaW5nVHJlZShwYXJzZXIucnVsZU5hbWVzKSk7XHJcbiAgICAgICAgaWYodGhpcy5lcnJvcnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZXJFcnJvcih0aGlzLmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkYWVTeXN0ZW1EZWYgPSB2aXNpdG9yLnN0YXJ0REFFKHRyZWUsIGxpc3RlbmVyKTtcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGFlU3lzdGVtRGVmLnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlU3RhdGVtZW50KGl0ZW0pO1xyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgaWYodGhpcy5lcnJvcnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZXJFcnJvcih0aGlzLmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB4OnN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IHo6c3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgeDA6bnVtYmVyW10gPSBbXTtcclxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhYmxlcykuZm9yRWFjaChmdW5jdGlvbihba2V5LCB2YXJpYWJsZV0pe1xyXG4gICAgICAgICAgICBpZih2YXJpYWJsZS5pc0FsZ2VicmFpYylcclxuICAgICAgICAgICAgICAgIHoucHVzaChrZXkpO1xyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgeC5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICB4MC5wdXNoKHZhcmlhYmxlLmluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvL3ByZXBhcmUgdmFyaWFibGUgaW5kaWNpZXNcclxuICAgICAgICBsZXQgYWxnQ29udGV4dDpFeHBDb21waWxlckNvbnRleHQgPSB7aW5kaWNpZXM6e30sZXJyb3JzOnRoaXMuZXJyb3JzfTtcclxuICAgICAgICBsZXQgZGlmQ29udGV4dDpFeHBDb21waWxlckNvbnRleHQgPSB7aW5kaWNpZXM6e30sZXJyb3JzOnRoaXMuZXJyb3JzfTtcclxuICAgICAgICB4LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XHJcbiAgICAgICAgICAgIGFsZ0NvbnRleHQuaW5kaWNpZXNbaXRlbV0gPSBpbmRleDtcclxuICAgICAgICAgICAgZGlmQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICAgZGlmQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4ICsgeC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tcInRcIl0gPSB4Lmxlbmd0aDtcclxuICAgICAgICBkaWZDb250ZXh0LmluZGljaWVzW1widFwiXSA9IHgubGVuZ3RoICsgei5sZW5ndGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGY6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgbGV0IGc6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIHZhcmlhYmxlXSl7XHJcbiAgICAgICAgICAgIGlmKCFzZWxmLmVxdWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTWlzc2luZyBlcXVhdGlvbiBmb3IgdmFyaWFibGUgXCIke2tleX1cImApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXF1YXRpb24gPSBzZWxmLmVxdWF0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBpZih2YXJpYWJsZS5pc0FsZ2VicmFpYyE9ZXF1YXRpb24uaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKGVxdWF0aW9uLnRleFBveCxgTm9uIGNvbXBhdGlibGUgdHlwZXMgb2YgdmFyaWFibGUgYW5kIGVxdWF0aW9uIFwiJHtrZXl9XCJgKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodmFyaWFibGUuaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgZy5wdXNoKGNvbXBpbGVFeHByZXNzaW9uKGVxdWF0aW9uLmV4cHJlc3Npb24sYWxnQ29udGV4dCkuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgZi5wdXNoKGNvbXBpbGVFeHByZXNzaW9uKGVxdWF0aW9uLmV4cHJlc3Npb24sZGlmQ29udGV4dCkuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRmZHg6RXhwcmVzc2lvbltdW10gPSBbXTtcclxuICAgICAgICBsZXQgZGZkejpFeHByZXNzaW9uW11bXSA9IFtdO1xyXG4gICAgICAgIGxldCBkZ2R4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihfeCl7XHJcbiAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgdGhpcy5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgZGZkeC5wdXNoKGR4Um93KTtcclxuICAgICAgICAgICAgbGV0IGR6Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24oX3ope1xyXG4gICAgICAgICAgICAgICAgZHpSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3osIHRoaXMuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgIGRmZHoucHVzaChkelJvdyk7XHJcbiAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIGxldCBkeFJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKF94KXtcclxuICAgICAgICAgICAgICAgIGR4Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF94LCB0aGlzLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICBkZ2R4LnB1c2goZHhSb3cpO1xyXG4gICAgICAgIH0sdGhpcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB7c3lzdGVtOm5ldyBDdXN0b21FREFFU3lzdGVtKGYsZyxkZmR4LGRmZHosZGdkeCkseDA6bmV3IHZlY3Rvcih4MCkseDp4LHo6en07XHJcbiAgICB9XHJcbiAgICBjb21waWxlSW1wbGljaXQodGV4dDpzdHJpbmcpOntzeXN0ZW06Q3VzdG9tSURBRVN5c3RlbSx4MDp2ZWN0b3IseDpzdHJpbmdbXSx6MDp2ZWN0b3IsejpzdHJpbmdbXX17XHJcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBjaGFycyA9IG5ldyBhbnRscjQuSW5wdXRTdHJlYW0odGV4dCk7XHJcbiAgICAgICAgdmFyIGxleGVyID0gbmV3IG9kZUdyYW1tYXJMZXhlci5vZGVHcmFtbWFyTGV4ZXIoY2hhcnMpO1xyXG4gICAgICAgIChsZXhlciBhcyB1bmtub3duIGFzIExleGVyKS5yZW1vdmVFcnJvckxpc3RlbmVycygpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG5ldyBFcnJvckxpc3RlbmVyKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICAobGV4ZXIgYXMgdW5rbm93biBhcyBMZXhlcikuYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV4ZXIuc3RyaWN0TW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSBuZXcgYW50bHI0LkNvbW1vblRva2VuU3RyZWFtKGxleGVyIGFzIHVua25vd24gYXMgTGV4ZXIpO1xyXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyKHRva2Vucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikucmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTtcclxuICAgICAgICAocGFyc2VyIGFzIHVua25vd24gYXMgUGFyc2VyKS5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaXNpdG9yKCk7XHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikuYnVpbGRQYXJzZVRyZWVzID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdHJlZSA9IHBhcnNlci5kYWUoKTtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHRyZWUudG9TdHJpbmdUcmVlKHBhcnNlci5ydWxlTmFtZXMpKTtcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRhZVN5c3RlbURlZiA9IHZpc2l0b3Iuc3RhcnREQUUodHJlZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIGlmKHRoaXMuZXJyb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVyRXJyb3IodGhpcy5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYWVTeXN0ZW1EZWYuc3RhdGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVTdGF0ZW1lbnQoaXRlbSk7XHJcbiAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgbGV0IHg6c3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgejpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCB4MDpudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGxldCB6MDpudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIHZhcmlhYmxlXSl7XHJcbiAgICAgICAgICAgIGlmKHZhcmlhYmxlLmlzQWxnZWJyYWljKXtcclxuICAgICAgICAgICAgICAgIHoucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgejAucHVzaCh2YXJpYWJsZS5pbml0aWFsVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB4LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIHgwLnB1c2godmFyaWFibGUuaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL3ByZXBhcmUgdmFyaWFibGUgaW5kaWNpZXNcclxuICAgICAgICAvL3gseix0XHJcbiAgICAgICAgbGV0IGFsZ0NvbnRleHQ6RXhwQ29tcGlsZXJDb250ZXh0ID0ge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc307XHJcbiAgICAgICAgLy94LGR4LHosdFxyXG4gICAgICAgIGxldCBkaWZDb250ZXh0OkV4cENvbXBpbGVyQ29udGV4dCA9IHtpbmRpY2llczp7fSxlcnJvcnM6dGhpcy5lcnJvcnN9O1xyXG4gICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4O1xyXG4gICAgICAgICAgICBkaWZDb250ZXh0LmluZGljaWVzW2l0ZW1dID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbStcIidcIl0gPSBpbmRleCArIHgubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4ICsgeC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbV0gPSBpbmRleCArIDIqeC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tcInRcIl0gPSB4Lmxlbmd0aCArIHoubGVuZ3RoO1xyXG4gICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbXCJ0XCJdID0gMip4Lmxlbmd0aCArIHoubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFsZ0VxdWF0aW9uczpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCBkaWZFcXVhdGlvbnM6c3RyaW5nW10gPSBbXTtcclxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVxdWF0aW9ucykuZm9yRWFjaChmdW5jdGlvbihba2V5LHZhbHVlXSl7XHJcbiAgICAgICAgICAgIGlmKHZhbHVlLmlzQWxnZWJyYWljKVxyXG4gICAgICAgICAgICAgICAgYWxnRXF1YXRpb25zLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGlmRXF1YXRpb25zLnB1c2goa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZihkaWZFcXVhdGlvbnMubGVuZ3RoIT14Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShUZXh0UG9zaXRpb24uaW52YWxpZCgpLGBOdW1iZXIgb2YgZGlmLiBlcXVhdGlvbnM6ICR7ZGlmRXF1YXRpb25zLmxlbmd0aH0sIGRpZi4gdmFyaWFibGVzOiAke3gubGVuZ3RofWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoYWxnRXF1YXRpb25zLmxlbmd0aCE9ei5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTnVtYmVyIG9mIGFsZy4gZXF1YXRpb25zOiAke2FsZ0VxdWF0aW9ucy5sZW5ndGh9LCBhbGcuIHZhcmlhYmxlczogJHt6Lmxlbmd0aH1gKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZjpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICBsZXQgZzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgICAgIGFsZ0VxdWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsKXtcclxuICAgICAgICAgICAgbGV0IGVxdWF0aW9uID0gc2VsZi5lcXVhdGlvbnNbbGFiZWxdO1xyXG4gICAgICAgICAgICBnLnB1c2goY29tcGlsZUV4cHJlc3Npb24oZXF1YXRpb24uZXhwcmVzc2lvbiwgYWxnQ29udGV4dCkuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgfSx0aGlzKTtcclxuXHJcbiAgICAgICAgZGlmRXF1YXRpb25zLmZvckVhY2goZnVuY3Rpb24obGFiZWwpe1xyXG4gICAgICAgICAgICBsZXQgZXF1YXRpb24gPSBzZWxmLmVxdWF0aW9uc1tsYWJlbF07XHJcbiAgICAgICAgICAgIGYucHVzaChjb21waWxlRXhwcmVzc2lvbihlcXVhdGlvbi5leHByZXNzaW9uLCBkaWZDb250ZXh0KS5zaW1wbGlmeSgpKTtcclxuICAgICAgICB9LHRoaXMpO1xyXG5cclxuICAgICAgICBpZihhbGdDb250ZXh0LmVycm9ycy5sZW5ndGg+MHx8ZGlmQ29udGV4dC5lcnJvcnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZXJFcnJvcihhbGdDb250ZXh0LmVycm9ycy5jb25jYXQoZGlmQ29udGV4dC5lcnJvcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBkZmR4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgbGV0IGRmZGR4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgbGV0IGRmZHo6RXhwcmVzc2lvbltdW10gPSBbXTtcclxuICAgICAgICBsZXQgZGdkeDpFeHByZXNzaW9uW11bXSA9IFtdO1xyXG4gICAgICAgIGxldCBkZ2R6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihfeCl7XHJcbiAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgdGhpcy5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIGRkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCArIFwiJ1wiLCB0aGlzLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICBkZmR4LnB1c2goZHhSb3cpO1xyXG4gICAgICAgICAgICBkZmRkeC5wdXNoKGRkeFJvdyk7XHJcbiAgICAgICAgICAgIGxldCBkelJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgei5mb3JFYWNoKGZ1bmN0aW9uKF96KXtcclxuICAgICAgICAgICAgICAgIGR6Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF96LCB0aGlzLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgICAgICBkZmR6LnB1c2goZHpSb3cpO1xyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihfeCl7XHJcbiAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgdGhpcy5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICAgICAgZGdkeC5wdXNoKGR4Um93KTtcclxuICAgICAgICAgICAgbGV0IGR6Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24oX3ope1xyXG4gICAgICAgICAgICAgICAgZHpSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3osIHRoaXMuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgIH0sdGhpcyk7XHJcbiAgICAgICAgICAgIGRnZHoucHVzaChkelJvdyk7XHJcbiAgICAgICAgfSx0aGlzKVxyXG5cclxuICAgICAgICByZXR1cm4ge3N5c3RlbTpuZXcgQ3VzdG9tSURBRVN5c3RlbShmLGcsZGZkeCxkZmRkeCxkZmR6LGRnZHgsZGdkeikseDA6bmV3IHZlY3Rvcih4MCkseDp4LHowOm5ldyB2ZWN0b3IoejApLHo6en07XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZ2V0U3ltYm9sTmFtZShub2RlOlZhcklkZW50aWZpZXJOb2RlKTpzdHJpbmd7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5vZGUuaWQ7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUuaW5kaWNpZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICBsZXQgaW5kZXhWYWx1ZSA9IChjb21waWxlRXhwcmVzc2lvbihzZWxmLmV4cGFuZEV4cHJlc3Npb24oaXRlbS5jbG9uZSgpKSx7aW5kaWNpZXM6e30sZXJyb3JzOnNlbGYuZXJyb3JzfSkpLmV2YWwoe30pO1xyXG4gICAgICAgICAgICBpZihOdW1iZXIuaXNJbnRlZ2VyKGluZGV4VmFsdWUpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCs9YFske2luZGV4VmFsdWV9XWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgRXhwcmVzc2lvbiBmb3IgJHtpbmRleH0gaW5kZXggdmFsdWUgb2YgdmFyaWFibGUgXCIke25vZGUuaWR9XCIgaXMgbm90IGNvbnN0YW50YCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBleHBhbmRCb29sRXhwcmVzc2lvbihub2RlOkV4cHJlc3Npb25Ob2RlKTpCb29sRXhwcmVzc2lvbk5vZGV7XHJcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0FuZDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgYW5kID0gbm9kZSBhcyBCb29sQW5kTm9kZTtcclxuICAgICAgICAgICAgICAgIGFuZC5sZWZ0ID0gdGhpcy5leHBhbmRCb29sRXhwcmVzc2lvbihhbmQubGVmdCk7XHJcbiAgICAgICAgICAgICAgICBhbmQucmlnaHQgPSB0aGlzLmV4cGFuZEJvb2xFeHByZXNzaW9uKGFuZC5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX09yOntcclxuICAgICAgICAgICAgICAgIGxldCBvciA9IG5vZGUgYXMgQm9vbE9yTm9kZTtcclxuICAgICAgICAgICAgICAgIG9yLmxlZnQgPSB0aGlzLmV4cGFuZEJvb2xFeHByZXNzaW9uKG9yLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgb3IucmlnaHQgPSB0aGlzLmV4cGFuZEJvb2xFeHByZXNzaW9uKG9yLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9Ob3Q6e1xyXG4gICAgICAgICAgICAgICAgbGV0IG5vdCA9IG5vZGUgYXMgQm9vbE5lZ2F0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgIG5vdC5pbm5lciA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihub3QuaW5uZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9HcmVhdGVyOntcclxuICAgICAgICAgICAgICAgIGxldCBnID0gbm9kZSBhcyBCb29sR05vZGU7XHJcbiAgICAgICAgICAgICAgICBnLmxlZnQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZy5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGcucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZy5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9HcmVhdGVyRXF1YWw6e1xyXG4gICAgICAgICAgICAgICAgbGV0IGdlID0gbm9kZSBhcyBCb29sR0VOb2RlO1xyXG4gICAgICAgICAgICAgICAgZ2UubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihnZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGdlLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGdlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9MZXNzOntcclxuICAgICAgICAgICAgICAgIGxldCBsID0gbm9kZSBhcyBCb29sTE5vZGU7XHJcbiAgICAgICAgICAgICAgICBsLmxlZnQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obC5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGwucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obC5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9MZXNzRXF1YWw6e1xyXG4gICAgICAgICAgICAgICAgbGV0IGxlID0gbm9kZSBhcyBCb29sTEVOb2RlO1xyXG4gICAgICAgICAgICAgICAgbGUubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihsZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGxlLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGxlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9FcXVhbDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IG5vZGUgYXMgQm9vbEVOb2RlO1xyXG4gICAgICAgICAgICAgICAgZS5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGUubGVmdCk7XHJcbiAgICAgICAgICAgICAgICBlLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fTm90RXF1YWw6e1xyXG4gICAgICAgICAgICAgICAgbGV0IG5lID0gbm9kZSBhcyBCb29sTkVOb2RlO1xyXG4gICAgICAgICAgICAgICAgbmUubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihuZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIG5lLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG5lLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9Cb29sQ29uc3RhbnQ6e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsXCJVbmV4cGVjdGVkIGJvb2xlYW4gZXhwcmVzc2lvbiB0eXBlIGF0IGV4cGFuZEJvb2xFeHByZXNzaW9uKClcIikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sQ29uc3RhbnROb2RlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZXhwYW5kRXhwcmVzc2lvbihub2RlOkV4cHJlc3Npb25Ob2RlKTpFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXsgICBcclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fQWRkaXRpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlIGFzIEFkZGl0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihhZGQubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGFkZC5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fU3VidHJhY3Rpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWIgPSBub2RlIGFzIFN1YnRyYWN0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihzdWIubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKHN1Yi5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fTXVsdGlwbGljYXRpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtdWx0ID0gbm9kZSBhcyBNdWx0aXBsaWNhdGlvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdC5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG11bHQubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdC5yaWdodCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihtdWx0LnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXVsdDtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0RpdmlzaW9uOntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ID0gbm9kZSBhcyBEaXZpc2lvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmxlZnQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZGl2LmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5yaWdodCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihkaXYucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX05lZ2F0aW9uOntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmVnID0gbm9kZSBhcyBOZWdhdGlvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVnLmlubmVyID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG5lZy5pbm5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fRGVyaXZhdGl2ZTp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlciA9IG5vZGUgYXMgRGVyaXZhdGl2ZU5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGRlci5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaWQgaW5zdGFuY2VvZiBWYXJJZGVudGlmaWVyTm9kZSAmJiBpZC5pZCAhPSBcInRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KGlkLmlkKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1tpZC5pZF0uaXNBbGdlYnJhaWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1tpZC5pZF0gPSBuZXcgVmFyaWFibGVFbnRyeShpZC5pZCxmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVyLmlkID0gaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEluY29ycmVjdCBzeW1ib2wgaW4gZGVyaXZhdGl2ZWApKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fRnVuY3Rpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdW4gPSBub2RlIGFzIEZ1bmN0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDtpPGZ1bi5hcmdzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW4uYXJnc1tpXSA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihmdW4uYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX1ZhcklkZW50aWZpZXI6e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBfdmFyID0gbm9kZSBhcyBWYXJJZGVudGlmaWVyTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihfdmFyLmluZGljaWVzLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoX2NvbnRleHQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2NvbnRleHQgaW5zdGFuY2VvZiBMb29wQ29udGV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2NvbnRleHQuaXRlcmF0b3IgPT0gX3Zhci5pZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKF9jb250ZXh0LmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZihfY29udGV4dCBpbnN0YW5jZW9mIE1hY3JvQ29udGV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2NvbnRleHQuYXJncy5oYXNPd25Qcm9wZXJ0eShfdmFyLmlkKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEV4cHJlc3Npb24oX2NvbnRleHQuYXJnc1tfdmFyLmlkXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dCA9IF9jb250ZXh0LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF92YXIuaWQgPSB0aGlzLmdldFN5bWJvbE5hbWUoX3Zhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Zhci5pbmRpY2llcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KF92YXIuaWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUodGhpcy5jb25zdGFudHNbX3Zhci5pZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihfdmFyLmlkIT1cInRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLnZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShfdmFyLmlkKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1tfdmFyLmlkXSA9IG5ldyBWYXJpYWJsZUVudHJ5KF92YXIuaWQsdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0NvbnN0YW50OntcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fU3VtbWF0aW9uOntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3VtbWF0aW9uID0gbm9kZSBhcyBTdW1FeHByZXNzaW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzdW1tYXRpb24uYm91bmRzLmw+c3VtbWF0aW9uLmJvdW5kcy5yKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgTGVmdCBib3VuZCBvZiBzdW1tYXRpb24gaXMgYmlnZ2VyIHRoZW4gcmlnaHQgYm91bmRgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3VtOkV4cHJlc3Npb25Ob2RlW10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgX2NvbnRleHQgPSBuZXcgTG9vcENvbnRleHQodGhpcy5jb250ZXh0LHN1bW1hdGlvbi5pdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPXN1bW1hdGlvbi5ib3VuZHMubDtpPD1zdW1tYXRpb24uYm91bmRzLnI7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQuaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0ucHVzaCh0aGlzLmV4cGFuZEV4cHJlc3Npb24oc3VtbWF0aW9uLmV4cHJlc3Npb24uY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGlzLmV4cGFuZEV4cHJlc3Npb24oc3VtbWF0aW9uLmV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY29udGV4dC5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OkV4cHJlc3Npb25Ob2RlID0gc3VtWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1bS5sZW5ndGg9PTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMTtpPHN1bS5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFkZGl0aW9uTm9kZShyZXN1bHQsIHN1bVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX01hY3JvOntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWFjcm8gPSBub2RlIGFzIE1hY3JvRXhwcmVzc2lvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hY3JvTmFtZSA9IHRoaXMuZ2V0U3ltYm9sTmFtZShtYWNyby5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hY3JvRGVmID0gdGhpcy5tYWNyb3NbbWFjcm9OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihtYWNyb0RlZj09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgVW5kZWZpbmVkIG1hY3JvIFwiJHttYWNyb05hbWV9XCJgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihtYWNyb0RlZi5hcmdzLmxlbmd0aCAhPSBtYWNyby5hcmdzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBtYWNybyBcIiR7bWFjcm9OYW1lfVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ3M6UmVjb3JkPHN0cmluZyxFeHByZXNzaW9uTm9kZT4gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBtYWNyby5hcmdzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbbWFjcm9EZWYuYXJnc1tpbmRleF1dID0gaXRlbS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IE1hY3JvQ29udGV4dCh0aGlzLmNvbnRleHQsYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihtYWNyb0RlZi5leHByZXNzaW9uLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY29udGV4dC5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9UZXJuYXJ5OntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVyID0gbm9kZSBhcyBUZXJuYXJ5T3BlcmF0b3JOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlci5jb25kaXRpb24gPSB0aGlzLmV4cGFuZEJvb2xFeHByZXNzaW9uKHRlci5jb25kaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlci50cnVlID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKHRlci50cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXIuZmFsc2UgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24odGVyLmZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxcIlVuZXhwZWN0ZWQgZXhwcmVzc2lvbiB0eXBlIGF0IHZhbGlkYXRlRXhwcmVzc2lvbigpXCIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlQ29uc3RhbnQobm9kZTpDb25zdGFudFN0YXRlbWVudE5vZGUpe1xyXG4gICAgICAgIGxldCBjb25zdGFudCA9IHRoaXMuZ2V0U3ltYm9sTmFtZShub2RlLmlkKTtcclxuICAgICAgICBpZihjb25zdGFudCA9PSBcInRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsJ0ludmFsaWQgdXNlIG9mIHRpbWUgdmFyaWFibGUnKSk7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy52YXJpYWJsZXMuaGFzT3duUHJvcGVydHkoY29uc3RhbnQpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmVkZWZlbml0aW9uIG9mIHZhcmlhYmxlIFwiJHtjb25zdGFudH1cImApKTtcclxuICAgICAgICB9ZWxzZSBpZih0aGlzLmNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShjb25zdGFudCkpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBSZWRlZmVuaXRpb24gb2YgY29uc3RhbnQgXCIke2NvbnN0YW50fVwiYCkpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0YW50c1tjb25zdGFudF0gPSAoY29tcGlsZUV4cHJlc3Npb24odGhpcy5leHBhbmRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbi5jbG9uZSgpKSx7aW5kaWNpZXM6e30sZXJyb3JzOnRoaXMuZXJyb3JzfSkpLmV2YWwoe30pO1xyXG4gICAgICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxlcnJvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVJbml0aWFsQ29uZGl0aW9uKG5vZGU6SW5pdGlhbENvbmRpdGlvbk5vZGUpe1xyXG4gICAgICAgIGxldCB2YXJpYWJsZSA9IHRoaXMuZ2V0U3ltYm9sTmFtZShub2RlLmlkKTtcclxuICAgICAgICBsZXQgdmFsdWU6bnVtYmVyID0gMDtcclxuICAgICAgICBpZih2YXJpYWJsZSA9PSBcInRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgdXNlIG9mIHRpbWUgdmFyaWFibGVgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW52YWxpZCB1c2Ugb2YgY29uc3RhbnQgXCIke3ZhcmlhYmxlfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgdmFsdWUgPSAoY29tcGlsZUV4cHJlc3Npb24odGhpcy5leHBhbmRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbi5jbG9uZSgpKSwge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc30pKS5ldmFsKHt9KTtcclxuICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBDYW4ndCBldmFsdWF0ZSBpbml0aWFsIGNvbmRpdGlvbiBmb3IgdmFyaWFibGUgXCIke3ZhcmlhYmxlfVwiYCkpO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGVycm9yKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy52YXJpYWJsZXMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0gPSBuZXcgVmFyaWFibGVFbnRyeSh2YXJpYWJsZSx0cnVlLHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZUFsZ0VxdWF0aW9uKG5vZGU6RXF1YXRpb25Ob2RlKXtcclxuICAgICAgICBsZXQgdmFyaWFibGUgPSB0aGlzLmdldFN5bWJvbE5hbWUobm9kZS5sZWZ0IGFzIFZhcklkZW50aWZpZXJOb2RlKTtcclxuICAgICAgICBpZih0aGlzLmVxdWF0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YXJpYWJsZSkpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBNdWx0aXBsZSBlcXVhdGlvbnMgZm9yIHZhcmlhYmxlIFwiJHt2YXJpYWJsZX1cImApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih2YXJpYWJsZSA9PSBcInRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgdXNlIG9mIHRpbWUgdmFyaWFibGVgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW52YWxpZCB1c2Ugb2YgY29uc3RhbnQgXCIke3ZhcmlhYmxlfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KHZhcmlhYmxlKSl7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW3ZhcmlhYmxlXSA9IG5ldyBWYXJpYWJsZUVudHJ5KHZhcmlhYmxlLHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXF1YXRpb24gPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obm9kZS5yaWdodC5jbG9uZSgpKTtcclxuICAgICAgICAvL3JpZ2h0IHNpZGUgc2hvdWxkbid0IGhhdmUgYW55IGRlcml2YXRpdmVzXHJcbiAgICAgICAgaWYoaGFzRGVyaXZhdGl2ZShlcXVhdGlvbikpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBSaWdodCBoYW5kIHNpZGUgZXhwcmVzc2lvbiBmb3IgdmFyaWFibGUgXCIke3ZhcmlhYmxlfVwiIGNvbnRhaW5zIGRlcml2YXRpdmVzYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zW3ZhcmlhYmxlXSA9IG5ldyBFcXVhdGlvbkVudHJ5KGVxdWF0aW9uLHRydWUsbm9kZS50ZXh0UG9zKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlRGlmRXF1YXRpb24obm9kZTpFcXVhdGlvbk5vZGUpe1xyXG4gICAgICAgIGxldCB2YXJpYWJsZSA9IHRoaXMuZ2V0U3ltYm9sTmFtZSgobm9kZS5sZWZ0IGFzIERlcml2YXRpdmVOb2RlKS5pZCk7XHJcbiAgICAgICAgaWYodGhpcy5lcXVhdGlvbnMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgTXVsdGlwbGUgZXF1YXRpb25zIGZvciB2YXJpYWJsZSBcIiR7dmFyaWFibGV9XCJgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodmFyaWFibGUgPT0gXCJ0XCIpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBJbnZhbGlkIHVzZSBvZiBjb25zdGFudCBcIiR7dmFyaWFibGV9XCJgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmVkZWZlbml0aW9uIG9mIGNvbnN0YW50IFwiJHt2YXJpYWJsZX1cImApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLnZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eSh2YXJpYWJsZSkpe1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0uaXNBbGdlYnJhaWMgPSBmYWxzZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdID0gbmV3IFZhcmlhYmxlRW50cnkodmFyaWFibGUsZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXF1YXRpb24gPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obm9kZS5yaWdodC5jbG9uZSgpKTtcclxuICAgICAgICBpZihoYXNEZXJpdmF0aXZlKGVxdWF0aW9uKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYFJpZ2h0IGhhbmQgc2lkZSBleHByZXNzaW9uIGZvciB2YXJpYWJsZSBcIiR7dmFyaWFibGV9XCIgY29udGFpbnMgZGVyaXZhdGl2ZXNgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lcXVhdGlvbnNbdmFyaWFibGVdID0gbmV3IEVxdWF0aW9uRW50cnkoZXF1YXRpb24sZmFsc2Usbm9kZS50ZXh0UG9zKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlRXhwbGljaXRFcXVhdGlvbihub2RlOkVxdWF0aW9uTm9kZSl7XHJcbiAgICAgICAgaWYobm9kZS5sZWZ0IGluc3RhbmNlb2YgVmFySWRlbnRpZmllck5vZGUpe1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVBbGdFcXVhdGlvbihub2RlKTtcclxuICAgICAgICB9ZWxzZSBpZihub2RlLmxlZnQgaW5zdGFuY2VvZiBEZXJpdmF0aXZlTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZURpZkVxdWF0aW9uKG5vZGUpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBFcXVhdGlvbiBzaG91bGQgYmUgaW4gZXhwbGljaXQgZm9ybWApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZUltcGxpY2l0RXF1YXRpb24obm9kZTpFcXVhdGlvbk5vZGUpe1xyXG4gICAgICAgIGxldCBsYWJlbCA9IChub2RlLmxhYmVsIT1udWxsP3RoaXMuZ2V0U3ltYm9sTmFtZShub2RlLmxhYmVsKTooT2JqZWN0LmtleXModGhpcy5lcXVhdGlvbnMpLmxlbmd0aCsxKSk7XHJcbiAgICAgICAgbGV0IGVxdWF0aW9uOkV4cHJlc3Npb25Ob2RlID0gbmV3IFN1YnRyYWN0aW9uTm9kZShub2RlLmxlZnQsbm9kZS5yaWdodCk7XHJcbiAgICAgICAgZXF1YXRpb24gPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZXF1YXRpb24uY2xvbmUoKSk7Ly9UT0RPIGFkZCB2YXJpYWJsZXMgdG8gdmFyaWFibGVzVGFibGUgYW5kIHJlbW92ZSB2YWxpZGF0ZVxyXG4gICAgICAgIHRoaXMuZXF1YXRpb25zW2xhYmVsXSA9IG5ldyBFcXVhdGlvbkVudHJ5KGVxdWF0aW9uLCFoYXNEZXJpdmF0aXZlKGVxdWF0aW9uKSxub2RlLnRleHRQb3MpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVMb29wKG5vZGU6TG9vcFN0YXRlbWVudE5vZGUpe1xyXG4gICAgICAgIGxldCBfY29udGV4dCA9IG5ldyBMb29wQ29udGV4dCh0aGlzLmNvbnRleHQsbm9kZS5pdGVyYXRvcik7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgbGV0IHN0YXRlbWVudHMgPSBub2RlLnN0YXRlbWVudHM7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLmZvckVhY2goZnVuY3Rpb24oYm91bmRzKXtcclxuICAgICAgICAgICAgaWYoYm91bmRzLmw+Ym91bmRzLnIpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgTGVmdCBib3VuZCB2YWx1ZSBcIiR7Ym91bmRzLmx9XCIgaXMgaGlnaGVyIHRoZW4gcmlnaHQgYm91bmQgdmFsdWUgXCIke2JvdW5kcy5yfVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IGJvdW5kcy5sO2k8PWJvdW5kcy5yO2krKyl7XHJcbiAgICAgICAgICAgICAgICBfY29udGV4dC5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oc3RhdGVtZW50KXtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbXBpbGVTdGF0ZW1lbnQoc3RhdGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jb250ZXh0LnByZXZpb3VzO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVNYWNybyhub2RlOk1hY3JvU3RhdGVtZW50Tm9kZSl7XHJcbiAgICAgICAgbGV0IG1hY3JvTmFtZSA9IHRoaXMuZ2V0U3ltYm9sTmFtZShub2RlLmlkKTtcclxuICAgICAgICBpZih0aGlzLm1hY3Jvcy5oYXNPd25Qcm9wZXJ0eShtYWNyb05hbWUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmVkZWZlbml0aW9uIG9mIG1hY3JvIFwiJHttYWNyb05hbWV9XCJgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYWNyb3NbbWFjcm9OYW1lXSA9IG5vZGU7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZVN0YXRlbWVudChub2RlOlN0YXRlbWVudE5vZGUpOnZvaWR7XHJcbiAgICAgICAgc3dpdGNoKG5vZGUudHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0NvbnN0YW50U3RhdGVtZW50OntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVDb25zdGFudChub2RlIGFzIENvbnN0YW50U3RhdGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0luaXRpYWxDb25kaXRpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZUluaXRpYWxDb25kaXRpb24obm9kZSBhcyBJbml0aWFsQ29uZGl0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0VxdWF0aW9uOntcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmlzRXhwbGljaXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZUV4cGxpY2l0RXF1YXRpb24obm9kZSBhcyBFcXVhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlSW1wbGljaXRFcXVhdGlvbihub2RlIGFzIEVxdWF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0xvb3A6e1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZUxvb3Aobm9kZSBhcyBMb29wU3RhdGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX01hY3JvRGVmaW5pdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlTWFjcm8obm9kZSBhcyBNYWNyb1N0YXRlbWVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgVW5leHBlY3RlZCBzdGF0ZW1lbnQgdHlwZSBhdCBjb21waWxlU3RhdGVtZW50KClgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgRXhwcmVzc2lvbk5vZGUgfSBmcm9tIFwiLi9hc3ROb2RlXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb21waWxlckNvbnRleHR7XHJcbiAgICBwcmV2aW91czpDb21waWxlckNvbnRleHQ7XHJcbiAgICBpbmRleDpudW1iZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91czpDb21waWxlckNvbnRleHQpe1xyXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgTG9vcENvbnRleHQgZXh0ZW5kcyBDb21waWxlckNvbnRleHR7XHJcbiAgICBpdGVyYXRvcjpzdHJpbmc7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmV2aW91czpDb21waWxlckNvbnRleHQsaXRlcmF0b3I6c3RyaW5nKXtcclxuICAgICAgICBzdXBlcihwcmV2aW91cyk7XHJcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBNYWNyb0NvbnRleHQgZXh0ZW5kcyBDb21waWxlckNvbnRleHR7XHJcbiAgICBhcmdzOlJlY29yZDxzdHJpbmcsRXhwcmVzc2lvbk5vZGU+O1xyXG4gICAgY29uc3RydWN0b3IocHJldmlvdXM6Q29tcGlsZXJDb250ZXh0LGFyZ3M6UmVjb3JkPHN0cmluZyxFeHByZXNzaW9uTm9kZT4pe1xyXG4gICAgICAgIHN1cGVyKHByZXZpb3VzKTtcclxuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEVycm9yTWVzc2FnZSBmcm9tIFwiLi9lcnJvclwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBDb21waWxlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgbWVzc2FnZXM6IEVycm9yTWVzc2FnZVtdO1xyXG4gICAgY29uc3RydWN0b3IobWVzc2FnZXM6IEVycm9yTWVzc2FnZVtdKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgVGV4dFBvc2l0aW9uIH0gZnJvbSBcIi4vYXN0Tm9kZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXJyb3JNZXNzYWdle1xyXG4gICAgdGV4dFBvczpUZXh0UG9zaXRpb247XHJcbiAgICBtZXNzYWdlOnN0cmluZztcclxuICAgIGNvbnN0cnVjdG9yKHRleHRQb3M6VGV4dFBvc2l0aW9uLG1lc3NhZ2U6c3RyaW5nKXtcclxuICAgICAgdGhpcy50ZXh0UG9zID0gdGV4dFBvcztcclxuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgIH1cclxuICAgIHByaW50KCl7XHJcbiAgICAgIGlmKHRoaXMudGV4dFBvcy5saW5lIT0tMSlcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5tZXNzYWdlfSBhdCBsaW5lOiR7dGhpcy50ZXh0UG9zLmxpbmV9LCBwb3NpdGlvbjoke3RoaXMudGV4dFBvcy5jb2x1bW59YDtcclxuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcclxuICAgIH1cclxuICB9IiwiaW1wb3J0IGFudGxyNCBmcm9tIFwiYW50bHI0L2Vycm9yL1wiO1xyXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgRXJyb3JNZXNzYWdlIGZyb20gXCIuL2Vycm9yXCI7XHJcbmltcG9ydCB7IFRva2VuLCBSZWNvZ25pemVyIH0gZnJvbSBcImFudGxyNFwiO1xyXG5pbXBvcnQgeyBUZXh0UG9zaXRpb24gfSBmcm9tIFwiLi9hc3ROb2RlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckxpc3RlbmVyIGV4dGVuZHMgYW50bHI0LkVycm9yTGlzdGVuZXIge1xyXG4gICAgZXJyb3JzOkVycm9yTWVzc2FnZVtdO1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3JzOkVycm9yTWVzc2FnZVtdKXtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBzeW50YXhFcnJvcihyZWNvZ25pemVyOiBSZWNvZ25pemVyLCBvZmZlbmRpbmdTeW1ib2w6IFRva2VuLCBsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyLCBtc2c6IHN0cmluZywgZTogYW55KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShuZXcgVGV4dFBvc2l0aW9uKGxpbmUsY29sdW1uLG9mZmVuZGluZ1N5bWJvbC5zdGFydCxvZmZlbmRpbmdTeW1ib2wuc3RvcCksIG1zZykpXHJcbiAgICB9XHJcbiAgICBhZGQodGV4dFBvczpUZXh0UG9zaXRpb24sbXNnOnN0cmluZyl7XHJcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZSh0ZXh0UG9zLG1zZykpO1xyXG4gICAgfVxyXG4gIH0iLCJpbXBvcnQgeyBmdW5jdGlvbkRpY3Rpb25hcnksRnVuY3Rpb25EZWYgfSBmcm9tIFwiLi9mdW5jdGlvbnNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBOb2RlVHlwZSA9IHtcclxuICAgIF9Db25zdGFudDowLFxyXG4gICAgX0Z1bmN0aW9uOjEsXHJcbiAgICBfVmFyaWFibGU6MixcclxuICAgIF9UZXJuYXJ5OjMsXHJcbiAgICBfRGl2aXNpb246NCxcclxuICAgIF9NdWx0aXBsaWNhdGlvbjo1LFxyXG4gICAgX05lZ2F0aW9uOjYsXHJcbiAgICBfU3VidHJhY3Rpb246NyxcclxuICAgIF9BZGRpdGlvbjo4XHJcbn07XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRXhwcmVzc2lvbntcclxuICAgIHR5cGU6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3IodHlwZTpudW1iZXIpe1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICB9XHJcbiAgICBhYnN0cmFjdCBjbG9uZSgpOkV4cHJlc3Npb247XHJcblx0YWJzdHJhY3QgZGlmZmVyZW50aWF0ZSh2YXJpYWJsZTpzdHJpbmcsZXBzaWxvbjpudW1iZXIpOkV4cHJlc3Npb247XHJcbiAgICBhYnN0cmFjdCBldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6bnVtYmVyO1xyXG4gICAgYWJzdHJhY3QgZXhlY3V0ZSh2YXJpYWJsZVZhbHVlczpudW1iZXJbXSk6bnVtYmVyO1xyXG5cdGFic3RyYWN0IHNpbXBsaWZ5KCk6RXhwcmVzc2lvbjtcclxuXHRhYnN0cmFjdCBwcmludCgpOnN0cmluZztcclxufVxyXG5leHBvcnQgY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBFeHByZXNzaW9ue1xyXG4gICAgdmFsdWU6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3IodmFsdWU6bnVtYmVyKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fQ29uc3RhbnQpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNsb25lKCk6RXhwcmVzc2lvbntcclxuICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50KHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cdGRpZmZlcmVudGlhdGUodmFyaWFibGU6c3RyaW5nLCBlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdHJldHVybiBuZXcgQ29uc3RhbnQoMC4wKTtcclxuXHR9XHJcbiAgICBldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZSh2YXJpYWJsZVZhbHVlczpudW1iZXJbXSk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2ltcGxpZnkoKTpFeHByZXNzaW9ue1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE5lZ2F0aW9uIGV4dGVuZHMgRXhwcmVzc2lvbntcclxuICAgIGlubmVyOkV4cHJlc3Npb247XHJcbiAgICBjb25zdHJ1Y3Rvcihpbm5lcjpFeHByZXNzaW9uKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fTmVnYXRpb24pO1xyXG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcclxuICAgIH1cclxuICAgIGNsb25lKCl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGlvbih0aGlzLmlubmVyLmNsb25lKCkpO1xyXG4gICAgfVxyXG5cdGRpZmZlcmVudGlhdGUodmFyaWFibGU6c3RyaW5nLCBlcHNpbG9uOm51bWJlcil7XHJcblx0XHRyZXR1cm4gbmV3IE5lZ2F0aW9uKHRoaXMuaW5uZXIuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSxlcHNpbG9uKSk7XHJcblx0fVxyXG4gICAgZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOm51bWJlcntcclxuICAgICAgICByZXR1cm4gLXRoaXMuaW5uZXIuZXZhbCh2YXJpYWJsZU1hcCk7XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIC10aGlzLmlubmVyLmV4ZWN1dGUodmFyaWFibGVWYWx1ZXMpO1xyXG4gICAgfVxyXG5cdHNpbXBsaWZ5KCl7XHJcblx0XHRsZXQgbm9kZSA9IHRoaXMuaW5uZXIuc2ltcGxpZnkoKTtcclxuXHRcdGlmKG5vZGUgaW5zdGFuY2VvZiBDb25zdGFudClcclxuXHRcdFx0cmV0dXJuIG5ldyBDb25zdGFudCgtbm9kZS52YWx1ZSk7XHJcblx0XHRpZihub2RlIGluc3RhbmNlb2YgTmVnYXRpb24pe1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5pbm5lcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTmVnYXRpb24obm9kZSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0bGV0IGFyZyA9IHRoaXMuaW5uZXIucHJpbnQoKTtcclxuXHRcdHJldHVybiBcIi1cIisodGhpcy5pbm5lci50eXBlPj10aGlzLnR5cGU/XCIoXCIrYXJnK1wiKVwiOmFyZyk7XHJcblx0fVxyXG59XHJcbmFic3RyYWN0IGNsYXNzIEJpbmFyeU9wIGV4dGVuZHMgRXhwcmVzc2lvbntcclxuICAgIGxlZnQ6RXhwcmVzc2lvbjtcclxuICAgIHJpZ2h0OkV4cHJlc3Npb247XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlOm51bWJlcixsZWZ0OkV4cHJlc3Npb24scmlnaHQ6RXhwcmVzc2lvbil7XHJcbiAgICAgICAgc3VwZXIodHlwZSk7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIE11bHRpcGxpY2F0aW9uIGV4dGVuZHMgQmluYXJ5T3B7XHJcbiAgICBjb25zdHJ1Y3RvcihsZWZ0OkV4cHJlc3Npb24scmlnaHQ6RXhwcmVzc2lvbil7XHJcbiAgICAgICAgc3VwZXIoTm9kZVR5cGUuX011bHRpcGxpY2F0aW9uLGxlZnQscmlnaHQpXHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlwbGljYXRpb24odGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxuXHRkaWZmZXJlbnRpYXRlKHZhcmlhYmxlOnN0cmluZywgZXBzaWxvbjpudW1iZXIpe1xyXG5cdFx0cmV0dXJuIG5ldyBBZGRpdGlvbihcclxuXHRcdFx0XHRuZXcgTXVsdGlwbGljYXRpb24oXHJcblx0XHRcdFx0XHR0aGlzLmxlZnQuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSwgZXBzaWxvbiksXHJcblx0XHRcdFx0XHR0aGlzLnJpZ2h0LmNsb25lKClcclxuXHRcdFx0XHQpLFxyXG5cdFx0XHRcdG5ldyBNdWx0aXBsaWNhdGlvbihcclxuXHRcdFx0XHRcdHRoaXMubGVmdC5jbG9uZSgpLFxyXG5cdFx0XHRcdFx0dGhpcy5yaWdodC5kaWZmZXJlbnRpYXRlKHZhcmlhYmxlLCBlcHNpbG9uKVxyXG5cdFx0XHRcdClcclxuXHRcdFx0KTtcclxuXHR9XHJcbiAgICBldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCkqdGhpcy5yaWdodC5ldmFsKHZhcmlhYmxlTWFwKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUodmFyaWFibGVWYWx1ZXM6bnVtYmVyW10pOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVWYWx1ZXMpKnRoaXMucmlnaHQuZXhlY3V0ZSh2YXJpYWJsZVZhbHVlcyk7XHJcbiAgICB9XHJcblx0c2ltcGxpZnkoKXtcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnNpbXBsaWZ5KCk7XHJcblx0XHRsZXQgciA9IHRoaXMucmlnaHQuc2ltcGxpZnkoKTtcclxuXHRcdGlmKGwgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdGlmKHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25zdGFudChsLnZhbHVlICogci52YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoTWF0aC5hYnMobC52YWx1ZSk9PTAuMClcclxuXHRcdFx0XHRyZXR1cm4gbDtcclxuXHRcdFx0aWYobC52YWx1ZSA9PSAxKVxyXG5cdFx0XHRcdHJldHVybiByO1xyXG5cdFx0XHRpZihsLnZhbHVlID09IC0xKVxyXG5cdFx0XHRcdHJldHVybiBuZXcgTmVnYXRpb24ocik7XHJcblx0XHR9ZWxzZSBpZihyIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRpZihNYXRoLmFicyhyLnZhbHVlKT09MC4wKVxyXG5cdFx0XHRcdHJldHVybiByO1xyXG5cdFx0XHRpZihyLnZhbHVlID09IDEpXHJcblx0XHRcdFx0cmV0dXJuIGw7XHJcblx0XHRcdGlmKHIudmFsdWUgPT0gLTEpXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBOZWdhdGlvbihsKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTXVsdGlwbGljYXRpb24obCxyKTtcclxuXHR9XHJcblx0cHJpbnQoKTpzdHJpbmd7XHJcblx0XHRsZXQgbCA9IHRoaXMubGVmdC5wcmludCgpO1xyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnByaW50KCk7XHJcblx0XHRyZXR1cm4gKHRoaXMubGVmdC50eXBlPnRoaXMudHlwZT9cIihcIitsK1wiKVwiOmwpK1wiKlwiKyh0aGlzLnJpZ2h0LnR5cGU+dGhpcy50eXBlP1wiKFwiK3IrXCIpXCI6cik7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBBZGRpdGlvbiBleHRlbmRzIEJpbmFyeU9we1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpFeHByZXNzaW9uLHJpZ2h0OkV4cHJlc3Npb24pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9BZGRpdGlvbiwgbGVmdCwgcmlnaHQpXHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgQWRkaXRpb24odGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxuXHRkaWZmZXJlbnRpYXRlKHZhcmlhYmxlOnN0cmluZywgZXBzaWxvbjpudW1iZXIpe1xyXG5cdFx0cmV0dXJuIG5ldyBBZGRpdGlvbihcclxuXHRcdFx0dGhpcy5sZWZ0LmRpZmZlcmVudGlhdGUodmFyaWFibGUsZXBzaWxvbiksXHJcblx0XHRcdHRoaXMucmlnaHQuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSxlcHNpbG9uKVxyXG5cdFx0XHQpO1xyXG5cdH1cclxuICAgIGV2YWwodmFyaWFibGVNYXA6UmVjb3JkPHN0cmluZyxudW1iZXI+KTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5ldmFsKHZhcmlhYmxlTWFwKSt0aGlzLnJpZ2h0LmV2YWwodmFyaWFibGVNYXApO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZSh2YXJpYWJsZVZhbHVlczpudW1iZXJbXSk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXhlY3V0ZSh2YXJpYWJsZVZhbHVlcykrdGhpcy5yaWdodC5leGVjdXRlKHZhcmlhYmxlVmFsdWVzKTtcclxuICAgIH1cclxuXHRzaW1wbGlmeSgpe1xyXG5cdFx0bGV0IGwgPSB0aGlzLmxlZnQuc2ltcGxpZnkoKTtcclxuXHRcdGxldCByID0gdGhpcy5yaWdodC5zaW1wbGlmeSgpO1xyXG5cdFx0aWYobCBpbnN0YW5jZW9mIENvbnN0YW50KXtcclxuXHRcdFx0aWYociBpbnN0YW5jZW9mIENvbnN0YW50KXtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbnN0YW50KGwudmFsdWUgKyByLnZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihNYXRoLmFicyhsLnZhbHVlKT09MClcclxuXHRcdFx0XHRyZXR1cm4gcjtcclxuXHRcdH1lbHNlIGlmKHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdGlmKE1hdGguYWJzKHIudmFsdWUpPT0wLjApXHJcblx0XHRcdFx0cmV0dXJuIGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEFkZGl0aW9uKGwscik7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0bGV0IGwgPSB0aGlzLmxlZnQucHJpbnQoKTtcclxuXHRcdGxldCByID0gdGhpcy5yaWdodC5wcmludCgpO1xyXG5cdFx0cmV0dXJuICh0aGlzLmxlZnQudHlwZT50aGlzLnR5cGU/XCIoXCIrbCtcIilcIjpsKStcIitcIisodGhpcy5yaWdodC50eXBlPnRoaXMudHlwZT9cIihcIityK1wiKVwiOnIpO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgU3VidHJhY3Rpb24gZXh0ZW5kcyBCaW5hcnlPcHtcclxuICAgIGNvbnN0cnVjdG9yKGxlZnQ6RXhwcmVzc2lvbixyaWdodDpFeHByZXNzaW9uKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fU3VidHJhY3Rpb24sIGxlZnQsIHJpZ2h0KVxyXG4gICAgfVxyXG4gICAgY2xvbmUoKXtcclxuICAgICAgICByZXR1cm4gbmV3IFN1YnRyYWN0aW9uKHRoaXMubGVmdC5jbG9uZSgpLHRoaXMucmlnaHQuY2xvbmUoKSk7XHJcbiAgICB9XHJcblx0ZGlmZmVyZW50aWF0ZSh2YXJpYWJsZTpzdHJpbmcsIGVwc2lsb246bnVtYmVyKXtcclxuXHRcdHJldHVybiBuZXcgU3VidHJhY3Rpb24oXHJcblx0XHRcdHRoaXMubGVmdC5kaWZmZXJlbnRpYXRlKHZhcmlhYmxlLGVwc2lsb24pLFxyXG5cdFx0XHR0aGlzLnJpZ2h0LmRpZmZlcmVudGlhdGUodmFyaWFibGUsZXBzaWxvbilcclxuXHRcdFx0KTtcclxuXHR9XHJcbiAgICBldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCktdGhpcy5yaWdodC5ldmFsKHZhcmlhYmxlTWFwKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUodmFyaWFibGVWYWx1ZXM6bnVtYmVyW10pOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVWYWx1ZXMpLXRoaXMucmlnaHQuZXhlY3V0ZSh2YXJpYWJsZVZhbHVlcyk7XHJcbiAgICB9XHJcblx0c2ltcGxpZnkoKXtcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnNpbXBsaWZ5KCk7XHJcblx0XHRsZXQgciA9IHRoaXMucmlnaHQuc2ltcGxpZnkoKTtcclxuXHRcdGlmKGwgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdGlmKHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBDb25zdGFudChsLnZhbHVlIC0gci52YWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoTWF0aC5hYnMobC52YWx1ZSk9PTApXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBOZWdhdGlvbihyKTtcclxuXHRcdH1lbHNlIGlmKHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdGlmKE1hdGguYWJzKHIudmFsdWUpPT0wKVxyXG5cdFx0XHRcdHJldHVybiBsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBTdWJ0cmFjdGlvbihsLHIpO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnByaW50KCk7XHJcblx0XHRsZXQgciA9IHRoaXMucmlnaHQucHJpbnQoKTtcclxuXHRcdHJldHVybiAodGhpcy5sZWZ0LnR5cGU+dGhpcy50eXBlP1wiKFwiK2wrXCIpXCI6bCkrXCItXCIrKHRoaXMucmlnaHQudHlwZT49dGhpcy50eXBlP1wiKFwiK3IrXCIpXCI6cik7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBEaXZpc2lvbiBleHRlbmRzIEJpbmFyeU9we1xyXG4gICAgY29uc3RydWN0b3IobGVmdDpFeHByZXNzaW9uLHJpZ2h0OkV4cHJlc3Npb24pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9EaXZpc2lvbiwgbGVmdCwgcmlnaHQpXHJcbiAgICB9XHJcbiAgICBjbG9uZSgpe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24odGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuICAgIH1cclxuXHRkaWZmZXJlbnRpYXRlKHZhcmlhYmxlOnN0cmluZywgZXBzaWxvbjpudW1iZXIpe1xyXG5cdFx0cmV0dXJuIG5ldyBTdWJ0cmFjdGlvbihcclxuXHRcdFx0bmV3IERpdmlzaW9uKFxyXG5cdFx0XHRcdHRoaXMubGVmdC5kaWZmZXJlbnRpYXRlKHZhcmlhYmxlLGVwc2lsb24pLFxyXG5cdFx0XHRcdHRoaXMucmlnaHQuY2xvbmUoKSxcclxuXHRcdFx0KSxcclxuXHRcdFx0bmV3IE11bHRpcGxpY2F0aW9uKFxyXG5cdFx0XHRcdHRoaXMucmlnaHQuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSxlcHNpbG9uKSxcclxuXHRcdFx0XHRuZXcgRGl2aXNpb24oXHJcblx0XHRcdFx0XHR0aGlzLmxlZnQuY2xvbmUoKSxcclxuXHRcdFx0XHRcdG5ldyBGdW5jdGlvbihcInBvd1wiLFtcclxuXHRcdFx0XHRcdFx0dGhpcy5yaWdodC5jbG9uZSgpLG5ldyBDb25zdGFudCgyKV1cclxuXHRcdFx0XHRcdClcclxuXHRcdFx0XHQpXHJcblx0XHRcdClcclxuXHRcdCk7XHJcblx0fVxyXG4gICAgZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmV2YWwodmFyaWFibGVNYXApL3RoaXMucmlnaHQuZXZhbCh2YXJpYWJsZU1hcCk7XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5leGVjdXRlKHZhcmlhYmxlVmFsdWVzKS90aGlzLnJpZ2h0LmV4ZWN1dGUodmFyaWFibGVWYWx1ZXMpO1xyXG4gICAgfVxyXG5cdHNpbXBsaWZ5KCl7XHJcblx0XHRsZXQgbCA9IHRoaXMubGVmdC5zaW1wbGlmeSgpO1xyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihsIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRpZihNYXRoLmFicyhsLnZhbHVlKT09MC4wKVxyXG5cdFx0XHRcdHJldHVybiBsO1xyXG5cdFx0XHRpZihyIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRcdHJldHVybiBuZXcgQ29uc3RhbnQobC52YWx1ZSAvIHIudmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9ZWxzZSBpZihyIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRpZihyLnZhbHVlID09IDEpXHJcblx0XHRcdFx0cmV0dXJuIGw7XHJcblx0XHRcdGlmKHIudmFsdWUgPT0gLTEpXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBOZWdhdGlvbihsKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgRGl2aXNpb24obCxyKTtcclxuXHR9XHJcblx0cHJpbnQoKTpzdHJpbmd7XHJcblx0XHRsZXQgbCA9IHRoaXMubGVmdC5wcmludCgpO1xyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnByaW50KCk7XHJcblx0XHRyZXR1cm4gKHRoaXMubGVmdC50eXBlPj10aGlzLnR5cGU/XCIoXCIrbCtcIilcIjpsKStcIi9cIisodGhpcy5yaWdodC50eXBlPj10aGlzLnR5cGU/XCIoXCIrcitcIilcIjpyKTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uIGV4dGVuZHMgRXhwcmVzc2lvbntcclxuICAgIGZ1bmN0aW9uTmFtZTpzdHJpbmc7XHJcbiAgICBmdW5jdGlvbjpGdW5jdGlvbkRlZjtcclxuICAgIGFyZ3M6QXJyYXk8RXhwcmVzc2lvbj47XHJcbiAgICBjb25zdHJ1Y3RvcihmdW5jdGlvbk5hbWU6c3RyaW5nLGFyZ3M6QXJyYXk8RXhwcmVzc2lvbj4pe1xyXG4gICAgICAgIHN1cGVyKE5vZGVUeXBlLl9GdW5jdGlvbik7XHJcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWU7XHJcbiAgICAgICAgdGhpcy5mdW5jdGlvbiA9IGZ1bmN0aW9uRGljdGlvbmFyeVtmdW5jdGlvbk5hbWVdO1xyXG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XHJcbiAgICAgICAgaWYodGhpcy5mdW5jdGlvbiA9PT11bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IGBVbmtub3duIGZ1bmN0aW9uIFxcXCIke2Z1bmN0aW9uTmFtZX1gO1xyXG4gICAgICAgIGlmKHRoaXMuZnVuY3Rpb24uYXJnQ291bnQhPWFyZ3MubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgaW4gZnVuY3Rpb24gXFxcIiR7ZnVuY3Rpb25OYW1lfTogJHthcmdzLmxlbmd0aH0sICR7dGhpcy5mdW5jdGlvbi5hcmdDb3VudH0gZXhwZWN0ZWRgO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKTpFeHByZXNzaW9ue1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24odGhpcy5mdW5jdGlvbk5hbWUsdGhpcy5hcmdzLm1hcChmdW5jdGlvbihpdGVtOkV4cHJlc3Npb24pe1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICApKTtcclxuICAgIH1cclxuXHRkaWZmZXJlbnRpYXRlKHZhcmlhYmxlOnN0cmluZyxlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdGlmKHRoaXMuYXJncy5sZW5ndGg9PTApXHJcblx0XHRcdHJldHVybiBuZXcgQ29uc3RhbnQoMC4wKTtcclxuXHRcdGlmICh0aGlzLmFyZ3MubGVuZ3RoID09IDEpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IE11bHRpcGxpY2F0aW9uKFxyXG5cdFx0XHRcdFx0dGhpcy5hcmdzWzBdLmRpZmZlcmVudGlhdGUodmFyaWFibGUsIGVwc2lsb24pLFxyXG5cdFx0XHRcdFx0dGhpcy5nZXREZXJpdmF0aXZlKDAsZXBzaWxvbilcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHRcdGxldCByb290ID0gbmV3IEFkZGl0aW9uKG51bGwsbnVsbCk7XHJcblx0XHRsZXQgY3VycmVudDpBZGRpdGlvbiA9IHJvb3Q7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGggLSAxOyBpKyspe1xyXG5cdFx0XHRjdXJyZW50LmxlZnQgPSBuZXcgTXVsdGlwbGljYXRpb25cclxuXHRcdFx0KFxyXG5cdFx0XHRcdHRoaXMuYXJnc1tpXS5kaWZmZXJlbnRpYXRlKHZhcmlhYmxlLGVwc2lsb24pLFxyXG5cdFx0XHRcdHRoaXMuZ2V0RGVyaXZhdGl2ZShpLGVwc2lsb24pXHJcblx0XHRcdCk7XHJcblx0XHRcdGlmIChpIDwgdGhpcy5hcmdzLmxlbmd0aCAtIDIpe1xyXG5cdFx0XHRcdGN1cnJlbnQucmlnaHQgPSBuZXcgQWRkaXRpb24obnVsbCxudWxsKTtcclxuXHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5yaWdodCBhcyBBZGRpdGlvbjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y3VycmVudC5yaWdodCA9IG5ldyBNdWx0aXBsaWNhdGlvblxyXG5cdFx0KFxyXG5cdFx0XHR0aGlzLmFyZ3NbdGhpcy5hcmdzLmxlbmd0aCAtIDFdLmRpZmZlcmVudGlhdGUodmFyaWFibGUsZXBzaWxvbiksXHJcblx0XHRcdHRoaXMuZ2V0RGVyaXZhdGl2ZSh0aGlzLmFyZ3MubGVuZ3RoIC0gMSxlcHNpbG9uKVxyXG5cdFx0KTtcclxuXHRcdHJldHVybiByb290O1xyXG5cdH1cclxuXHRldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6bnVtYmVye1xyXG5cdFx0bGV0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKChpdGVtKT0+e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZXZhbCh2YXJpYWJsZU1hcCk7XHJcbiAgICAgICAgICAgIH1cclxuXHRcdCk7XHJcblx0XHRyZXR1cm4gdGhpcy5mdW5jdGlvbi5leGVjKGFyZ3MpO1xyXG5cdH1cclxuXHRleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpudW1iZXJ7XHJcblx0XHRsZXQgYXJncyA9IHRoaXMuYXJncy5tYXAoKGl0ZW0pPT57XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5leGVjdXRlKHZhcmlhYmxlVmFsdWVzKTtcclxuICAgICAgICAgICAgfVxyXG5cdFx0KTtcclxuXHRcdHJldHVybiB0aGlzLmZ1bmN0aW9uLmV4ZWMoYXJncyk7XHJcblx0fVxyXG5cdGdldERlcml2YXRpdmUoaW5kZXg6bnVtYmVyLCBlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdGlmKHRoaXMuZnVuY3Rpb24uZGVyaXZhdGl2ZXM9PT1udWxsKXsvL3VzZSBiYWNrd2FyZCBkaWZmZXJlbmNle1xyXG5cdFx0XHRsZXQgYXJndW1lbnRzQmFja3dhcmQgPSB0aGlzLmFyZ3Muc2xpY2UoKTtcclxuXHRcdFx0YXJndW1lbnRzQmFja3dhcmRbaW5kZXhdID0gbmV3IFN1YnRyYWN0aW9uKGFyZ3VtZW50c0JhY2t3YXJkW2luZGV4XSxuZXcgQ29uc3RhbnQoZXBzaWxvbikpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IERpdmlzaW9uKG5ldyBTdWJ0cmFjdGlvbihcclxuXHRcdFx0XHRuZXcgRnVuY3Rpb24odGhpcy5mdW5jdGlvbk5hbWUsIHRoaXMuYXJncyksXHJcblx0XHRcdFx0bmV3IEZ1bmN0aW9uKHRoaXMuZnVuY3Rpb25OYW1lLCBhcmd1bWVudHNCYWNrd2FyZCksXHJcblx0XHRcdFx0KSxuZXcgQ29uc3RhbnQoZXBzaWxvbikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZnVuY3Rpb24uZGVyaXZhdGl2ZXNbaW5kZXhdKHRoaXMuYXJncyk7XHJcblx0fVxyXG5cdHNpbXBsaWZ5KCk6RXhwcmVzc2lvbntcclxuXHRcdGxldCBjb25zdGFudEFyZ3MgPSB0cnVlO1xyXG5cdFx0bGV0IGFyZ3MgPSB0aGlzLmFyZ3MubWFwKChpdGVtKT0+e1xyXG5cdFx0XHRcdGxldCBfaXRlbSA9IGl0ZW0uc2ltcGxpZnkoKTtcclxuXHRcdFx0XHRjb25zdGFudEFyZ3MgPSBjb25zdGFudEFyZ3MgJiYgKGl0ZW0gaW5zdGFuY2VvZiBDb25zdGFudCk7XHJcblx0XHRcdFx0cmV0dXJuIF9pdGVtO1xyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdFx0aWYoY29uc3RhbnRBcmdzKXtcclxuXHRcdFx0bGV0IGNvbnN0QXJncyA9IGFyZ3MubWFwKChpdGVtOkNvbnN0YW50KT0+e3JldHVybiBpdGVtLnZhbHVlO30pO1xyXG5cdFx0XHRyZXR1cm4gbmV3IENvbnN0YW50KHRoaXMuZnVuY3Rpb24uZXhlYyhjb25zdEFyZ3MpKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuYXJncyA9IGFyZ3M7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblx0cHJpbnQoKTpzdHJpbmd7XHJcblx0XHRsZXQgYXJncyA9IHRoaXMuYXJncy5tYXAoKGl0ZW0pPT5pdGVtLnByaW50KCkpO1xyXG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMuZnVuY3Rpb24ubmFtZStcIihcIjtcclxuXHRcdHRoaXMuYXJncy5mb3JFYWNoKChpdGVtLGluZGV4KT0+e1xyXG5cdFx0XHRyZXN1bHQrPShpbmRleD4wP1wiLCBcIjpcIlwiKStpdGVtLnByaW50KCk7XHJcblx0XHR9KVxyXG5cdFx0cmV0dXJuIHJlc3VsdCArIFwiKVwiO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgVmFyaWFibGUgZXh0ZW5kcyBFeHByZXNzaW9ue1xyXG4gICAgaW5kZXg6bnVtYmVyO1xyXG4gICAgbmFtZTpzdHJpbmc7XHJcblx0Y29uc3RydWN0b3IoaW5kZXg6bnVtYmVyLG5hbWU6c3RyaW5nKXtcclxuXHRcdHN1cGVyKE5vZGVUeXBlLl9WYXJpYWJsZSk7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuICAgIH1cclxuXHRjbG9uZSgpOkV4cHJlc3Npb257XHJcblx0XHRyZXR1cm4gbmV3IFZhcmlhYmxlKHRoaXMuaW5kZXgsdGhpcy5uYW1lKTtcclxuXHR9XHJcblx0ZGlmZmVyZW50aWF0ZSh2YXJpYWJsZTpzdHJpbmcsIGVwc2lsb246bnVtYmVyKXtcclxuXHRcdGlmKHZhcmlhYmxlID09IHRoaXMubmFtZSlcclxuXHRcdFx0cmV0dXJuIG5ldyBDb25zdGFudCgxLjApO1xyXG5cdFx0cmV0dXJuIG5ldyBDb25zdGFudCgwLjApO1xyXG4gICAgfVxyXG5cdGV2YWwodmFyaWFibGVNYXA6UmVjb3JkPHN0cmluZyxudW1iZXI+KTpudW1iZXJ7XHJcblx0XHRyZXR1cm4gdmFyaWFibGVNYXBbdGhpcy5uYW1lXTtcclxuXHR9XHJcbiAgICBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWVzW3RoaXMuaW5kZXhdO1xyXG4gICAgfVxyXG5cdHNpbXBsaWZ5KCl7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdHJldHVybiB0aGlzLm5hbWU7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBUZXJuYXJ5T3BlcmF0b3IgZXh0ZW5kcyBFeHByZXNzaW9ue1xyXG5cdGNvbmRpdGlvbjpCb29sRXhwcmVzc2lvbjtcclxuXHR0OkV4cHJlc3Npb247XHJcblx0ZjpFeHByZXNzaW9uO1xyXG5cdGNvbnN0cnVjdG9yKGNvbmRpdGlvbjpCb29sRXhwcmVzc2lvbix0OkV4cHJlc3Npb24sZjpFeHByZXNzaW9uKXtcclxuICAgICAgICBzdXBlcihOb2RlVHlwZS5fVGVybmFyeSk7XHJcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XHJcblx0XHR0aGlzLnQgPSB0O1xyXG5cdFx0dGhpcy5mID0gZjtcclxuXHR9XHJcblx0Y2xvbmUoKTpFeHByZXNzaW9ue1xyXG5cdFx0cmV0dXJuIG5ldyBUZXJuYXJ5T3BlcmF0b3IodGhpcy5jb25kaXRpb24uY2xvbmUoKSx0aGlzLnQuY2xvbmUoKSx0aGlzLmYuY2xvbmUoKSk7XHJcblx0fVxyXG5cdGRpZmZlcmVudGlhdGUodmFyaWFibGU6c3RyaW5nLCBlcHNpbG9uOm51bWJlcil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJuYXJ5T3BlcmF0b3IodGhpcy5jb25kaXRpb24uY2xvbmUoKSxcclxuICAgICAgICB0aGlzLnQuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSxlcHNpbG9uKSxcclxuICAgICAgICB0aGlzLmYuZGlmZmVyZW50aWF0ZSh2YXJpYWJsZSxlcHNpbG9uKSk7XHJcblx0fVxyXG5cdGV2YWwodmFyaWFibGVNYXA6UmVjb3JkPHN0cmluZyxudW1iZXI+KTpudW1iZXJ7XHJcbiAgICAgICAgaWYodGhpcy5jb25kaXRpb24uZXZhbCh2YXJpYWJsZU1hcCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50LmV2YWwodmFyaWFibGVNYXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mLmV2YWwodmFyaWFibGVNYXApO1xyXG5cdH1cclxuICAgIGV4ZWN1dGUodmFyaWFibGVWYWx1ZXM6bnVtYmVyW10pOm51bWJlcntcclxuICAgICAgICBpZih0aGlzLmNvbmRpdGlvbi5leGVjdXRlKHZhcmlhYmxlVmFsdWVzKSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnQuZXhlY3V0ZSh2YXJpYWJsZVZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmYuZXhlY3V0ZSh2YXJpYWJsZVZhbHVlcyk7XHJcbiAgICB9XHJcblx0c2ltcGxpZnkoKXtcclxuICAgICAgICBsZXQgY29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24uc2ltcGxpZnkoKTtcclxuICAgICAgICBpZihjb25kaXRpb24gaW5zdGFuY2VvZiBCb29sQ29uc3RhbnQpe1xyXG4gICAgICAgICAgICBsZXQgY29uc3RhbnQgPSBjb25kaXRpb24gYXMgQm9vbENvbnN0YW50O1xyXG4gICAgICAgICAgICBpZihjb25zdGFudC52YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnQuc2ltcGxpZnkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZi5zaW1wbGlmeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRlcm5hcnlPcGVyYXRvcihjb25kaXRpb24sdGhpcy50LnNpbXBsaWZ5KCksdGhpcy5mLnNpbXBsaWZ5KCkpO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdHJldHVybiBgeyR7dGhpcy5jb25kaXRpb24ucHJpbnQoKX0/JHt0aGlzLnQucHJpbnQoKX06JHt0aGlzLmYucHJpbnQoKX19YDtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCb29sRXhwcmVzc2lvbntcclxuICAgIGFic3RyYWN0IGNsb25lKCk6Qm9vbEV4cHJlc3Npb247XHJcblx0YWJzdHJhY3QgZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOmJvb2xlYW47XHJcbiAgICBhYnN0cmFjdCBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpib29sZWFuO1xyXG5cdGFic3RyYWN0IHNpbXBsaWZ5KCk6Qm9vbEV4cHJlc3Npb247XHJcblx0YWJzdHJhY3QgY29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbjtcclxuXHRhYnN0cmFjdCBwcmludCgpOnN0cmluZztcclxufVxyXG5hYnN0cmFjdCBjbGFzcyBCb29sQmluYXJ5T3AgZXh0ZW5kcyBCb29sRXhwcmVzc2lvbntcclxuXHRsZWZ0OkJvb2xFeHByZXNzaW9uO1xyXG5cdHJpZ2h0OkJvb2xFeHByZXNzaW9uO1xyXG5cdGNvbnN0cnVjdG9yKGxlZnQ6Qm9vbEV4cHJlc3Npb24scmlnaHQ6Qm9vbEV4cHJlc3Npb24pe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0XHR0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcblx0fVxyXG59XHJcbmFic3RyYWN0IGNsYXNzIEJvb2xCaW5hcnlFeHBPcCBleHRlbmRzIEJvb2xFeHByZXNzaW9ue1xyXG5cdGxlZnQ6RXhwcmVzc2lvbjtcclxuXHRyaWdodDpFeHByZXNzaW9uO1xyXG5cdGNvbnN0cnVjdG9yKGxlZnQ6RXhwcmVzc2lvbixyaWdodDpFeHByZXNzaW9uKXtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLmxlZnQgPSBsZWZ0O1xyXG5cdFx0dGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgQW5kIGV4dGVuZHMgQm9vbEJpbmFyeU9we1xyXG5cdGNsb25lKCl7XHJcblx0XHRyZXR1cm4gbmV3IEFuZCh0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG5cdH1cclxuXHRldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCkmJnRoaXMucmlnaHQuZXZhbCh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdGV4ZWN1dGUodmFyaWFibGVNYXA6bnVtYmVyW10pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVNYXApJiZ0aGlzLnJpZ2h0LmV4ZWN1dGUodmFyaWFibGVNYXApO1xyXG5cdH1cclxuXHRzaW1wbGlmeSgpOkJvb2xFeHByZXNzaW9ue1xyXG5cdFx0bGV0IGwgPSB0aGlzLmxlZnQuc2ltcGxpZnkoKTtcclxuXHRcdGlmKGwgaW5zdGFuY2VvZiBCb29sQ29uc3RhbnQpe1xyXG5cdFx0XHRpZihsLnZhbHVlID09IGZhbHNlKVxyXG5cdFx0XHRcdHJldHVybiBsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yaWdodC5zaW1wbGlmeSgpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihyIGluc3RhbmNlb2YgQm9vbENvbnN0YW50KXtcclxuXHRcdFx0aWYoci52YWx1ZSA9PSBmYWxzZSl7XHJcblx0XHRcdFx0cmV0dXJuIHI7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGw7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IEFuZChsLHIpO1xyXG5cdH1cclxuXHRjb252ZXJ0VG9FeHByZXNzaW9uKGVwc2lsb246bnVtYmVyKTpFeHByZXNzaW9ue1xyXG5cdFx0cmV0dXJuIG5ldyBGdW5jdGlvbihcIm1pblwiLFxyXG5cdFx0W3RoaXMubGVmdC5jb252ZXJ0VG9FeHByZXNzaW9uKGVwc2lsb24pLHRoaXMucmlnaHQuY29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uKV0pO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdHJldHVybiBgKCR7dGhpcy5sZWZ0LnByaW50KCl9KSBhbmQgKCR7dGhpcy5yaWdodC5wcmludCgpfSlgO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgT3IgZXh0ZW5kcyBCb29sQmluYXJ5T3B7XHJcblx0Y2xvbmUoKXtcclxuXHRcdHJldHVybiBuZXcgT3IodGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKTtcclxuXHR9XHJcblx0ZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV2YWwodmFyaWFibGVNYXApfHx0aGlzLnJpZ2h0LmV2YWwodmFyaWFibGVNYXApO1xyXG5cdH1cclxuXHRleGVjdXRlKHZhcmlhYmxlTWFwOm51bWJlcltdKTpib29sZWFue1xyXG5cdFx0cmV0dXJuIHRoaXMubGVmdC5leGVjdXRlKHZhcmlhYmxlTWFwKXx8dGhpcy5yaWdodC5leGVjdXRlKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0c2ltcGxpZnkoKTpCb29sRXhwcmVzc2lvbntcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihsIGluc3RhbmNlb2YgQm9vbENvbnN0YW50KXtcclxuXHRcdFx0aWYobC52YWx1ZSA9PSB0cnVlKVxyXG5cdFx0XHRcdHJldHVybiBsO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yaWdodC5zaW1wbGlmeSgpO1xyXG5cdFx0fVxyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihyIGluc3RhbmNlb2YgQm9vbENvbnN0YW50KXtcclxuXHRcdFx0aWYoci52YWx1ZSA9PSB0cnVlKXtcclxuXHRcdFx0XHRyZXR1cm4gcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgT3IobCxyKTtcclxuXHR9XHJcblx0Y29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdHJldHVybiBuZXcgRnVuY3Rpb24oXCJtYXhcIixcclxuXHRcdFt0aGlzLmxlZnQuY29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uKSx0aGlzLnJpZ2h0LmNvbnZlcnRUb0V4cHJlc3Npb24oZXBzaWxvbildKTtcclxuXHR9XHJcblx0cHJpbnQoKTpzdHJpbmd7XHJcblx0XHRyZXR1cm4gYCgke3RoaXMubGVmdC5wcmludCgpfSkgb3IgKCR7dGhpcy5yaWdodC5wcmludCgpfSlgO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgRXF1YWwgZXh0ZW5kcyBCb29sQmluYXJ5RXhwT3B7XHJcblx0Y2xvbmUoKXtcclxuXHRcdHJldHVybiBuZXcgRXF1YWwodGhpcy5sZWZ0LHRoaXMucmlnaHQpO1xyXG5cdH1cclxuXHRldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCk9PXRoaXMucmlnaHQuZXZhbCh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdGV4ZWN1dGUodmFyaWFibGVNYXA6bnVtYmVyW10pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVNYXApPT10aGlzLnJpZ2h0LmV4ZWN1dGUodmFyaWFibGVNYXApO1xyXG5cdH1cclxuXHRzaW1wbGlmeSgpOkJvb2xFeHByZXNzaW9ue1xyXG5cdFx0bGV0IGwgPSB0aGlzLmxlZnQuc2ltcGxpZnkoKTtcclxuXHRcdGxldCByID0gdGhpcy5yaWdodC5zaW1wbGlmeSgpO1xyXG5cdFx0aWYobCBpbnN0YW5jZW9mIENvbnN0YW50ICYmIHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdHJldHVybiBuZXcgQm9vbENvbnN0YW50KGwudmFsdWU9PXIudmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBFcXVhbChsLHIpO1xyXG5cdH1cclxuXHRjb252ZXJ0VG9FeHByZXNzaW9uKGVwc2lsb246bnVtYmVyKTpFeHByZXNzaW9ue1xyXG5cdFx0cmV0dXJuIG5ldyBTdWJ0cmFjdGlvbihuZXcgQ29uc3RhbnQoZXBzaWxvbiplcHNpbG9uKSxcclxuXHRcdG5ldyBGdW5jdGlvbihcInBvd1wiLFtuZXcgU3VidHJhY3Rpb24odGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKSxuZXcgQ29uc3RhbnQoMildKSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIGAke3RoaXMubGVmdC5wcmludCgpfSA9ICR7dGhpcy5yaWdodC5wcmludCgpfWA7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBOb3RFcXVhbCBleHRlbmRzIEJvb2xCaW5hcnlFeHBPcHtcclxuXHRjbG9uZSgpe1xyXG5cdFx0cmV0dXJuIG5ldyBOb3RFcXVhbCh0aGlzLmxlZnQsdGhpcy5yaWdodCk7XHJcblx0fVxyXG5cdGV2YWwodmFyaWFibGVNYXA6UmVjb3JkPHN0cmluZyxudW1iZXI+KTpib29sZWFue1xyXG5cdFx0cmV0dXJuIHRoaXMubGVmdC5ldmFsKHZhcmlhYmxlTWFwKSE9dGhpcy5yaWdodC5ldmFsKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0ZXhlY3V0ZSh2YXJpYWJsZU1hcDpudW1iZXJbXSk6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXhlY3V0ZSh2YXJpYWJsZU1hcCkhPXRoaXMucmlnaHQuZXhlY3V0ZSh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdHNpbXBsaWZ5KCk6Qm9vbEV4cHJlc3Npb257XHJcblx0XHRsZXQgbCA9IHRoaXMubGVmdC5zaW1wbGlmeSgpO1xyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihsIGluc3RhbmNlb2YgQ29uc3RhbnQgJiYgciBpbnN0YW5jZW9mIENvbnN0YW50KXtcclxuXHRcdFx0cmV0dXJuIG5ldyBCb29sQ29uc3RhbnQobC52YWx1ZSE9ci52YWx1ZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IE5vdEVxdWFsKGwscik7XHJcblx0fVxyXG5cdGNvbnZlcnRUb0V4cHJlc3Npb24oZXBzaWxvbjpudW1iZXIpOkV4cHJlc3Npb257XHJcblx0XHRyZXR1cm4gbmV3IEFkZGl0aW9uKG5ldyBDb25zdGFudCgtZXBzaWxvbiplcHNpbG9uKSxcclxuXHRcdG5ldyBGdW5jdGlvbihcInBvd1wiLFtuZXcgU3VidHJhY3Rpb24odGhpcy5sZWZ0LmNsb25lKCksdGhpcy5yaWdodC5jbG9uZSgpKSxuZXcgQ29uc3RhbnQoMildKSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIGAke3RoaXMubGVmdC5wcmludCgpfSAhPSAke3RoaXMucmlnaHQucHJpbnQoKX1gO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgR3JlYXRlciBleHRlbmRzIEJvb2xCaW5hcnlFeHBPcHtcclxuXHRjbG9uZSgpe1xyXG5cdFx0cmV0dXJuIG5ldyBHcmVhdGVyKHRoaXMubGVmdCx0aGlzLnJpZ2h0KTtcclxuXHR9XHJcblx0ZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV2YWwodmFyaWFibGVNYXApPnRoaXMucmlnaHQuZXZhbCh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdGV4ZWN1dGUodmFyaWFibGVNYXA6bnVtYmVyW10pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVNYXApPnRoaXMucmlnaHQuZXhlY3V0ZSh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdHNpbXBsaWZ5KCk6Qm9vbEV4cHJlc3Npb257XHJcblx0XHRsZXQgbCA9IHRoaXMubGVmdC5zaW1wbGlmeSgpO1xyXG5cdFx0bGV0IHIgPSB0aGlzLnJpZ2h0LnNpbXBsaWZ5KCk7XHJcblx0XHRpZihsIGluc3RhbmNlb2YgQ29uc3RhbnQgJiYgciBpbnN0YW5jZW9mIENvbnN0YW50KXtcclxuXHRcdFx0cmV0dXJuIG5ldyBCb29sQ29uc3RhbnQobC52YWx1ZT5yLnZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgR3JlYXRlcihsLHIpO1xyXG5cdH1cclxuXHRjb252ZXJ0VG9FeHByZXNzaW9uKGVwc2lsb246bnVtYmVyKTpFeHByZXNzaW9ue1xyXG5cdFx0cmV0dXJuIG5ldyBTdWJ0cmFjdGlvbih0aGlzLmxlZnQuY2xvbmUoKSx0aGlzLnJpZ2h0LmNsb25lKCkpO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdHJldHVybiBgJHt0aGlzLmxlZnQucHJpbnQoKX0+JHt0aGlzLnJpZ2h0LnByaW50KCl9YDtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEdFcXVhbCBleHRlbmRzIEJvb2xCaW5hcnlFeHBPcHtcclxuXHRjbG9uZSgpe1xyXG5cdFx0cmV0dXJuIG5ldyBHRXF1YWwodGhpcy5sZWZ0LHRoaXMucmlnaHQpO1xyXG5cdH1cclxuXHRldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCk+PXRoaXMucmlnaHQuZXZhbCh2YXJpYWJsZU1hcCk7XHJcblx0fVxyXG5cdGV4ZWN1dGUodmFyaWFibGVNYXA6bnVtYmVyW10pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV4ZWN1dGUodmFyaWFibGVNYXApPj10aGlzLnJpZ2h0LmV4ZWN1dGUodmFyaWFibGVNYXApO1xyXG5cdH1cclxuXHRzaW1wbGlmeSgpOkJvb2xFeHByZXNzaW9ue1xyXG5cdFx0bGV0IGwgPSB0aGlzLmxlZnQuc2ltcGxpZnkoKTtcclxuXHRcdGxldCByID0gdGhpcy5yaWdodC5zaW1wbGlmeSgpO1xyXG5cdFx0aWYobCBpbnN0YW5jZW9mIENvbnN0YW50ICYmIHIgaW5zdGFuY2VvZiBDb25zdGFudCl7XHJcblx0XHRcdHJldHVybiBuZXcgQm9vbENvbnN0YW50KGwudmFsdWU+PXIudmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBHRXF1YWwobCxyKTtcclxuXHR9XHJcblx0Y29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdHJldHVybiBuZXcgQWRkaXRpb24obmV3IFN1YnRyYWN0aW9uKHRoaXMubGVmdC5jbG9uZSgpLHRoaXMucmlnaHQuY2xvbmUoKSksbmV3IENvbnN0YW50KGVwc2lsb24pKTtcclxuXHR9XHJcblx0cHJpbnQoKTpzdHJpbmd7XHJcblx0XHRyZXR1cm4gYCR7dGhpcy5sZWZ0LnByaW50KCl9ID49ICR7dGhpcy5yaWdodC5wcmludCgpfWA7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBMZXNzIGV4dGVuZHMgQm9vbEJpbmFyeUV4cE9we1xyXG5cdGNsb25lKCl7XHJcblx0XHRyZXR1cm4gbmV3IExlc3ModGhpcy5sZWZ0LHRoaXMucmlnaHQpO1xyXG5cdH1cclxuXHRldmFsKHZhcmlhYmxlTWFwOlJlY29yZDxzdHJpbmcsbnVtYmVyPik6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXZhbCh2YXJpYWJsZU1hcCk8dGhpcy5yaWdodC5ldmFsKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0ZXhlY3V0ZSh2YXJpYWJsZU1hcDpudW1iZXJbXSk6Ym9vbGVhbntcclxuXHRcdHJldHVybiB0aGlzLmxlZnQuZXhlY3V0ZSh2YXJpYWJsZU1hcCk8dGhpcy5yaWdodC5leGVjdXRlKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0c2ltcGxpZnkoKTpCb29sRXhwcmVzc2lvbntcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnNpbXBsaWZ5KCk7XHJcblx0XHRsZXQgciA9IHRoaXMucmlnaHQuc2ltcGxpZnkoKTtcclxuXHRcdGlmKGwgaW5zdGFuY2VvZiBDb25zdGFudCAmJiByIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IEJvb2xDb25zdGFudChsLnZhbHVlPHIudmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBMZXNzKGwscik7XHJcblx0fVxyXG5cdGNvbnZlcnRUb0V4cHJlc3Npb24oZXBzaWxvbjpudW1iZXIpOkV4cHJlc3Npb257XHJcblx0XHRyZXR1cm4gbmV3IFN1YnRyYWN0aW9uKHRoaXMucmlnaHQuY2xvbmUoKSx0aGlzLmxlZnQuY2xvbmUoKSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIGAke3RoaXMubGVmdC5wcmludCgpfSA8ICR7dGhpcy5yaWdodC5wcmludCgpfWA7XHJcblx0fVxyXG59XHJcbmV4cG9ydCBjbGFzcyBMRXF1YWwgZXh0ZW5kcyBCb29sQmluYXJ5RXhwT3B7XHJcblx0Y2xvbmUoKXtcclxuXHRcdHJldHVybiBuZXcgTEVxdWFsKHRoaXMubGVmdCx0aGlzLnJpZ2h0KTtcclxuXHR9XHJcblx0ZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOmJvb2xlYW57XHJcblx0XHRyZXR1cm4gdGhpcy5sZWZ0LmV2YWwodmFyaWFibGVNYXApPD10aGlzLnJpZ2h0LmV2YWwodmFyaWFibGVNYXApO1xyXG5cdH1cclxuXHRleGVjdXRlKHZhcmlhYmxlTWFwOm51bWJlcltdKTpib29sZWFue1xyXG5cdFx0cmV0dXJuIHRoaXMubGVmdC5leGVjdXRlKHZhcmlhYmxlTWFwKTw9dGhpcy5yaWdodC5leGVjdXRlKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0c2ltcGxpZnkoKTpCb29sRXhwcmVzc2lvbntcclxuXHRcdGxldCBsID0gdGhpcy5sZWZ0LnNpbXBsaWZ5KCk7XHJcblx0XHRsZXQgciA9IHRoaXMucmlnaHQuc2ltcGxpZnkoKTtcclxuXHRcdGlmKGwgaW5zdGFuY2VvZiBDb25zdGFudCAmJiByIGluc3RhbmNlb2YgQ29uc3RhbnQpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IEJvb2xDb25zdGFudChsLnZhbHVlPD1yLnZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgTEVxdWFsKGwscik7XHJcblx0fVxyXG5cdGNvbnZlcnRUb0V4cHJlc3Npb24oZXBzaWxvbjpudW1iZXIpOkV4cHJlc3Npb257XHJcblx0XHRyZXR1cm4gbmV3IEFkZGl0aW9uKG5ldyBTdWJ0cmFjdGlvbih0aGlzLnJpZ2h0LmNsb25lKCksdGhpcy5sZWZ0LmNsb25lKCkpLG5ldyBDb25zdGFudChlcHNpbG9uKSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIGAke3RoaXMubGVmdC5wcmludCgpfSA8PSAke3RoaXMucmlnaHQucHJpbnQoKX1gO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgQm9vbE5vdCBleHRlbmRzIEJvb2xFeHByZXNzaW9ue1xyXG5cdGlubmVyOkJvb2xFeHByZXNzaW9uO1xyXG5cdGNvbnN0cnVjdG9yKGlubmVyOkJvb2xFeHByZXNzaW9uKXtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLmlubmVyID0gaW5uZXI7XHJcblx0fVxyXG5cdGNsb25lKCl7XHJcblx0XHRyZXR1cm4gbmV3IEJvb2xOb3QodGhpcy5pbm5lci5jbG9uZSgpKTtcclxuXHR9XHJcbiAgICBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpib29sZWFue1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pbm5lci5leGVjdXRlKHZhcmlhYmxlVmFsdWVzKTtcclxuICAgIH1cclxuICAgIGV2YWwodmFyaWFibGVNYXA6UmVjb3JkPHN0cmluZyxudW1iZXI+KTpib29sZWFue1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pbm5lci5ldmFsKHZhcmlhYmxlTWFwKTtcclxuXHR9XHJcblx0c2ltcGxpZnkoKTpCb29sRXhwcmVzc2lvbntcclxuXHRcdGxldCBpID0gdGhpcy5pbm5lci5zaW1wbGlmeSgpO1xyXG5cdFx0aWYoaSBpbnN0YW5jZW9mIEJvb2xDb25zdGFudCl7XHJcblx0XHRcdHJldHVybiBuZXcgQm9vbENvbnN0YW50KCFpLnZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgQm9vbE5vdChpKTtcclxuXHR9XHJcblx0Y29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uOm51bWJlcik6RXhwcmVzc2lvbntcclxuXHRcdHJldHVybiBuZXcgQ29uc3RhbnQoLXRoaXMuaW5uZXIuY29udmVydFRvRXhwcmVzc2lvbihlcHNpbG9uKSk7XHJcblx0fVxyXG5cdHByaW50KCk6c3RyaW5ne1xyXG5cdFx0cmV0dXJuIGAhKCR7dGhpcy5pbm5lci5wcmludCgpfSlgO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY2xhc3MgQm9vbENvbnN0YW50IGV4dGVuZHMgQm9vbEV4cHJlc3Npb257XHJcbiAgICB2YWx1ZTpib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IodmFsdWU6Ym9vbGVhbil7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpOkJvb2xFeHByZXNzaW9ue1xyXG4gICAgICAgIHJldHVybiBuZXcgQm9vbENvbnN0YW50KHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZXZhbCh2YXJpYWJsZU1hcDpSZWNvcmQ8c3RyaW5nLG51bWJlcj4pOmJvb2xlYW57XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKHZhcmlhYmxlVmFsdWVzOm51bWJlcltdKTpib29sZWFue1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2ltcGxpZnkoKTpCb29sRXhwcmVzc2lvbntcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpXHJcblx0fVxyXG5cdGNvbnZlcnRUb0V4cHJlc3Npb24oKTpFeHByZXNzaW9ue1xyXG5cdFx0cmV0dXJuIG5ldyBDb25zdGFudCh0aGlzLnZhbHVlPzE6LTEpO1xyXG5cdH1cclxuXHRwcmludCgpOnN0cmluZ3tcclxuXHRcdHJldHVybiB0aGlzLnZhbHVlP1widHJ1ZVwiOlwiZmFsc2VcIjtcclxuXHR9XHJcbn0iLCJpbXBvcnQgRXJyb3JNZXNzYWdlIGZyb20gXCIuL2Vycm9yXCI7XHJcbmltcG9ydCB7IEJvb2xFeHByZXNzaW9uTm9kZSwgIE5vZGVUeXBlLCAgVmFySWRlbnRpZmllck5vZGUsIEV4cHJlc3Npb25Ob2RlLCBDb25zdGFudE5vZGUsIERlcml2YXRpdmVOb2RlLCBBZGRpdGlvbk5vZGUsIE11bHRpcGxpY2F0aW9uTm9kZSwgRnVuY3Rpb25Ob2RlLCBTdWJ0cmFjdGlvbk5vZGUsIERpdmlzaW9uTm9kZSwgTmVnYXRpb25Ob2RlLCBCb29sQW5kTm9kZSwgQm9vbE9yTm9kZSwgQm9vbE5lZ2F0aW9uTm9kZSwgQm9vbEdOb2RlLCBCb29sR0VOb2RlLCBCb29sTE5vZGUsIEJvb2xDb25zdGFudE5vZGUsIEJvb2xMRU5vZGUsIEJvb2xORU5vZGUsIEJvb2xFTm9kZSwgVGVybmFyeU9wZXJhdG9yTm9kZSwgQVNUTm9kZSwgVGV4dFBvc2l0aW9uIH0gZnJvbSBcIi4vYXN0Tm9kZVwiO1xyXG5pbXBvcnQgeyBFeHByZXNzaW9uLCBDb25zdGFudCwgQm9vbEV4cHJlc3Npb24sIEJvb2xDb25zdGFudCwgQWRkaXRpb24sIFN1YnRyYWN0aW9uLCBNdWx0aXBsaWNhdGlvbiwgRGl2aXNpb24sIE5lZ2F0aW9uLCBWYXJpYWJsZSwgQW5kLCBPciwgQm9vbE5vdCwgR3JlYXRlciwgR0VxdWFsLCBMZXNzLCBMRXF1YWwsIE5vdEVxdWFsLCBFcXVhbCwgRnVuY3Rpb24sIFRlcm5hcnlPcGVyYXRvciB9IGZyb20gXCIuL2V4cHJlc3Npb25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBFeHBDb21waWxlckNvbnRleHR7XHJcbiAgICBpbmRpY2llczpSZWNvcmQ8c3RyaW5nLG51bWJlcj47XHJcbiAgICBlcnJvcnM6RXJyb3JNZXNzYWdlW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNEZXJpdmF0aXZlKG5vZGU6QVNUTm9kZSk6Ym9vbGVhbntcclxuICAgIHN3aXRjaChub2RlLnR5cGUpe1xyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0FkZGl0aW9uOntcclxuICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUgYXMgQWRkaXRpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShhZGQubGVmdCl8fGhhc0Rlcml2YXRpdmUoYWRkLnJpZ2h0KTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX1N1YnRyYWN0aW9uOntcclxuICAgICAgICAgICAgbGV0IHN1YiA9IG5vZGUgYXMgU3VidHJhY3Rpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShzdWIubGVmdCl8fGhhc0Rlcml2YXRpdmUoc3ViLnJpZ2h0KTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX011bHRpcGxpY2F0aW9uOntcclxuICAgICAgICAgICAgbGV0IG11bCA9IG5vZGUgYXMgTXVsdGlwbGljYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShtdWwubGVmdCl8fGhhc0Rlcml2YXRpdmUobXVsLnJpZ2h0KTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0RpdmlzaW9uOntcclxuICAgICAgICAgICAgbGV0IGRpdiA9IG5vZGUgYXMgRGl2aXNpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShkaXYubGVmdCl8fGhhc0Rlcml2YXRpdmUoZGl2LnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fTmVnYXRpb246e1xyXG4gICAgICAgICAgICBsZXQgbmVnID0gbm9kZSBhcyBOZWdhdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNEZXJpdmF0aXZlKG5lZy5pbm5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0Z1bmN0aW9uOntcclxuICAgICAgICAgICAgbGV0IGZ1biA9IG5vZGUgYXMgRnVuY3Rpb25Ob2RlO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZ1bi5hcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBoYXNEZXJpdmF0aXZlKGFyZyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX1Rlcm5hcnk6e1xyXG4gICAgICAgICAgICBsZXQgdGVyID0gbm9kZSBhcyBUZXJuYXJ5T3BlcmF0b3JOb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZSh0ZXIuY29uZGl0aW9uKXx8aGFzRGVyaXZhdGl2ZSh0ZXIudHJ1ZSl8fGhhc0Rlcml2YXRpdmUodGVyLmZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fQ29uc3RhbnQ6e1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0Rlcml2YXRpdmU6e1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fVmFySWRlbnRpZmllcjp7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fQW5kOntcclxuICAgICAgICAgICAgbGV0IGFuZCA9IG5vZGUgYXMgQm9vbEFuZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNEZXJpdmF0aXZlKGFuZC5sZWZ0KXx8aGFzRGVyaXZhdGl2ZShhbmQucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Pcjp7XHJcbiAgICAgICAgICAgIGxldCBvciA9IG5vZGUgYXMgQm9vbE9yTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc0Rlcml2YXRpdmUob3IubGVmdCl8fGhhc0Rlcml2YXRpdmUob3IucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Ob3Q6e1xyXG4gICAgICAgICAgICBsZXQgbm90ID0gbm9kZSBhcyBCb29sTmVnYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShub3QuaW5uZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9HcmVhdGVyOntcclxuICAgICAgICAgICAgbGV0IGcgPSBub2RlIGFzIEJvb2xHTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc0Rlcml2YXRpdmUoZy5sZWZ0KXx8aGFzRGVyaXZhdGl2ZShnLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fR3JlYXRlckVxdWFsOntcclxuICAgICAgICAgICAgbGV0IGdlID0gbm9kZSBhcyBCb29sR0VOb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShnZS5sZWZ0KXx8aGFzRGVyaXZhdGl2ZShnZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0xlc3M6e1xyXG4gICAgICAgICAgICBsZXQgbCA9IG5vZGUgYXMgQm9vbExOb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShsLmxlZnQpfHxoYXNEZXJpdmF0aXZlKGwucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9MZXNzRXF1YWw6e1xyXG4gICAgICAgICAgICBsZXQgbGUgPSBub2RlIGFzIEJvb2xMRU5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXNEZXJpdmF0aXZlKGxlLmxlZnQpfHxoYXNEZXJpdmF0aXZlKGxlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fRXF1YWw6e1xyXG4gICAgICAgICAgICBsZXQgZSA9IG5vZGUgYXMgQm9vbEVOb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzRGVyaXZhdGl2ZShlLmxlZnQpfHxoYXNEZXJpdmF0aXZlKGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Ob3RFcXVhbDp7XHJcbiAgICAgICAgICAgIGxldCBuZSA9IG5vZGUgYXMgQm9vbE5FTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc0Rlcml2YXRpdmUobmUubGVmdCl8fGhhc0Rlcml2YXRpdmUobmUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Cb29sQ29uc3RhbnQ6e1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlIGluIGhhc0Rlcml2YXRpdmUoKVwiKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVCb29sRXhwcmVzc2lvbihpdGVtOkJvb2xFeHByZXNzaW9uTm9kZSxjb250ZXh0OkV4cENvbXBpbGVyQ29udGV4dCk6Qm9vbEV4cHJlc3Npb257XHJcbiAgICBzd2l0Y2goaXRlbS50eXBlKXtcclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9BbmQ6e1xyXG4gICAgICAgICAgICBsZXQgYW5kID0gaXRlbSBhcyBCb29sQW5kTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbmQoY29tcGlsZUJvb2xFeHByZXNzaW9uKGFuZC5sZWZ0LGNvbnRleHQpXHJcbiAgICAgICAgICAgICxjb21waWxlQm9vbEV4cHJlc3Npb24oYW5kLnJpZ2h0LGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fT3I6e1xyXG4gICAgICAgICAgICBsZXQgb3IgPSBpdGVtIGFzIEJvb2xPck5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3IoY29tcGlsZUJvb2xFeHByZXNzaW9uKG9yLmxlZnQsY29udGV4dClcclxuICAgICAgICAgICAgLGNvbXBpbGVCb29sRXhwcmVzc2lvbihvci5yaWdodCxjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX05vdDp7XHJcbiAgICAgICAgICAgIGxldCBub3QgPSBpdGVtIGFzIEJvb2xOZWdhdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm9vbE5vdChjb21waWxlQm9vbEV4cHJlc3Npb24obm90LmlubmVyLGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fR3JlYXRlcjp7XHJcbiAgICAgICAgICAgIGxldCBnID0gaXRlbSBhcyBCb29sR05vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JlYXRlcihjb21waWxlRXhwcmVzc2lvbihnLmxlZnQsY29udGV4dClcclxuICAgICAgICAgICAgLGNvbXBpbGVFeHByZXNzaW9uKGcucmlnaHQsY29udGV4dClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fR3JlYXRlckVxdWFsOntcclxuICAgICAgICAgICAgbGV0IGdlID0gaXRlbSBhcyBCb29sR0VOb2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEdFcXVhbChjb21waWxlRXhwcmVzc2lvbihnZS5sZWZ0LGNvbnRleHQpXHJcbiAgICAgICAgICAgICxjb21waWxlRXhwcmVzc2lvbihnZS5yaWdodCxjb250ZXh0KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9MZXNzOntcclxuICAgICAgICAgICAgbGV0IGwgPSBpdGVtIGFzIEJvb2xMTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMZXNzKGNvbXBpbGVFeHByZXNzaW9uKGwubGVmdCxjb250ZXh0KVxyXG4gICAgICAgICAgICAsY29tcGlsZUV4cHJlc3Npb24obC5yaWdodCxjb250ZXh0KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9MZXNzRXF1YWw6e1xyXG4gICAgICAgICAgICBsZXQgbGUgPSBpdGVtIGFzIEJvb2xMRU5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTEVxdWFsKGNvbXBpbGVFeHByZXNzaW9uKGxlLmxlZnQsY29udGV4dClcclxuICAgICAgICAgICAgLGNvbXBpbGVFeHByZXNzaW9uKGxlLnJpZ2h0LGNvbnRleHQpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0VxdWFsOntcclxuICAgICAgICAgICAgbGV0IGUgPSBpdGVtIGFzIEJvb2xFTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcXVhbChjb21waWxlRXhwcmVzc2lvbihlLmxlZnQsY29udGV4dClcclxuICAgICAgICAgICAgLGNvbXBpbGVFeHByZXNzaW9uKGUucmlnaHQsY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Ob3RFcXVhbDp7XHJcbiAgICAgICAgICAgIGxldCBuZSA9IGl0ZW0gYXMgQm9vbE5FTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RFcXVhbChjb21waWxlRXhwcmVzc2lvbihuZS5sZWZ0LGNvbnRleHQpXHJcbiAgICAgICAgICAgICxjb21waWxlRXhwcmVzc2lvbihuZS5yaWdodCxjb250ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX0Jvb2xDb25zdGFudDp7XHJcbiAgICAgICAgICAgIGxldCBiYyA9IGl0ZW0gYXMgQm9vbENvbnN0YW50Tm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sQ29uc3RhbnQoYmMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoaXRlbS50ZXh0UG9zLFwiVW5leHBlY3RlZCBib29sZWFuIGV4cHJlc3Npb24gdHlwZSBhdCBjb21waWxlRXhwcmVzc2lvbigpXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sQ29uc3RhbnQoZmFsc2UpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlRXhwcmVzc2lvbihpdGVtOkV4cHJlc3Npb25Ob2RlLGNvbnRleHQ6RXhwQ29tcGlsZXJDb250ZXh0KTpFeHByZXNzaW9ue1xyXG4gICAgc3dpdGNoKGl0ZW0udHlwZSl7XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fQWRkaXRpb246e1xyXG4gICAgICAgICAgICBsZXQgYWRkID0gaXRlbSBhcyBBZGRpdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkaXRpb24oY29tcGlsZUV4cHJlc3Npb24oYWRkLmxlZnQsY29udGV4dCksY29tcGlsZUV4cHJlc3Npb24oYWRkLnJpZ2h0LGNvbnRleHQpKTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGNhc2UgTm9kZVR5cGUuX1N1YnRyYWN0aW9uOntcclxuICAgICAgICAgICAgbGV0IHN1YiA9IGl0ZW0gYXMgU3VidHJhY3Rpb25Ob2RlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YnRyYWN0aW9uKGNvbXBpbGVFeHByZXNzaW9uKHN1Yi5sZWZ0LGNvbnRleHQpLGNvbXBpbGVFeHByZXNzaW9uKHN1Yi5yaWdodCxjb250ZXh0KSk7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9NdWx0aXBsaWNhdGlvbjp7XHJcbiAgICAgICAgICAgIGxldCBtdWwgPSBpdGVtIGFzIE11bHRpcGxpY2F0aW9uTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNdWx0aXBsaWNhdGlvbihjb21waWxlRXhwcmVzc2lvbihtdWwubGVmdCxjb250ZXh0KSxjb21waWxlRXhwcmVzc2lvbihtdWwucmlnaHQsY29udGV4dCkpO1xyXG4gICAgICAgIH0gXHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fRGl2aXNpb246e1xyXG4gICAgICAgICAgICBsZXQgZGl2ID0gaXRlbSBhcyBEaXZpc2lvbk5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24oY29tcGlsZUV4cHJlc3Npb24oZGl2LmxlZnQsY29udGV4dCksY29tcGlsZUV4cHJlc3Npb24oZGl2LnJpZ2h0LGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fTmVnYXRpb246e1xyXG4gICAgICAgICAgICBsZXQgbmVnID0gaXRlbSBhcyBOZWdhdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmVnYXRpb24oY29tcGlsZUV4cHJlc3Npb24obmVnLmlubmVyLGNvbnRleHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fRnVuY3Rpb246e1xyXG4gICAgICAgICAgICBsZXQgZnVuID0gaXRlbSBhcyBGdW5jdGlvbk5vZGU7XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oZnVuLm5hbWUsZnVuLmFyZ3MubWFwKGZ1bmN0aW9uKGFyZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVFeHByZXNzaW9uKGFyZyxjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfWNhdGNoKGV4Y2VwdGlvbil7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoaXRlbS50ZXh0UG9zLGV4Y2VwdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9Db25zdGFudDp7XHJcbiAgICAgICAgICAgIGxldCBjb24gPSBpdGVtIGFzIENvbnN0YW50Tm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudChjb24udmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9UZXJuYXJ5OntcclxuICAgICAgICAgICAgbGV0IHRlciA9IGl0ZW0gYXMgVGVybmFyeU9wZXJhdG9yTm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXJuYXJ5T3BlcmF0b3IoY29tcGlsZUJvb2xFeHByZXNzaW9uKHRlci5jb25kaXRpb24sY29udGV4dClcclxuICAgICAgICAgICAgLGNvbXBpbGVFeHByZXNzaW9uKHRlci50cnVlLGNvbnRleHQpXHJcbiAgICAgICAgICAgICxjb21waWxlRXhwcmVzc2lvbih0ZXIuZmFsc2UsY29udGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIE5vZGVUeXBlLl9WYXJJZGVudGlmaWVyOntcclxuICAgICAgICAgICAgbGV0IF92YXIgPSBpdGVtIGFzIFZhcklkZW50aWZpZXJOb2RlO1xyXG4gICAgICAgICAgICBpZihfdmFyLmluZGljaWVzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hbGVydChcIlZhciBpZGVudGlmaWVyIGNvbXBpbGVyIGFzc2VydCFcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50KDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGNvbnRleHQuaW5kaWNpZXMuaGFzT3duUHJvcGVydHkoX3Zhci5pZCkpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZShjb250ZXh0LmluZGljaWVzW192YXIuaWRdLF92YXIuaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShpdGVtLnRleHRQb3MsYFVua25vd24gdmFyaWFibGUgXCIke192YXIuaWR9XCIgYXQgY29tcGlsZUV4cHJlc3Npb24oKWApKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBOb2RlVHlwZS5fRGVyaXZhdGl2ZTp7XHJcbiAgICAgICAgICAgIGxldCBfZGVyID0gaXRlbSBhcyBEZXJpdmF0aXZlTm9kZTtcclxuICAgICAgICAgICAgbGV0IGlkID0gX2Rlci5pZC5pZCtcIidcIjtcclxuICAgICAgICAgICAgaWYoX2Rlci5pZC5pbmRpY2llcy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWxlcnQoXCJWYXIgaWRlbnRpZmllciBjb21waWxlciBhc3NlcnQhXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjb250ZXh0LmluZGljaWVzLmhhc093blByb3BlcnR5KGlkKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlKGNvbnRleHQuaW5kaWNpZXNbaWRdLGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoaXRlbS50ZXh0UG9zLGBVbmtub3duIHZhcmlhYmxlIFwiJHtpZH1cIiBhdCBjb21waWxlRXhwcmVzc2lvbigpYCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoaXRlbS50ZXh0UG9zLFwiVW5leHBlY3RlZCBleHByZXNzaW9uIHR5cGUgYXQgY29tcGlsZUV4cHJlc3Npb24oKVwiKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnQoMCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICAgIEV4cHJlc3Npb24sXHJcbiAgICBGdW5jdGlvbixcclxuICAgIE5lZ2F0aW9uLFxyXG4gICAgQ29uc3RhbnQsXHJcbiAgICBEaXZpc2lvbixcclxuICAgIE11bHRpcGxpY2F0aW9uLCBcclxuICAgIFN1YnRyYWN0aW9uLFxyXG4gICAgQWRkaXRpb25cclxufSBmcm9tIFwiLi9leHByZXNzaW9uXCI7XHJcbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25EZXJpdmF0aXZle1xyXG4gICAgKGFyZ3M6RXhwcmVzc2lvbltdKTpFeHByZXNzaW9uO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZ1bmN0aW9uRGVme1xyXG4gICAgbmFtZTpzdHJpbmc7XHJcbiAgICBhcmdDb3VudDpudW1iZXI7XHJcbiAgICBkZXJpdmF0aXZlczpBcnJheTwoYXJnczogRXhwcmVzc2lvbltdKT0+RXhwcmVzc2lvbj47XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lOnN0cmluZyxhcmdDb3VudDpudW1iZXIsZGVyaXZhdGl2ZXM6RnVuY3Rpb25EZXJpdmF0aXZlW10pe1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5hcmdDb3VudCA9IGFyZ0NvdW50O1xyXG4gICAgICAgIHRoaXMuZGVyaXZhdGl2ZXMgPSBkZXJpdmF0aXZlcztcclxuICAgIH1cclxuICAgIGFic3RyYWN0IGV4ZWMoYXJnczpudW1iZXJbXSk6bnVtYmVyO1xyXG4gICAgZ2V0RGVyaXZhdGl2ZShpbmRleDpudW1iZXIsIGFyZ3M6RXhwcmVzc2lvbltdKTpFeHByZXNzaW9ue1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlcml2YXRpdmVzW2luZGV4XShhcmdzKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBzaW4gZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJzaW5cIiwxLCBbc2luLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaW4oYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiY29zXCIsYXJncyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgY29zIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiY29zXCIsMSwgW2Nvcy5kZXJdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY29zKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGlvbihuZXcgRnVuY3Rpb24oXCJjb3NcIixhcmdzKSk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3Mgc2luYyBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcInNpbmNcIiwxLFtzaW5jLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICBpZihhcmdzWzBdPDAuMDAwMSlcclxuICAgICAgICAgICAgcmV0dXJuIDEuMC1hcmdzWzBdKmFyZ3NbMF0vNi4wKigxLi1hcmdzWzBdKmFyZ3NbMF0vMjApOy8vdHJ1bmNhdGVkIG1hY2xhdXJpbiBzZXJpZXMgXHJcbiAgICAgICAgcmV0dXJuIE1hdGguc2luKGFyZ3NbMF0pL2FyZ3NbMF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IERpdmlzaW9uKFxyXG4gICAgICAgICAgICBuZXcgU3VidHJhY3Rpb24obmV3IEZ1bmN0aW9uKFwiY29zXCIsYXJncyksbmV3IEZ1bmN0aW9uKFwic2luY1wiLGFyZ3MpKSxcclxuICAgICAgICAgICAgYXJnc1swXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyB0YW4gZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJ0YW5cIiwxLFt0YW4uZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLnRhbihhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJwb3dcIixbXHJcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcImNvc1wiLCBhcmdzKSxcclxuICAgICAgICAgICAgbmV3IENvbnN0YW50KDIpXSk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIGNvdCBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcImNvdFwiLDEsW2NvdC5kZXJdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY29zKGFyZ3NbMF0pL01hdGguc2luKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGlvbihcclxuICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwicG93XCIsW1xyXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwic2luXCIsYXJncyksXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29uc3RhbnQoMildKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIGFzaW4gZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJhc2luXCIsMSxbYXNpbi5kZXJdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYXNpbihhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24obmV3IENvbnN0YW50KDEuMCksXHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKFwic3FydFwiLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgbmV3IFN1YnRyYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMF0sYXJnc1swXSkpXHJcbiAgICAgICAgXSkpIFxyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBhY29zIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiYWNvc1wiLDEsW2Fjb3MuZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IE5lZ2F0aW9uKFxyXG4gICAgICAgICAgICBuZXcgRGl2aXNpb24obmV3IENvbnN0YW50KDEuMCksXHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKFwic3FydFwiLFxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgbmV3IFN1YnRyYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMF0sYXJnc1swXSkpXHJcbiAgICAgICAgXSkpKTtcclxuICAgIH19O1xyXG5jbGFzcyBhdGFuIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiYXRhblwiLDEsW2F0YW4uZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4oYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IERpdmlzaW9uKG5ldyBDb25zdGFudCgxLjApLFxyXG4gICAgICAgICAgICBuZXcgQWRkaXRpb24oXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29uc3RhbnQoMSksXHJcbiAgICAgICAgICAgICAgICBuZXcgTXVsdGlwbGljYXRpb24oYXJnc1swXSxhcmdzWzBdKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9fTtcclxuY2xhc3MgYWNvdCBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcImFjb3RcIiwxLFthY290LmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5QSS8yLU1hdGguYXRhbihhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgTmVnYXRpb24obmV3IERpdmlzaW9uKG5ldyBDb25zdGFudCgxLjApLFxyXG4gICAgICAgICAgICBuZXcgQWRkaXRpb24oXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29uc3RhbnQoMSksXHJcbiAgICAgICAgICAgICAgICBuZXcgTXVsdGlwbGljYXRpb24oYXJnc1swXSxhcmdzWzBdKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICkpO1xyXG4gICAgfX07XHJcbmNsYXNzIHNpbmggZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJzaW5oXCIsMSxbc2luaC5kZXJdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc2luaChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJjb3NoXCIsYXJncyk7XHJcbiAgICB9fTtcclxuY2xhc3MgY29zaCBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcImNvc2hcIiwxLFtjb3NoLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5jb3NoKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcInNpbmhcIixhcmdzKTtcclxuICAgIH19O1xyXG5jbGFzcyB0YW5oIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwidGFuaFwiLDEsW3RhbmguZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLnRhbmgoYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicG93XCIsW1xyXG4gICAgICAgICAgICBuZXcgRnVuY3Rpb24oXCJjb3NoXCIsYXJncylcclxuICAgICAgICAgICAgLG5ldyBDb25zdGFudCgtMilcclxuICAgICAgICBdKTtcclxuICAgIH19O1xyXG5jbGFzcyBjb3RoIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiY290aFwiLDEsW2NvdGguZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiAxLjAvTWF0aC50YW5oKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGlvbihuZXcgRnVuY3Rpb24oXCJwb3dcIixbXHJcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcInNpbmhcIixhcmdzKVxyXG4gICAgICAgICAgICAsbmV3IENvbnN0YW50KC0yKVxyXG4gICAgICAgIF0pKTtcclxuICAgIH19O1xyXG5jbGFzcyBhc2luaCBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcImFzaW5oXCIsMSxbYXNpbmguZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFzaW5oKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXZpc2lvbihuZXcgQ29uc3RhbnQoMSksXHJcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcInNxcnRcIixbbmV3IEFkZGl0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMF0sYXJnc1swXSksXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29uc3RhbnQoMSlcclxuICAgICAgICAgICAgKV0pXHJcbiAgICAgICAgKTsgXHJcbiAgICB9fTtcclxuY2xhc3MgYWNvc2ggZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJhY29zaFwiLDEsW2Fjb3NoLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5hY29zaChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24obmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICBuZXcgRnVuY3Rpb24oXCJzcXJ0XCIsW25ldyBTdWJ0cmFjdGlvbihcclxuICAgICAgICAgICAgICAgIG5ldyBNdWx0aXBsaWNhdGlvbihhcmdzWzBdLGFyZ3NbMF0pLFxyXG4gICAgICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpXHJcbiAgICAgICAgICAgICldKVxyXG4gICAgICAgICk7XHJcbiAgICB9fTtcclxuY2xhc3MgYXRhbmggZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJhdGFuaFwiLDEsW2F0YW5oLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuaChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24oXHJcbiAgICAgICAgICAgIG5ldyBDb25zdGFudCgxKSxcclxuICAgICAgICAgICAgbmV3IFN1YnRyYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMF0sYXJnc1swXSlcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICApXHJcbiAgICB9fTtcclxuY2xhc3MgYWNvdGggZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJhY290aFwiLDEsW2Fjb3RoLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gMC41Kk1hdGgubG9nKCgxK2FyZ3NbMF0pLyhhcmdzWzBdLTEpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24oXHJcbiAgICAgICAgICAgIG5ldyBDb25zdGFudCgxKSxcclxuICAgICAgICAgICAgbmV3IFN1YnRyYWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMF0sYXJnc1swXSlcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICApXHJcbiAgICB9fTtcclxuY2xhc3MgZXJmIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiZXJmXCIsMSxbZXJmLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNhbGwoeDpudW1iZXIpOm51bWJlcntcclxuICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHgpO1xyXG4gICAgICAgeCA9IE1hdGguYWJzKHgpO1xyXG4gICAgICAgdmFyIGExID0gMC4yNTQ4Mjk1OTI7XHJcbiAgICAgICB2YXIgYTIgPSAtMC4yODQ0OTY3MzY7XHJcbiAgICAgICB2YXIgYTMgPSAxLjQyMTQxMzc0MTtcclxuICAgICAgIHZhciBhNCA9IC0xLjQ1MzE1MjAyNztcclxuICAgICAgIHZhciBhNSA9IDEuMDYxNDA1NDI5O1xyXG4gICAgICAgdmFyIHAgPSAwLjMyNzU5MTE7XHJcbiAgICAgICB2YXIgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XHJcbiAgICAgICB2YXIgeSA9IDEuMCAtICgoKCgoYTUgKiB0ICsgYTQpICogdCkgKyBhMykgKiB0ICsgYTIpICogdCArIGExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xyXG4gICAgICAgcmV0dXJuIHNpZ24gKiB5O1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gZXJmLmNhbGwoYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpcGxpY2F0aW9uKG5ldyBDb25zdGFudCgyLjAgLyBNYXRoLnNxcnQoTWF0aC5QSSkpLCBuZXcgRnVuY3Rpb24oXCJleHBcIiwgW25ldyBOZWdhdGlvbihuZXcgTXVsdGlwbGljYXRpb24oYXJnc1swXSwgYXJnc1swXSkpXSkpO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBleHAgZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJleHBcIiwxLFtleHAuZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmV4cChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJleHBcIiwgYXJncyk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIHBvdyBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcInBvd1wiLDIsW3Bvdy5kZXJYLHBvdy5kZXJZXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXJYKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IE11bHRpcGxpY2F0aW9uKGFyZ3NbMV0sIG5ldyBGdW5jdGlvbihcInBvd1wiLCBbXHJcbiAgICAgICAgICAgIGFyZ3NbMF0sbmV3IFN1YnRyYWN0aW9uKGFyZ3NbMV0sIG5ldyBDb25zdGFudCgxKSlcclxuICAgICAgICBdKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyWShhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aXBsaWNhdGlvbihuZXcgRnVuY3Rpb24oXCJsblwiLCBbYXJnc1swXV0pLCBuZXcgRnVuY3Rpb24oXCJwb3dcIiwgYXJncykpO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBsbiBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcImxuXCIsMSxbbG4uZGVyXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLmxvZyhhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe3JldHVybiBuZXcgRGl2aXNpb24obmV3IENvbnN0YW50KDEuMCksIGFyZ3NbMF0pOyBcclxuICAgIH1cclxufTtcclxuY2xhc3MgbG9nIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwibG9nXCIsMixbbG9nLmRlclgsbG9nLmRlclldKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKGFyZ3NbMV0pL01hdGgubG9nKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlclgoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24oXHJcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcImxuXCIsW2FyZ3NbMV1dKSxcclxuICAgICAgICAgICAgbmV3IE11bHRpcGxpY2F0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKFwicG93XCIsW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbihcImxuXCIsW2FyZ3NbMF1dKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgQ29uc3RhbnQoMildKSxcclxuICAgICAgICAgICAgICAgICAgICBhcmdzWzBdKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyWShhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEaXZpc2lvbihcclxuICAgICAgICAgICAgbmV3IENvbnN0YW50KDEpLFxyXG4gICAgICAgICAgICBuZXcgTXVsdGlwbGljYXRpb24oYXJnc1sxXSxuZXcgRnVuY3Rpb24oXCJsblwiLFthcmdzWzBdXSkpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgbGcgZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJsZ1wiLDEsW2xnLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24oXHJcbiAgICAgICAgICAgIG5ldyBDb25zdGFudCgxLjAvTWF0aC5sb2coMTApKSxcclxuICAgICAgICAgICAgYXJnc1swXSk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIHNxcnQgZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJzcXJ0XCIsMSxbc3FydC5kZXJdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXIoYXJnczpFeHByZXNzaW9uW10pe1xyXG4gICAgICAgIHJldHVybiBuZXcgRGl2aXNpb24obmV3IENvbnN0YW50KDAuNSksbmV3IEZ1bmN0aW9uKFwic3FydFwiLGFyZ3MpKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgYWJzIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiYWJzXCIsMSxbYWJzLmRlcl0pO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXJnc1swXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVyKGFyZ3M6RXhwcmVzc2lvbltdKXtcclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RlcFwiLGFyZ3MpO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBtaW4gZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJtaW5cIiwyLG51bGwpO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIG1heCBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcIm1heFwiLDIsbnVsbCk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChhcmdzWzBdLCBhcmdzWzFdKTtcclxuICAgIH1cclxufTtcclxuY2xhc3Mgc2lnbiBleHRlbmRzIEZ1bmN0aW9uRGVme1xyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcihcInNpZ25cIiwxLG51bGwpO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5zaWduKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBzdGVwIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwic3RlcFwiLDEsbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2FsbCh4Om51bWJlcik6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB4PDA/MDoxO1xyXG4gICAgfVxyXG4gICAgZXhlYyhhcmdzOm51bWJlcltdKXtcclxuICAgICAgICByZXR1cm4gc3RlcC5jYWxsKGFyZ3NbMF0pO1xyXG4gICAgfVxyXG59O1xyXG5jbGFzcyBmcmFjIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwiZnJhY1wiLDEsbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2FsbCh4Om51bWJlcik6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiAoeC1NYXRoLmZsb29yKHgpKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIGZyYWMuY2FsbChhcmdzWzBdKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBzbW9vdGhzdGVwIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwic21vb3Roc3RlcFwiLDEsbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2FsbCh4Om51bWJlcik6bnVtYmVye1xyXG4gICAgICAgIHggPSBNYXRoLm1heChNYXRoLm1pbigxLHgpLDApO1xyXG4gICAgICAgIHJldHVybiB4KngqKDMtMip4KTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIHNtb290aHN0ZXAuY2FsbChhcmdzWzBdKTtcclxuICAgIH1cclxuICAgIC8qc3RhdGljIGRlcihhcmdzOkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgbGV0IHggPSBhcmdzWzBdO1xyXG4gICAgICAgIHJldHVybiBuZXcgXHJcbiAgICAgICAgeCA9IE1hdGgubWF4KE1hdGgubWluKDEseCksMCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudCg2KngqKDEteCkpO1xyXG4gICAgfSovXHJcbn07XHJcbmNsYXNzIGUgZXh0ZW5kcyBGdW5jdGlvbkRlZntcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoXCJlXCIsMCxbXSk7XHJcbiAgICB9XHJcbiAgICBleGVjKGFyZ3M6bnVtYmVyW10pe1xyXG4gICAgICAgIHJldHVybiBNYXRoLkU7XHJcbiAgICB9XHJcbn07XHJcbmNsYXNzIHBpIGV4dGVuZHMgRnVuY3Rpb25EZWZ7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKFwicGlcIiwwLFtdKTtcclxuICAgIH1cclxuICAgIGV4ZWMoYXJnczpudW1iZXJbXSl7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgdmFyIGZ1bmN0aW9uRGljdGlvbmFyeTpSZWNvcmQ8c3RyaW5nLEZ1bmN0aW9uRGVmPiA9IHtcclxuICAgIHNpbjpuZXcgc2luKCksXHJcbiAgICBjb3M6bmV3IGNvcygpLFxyXG4gICAgdGFuOm5ldyB0YW4oKSxcclxuICAgIGNvdDpuZXcgY290KCksXHJcbiAgICBhc2luOm5ldyBhc2luKCksXHJcbiAgICBhY29zOm5ldyBhY29zKCksXHJcbiAgICBhdGFuOm5ldyBhdGFuKCksXHJcbiAgICBhY290Om5ldyBhY290KCksXHJcbiAgICBzaW5oOm5ldyBzaW5oKCksXHJcbiAgICBjb3NoOm5ldyBjb3NoKCksXHJcbiAgICB0YW5oOm5ldyB0YW5oKCksXHJcbiAgICBjb3RoOm5ldyBjb3RoKCksXHJcbiAgICBhc2luaDpuZXcgYXNpbmgoKSxcclxuICAgIGFjb3NoOm5ldyBhY29zaCgpLFxyXG4gICAgYXRhbmg6bmV3IGF0YW5oKCksXHJcbiAgICBhY290aDpuZXcgYWNvdGgoKSxcclxuICAgIGVyZjpuZXcgZXJmKCksXHJcbiAgICBleHA6bmV3IGV4cCgpLFxyXG4gICAgcG93Om5ldyBwb3coKSxcclxuICAgIGxuOm5ldyBsbigpLFxyXG4gICAgbG9nOm5ldyBsb2coKSxcclxuICAgIGxnOm5ldyBsZygpLFxyXG4gICAgc3FydDpuZXcgc3FydCgpLFxyXG4gICAgYWJzOm5ldyBhYnMoKSxcclxuICAgIG1pbjpuZXcgbWluKCksXHJcbiAgICBtYXg6bmV3IG1heCgpLFxyXG4gICAgc2lnbjpuZXcgc2lnbigpLFxyXG4gICAgc3RlcDpuZXcgc3RlcCgpLFxyXG4gICAgZnJhYzpuZXcgZnJhYygpLFxyXG4gICAgc21vb3Roc3RlcDpuZXcgc21vb3Roc3RlcCgpLFxyXG4gICAgZTpuZXcgZSgpLFxyXG4gICAgcGk6bmV3IHBpKCksXHJcbiAgICBzaW5jOm5ldyBzaW5jKClcclxufTsiLCJpbXBvcnQgeyBFREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4uL2RhZS9lZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCB7IFN5c3RlbURlZmluaXRpb24sIEJvb2xFeHByZXNzaW9uTm9kZSwgTWFjcm9TdGF0ZW1lbnROb2RlLCBOb2RlVHlwZSwgU3RhdGVtZW50Tm9kZSwgTG9vcFN0YXRlbWVudE5vZGUsIEVxdWF0aW9uTm9kZSwgSW5pdGlhbENvbmRpdGlvbk5vZGUsIFZhcklkZW50aWZpZXJOb2RlLCBFeHByZXNzaW9uTm9kZSwgQ29uc3RhbnROb2RlLCBDb25zdGFudFN0YXRlbWVudE5vZGUsIFN1bUV4cHJlc3Npb25Ob2RlLCBEZXJpdmF0aXZlTm9kZSwgTWFjcm9FeHByZXNzaW9uTm9kZSwgQWRkaXRpb25Ob2RlLCBNdWx0aXBsaWNhdGlvbk5vZGUsIEZ1bmN0aW9uTm9kZSwgU3VidHJhY3Rpb25Ob2RlLCBEaXZpc2lvbk5vZGUsIE5lZ2F0aW9uTm9kZSwgQm9vbEFuZE5vZGUsIEJvb2xPck5vZGUsIEJvb2xOZWdhdGlvbk5vZGUsIEJvb2xHTm9kZSwgQm9vbEdFTm9kZSwgQm9vbExOb2RlLCBCb29sQ29uc3RhbnROb2RlLCBCb29sTEVOb2RlLCBCb29sTkVOb2RlLCBCb29sRU5vZGUsIFRlcm5hcnlPcGVyYXRvck5vZGUsIFN0YXRlTm9kZSwgU2V0dGVyTm9kZSwgVGV4dFBvc2l0aW9uIH0gZnJvbSBcIi4vYXN0Tm9kZVwiO1xyXG5pbXBvcnQgeyBJREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4uL2RhZS9pZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCBFcnJvck1lc3NhZ2UgZnJvbSBcIi4vZXJyb3JcIjtcclxuaW1wb3J0IHsgRXhwcmVzc2lvbn0gZnJvbSBcIi4vZXhwcmVzc2lvblwiO1xyXG5cclxuaW1wb3J0IEVycm9yTGlzdGVuZXIgZnJvbSBcIi4vZXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgVmlzaXRvciBmcm9tIFwiLi92aXNpdG9yXCI7XHJcbmltcG9ydCBhbnRscjQsIHsgTGV4ZXIsIFBhcnNlciB9IGZyb20gXCJhbnRscjQvaW5kZXhcIjtcclxuaW1wb3J0IG9kZUdyYW1tYXJMZXhlciBmcm9tIFwiLi4vZ3JhbW1hci9hbnRsck91dHB1dC9vZGVHcmFtbWFyTGV4ZXIuanNcIjtcclxuaW1wb3J0IG9kZUdyYW1tYXJQYXJzZXIgZnJvbSBcIi4uL2dyYW1tYXIvYW50bHJPdXRwdXQvb2RlR3JhbW1hclBhcnNlci5qc1wiO1xyXG5pbXBvcnQgeyBDb21waWxlckNvbnRleHQsIExvb3BDb250ZXh0LCBNYWNyb0NvbnRleHQgfSBmcm9tIFwiLi9jb21waWxlckNvbnRleHRcIjtcclxuaW1wb3J0IHsgY29tcGlsZUV4cHJlc3Npb24sIGhhc0Rlcml2YXRpdmUsIGNvbXBpbGVCb29sRXhwcmVzc2lvbiwgRXhwQ29tcGlsZXJDb250ZXh0IH0gZnJvbSBcIi4vZXhwcmVzc2lvbkNvbXBpbGVyXCI7XHJcbmltcG9ydCB7IEN1c3RvbUVEQUVIeWJyaWRTdGF0ZSB9IGZyb20gXCIuLi9kYWUvY3VzdG9tRURBRUh5YnJpZFN0YXRlXCI7XHJcbmltcG9ydCB7dmVjdG9yfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgQ3VzdG9tSHlicmlkU3RhdGVMaW5rIH0gZnJvbSBcIi4uL2RhZS9jdXN0b21IeWJyaWRTdGF0ZUxpbmtcIjtcclxuaW1wb3J0IHsgQ3VzdG9tSURBRUh5YnJpZFN0YXRlIH0gZnJvbSBcIi4uL2RhZS9jdXN0b21JREFFSHlicmlkU3RhdGVcIjtcclxuaW1wb3J0IHsgQ29tcGlsZXJFcnJvciB9IGZyb20gXCIuL2NvbXBpbGVyRXJyb3JcIjtcclxuXHJcblxyXG5jbGFzcyBWYXJpYWJsZUVudHJ5e1xyXG4gICAgbmFtZTpzdHJpbmc7XHJcbiAgICBpbml0aWFsVmFsdWU6bnVtYmVyO1xyXG4gICAgaXNBbGdlYnJhaWM6Ym9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWU6c3RyaW5nLGlzQWxnZWJyYWljOmJvb2xlYW4saW5pdGlhbFZhbHVlOm51bWJlciA9IDApe1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgdGhpcy5pc0FsZ2VicmFpYyA9IGlzQWxnZWJyYWljO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVxdWF0aW9uRW50cnl7XHJcbiAgICBleHByZXNzaW9uOkV4cHJlc3Npb25Ob2RlO1xyXG4gICAgaXNBbGdlYnJhaWM6Ym9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb246RXhwcmVzc2lvbk5vZGUsaXNBbGdlYnJhaWM6Ym9vbGVhbil7XHJcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcclxuICAgICAgICB0aGlzLmlzQWxnZWJyYWljID0gaXNBbGdlYnJhaWM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgVHJhbnNpdGlvbntcclxuICAgIGluY2lkZW50U3RhdGVzOnN0cmluZ1tdO1xyXG4gICAgY29uZGl0aW9uOkJvb2xFeHByZXNzaW9uTm9kZTtcclxuICAgIGNvbnN0cnVjdG9yKGluY2lkZW50U3RhdGVzOnN0cmluZ1tdLGNvbmRpdGlvbjpCb29sRXhwcmVzc2lvbk5vZGUpe1xyXG4gICAgICAgIHRoaXMuaW5jaWRlbnRTdGF0ZXMgPSBpbmNpZGVudFN0YXRlcztcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBTdGF0ZXtcclxuICAgIGVxdWF0aW9uczpSZWNvcmQ8c3RyaW5nLEVxdWF0aW9uRW50cnk+O1xyXG4gICAgc2V0dGVyczpSZWNvcmQ8c3RyaW5nLEV4cHJlc3Npb25Ob2RlPjtcclxuICAgIHRyYW5zaXRpb25zOlRyYW5zaXRpb25bXTtcclxuICAgIGlzVGVybWluYWw6Ym9vbGVhbjtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5lcXVhdGlvbnMgPSB7fTtcclxuICAgICAgICB0aGlzLnNldHRlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLnRyYW5zaXRpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5pc1Rlcm1pbmFsID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBIeWJyaWRTeXN0ZW1Db21waWxlcntcclxuICAgIHByb3RlY3RlZCBjb25zdGFudHM6UmVjb3JkPHN0cmluZyxudW1iZXI+O1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlczpSZWNvcmQ8c3RyaW5nLFN0YXRlPjtcclxuICAgIHByb3RlY3RlZCB2YXJpYWJsZXM6UmVjb3JkPHN0cmluZyxWYXJpYWJsZUVudHJ5PjtcclxuICAgIHByb3RlY3RlZCBtYWNyb3M6UmVjb3JkPHN0cmluZyxNYWNyb1N0YXRlbWVudE5vZGU+O1xyXG4gICAgcHJvdGVjdGVkIGNvbnRleHQ6Q29tcGlsZXJDb250ZXh0O1xyXG4gICAgcHJvdGVjdGVkIGVycm9yczpFcnJvck1lc3NhZ2VbXTtcclxuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6c3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIGlzRXhwbGljaXQ6Ym9vbGVhbjtcclxuICAgIHByb3RlY3RlZCBlcHNpbG9uOm51bWJlcjtcclxuICAgIHByb3RlY3RlZCBib29sRXhwRXBzaWxvbjpudW1iZXI7XHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMuY29uc3RhbnRzID0ge307XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB7aW5pdGlhbDpuZXcgU3RhdGUoKX07XHJcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBcImluaXRpYWxcIjtcclxuICAgICAgICB0aGlzLmVwc2lsb24gPSAxZS0zO1xyXG4gICAgICAgIHRoaXMuYm9vbEV4cEVwc2lsb24gPSAxZS04O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGNvbXBpbGVFeHBsaWNpdCh0ZXh0OnN0cmluZyk6e3N5c3RlbTpFREFFSHlicmlkU3lzdGVtLHgwOnZlY3Rvcix4OnN0cmluZ1tdLHo6c3RyaW5nW119e1xyXG4gICAgICAgIHRoaXMuaXNFeHBsaWNpdCA9IHRydWU7XHJcblxyXG4gICAgICAgIHZhciBjaGFycyA9IG5ldyBhbnRscjQuSW5wdXRTdHJlYW0odGV4dCk7XHJcbiAgICAgICAgdmFyIGxleGVyID0gbmV3IG9kZUdyYW1tYXJMZXhlci5vZGVHcmFtbWFyTGV4ZXIoY2hhcnMpO1xyXG4gICAgICAgIChsZXhlciBhcyB1bmtub3duIGFzIExleGVyKS5yZW1vdmVFcnJvckxpc3RlbmVycygpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG5ldyBFcnJvckxpc3RlbmVyKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICAobGV4ZXIgYXMgdW5rbm93biBhcyBMZXhlcikuYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV4ZXIuc3RyaWN0TW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSBuZXcgYW50bHI0LkNvbW1vblRva2VuU3RyZWFtKGxleGVyIGFzIHVua25vd24gYXMgTGV4ZXIpO1xyXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyKHRva2Vucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikucmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTtcclxuICAgICAgICAocGFyc2VyIGFzIHVua25vd24gYXMgUGFyc2VyKS5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaXNpdG9yKCk7XHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikuYnVpbGRQYXJzZVRyZWVzID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdHJlZSA9IHBhcnNlci5oeWJyaWQoKTtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHRyZWUudG9TdHJpbmdUcmVlKHBhcnNlci5ydWxlTmFtZXMpKTtcclxuXHJcbiAgICAgICAgLy9jaGVjayBmb3IgcGFyc2VyL2xleGVyIGVycm9yc1xyXG4gICAgICAgIGlmKHRoaXMuZXJyb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVyRXJyb3IodGhpcy5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGFlU3lzdGVtRGVmID0gdmlzaXRvci5zdGFydEh5YnJpZCh0cmVlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgLy9mb3IgZGVidWcgcHVycG9zZXNcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGRhZVN5c3RlbURlZi5zdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIHNlbGYuY29tcGlsZVN0YXRlbWVudChpdGVtKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9zZXQgdmFyaWFibGUgaW5kaWNpZXNcclxuICAgICAgICBsZXQgeDpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCB6OnN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IHgwOm51bWJlcltdID0gW107XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy52YXJpYWJsZXMpLmZvckVhY2goZnVuY3Rpb24oW2tleSwgdmFyaWFibGVdKXtcclxuICAgICAgICAgICAgaWYodmFyaWFibGUuaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgei5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHgucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgeDAucHVzaCh2YXJpYWJsZS5pbml0aWFsVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9wcmVwYXJlIHZhcmlhYmxlIGluZGljaWVzXHJcbiAgICAgICAgbGV0IGFsZ0NvbnRleHQ6RXhwQ29tcGlsZXJDb250ZXh0ID0ge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc307XHJcbiAgICAgICAgbGV0IGRpZkNvbnRleHQ6RXhwQ29tcGlsZXJDb250ZXh0ID0ge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc307XHJcbiAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saW5kZXgpe1xyXG4gICAgICAgICAgICBhbGdDb250ZXh0LmluZGljaWVzW2l0ZW1dID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbV0gPSBpbmRleDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbV0gPSBpbmRleCArIHgubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFsZ0NvbnRleHQuaW5kaWNpZXNbXCJ0XCJdID0geC5sZW5ndGg7XHJcbiAgICAgICAgZGlmQ29udGV4dC5pbmRpY2llc1tcInRcIl0gPSB4Lmxlbmd0aCArIHoubGVuZ3RoO1xyXG4gICAgICAgIC8vY29tcGlsZSBpbml0aWFsIHN0YXRlXHJcbiAgICAgICAgbGV0IHN0YXRlczpDdXN0b21FREFFSHlicmlkU3RhdGVbXSA9IFtdO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHRoaXMuc3RhdGVzW1wiaW5pdGlhbFwiXTtcclxuICAgICAgICAgICAgbGV0IGY6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBnOkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnZhcmlhYmxlcykuZm9yRWFjaChmdW5jdGlvbihba2V5LCB2YXJpYWJsZV0pe1xyXG4gICAgICAgICAgICAgICAgaWYoIWluaXRpYWxTdGF0ZS5lcXVhdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTWlzc2luZyBlcXVhdGlvbiBmb3IgdmFyaWFibGUgXCIke2tleX1cIiBpbiBpbml0aWFsIHN0YXRlYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBlcXVhdGlvbiA9IGluaXRpYWxTdGF0ZS5lcXVhdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmKHZhcmlhYmxlLmlzQWxnZWJyYWljIT1lcXVhdGlvbi5pc0FsZ2VicmFpYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKFRleHRQb3NpdGlvbi5pbnZhbGlkKCksYE5vbiBjb21wYXRpYmxlIHR5cGVzIG9mIHZhcmlhYmxlIGFuZCBlcXVhdGlvbiBcIiR7a2V5fVwiIGluIGluaXRpYWwgc3RhdGVgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYodmFyaWFibGUuaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGcucHVzaChjb21waWxlRXhwcmVzc2lvbihlcXVhdGlvbi5leHByZXNzaW9uLGFsZ0NvbnRleHQpLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZi5wdXNoKGNvbXBpbGVFeHByZXNzaW9uKGVxdWF0aW9uLmV4cHJlc3Npb24sZGlmQ29udGV4dCkuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgZGZkeDpFeHByZXNzaW9uW11bXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZGZkejpFeHByZXNzaW9uW11bXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZGdkeDpFeHByZXNzaW9uW11bXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgZGdkdDpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgbGV0IGR4Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKF94KXtcclxuICAgICAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGZkeC5wdXNoKGR4Um93KTtcclxuICAgICAgICAgICAgICAgIGxldCBkelJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihfeil7XHJcbiAgICAgICAgICAgICAgICAgICAgZHpSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3osIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRmZHoucHVzaChkelJvdyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2goZnVuY3Rpb24oX3gpe1xyXG4gICAgICAgICAgICAgICAgICAgIGR4Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF94LCBzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZ2R4LnB1c2goZHhSb3cpO1xyXG4gICAgICAgICAgICAgICAgZGdkdC5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShcInRcIixzZWxmLmVwc2lsb24pKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc3RhdGVzLnB1c2gobmV3IEN1c3RvbUVEQUVIeWJyaWRTdGF0ZShcImluaXRpYWxcIixbXSxmYWxzZSkuaW5pdChmLGcsZGZkeCxkZmR6LGRnZHgsZGdkdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbXBpbGUgc3RhdGVzXHJcbiAgICAgICAgbGV0IHN0YXRlSW5kaWNpZXM6UmVjb3JkPHN0cmluZyxudW1iZXI+ID0ge2luaXRpYWw6MH07XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5zdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oW2tleSxzdGF0ZV0pe1xyXG4gICAgICAgICAgICAvL3NraXAgaW5pdGlhbCBzdGF0ZVxyXG4gICAgICAgICAgICBpZihrZXk9PVwiaW5pdGlhbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGY6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBnOkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAvL2NoZWNrIGVxdWF0aW9uc1xyXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzZWxmLnZhcmlhYmxlcykuZm9yRWFjaChmdW5jdGlvbihba2V5LCB2YXJpYWJsZV0pe1xyXG4gICAgICAgICAgICAgICAgaWYoIXN0YXRlLmVxdWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29weSBlcXVhdGlvbnMgZnJvbSBpbml0aWFsIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodmFyaWFibGUuaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnLnB1c2goc3RhdGVzWzBdLl9nW2cubGVuZ3RoXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYucHVzaChzdGF0ZXNbMF0uX2ZbZi5sZW5ndGhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGVxdWF0aW9uID0gc3RhdGUuZXF1YXRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZih2YXJpYWJsZS5pc0FsZ2VicmFpYyE9ZXF1YXRpb24uaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShUZXh0UG9zaXRpb24uaW52YWxpZCgpLGBOb24gY29tcGF0aWJsZSB0eXBlcyBvZiB2YXJpYWJsZSBhbmQgZXF1YXRpb24gXCIke2tleX1cIiBpbiBzdGF0ZSBcIiR7a2V5fVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHZhcmlhYmxlLmlzQWxnZWJyYWljKXtcclxuICAgICAgICAgICAgICAgICAgICBnLnB1c2goY29tcGlsZUV4cHJlc3Npb24oZXF1YXRpb24uZXhwcmVzc2lvbixhbGdDb250ZXh0KS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGYucHVzaChjb21waWxlRXhwcmVzc2lvbihlcXVhdGlvbi5leHByZXNzaW9uLGRpZkNvbnRleHQpLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy9jb21waWxlIGRlcml2YXRpdmVzXHJcbiAgICAgICAgICAgIGxldCBkZmR4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZmR6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R0OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2goZnVuY3Rpb24oX3gpe1xyXG4gICAgICAgICAgICAgICAgICAgIGR4Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF94LCBzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZmR4LnB1c2goZHhSb3cpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGR6Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgei5mb3JFYWNoKGZ1bmN0aW9uKF96KXtcclxuICAgICAgICAgICAgICAgICAgICBkelJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeiwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGZkei5wdXNoKGR6Um93KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGcuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgICAgIGxldCBkeFJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihfeCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZHhSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3gsIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRnZHgucHVzaChkeFJvdyk7XHJcbiAgICAgICAgICAgICAgICBkZ2R0LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKFwidFwiLHNlbGYuZXBzaWxvbikpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdGF0ZUluZGljaWVzW2tleV0gPSBzdGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBzdGF0ZXMucHVzaChuZXcgQ3VzdG9tRURBRUh5YnJpZFN0YXRlKGtleSxbXSxmYWxzZSkuaW5pdChmLGcsZGZkeCxkZmR6LGRnZHgsZGdkdCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vY29tcGlsZSB0cmFuc2l0aW9uc1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksc3RhdGVdKXtcclxuICAgICAgICAgICAgaWYoa2V5PT1cImluaXRpYWxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgLy9jb21waWxlIHNldHRlcnNcclxuICAgICAgICAgICAgbGV0IHNldHRlcnM6e2luZGV4Om51bWJlcixleHByZXNzaW9uOkV4cHJlc3Npb259W10gPSBbXTtcclxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RhdGUuc2V0dGVycykuZm9yRWFjaChmdW5jdGlvbihba2V5LCBzZXR0ZXJdKXtcclxuICAgICAgICAgICAgICAgIGlmKHNlbGYudmFyaWFibGVzW2tleV0uaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCB2YXJpYWJsZUluZGV4ID0gYWxnQ29udGV4dC5pbmRpY2llc1trZXldO1xyXG4gICAgICAgICAgICAgICAgc2V0dGVycy5wdXNoKHtpbmRleDp2YXJpYWJsZUluZGV4LGV4cHJlc3Npb246Y29tcGlsZUV4cHJlc3Npb24oc2V0dGVyLGRpZkNvbnRleHQpLnNpbXBsaWZ5KCl9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZUluZGV4ID0gc3RhdGVJbmRpY2llc1trZXldO1xyXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zaXRpb24pe1xyXG4gICAgICAgICAgICAgICAgbGV0IHAgPSBjb21waWxlQm9vbEV4cHJlc3Npb24odHJhbnNpdGlvbi5jb25kaXRpb24sZGlmQ29udGV4dCkuc2ltcGxpZnkoKS5jb252ZXJ0VG9FeHByZXNzaW9uKHNlbGYuYm9vbEV4cEVwc2lsb24pO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRwZHQgPSBwLmRpZmZlcmVudGlhdGUoXCJ0XCIsc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRwZHg6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgZHBkejpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHNlbGYudmFyaWFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIHZhcmlhYmxlXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodmFyaWFibGUuaXNBbGdlYnJhaWMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcGR6LnB1c2gocC5kaWZmZXJlbnRpYXRlKGtleSxzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcGR4LnB1c2gocC5kaWZmZXJlbnRpYXRlKGtleSxzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5pbmNpZGVudFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGluY2lkZW50U3RhdGUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzZWxmLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShpbmNpZGVudFN0YXRlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShUZXh0UG9zaXRpb24uaW52YWxpZCgpLGBVbmtub3duIGluY2lkZW50IHN0YXRlIFwiJHtpbmNpZGVudFN0YXRlfVwiIGluIHRyYW5zaXRpb24gcnVsZSBmb3Igc3RhdGUgXCIke2tleX1cImApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXNbc3RhdGVJbmRpY2llc1tpbmNpZGVudFN0YXRlXV0ucHVzaExpbmsobmV3IEN1c3RvbUh5YnJpZFN0YXRlTGluayhuZXdTdGF0ZUluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJzLHAsZHBkeCxkcGR6LGRwZHQpKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKHRoaXMuZXJyb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVyRXJyb3IodGhpcy5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge3N5c3RlbTpuZXcgRURBRUh5YnJpZFN5c3RlbShzdGF0ZXMpLHgwOm5ldyB2ZWN0b3IoeDApLHg6eCx6Onp9O1xyXG4gICAgICAgIC8vcmV0dXJuIHtzeXN0ZW06LHgwOix4Oix6On07XHJcbiAgICB9XHJcbiAgICBjb21waWxlSW1wbGljaXQodGV4dDpzdHJpbmcpOntzeXN0ZW06SURBRUh5YnJpZFN5c3RlbSx4MDp2ZWN0b3IseDpzdHJpbmdbXSx6MDp2ZWN0b3IsejpzdHJpbmdbXX17XHJcbiAgICAgICAgdGhpcy5pc0V4cGxpY2l0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHZhciBjaGFycyA9IG5ldyBhbnRscjQuSW5wdXRTdHJlYW0odGV4dCk7XHJcbiAgICAgICAgdmFyIGxleGVyID0gbmV3IG9kZUdyYW1tYXJMZXhlci5vZGVHcmFtbWFyTGV4ZXIoY2hhcnMpO1xyXG4gICAgICAgIChsZXhlciBhcyB1bmtub3duIGFzIExleGVyKS5yZW1vdmVFcnJvckxpc3RlbmVycygpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG5ldyBFcnJvckxpc3RlbmVyKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICAobGV4ZXIgYXMgdW5rbm93biBhcyBMZXhlcikuYWRkRXJyb3JMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgbGV4ZXIuc3RyaWN0TW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSBuZXcgYW50bHI0LkNvbW1vblRva2VuU3RyZWFtKGxleGVyIGFzIHVua25vd24gYXMgTGV4ZXIpO1xyXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyKHRva2Vucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikucmVtb3ZlRXJyb3JMaXN0ZW5lcnMoKTtcclxuICAgICAgICAocGFyc2VyIGFzIHVua25vd24gYXMgUGFyc2VyKS5hZGRFcnJvckxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB2YXIgdmlzaXRvciA9IG5ldyBWaXNpdG9yKCk7XHJcbiAgICAgICAgKHBhcnNlciBhcyB1bmtub3duIGFzIFBhcnNlcikuYnVpbGRQYXJzZVRyZWVzID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdHJlZSA9IHBhcnNlci5oeWJyaWQoKTtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHRyZWUudG9TdHJpbmdUcmVlKHBhcnNlci5ydWxlTmFtZXMpKTtcclxuXHJcbiAgICAgICAgLy9jaGVjayBmb3IgcGFyc2VyL2xleGVyIGVycm9yc1xyXG4gICAgICAgIGlmKHRoaXMuZXJyb3JzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENvbXBpbGVyRXJyb3IodGhpcy5lcnJvcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGFlU3lzdGVtRGVmID0gdmlzaXRvci5zdGFydEh5YnJpZCh0cmVlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgLy9mb3IgZGVidWcgcHVycG9zZXNcclxuICAgICAgICBpZih0aGlzLmVycm9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21waWxlckVycm9yKHRoaXMuZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGRhZVN5c3RlbURlZi5zdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIHNlbGYuY29tcGlsZVN0YXRlbWVudChpdGVtKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHg6c3RyaW5nW10gPSBbXTtcclxuICAgICAgICBsZXQgejpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCB4MDpudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGxldCB6MDpudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMudmFyaWFibGVzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIHZhcmlhYmxlXSl7XHJcbiAgICAgICAgICAgIGlmKHZhcmlhYmxlLmlzQWxnZWJyYWljKXtcclxuICAgICAgICAgICAgICAgIHoucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgejAucHVzaCh2YXJpYWJsZS5pbml0aWFsVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB4LnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIHgwLnB1c2godmFyaWFibGUuaW5pdGlhbFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL3ByZXBhcmUgdmFyaWFibGUgaW5kaWNpZXNcclxuICAgICAgICAvL3gseix0XHJcbiAgICAgICAgbGV0IGFsZ0NvbnRleHQ6RXhwQ29tcGlsZXJDb250ZXh0ID0ge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc307XHJcbiAgICAgICAgLy94LGR4LHosdFxyXG4gICAgICAgIGxldCBkaWZDb250ZXh0OkV4cENvbXBpbGVyQ29udGV4dCA9IHtpbmRpY2llczp7fSxlcnJvcnM6dGhpcy5lcnJvcnN9O1xyXG4gICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4O1xyXG4gICAgICAgICAgICBkaWZDb250ZXh0LmluZGljaWVzW2l0ZW1dID0gaW5kZXg7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbStcIidcIl0gPSBpbmRleCArIHgubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihpdGVtLGluZGV4KXtcclxuICAgICAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tpdGVtXSA9IGluZGV4ICsgeC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbaXRlbV0gPSBpbmRleCArIDIqeC5sZW5ndGg7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYWxnQ29udGV4dC5pbmRpY2llc1tcInRcIl0gPSB4Lmxlbmd0aCArIHoubGVuZ3RoO1xyXG4gICAgICAgIGRpZkNvbnRleHQuaW5kaWNpZXNbXCJ0XCJdID0gMip4Lmxlbmd0aCArIHoubGVuZ3RoO1xyXG5cclxuICAgICAgICBsZXQgaW5pdGlhbFN0YXRlID0gdGhpcy5zdGF0ZXNbXCJpbml0aWFsXCJdO1xyXG4gICAgICAgIGxldCBlcXVhdGlvbkluZGljaWVzOlJlY29yZDxzdHJpbmcsbnVtYmVyPiA9IHt9O1xyXG4gICAgICAgIC8vY29tcGlsZSBpbml0aWFsIHN0YXRlXHJcbiAgICAgICAgbGV0IHN0YXRlczpDdXN0b21JREFFSHlicmlkU3RhdGVbXSA9IFtdO1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGY6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBnOkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhpbml0aWFsU3RhdGUuZXF1YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIGVxdWF0aW9uXSl7XHJcbiAgICAgICAgICAgICAgICBpZihlcXVhdGlvbi5pc0FsZ2VicmFpYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgZXF1YXRpb25JbmRpY2llc1trZXldID0gZy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZy5wdXNoKGNvbXBpbGVFeHByZXNzaW9uKGVxdWF0aW9uLmV4cHJlc3Npb24sYWxnQ29udGV4dCkuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBlcXVhdGlvbkluZGljaWVzW2tleV0gPSBmLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmLnB1c2goY29tcGlsZUV4cHJlc3Npb24oZXF1YXRpb24uZXhwcmVzc2lvbixkaWZDb250ZXh0KS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmKGYubGVuZ3RoIT14Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTnVtYmVyIG9mIGRpZi4gZXF1YXRpb25zOiAke2YubGVuZ3RofSwgZGlmLiB2YXJpYWJsZXM6ICR7eC5sZW5ndGh9IGluIHN0YXRlIFwiaW5pdGlhbFwiYCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGcubGVuZ3RoIT16Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTnVtYmVyIG9mIGFsZy4gZXF1YXRpb25zOiAke2cubGVuZ3RofSwgYWxnLiB2YXJpYWJsZXM6ICR7ei5sZW5ndGh9IGluIHN0YXRlIFwiaW5pdGlhbFwiYCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGZvciBlcXVhdGlvbnMgbnVtYmVyO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGRmZHg6RXhwcmVzc2lvbltdW10gPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRmZGR4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZmR6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R0OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICBmLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgZGR4Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKF94KXtcclxuICAgICAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBkZHhSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3ggKyBcIidcIiwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGZkeC5wdXNoKGR4Um93KTtcclxuICAgICAgICAgICAgICAgIGRmZGR4LnB1c2goZGR4Um93KTtcclxuICAgICAgICAgICAgICAgIGxldCBkelJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihfeil7XHJcbiAgICAgICAgICAgICAgICAgICAgZHpSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3osIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRmZHoucHVzaChkelJvdyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBnLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHhSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICB4LmZvckVhY2goZnVuY3Rpb24oX3gpe1xyXG4gICAgICAgICAgICAgICAgICAgIGR4Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF94LCBzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZ2R4LnB1c2goZHhSb3cpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGR6Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgei5mb3JFYWNoKGZ1bmN0aW9uKF96KXtcclxuICAgICAgICAgICAgICAgICAgICBkelJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeiwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGdkei5wdXNoKGR6Um93KTtcclxuICAgICAgICAgICAgICAgIGRnZHQucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoXCJ0XCIsc2VsZi5lcHNpbG9uKSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN0YXRlcy5wdXNoKG5ldyBDdXN0b21JREFFSHlicmlkU3RhdGUoXCJpbml0aWFsXCIsW10sZmFsc2UpLmluaXQoZixnLGRmZHgsZGZkZHgsZGZkeixkZ2R4LGRnZHosZGdkdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbXBpbGUgc3RhdGVzXHJcbiAgICAgICAgbGV0IHN0YXRlSW5kaWNpZXM6UmVjb3JkPHN0cmluZyxudW1iZXI+ID0ge2luaXRpYWw6MH07XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5zdGF0ZXMpLmZvckVhY2goZnVuY3Rpb24oW2tleSxzdGF0ZV0pe1xyXG4gICAgICAgICAgICAvL3NraXAgaW5pdGlhbCBzdGF0ZVxyXG4gICAgICAgICAgICBpZihrZXk9PVwiaW5pdGlhbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBsZXQgZjpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgbGV0IGc6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgIC8vY2hlY2sgZXF1YXRpb25zXHJcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGluaXRpYWxTdGF0ZS5lcXVhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oW2VxdWF0aW9uS2V5LCBlcXVhdGlvbl0pe1xyXG4gICAgICAgICAgICAgICAgaWYoIXN0YXRlLmVxdWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShlcXVhdGlvbktleSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb3B5IGVxdWF0aW9ucyBmcm9tIGluaXRpYWwgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZihlcXVhdGlvbi5pc0FsZ2VicmFpYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcucHVzaChzdGF0ZXNbMF0uX2dbZXF1YXRpb25JbmRpY2llc1tlcXVhdGlvbktleV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZi5wdXNoKHN0YXRlc1swXS5fZltlcXVhdGlvbkluZGljaWVzW2VxdWF0aW9uS2V5XV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGVFcXVhdGlvbiA9IHN0YXRlLmVxdWF0aW9uc1tlcXVhdGlvbktleV07XHJcbiAgICAgICAgICAgICAgICBpZihzdGF0ZUVxdWF0aW9uLmlzQWxnZWJyYWljKXtcclxuICAgICAgICAgICAgICAgICAgICBnLnB1c2goY29tcGlsZUV4cHJlc3Npb24oZXF1YXRpb24uZXhwcmVzc2lvbixhbGdDb250ZXh0KS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGYucHVzaChjb21waWxlRXhwcmVzc2lvbihlcXVhdGlvbi5leHByZXNzaW9uLGRpZkNvbnRleHQpLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZXF1YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGVxdWF0aW9uS2V5KXtcclxuICAgICAgICAgICAgICAgIGlmKCFpbml0aWFsU3RhdGUuZXF1YXRpb25zLmhhc093blByb3BlcnR5KGVxdWF0aW9uS2V5KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKFRleHRQb3NpdGlvbi5pbnZhbGlkKCksYFN0YXRlIFwiJHtrZXl9XCIgY29udGFpbnMgZXhjZXNzIGVxdWF0aW9uIFwiJHtlcXVhdGlvbktleX1cImApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgaWYoT2JqZWN0LmtleXMoc3RhdGUuZXF1YXRpb25zKS5sZW5ndGghPXN0YXRlc1swXS5fZi5sZW5ndGgrc3RhdGVzWzBdLl9nLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShUZXh0UG9zaXRpb24uaW52YWxpZCgpLGBTdGF0ZSAke2YubGVuZ3RofSwgZGlmLiB2YXJpYWJsZXM6ICR7eC5sZW5ndGh9YCkpO1xyXG4gICAgICAgICAgICBpZihmLmxlbmd0aCE9eC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKFRleHRQb3NpdGlvbi5pbnZhbGlkKCksYE51bWJlciBvZiBkaWYuIGVxdWF0aW9uczogJHtmLmxlbmd0aH0sIGRpZi4gdmFyaWFibGVzOiAke3gubGVuZ3RofSBpbiBzdGF0ZSBcIiR7a2V5fVwiYCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGcubGVuZ3RoIT16Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2UoVGV4dFBvc2l0aW9uLmludmFsaWQoKSxgTnVtYmVyIG9mIGFsZy4gZXF1YXRpb25zOiAke2cubGVuZ3RofSwgYWxnLiB2YXJpYWJsZXM6ICR7ei5sZW5ndGh9IGluIHN0YXRlIFwiJHtrZXl9XCJgKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGRmZHg6RXhwcmVzc2lvbltdW10gPSBbXTtcclxuICAgICAgICAgICAgbGV0IGRmZGR4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZmR6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R4OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R6OkV4cHJlc3Npb25bXVtdID0gW107XHJcbiAgICAgICAgICAgIGxldCBkZ2R0OkV4cHJlc3Npb25bXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgbGV0IGR4Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRkeFJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHguZm9yRWFjaChmdW5jdGlvbihfeCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZHhSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3gsIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGR4Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF94ICsgXCInXCIsIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRmZHgucHVzaChkeFJvdyk7XHJcbiAgICAgICAgICAgICAgICBkZmRkeC5wdXNoKGRkeFJvdyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHpSb3c6RXhwcmVzc2lvbltdID0gW107XHJcbiAgICAgICAgICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24oX3ope1xyXG4gICAgICAgICAgICAgICAgICAgIGR6Um93LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKF96LCBzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBkZmR6LnB1c2goZHpSb3cpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgbGV0IGR4Um93OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKF94KXtcclxuICAgICAgICAgICAgICAgICAgICBkeFJvdy5wdXNoKGl0ZW0uZGlmZmVyZW50aWF0ZShfeCwgc2VsZi5lcHNpbG9uKS5zaW1wbGlmeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZGdkeC5wdXNoKGR4Um93KTtcclxuICAgICAgICAgICAgICAgIGxldCBkelJvdzpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIHouZm9yRWFjaChmdW5jdGlvbihfeil7XHJcbiAgICAgICAgICAgICAgICAgICAgZHpSb3cucHVzaChpdGVtLmRpZmZlcmVudGlhdGUoX3osIHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGRnZHoucHVzaChkelJvdyk7XHJcbiAgICAgICAgICAgICAgICBkZ2R0LnB1c2goaXRlbS5kaWZmZXJlbnRpYXRlKFwidFwiLHNlbGYuZXBzaWxvbikpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdGF0ZUluZGljaWVzW2tleV0gPSBzdGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBzdGF0ZXMucHVzaChuZXcgQ3VzdG9tSURBRUh5YnJpZFN0YXRlKFwiaW5pdGlhbFwiLFtdLGZhbHNlKS5pbml0KGYsZyxkZmR4LGRmZGR4LGRmZHosZGdkeCxkZ2R6LGRnZHQpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvL2NvbXBpbGUgdHJhbnNpdGlvbnNcclxuICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLnN0YXRlcykuZm9yRWFjaChmdW5jdGlvbihba2V5LHN0YXRlXSl7XHJcbiAgICAgICAgICAgIGlmKGtleT09XCJpbml0aWFsXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAvL2NvbXBpbGUgc2V0dGVyc1xyXG4gICAgICAgICAgICBsZXQgc2V0dGVyczp7aW5kZXg6bnVtYmVyLGV4cHJlc3Npb246RXhwcmVzc2lvbn1bXSA9IFtdO1xyXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhzdGF0ZS5zZXR0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksIHNldHRlcl0pe1xyXG4gICAgICAgICAgICAgICAgaWYoc2VsZi52YXJpYWJsZXNba2V5XS5pc0FsZ2VicmFpYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlSW5kZXggPSBhbGdDb250ZXh0LmluZGljaWVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBzZXR0ZXJzLnB1c2goe2luZGV4OnZhcmlhYmxlSW5kZXgsZXhwcmVzc2lvbjpjb21waWxlRXhwcmVzc2lvbihzZXR0ZXIsZGlmQ29udGV4dCkuc2ltcGxpZnkoKX0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlSW5kZXggPSBzdGF0ZUluZGljaWVzW2tleV07XHJcbiAgICAgICAgICAgIHN0YXRlLnRyYW5zaXRpb25zLmZvckVhY2goZnVuY3Rpb24odHJhbnNpdGlvbil7XHJcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGNvbXBpbGVCb29sRXhwcmVzc2lvbih0cmFuc2l0aW9uLmNvbmRpdGlvbixkaWZDb250ZXh0KS5zaW1wbGlmeSgpLmNvbnZlcnRUb0V4cHJlc3Npb24oc2VsZi5ib29sRXhwRXBzaWxvbik7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHBkdCA9IHAuZGlmZmVyZW50aWF0ZShcInRcIixzZWxmLmVwc2lsb24pLnNpbXBsaWZ5KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHBkeDpFeHByZXNzaW9uW10gPSBbXTtcclxuICAgICAgICAgICAgICAgIGxldCBkcGR6OkV4cHJlc3Npb25bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoc2VsZi52YXJpYWJsZXMpLmZvckVhY2goZnVuY3Rpb24oW2tleSwgdmFyaWFibGVdKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih2YXJpYWJsZS5pc0FsZ2VicmFpYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwZHoucHVzaChwLmRpZmZlcmVudGlhdGUoa2V5LHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwZHgucHVzaChwLmRpZmZlcmVudGlhdGUoa2V5LHNlbGYuZXBzaWxvbikuc2ltcGxpZnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLmluY2lkZW50U3RhdGVzLmZvckVhY2goZnVuY3Rpb24oaW5jaWRlbnRTdGF0ZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXNlbGYuc3RhdGVzLmhhc093blByb3BlcnR5KGluY2lkZW50U3RhdGUpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKFRleHRQb3NpdGlvbi5pbnZhbGlkKCksYFVua25vd24gaW5jaWRlbnQgc3RhdGUgXCIke2luY2lkZW50U3RhdGV9XCIgaW4gdHJhbnNpdGlvbiBydWxlIGZvciBzdGF0ZSBcIiR7a2V5fVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlc1tzdGF0ZUluZGljaWVzW2luY2lkZW50U3RhdGVdXS5wdXNoTGluayhuZXcgQ3VzdG9tSHlicmlkU3RhdGVMaW5rKG5ld1N0YXRlSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcnMscCxkcGR4LGRwZHosZHBkdCkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYodGhpcy5lcnJvcnMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcGlsZXJFcnJvcih0aGlzLmVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7c3lzdGVtOm5ldyBJREFFSHlicmlkU3lzdGVtKHN0YXRlcykseDA6bmV3IHZlY3Rvcih4MCksejA6bmV3IHZlY3Rvcih6MCkseDp4LHo6en07XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZXhwYW5kQm9vbEV4cHJlc3Npb24obm9kZTpCb29sRXhwcmVzc2lvbk5vZGUpOkJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICBzd2l0Y2gobm9kZS50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fQW5kOntcclxuICAgICAgICAgICAgICAgIGxldCBhbmQgPSBub2RlIGFzIEJvb2xBbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgYW5kLmxlZnQgPSB0aGlzLmV4cGFuZEJvb2xFeHByZXNzaW9uKGFuZC5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGFuZC5yaWdodCA9IHRoaXMuZXhwYW5kQm9vbEV4cHJlc3Npb24oYW5kLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fT3I6e1xyXG4gICAgICAgICAgICAgICAgbGV0IG9yID0gbm9kZSBhcyBCb29sT3JOb2RlO1xyXG4gICAgICAgICAgICAgICAgb3IubGVmdCA9IHRoaXMuZXhwYW5kQm9vbEV4cHJlc3Npb24ob3IubGVmdCk7XHJcbiAgICAgICAgICAgICAgICBvci5yaWdodCA9IHRoaXMuZXhwYW5kQm9vbEV4cHJlc3Npb24ob3IucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX05vdDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm90ID0gbm9kZSBhcyBCb29sTmVnYXRpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgbm90LmlubmVyID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG5vdC5pbm5lcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0dyZWF0ZXI6e1xyXG4gICAgICAgICAgICAgICAgbGV0IGcgPSBub2RlIGFzIEJvb2xHTm9kZTtcclxuICAgICAgICAgICAgICAgIGcubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihnLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgZy5yaWdodCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihnLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0dyZWF0ZXJFcXVhbDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgZ2UgPSBub2RlIGFzIEJvb2xHRU5vZGU7XHJcbiAgICAgICAgICAgICAgICBnZS5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGdlLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgZ2UucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZ2UucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0xlc3M6e1xyXG4gICAgICAgICAgICAgICAgbGV0IGwgPSBub2RlIGFzIEJvb2xMTm9kZTtcclxuICAgICAgICAgICAgICAgIGwubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihsLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgbC5yaWdodCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihsLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0xlc3NFcXVhbDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGUgPSBub2RlIGFzIEJvb2xMRU5vZGU7XHJcbiAgICAgICAgICAgICAgICBsZS5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGxlLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgbGUucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0VxdWFsOntcclxuICAgICAgICAgICAgICAgIGxldCBlID0gbm9kZSBhcyBCb29sRU5vZGU7XHJcbiAgICAgICAgICAgICAgICBlLmxlZnQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIGUucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9Ob3RFcXVhbDp7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmUgPSBub2RlIGFzIEJvb2xORU5vZGU7XHJcbiAgICAgICAgICAgICAgICBuZS5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG5lLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgbmUucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obmUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0Jvb2xDb25zdGFudDp7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxcIlVuZXhwZWN0ZWQgYm9vbGVhbiBleHByZXNzaW9uIHR5cGUgYXQgZXhwYW5kQm9vbEV4cHJlc3Npb24oKVwiKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xDb25zdGFudE5vZGUoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBleHBhbmRFeHByZXNzaW9uKG5vZGU6RXhwcmVzc2lvbk5vZGUpOkV4cHJlc3Npb25Ob2Rle1xyXG4gICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgICAgIHN3aXRjaChub2RlLnR5cGUpeyAgIFxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9BZGRpdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkZCA9IG5vZGUgYXMgQWRkaXRpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZC5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGFkZC5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oYWRkLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9TdWJ0cmFjdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YiA9IG5vZGUgYXMgU3VidHJhY3Rpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi5sZWZ0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKHN1Yi5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBzdWIucmlnaHQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oc3ViLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9NdWx0aXBsaWNhdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG11bHQgPSBub2RlIGFzIE11bHRpcGxpY2F0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0LmxlZnQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obXVsdC5sZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0LnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKG11bHQucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtdWx0O1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fRGl2aXNpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXYgPSBub2RlIGFzIERpdmlzaW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBkaXYubGVmdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihkaXYubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnJpZ2h0ID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGRpdi5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fTmVnYXRpb246e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBuZWcgPSBub2RlIGFzIE5lZ2F0aW9uTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBuZWcuaW5uZXIgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24obmVnLmlubmVyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9EZXJpdmF0aXZlOntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVyID0gbm9kZSBhcyBEZXJpdmF0aXZlTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSB0aGlzLmV4cGFuZEV4cHJlc3Npb24oZGVyLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihpZCBpbnN0YW5jZW9mIFZhcklkZW50aWZpZXJOb2RlICYmIGlkLmlkICE9IFwidFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy52YXJpYWJsZXMuaGFzT3duUHJvcGVydHkoaWQuaWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW2lkLmlkXS5pc0FsZ2VicmFpYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW2lkLmlkXSA9IG5ldyBWYXJpYWJsZUVudHJ5KGlkLmlkLGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXIuaWQgPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW5jb3JyZWN0IHN5bWJvbCBpbiBkZXJpdmF0aXZlYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9GdW5jdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZ1biA9IG5vZGUgYXMgRnVuY3Rpb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8ZnVuLmFyZ3MubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bi5hcmdzW2ldID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGZ1bi5hcmdzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fVmFySWRlbnRpZmllcjp7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ZhciA9IG5vZGUgYXMgVmFySWRlbnRpZmllck5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZihfdmFyLmluZGljaWVzLmxlbmd0aD09MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKF9jb250ZXh0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2NvbnRleHQgaW5zdGFuY2VvZiBMb29wQ29udGV4dCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfY29udGV4dC5pdGVyYXRvciA9PSBfdmFyLmlkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZShfY29udGV4dC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKF9jb250ZXh0IGluc3RhbmNlb2YgTWFjcm9Db250ZXh0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9jb250ZXh0LmFyZ3MuaGFzT3duUHJvcGVydHkoX3Zhci5pZCkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuZEV4cHJlc3Npb24oX2NvbnRleHQuYXJnc1tfdmFyLmlkXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dCA9IF9jb250ZXh0LnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF92YXIuaWQgPSB0aGlzLmdldFN5bWJvbFN0cmluZyhfdmFyKTtcclxuICAgICAgICAgICAgICAgIF92YXIuaW5kaWNpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KF92YXIuaWQpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSh0aGlzLmNvbnN0YW50c1tfdmFyLmlkXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihfdmFyLmlkIT1cInRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KF92YXIuaWQpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbX3Zhci5pZF0gPSBuZXcgVmFyaWFibGVFbnRyeShfdmFyLmlkLHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdmFyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9Db25zdGFudDp7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX1N1bW1hdGlvbjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bW1hdGlvbiA9IG5vZGUgYXMgU3VtRXhwcmVzc2lvbk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3VtbWF0aW9uLmJvdW5kcy5sPnN1bW1hdGlvbi5ib3VuZHMucil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYExlZnQgYm91bmQgb2Ygc3VtbWF0aW9uIGlzIGJpZ2dlciB0aGVuIHJpZ2h0IGJvdW5kYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1bTpFeHByZXNzaW9uTm9kZVtdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IF9jb250ZXh0ID0gbmV3IExvb3BDb250ZXh0KHRoaXMuY29udGV4dCxzdW1tYXRpb24uaXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IF9jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT1zdW1tYXRpb24uYm91bmRzLmw7aTw9c3VtbWF0aW9uLmJvdW5kcy5yO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LmluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtLnB1c2godGhpcy5leHBhbmRFeHByZXNzaW9uKHN1bW1hdGlvbi5leHByZXNzaW9uLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhpcy5leHBhbmRFeHByZXNzaW9uKHN1bW1hdGlvbi5leHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbnRleHQucHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdDpFeHByZXNzaW9uTm9kZSA9IHN1bVswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzdW0ubGVuZ3RoPT0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDE7aTxzdW0ubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBZGRpdGlvbk5vZGUocmVzdWx0LCBzdW1baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9NYWNybzp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hY3JvID0gbm9kZSBhcyBNYWNyb0V4cHJlc3Npb25Ob2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYWNyb05hbWUgPSB0aGlzLmdldFN5bWJvbFN0cmluZyhtYWNyby5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hY3JvRGVmID0gdGhpcy5tYWNyb3NbbWFjcm9OYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihtYWNyb0RlZj09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgVW5kZWZpbmVkIG1hY3JvIFwiJHttYWNyb05hbWV9XCJgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnROb2RlKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihtYWNyb0RlZi5hcmdzLmxlbmd0aCAhPSBtYWNyby5hcmdzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBpbiBtYWNybyBcIiR7bWFjcm9OYW1lfVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ3M6UmVjb3JkPHN0cmluZyxFeHByZXNzaW9uTm9kZT4gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBtYWNyby5hcmdzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbbWFjcm9EZWYuYXJnc1tpbmRleF1dID0gaXRlbS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV3IE1hY3JvQ29udGV4dCh0aGlzLmNvbnRleHQsYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihtYWNyb0RlZi5leHByZXNzaW9uLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY29udGV4dC5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fVGVybmFyeTp7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlciA9IG5vZGUgYXMgVGVybmFyeU9wZXJhdG9yTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXIuY29uZGl0aW9uID0gdGhpcy5leHBhbmRCb29sRXhwcmVzc2lvbih0ZXIuY29uZGl0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXIudHJ1ZSA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbih0ZXIudHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVyLmZhbHNlID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKHRlci5mYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxcIlVuZXhwZWN0ZWQgZXhwcmVzc2lvbiB0eXBlIGF0IHZhbGlkYXRlRXhwcmVzc2lvbigpXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0YW50Tm9kZSgwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgZ2V0U3ltYm9sU3RyaW5nKHN5bWJvbDpWYXJJZGVudGlmaWVyTm9kZSl7Ly9ET05FXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN5bWJvbC5pZDtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgc3ltYm9sLmluZGljaWVzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpbmRleCl7XHJcbiAgICAgICAgICAgbGV0IGluZGV4VmFsdWUgPSAoY29tcGlsZUV4cHJlc3Npb24oc2VsZi5leHBhbmRFeHByZXNzaW9uKGl0ZW0uY2xvbmUoKSkse2luZGljaWVzOnt9LGVycm9yczpzZWxmLmVycm9yc30pKS5ldmFsKHt9KTtcclxuICAgICAgICAgICAgaWYoTnVtYmVyLmlzSW50ZWdlcihpbmRleFZhbHVlKSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQrPWBbJHtzZWxmLmNvbnRleHQuaW5kZXh9XWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKHN5bWJvbC50ZXh0UG9zLGBFeHByZXNzaW9uIGZvciAke2luZGV4fSBpbmRleCB2YWx1ZSBvZiBzeW1ib2wgXCIke3N5bWJvbC5pZH1cIiBpcyBub3QgY29uc3RhbnRgKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVMb29wKG5vZGU6TG9vcFN0YXRlbWVudE5vZGUpey8vRE9ORVxyXG4gICAgICAgIGxldCBfY29udGV4dCA9IG5ldyBMb29wQ29udGV4dCh0aGlzLmNvbnRleHQsbm9kZS5pdGVyYXRvcik7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gX2NvbnRleHQ7XHJcbiAgICAgICAgbGV0IHN0YXRlbWVudHMgPSBub2RlLnN0YXRlbWVudHM7XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLmZvckVhY2goZnVuY3Rpb24oYm91bmRzKXtcclxuICAgICAgICAgICAgaWYoYm91bmRzLmw+Ym91bmRzLnIpe1xyXG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgTGVmdCBib3VuZCB2YWx1ZSBcIiR7Ym91bmRzLmx9XCIgaXMgaGlnaGVyIHRoZW4gcmlnaHQgYm91bmQgdmFsdWUgXCIke2JvdW5kcy5yfVwiYCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IGJvdW5kcy5sO2k8Ym91bmRzLnI7aSsrKXtcclxuICAgICAgICAgICAgICAgIF9jb250ZXh0LmluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0ZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29tcGlsZVN0YXRlbWVudChzdGF0ZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbnRleHQucHJldmlvdXM7XHJcbiAgICB9O1xyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVJbml0aWFsQ29uZGl0aW9uKG5vZGU6SW5pdGlhbENvbmRpdGlvbk5vZGUpey8vRE9ORVxyXG4gICAgICAgIGxldCB2YXJpYWJsZSA9IHRoaXMuZ2V0U3ltYm9sU3RyaW5nKG5vZGUuaWQpO1xyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudFN0YXRlIT1cImluaXRpYWxcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYERlZmluaXRpb24gb2YgaW5pdGlhbCBjb25kaXRpb24gZm9yIHZhcmlhYmxlIFwiJHt2YXJpYWJsZX1cIiBub3QgaW4gdGhlIGdsb2JhbCBzY29wZWApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih2YXJpYWJsZSA9PSBcInRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgdXNlIG9mIHRpbWUgdmFyaWFibGVgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW52YWxpZCB1c2Ugb2YgY29uc3RhbnQgXCIke3ZhcmlhYmxlfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2YWx1ZTpudW1iZXIgPSAwO1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgdmFsdWUgPSAoY29tcGlsZUV4cHJlc3Npb24odGhpcy5leHBhbmRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbi5jbG9uZSgpKSwge2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc30pKS5ldmFsKHt9KTtcclxuICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBDYW4ndCBldmFsdWF0ZSBpbml0aWFsIGNvbmRpdGlvbiBmb3IgdmFyaWFibGUgXCIke3ZhcmlhYmxlfVwiYCkpO1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGVycm9yKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy52YXJpYWJsZXMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdLmluaXRpYWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0gPSBuZXcgVmFyaWFibGVFbnRyeSh2YXJpYWJsZSx0cnVlLHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZU1hY3JvRGVmaW5pdGlvbihub2RlOk1hY3JvU3RhdGVtZW50Tm9kZSl7Ly9ET05FXHJcbiAgICAgICAgaWYodGhpcy5jdXJyZW50U3RhdGUhPVwiaW5pdGlhbFwiKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgRGVmaW5pdGlvbiBvZiBtYWNybyBcIiR7bm9kZS5pZH1cIiBub3QgaW4gdGhlIGdsb2JhbCBzY29wZWApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWFjcm9OYW1lID0gdGhpcy5nZXRTeW1ib2xTdHJpbmcobm9kZS5pZCk7XHJcbiAgICAgICAgaWYodGhpcy5tYWNyb3MuaGFzT3duUHJvcGVydHkobWFjcm9OYW1lKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYFJlZGVmZW5pdGlvbiBvZiBtYWNybyBcIiR7bWFjcm9OYW1lfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWFjcm9zW21hY3JvTmFtZV0gPSBub2RlO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVDb25zdGFudFN0YXRlbWVudChub2RlOkNvbnN0YW50U3RhdGVtZW50Tm9kZSl7Ly9ET05FXHJcbiAgICAgICAgbGV0IGNvbnN0YW50ID0gdGhpcy5nZXRTeW1ib2xTdHJpbmcobm9kZS5pZCk7XHJcbiAgICAgICAgaWYodGhpcy5jdXJyZW50U3RhdGUhPVwiaW5pdGlhbFwiKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgRGVmaW5pdGlvbiBvZiBjb25zdGFudCBcIiR7Y29uc3RhbnR9XCIgbm90IGluIHRoZSBnbG9iYWwgc2NvcGVgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY29uc3RhbnQgPT0gXCJ0XCIpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLCdJbnZhbGlkIHVzZSBvZiB0aW1lIHZhcmlhYmxlJykpO1xyXG4gICAgICAgIH1lbHNlIGlmKHRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KGNvbnN0YW50KSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYFJlZGVmZW5pdGlvbiBvZiB2YXJpYWJsZSBcIiR7Y29uc3RhbnR9XCJgKSk7XHJcbiAgICAgICAgfWVsc2UgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkoY29uc3RhbnQpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmVkZWZlbml0aW9uIG9mIGNvbnN0YW50IFwiJHtjb25zdGFudH1cImApKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdGFudHNbY29uc3RhbnRdID0gKGNvbXBpbGVFeHByZXNzaW9uKHRoaXMuZXhwYW5kRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24uY2xvbmUoKSkse2luZGljaWVzOnt9LGVycm9yczp0aGlzLmVycm9yc30pKS5ldmFsKHt9KTtcclxuICAgICAgICAgICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsZXJyb3IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlQWxnRXF1YXRpb24obm9kZTpFcXVhdGlvbk5vZGUpe1xyXG4gICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0YXRlc1t0aGlzLmN1cnJlbnRTdGF0ZV07XHJcbiAgICAgICAgbGV0IHZhcmlhYmxlID0gdGhpcy5nZXRTeW1ib2xTdHJpbmcobm9kZS5sZWZ0IGFzIFZhcklkZW50aWZpZXJOb2RlKTtcclxuICAgICAgICBpZihjdXJyZW50U3RhdGUuZXF1YXRpb25zLmhhc093blByb3BlcnR5KHZhcmlhYmxlKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYE11bHRpcGxlIGVxdWF0aW9ucyBmb3IgdmFyaWFibGUgXCIke3ZhcmlhYmxlfVwiIGluIHN0YXRlIFwiJHt0aGlzLmN1cnJlbnRTdGF0ZX1cImApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih2YXJpYWJsZSA9PSBcInRcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgdXNlIG9mIHRpbWUgdmFyaWFibGUgaW4gc3RhdGUgXCIke3RoaXMuY3VycmVudFN0YXRlfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuY29uc3RhbnRzLmhhc093blByb3BlcnR5KHZhcmlhYmxlKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgdXNlIG9mIGNvbnN0YW50IFwiJHt2YXJpYWJsZX1cIiBpbiBzdGF0ZSBcIiR7dGhpcy5jdXJyZW50U3RhdGV9XCJgKSk7XHJcbiAgICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZighdGhpcy52YXJpYWJsZXMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXNbdmFyaWFibGVdID0gbmV3IFZhcmlhYmxlRW50cnkodmFyaWFibGUsdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlcXVhdGlvbiA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihub2RlLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgICAgIGlmKGhhc0Rlcml2YXRpdmUoZXF1YXRpb24pKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmlnaHQgaGFuZCBzaWRlIGV4cHJlc3Npb24gZm9yIHZhcmlhYmxlIFwiJHt2YXJpYWJsZX1cIiBpbiBzdGF0ZSBcIiR7dGhpcy5jdXJyZW50U3RhdGV9XCIgY29udGFpbnMgZGVyaXZhdGl2ZXNgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFN0YXRlLmVxdWF0aW9uc1t2YXJpYWJsZV0gPSBuZXcgRXF1YXRpb25FbnRyeShlcXVhdGlvbix0cnVlKTtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlRGlmRXF1YXRpb24obm9kZTpFcXVhdGlvbk5vZGUpe1xyXG4gICAgICAgIC8vdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xyXG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB0aGlzLnN0YXRlc1t0aGlzLmN1cnJlbnRTdGF0ZV07XHJcbiAgICAgICAgbGV0IHZhcmlhYmxlID0gdGhpcy5nZXRTeW1ib2xTdHJpbmcoKG5vZGUubGVmdCBhcyBEZXJpdmF0aXZlTm9kZSkuaWQpO1xyXG4gICAgICAgIGlmKGN1cnJlbnRTdGF0ZS5lcXVhdGlvbnMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgTXVsdGlwbGUgZXF1YXRpb25zIGZvciB2YXJpYWJsZSBcIiR7dmFyaWFibGV9XCIgaW4gc3RhdGUgXCIke3RoaXMuY3VycmVudFN0YXRlfVwiYCkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHZhcmlhYmxlID09IFwidFwiKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW52YWxpZCB1c2Ugb2YgdGltZSB2YXJpYWJsZSBpbiBzdGF0ZSBcIiR7dGhpcy5jdXJyZW50U3RhdGV9XCJgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jb25zdGFudHMuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgSW52YWxpZCB1c2Ugb2YgY29uc3RhbnQgXCIke3ZhcmlhYmxlfVwiIGluIHN0YXRlIFwiJHt0aGlzLmN1cnJlbnRTdGF0ZX1cImApKTtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KHZhcmlhYmxlKSl7XHJcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVzW3ZhcmlhYmxlXS5pc0FsZ2VicmFpYyA9IGZhbHNlO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlc1t2YXJpYWJsZV0gPSBuZXcgVmFyaWFibGVFbnRyeSh2YXJpYWJsZSxmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBlcXVhdGlvbiA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihub2RlLnJpZ2h0LmNsb25lKCkpO1xyXG4gICAgICAgIGlmKGhhc0Rlcml2YXRpdmUoZXF1YXRpb24pKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgUmlnaHQgaGFuZCBzaWRlIGV4cHJlc3Npb24gZm9yIHZhcmlhYmxlIFwiJHt2YXJpYWJsZX1cIiBpbiBzdGF0ZSBcIiR7dGhpcy5jdXJyZW50U3RhdGV9XCIgY29udGFpbnMgZGVyaXZhdGl2ZXNgKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFN0YXRlLmVxdWF0aW9uc1t2YXJpYWJsZV0gPSBuZXcgRXF1YXRpb25FbnRyeShlcXVhdGlvbixmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZUV4cGxpY2l0RXF1YXRpb24obm9kZTpFcXVhdGlvbk5vZGUpey8vRE9ORT9cclxuICAgICAgICAvL3Rocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgICAgICBpZihub2RlLmxlZnQgaW5zdGFuY2VvZiBWYXJJZGVudGlmaWVyTm9kZSl7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGlsZUFsZ0VxdWF0aW9uKG5vZGUpO1xyXG4gICAgICAgIH1lbHNlIGlmKG5vZGUubGVmdCBpbnN0YW5jZW9mIERlcml2YXRpdmVOb2RlKXtcclxuICAgICAgICAgICAgdGhpcy5jb21waWxlRGlmRXF1YXRpb24obm9kZSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsXCJFcXVhdGlvbiBzaG91bGQgYmUgaW4gZXhwbGljaXQgZm9ybVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGNvbXBpbGVJbXBsaWNpdEVxdWF0aW9uKG5vZGU6RXF1YXRpb25Ob2RlKXsvL0RPTkU/XHJcbiAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlXTtcclxuXHJcbiAgICAgICAgbGV0IGxhYmVsID0gKG5vZGUubGFiZWwhPW51bGw/dGhpcy5nZXRTeW1ib2xTdHJpbmcobm9kZS5sYWJlbCk6KE9iamVjdC5rZXlzKGN1cnJlbnRTdGF0ZS5lcXVhdGlvbnMpLmxlbmd0aCsxKSk7XHJcbiAgICAgICAgaWYoY3VycmVudFN0YXRlLmVxdWF0aW9ucy5oYXNPd25Qcm9wZXJ0eShsYWJlbCkpe1xyXG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBFcnJvck1lc3NhZ2Uobm9kZS50ZXh0UG9zLGBSZWRlY2xhcmF0aW9uIG9mIGVxdWF0aW9uIFwiJHtsYWJlbH1cImApKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbGV0IGVxdWF0aW9uOkV4cHJlc3Npb25Ob2RlID0gbmV3IFN1YnRyYWN0aW9uTm9kZShub2RlLmxlZnQsbm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIGVxdWF0aW9uID0gdGhpcy5leHBhbmRFeHByZXNzaW9uKGVxdWF0aW9uLmNsb25lKCkpOy8vVE9ETyBhZGQgdmFyaWFibGVzIHRvIHZhcmlhYmxlc1RhYmxlIGFuZCByZW1vdmUgdmFsaWRhdGVcclxuICAgICAgICAgICAgY3VycmVudFN0YXRlLmVxdWF0aW9uc1tsYWJlbF0gPSBuZXcgRXF1YXRpb25FbnRyeShlcXVhdGlvbiwhaGFzRGVyaXZhdGl2ZShlcXVhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBjb21waWxlU3RhdGUobm9kZTpTdGF0ZU5vZGUpey8vRE9ORVxyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudFN0YXRlIT1cImluaXRpYWxcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYEludmFsaWQgc3RhdGUgZGVmaW5pdGlvbmApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShub2RlLmlkKSl7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYFJlZGVjbGFyYXRpb24gb2Ygc3RhdGUgXCIke25vZGUuaWR9XCJgKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5vZGUuaWQ7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcbiAgICAgICAgc3RhdGUuaXNUZXJtaW5hbCA9IG5vZGUuaXNUZXJtaW5hbDtcclxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXNbbm9kZS5pZF0gPSBzdGF0ZTtcclxuICAgICAgICBub2RlLnN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgc2VsZi5jb21waWxlU3RhdGVtZW50KGl0ZW0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG5vZGUuc3RhdGVUcmFuc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2l0aW9ucy5wdXNoKG5ldyBUcmFuc2l0aW9uKGl0ZW0ucHJldlN0YXRlcyxzZWxmLmV4cGFuZEJvb2xFeHByZXNzaW9uKGl0ZW0uY29uZGl0aW9uKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gXCJpbml0aWFsXCI7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZVNldHRlcihub2RlOlNldHRlck5vZGUpey8vRE9ORVxyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudFN0YXRlPT1cImluaXRpYWxcIil7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShub2RlLnRleHRQb3MsYFNldHRlciBkZWZpbml0aW9uIHNob3VsZG4ndCBleGlzdCBpbiBpbml0aWFsIHN0YXRlLmApKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2V0dGVycyA9IHRoaXMuc3RhdGVzW3RoaXMuY3VycmVudFN0YXRlXS5zZXR0ZXJzO1xyXG4gICAgICAgIGxldCBpZCA9IHRoaXMuZ2V0U3ltYm9sU3RyaW5nKG5vZGUuaWQpO1xyXG4gICAgICAgIGlmKHNldHRlcnMuaGFzT3duUHJvcGVydHkoaWQpKXtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgRXJyb3JNZXNzYWdlKG5vZGUudGV4dFBvcyxgU2V0dGVyIHJlZGVmZW5pdGlvbiBmb3IgdmFyaWFibGUgXCIke2lkfSBpbiBzdGF0ZSBcIiR7dGhpcy5jdXJyZW50U3RhdGV9XCJcImApKVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0ZXJzW2lkXSA9IHRoaXMuZXhwYW5kRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24uY2xvbmUoKSk7XHJcbiAgICB9XHJcbiAgICBwcm90ZWN0ZWQgY29tcGlsZVN0YXRlbWVudChzdGF0ZW1lbnQ6U3RhdGVtZW50Tm9kZSl7Ly9ET05FXHJcbiAgICAgICAgc3dpdGNoKHN0YXRlbWVudC50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fSW5pdGlhbENvbmRpdGlvbjp7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVJbml0aWFsQ29uZGl0aW9uKHN0YXRlbWVudCBhcyBJbml0aWFsQ29uZGl0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9NYWNyb0RlZmluaXRpb246e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlTWFjcm9EZWZpbml0aW9uKHN0YXRlbWVudCBhcyBNYWNyb1N0YXRlbWVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fQ29uc3RhbnRTdGF0ZW1lbnQ6e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlQ29uc3RhbnRTdGF0ZW1lbnQoc3RhdGVtZW50IGFzIENvbnN0YW50U3RhdGVtZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9FcXVhdGlvbjp7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzRXhwbGljaXQpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21waWxlRXhwbGljaXRFcXVhdGlvbihzdGF0ZW1lbnQgYXMgRXF1YXRpb25Ob2RlKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVJbXBsaWNpdEVxdWF0aW9uKHN0YXRlbWVudCBhcyBFcXVhdGlvbk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5fU3RhdGU6e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlU3RhdGUoc3RhdGVtZW50IGFzIFN0YXRlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLl9TZXR0ZXI6e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlU2V0dGVyKHN0YXRlbWVudCBhcyBTZXR0ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgTm9kZVR5cGUuX0xvb3A6e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21waWxlTG9vcChzdGF0ZW1lbnQgYXMgTG9vcFN0YXRlbWVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IEVycm9yTWVzc2FnZShzdGF0ZW1lbnQudGV4dFBvcyxgVW5leHBlY3RlZCBzdGF0ZW1lbnQgdHlwZSBhdCBjb21waWxlU3RhdGVtZW50KClgKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IG9kZUdyYW1tYXJMZXhlciBmcm9tIFwiLi4vZ3JhbW1hci9hbnRsck91dHB1dC9vZGVHcmFtbWFyTGV4ZXIuanNcIjtcclxuaW1wb3J0IG9kZUdyYW1tYXJWaXNpdG9yIGZyb20gXCIuLi9ncmFtbWFyL2FudGxyT3V0cHV0L29kZUdyYW1tYXJWaXNpdG9yLmpzXCI7XHJcbmltcG9ydCBvZGVHcmFtbWFyUGFyc2VyIGZyb20gXCIuLi9ncmFtbWFyL2FudGxyT3V0cHV0L29kZUdyYW1tYXJQYXJzZXIuanNcIjtcclxuaW1wb3J0IHtcclxuICAgIEV4cHJlc3Npb25Ob2RlLFxyXG4gICAgQm9vbEV4cHJlc3Npb25Ob2RlLFxyXG4gICAgU3lzdGVtRGVmaW5pdGlvbixcclxuICAgIE1hY3JvU3RhdGVtZW50Tm9kZSxcclxuICAgIENvbnN0YW50U3RhdGVtZW50Tm9kZSxcclxuICAgIFN0YXRlbWVudE5vZGUsXHJcbiAgICBWYXJJZGVudGlmaWVyTm9kZSxcclxuICAgIEJvb2xOZWdhdGlvbk5vZGUsXHJcbiAgICBTdGF0ZU5vZGUsXHJcbiAgICBTZXR0ZXJOb2RlLFxyXG4gICAgSW5pdGlhbENvbmRpdGlvbk5vZGUsXHJcbiAgICBMb29wU3RhdGVtZW50Tm9kZSxcclxuICAgIE1hY3JvRXhwcmVzc2lvbk5vZGUsXHJcbiAgICBDb25zdGFudE5vZGUsXHJcbiAgICBTdW1FeHByZXNzaW9uTm9kZSxcclxuICAgIEZ1bmN0aW9uTm9kZSxcclxuICAgIERlcml2YXRpdmVOb2RlLFxyXG4gICAgRGl2aXNpb25Ob2RlLFxyXG4gICAgTXVsdGlwbGljYXRpb25Ob2RlLFxyXG4gICAgQWRkaXRpb25Ob2RlLFxyXG4gICAgU3VidHJhY3Rpb25Ob2RlLFxyXG4gICAgTmVnYXRpb25Ob2RlLFxyXG4gICAgQm9vbExOb2RlLFxyXG4gICAgQm9vbExFTm9kZSxcclxuICAgIEJvb2xHTm9kZSxcclxuICAgIEJvb2xHRU5vZGUsXHJcbiAgICBCb29sRU5vZGUsXHJcbiAgICBCb29sTkVOb2RlLFxyXG4gICAgQm9vbEFuZE5vZGUsXHJcbiAgICBFcXVhdGlvbk5vZGUsXHJcbiAgICBCb3VuZHMsXHJcbiAgICBUZXJuYXJ5T3BlcmF0b3JOb2RlLFxyXG4gICAgVHJhbnNpdGlvbk5vZGUsXHJcbiAgICBUZXh0UG9zaXRpb24sXHJcbiAgICBCb29sT3JOb2RlLFxyXG4gICAgQm9vbENvbnN0YW50Tm9kZVxyXG59IGZyb20gXCIuL2FzdE5vZGVcIjtcclxuaW1wb3J0IEVycm9yTGlzdGVuZXIgZnJvbSBcIi4vZXJyb3JMaXN0ZW5lclwiO1xyXG5pbXBvcnQgeyBQYXJzZVRyZWVWaXNpdG9yIH0gZnJvbSBcImFudGxyNC90cmVlL1RyZWVcIjtcclxuaW1wb3J0IHsgQm9vbENvbnN0YW50IH0gZnJvbSBcIi4vZXhwcmVzc2lvblwiO1xyXG5cclxuXHJcblxyXG5jbGFzcyBWaXNpdG9yIGV4dGVuZHMgb2RlR3JhbW1hclZpc2l0b3Iub2RlR3JhbW1hclZpc2l0b3J7XHJcbiAgICBlcnJvckxpc3RlbmVyOkVycm9yTGlzdGVuZXI7XHJcbiAgICBzdGF0ZW1lbnRzOlN0YXRlbWVudE5vZGVbXTtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBbXTtcclxuICAgIH1cclxuICAgIHN0YXJ0REFFKGN0eDphbnksIGVycm9yTGlzdGVuZXI6RXJyb3JMaXN0ZW5lcik6U3lzdGVtRGVmaW5pdGlvbntcclxuICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXIgPSBlcnJvckxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMudmlzaXREYWUoY3R4KTtcclxuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbURlZmluaXRpb24odGhpcy5zdGF0ZW1lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXJ0SHlicmlkKGN0eDphbnksIGVycm9yTGlzdGVuZXI6RXJyb3JMaXN0ZW5lcik6U3lzdGVtRGVmaW5pdGlvbntcclxuICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXIgPSBlcnJvckxpc3RlbmVyO1xyXG4gICAgICAgIHRoaXMudmlzaXRIeWJyaWQoY3R4KTtcclxuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbURlZmluaXRpb24odGhpcy5zdGF0ZW1lbnRzKTtcclxuICAgIH1cclxuICAgIHN0YXJ0RXhwcmVzc2lvbihjdHg6YW55LCBlcnJvckxpc3RlbmVyOkVycm9yTGlzdGVuZXIpOkV4cHJlc3Npb25Ob2Rle1xyXG4gICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lciA9IGVycm9yTGlzdGVuZXI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eCk7XHJcbiAgICB9XHJcbiAgICB2aXNpdE1hY3JvU3RhdGVtZW50KGN0eDphbnkpOk1hY3JvU3RhdGVtZW50Tm9kZXtcclxuICAgICAgICBsZXQgYXJnczpzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGlmKGN0eC5tYWNyb0FyZ3VtZW50cyErdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbGV0IG1hY3JvQXJncyA9IGN0eC5tYWNyb0FyZ3VtZW50cygpO1xyXG4gICAgICAgICAgICBpZihtYWNyb0FyZ3MhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBtYWNyb0FyZ3MuSUQoKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06YW55KXtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goaXRlbS5nZXRUZXh0KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYWNyb1N0YXRlbWVudE5vZGUodGhpcy52aXNpdFZhcklkZW50aWZpZXIoY3R4LmlkKSxhcmdzLHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5leHApKVxyXG4gICAgICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgLyogdmlzaXREYWVTdGF0ZW1lbnQoY3R4OmFueSk6U3RhdGVtZW50Tm9kZXtcclxuICAgICAgICByZXR1cm4gKHRoaXMgYXMgdW5rbm93biBhcyBQYXJzZVRyZWVWaXNpdG9yKS52aXNpdChjdHgpIGFzIFN0YXRlbWVudE5vZGU7XHJcbiAgICB9Ki9cclxuICAgIHZpc2l0RGFlU3RhdGVtZW50KGN0eDphbnkpOlN0YXRlbWVudE5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4LmNoaWxkcmVuWzBdKSBhcyBTdGF0ZW1lbnROb2RlO1xyXG4gICAgfVxyXG4gICAgdmlzaXREYWUoY3R4OmFueSk6dm9pZHtcclxuICAgICAgICBjdHguZGFlU3RhdGVtZW50KCkuZm9yRWFjaChmdW5jdGlvbihpdGVtOmFueSl7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKCh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoaXRlbSkpO1xyXG4gICAgICAgIH0sdGhpcyk7XHJcbiAgICB9XHJcbiAgICB2aXNpdFN0YXRlU3RhdGVtZW50KGN0eDphbnkpOlN0YXRlbWVudE5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4LmNoaWxkcmVuWzBdKSBhcyBTdGF0ZW1lbnROb2RlO1xyXG4gICAgfVxyXG4gICAgdmlzaXRCb29sRXhwcmVzc2lvbihjdHg6YW55KTpCb29sRXhwcmVzc2lvbk5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4KSBhcyBCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICB9XHJcbiAgICB2aXNpdEV4cHJlc3Npb24oY3R4OmFueSk6RXhwcmVzc2lvbk5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4KSBhcyBFeHByZXNzaW9uTm9kZTtcclxuICAgIH1cclxuICAgIHZpc2l0SHlicmlkU3RhdGVtZW50KGN0eDphbnkpOlN0YXRlbWVudE5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4LmNoaWxkcmVuWzBdKSBhcyBTdGF0ZW1lbnROb2RlO1xyXG4gICAgfVxyXG4gICAgdmlzaXRMb29wU3RhdGVtZW50KGN0eDphbnkpOlN0YXRlbWVudE5vZGV7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24gYXMgUGFyc2VUcmVlVmlzaXRvcikudmlzaXQoY3R4LmNoaWxkcmVuWzBdKSBhcyBTdGF0ZW1lbnROb2RlO1xyXG4gICAgfVxyXG4gICAgdmlzaXRIeWJyaWQoY3R4OmFueSl7XHJcbiAgICAgICAgY3R4Lmh5YnJpZFN0YXRlbWVudCgpLmZvckVhY2goZnVuY3Rpb24oaXRlbTphbnkpe1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudHMucHVzaCh0aGlzLnZpc2l0SHlicmlkU3RhdGVtZW50KGl0ZW0pKTtcclxuICAgICAgICB9LHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRJbmRleChjdHg6YW55KXtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cCk7XHJcbiAgICB9XHJcbiAgICB2aXNpdFZhcklkZW50aWZpZXIoY3R4OmFueSk6VmFySWRlbnRpZmllck5vZGV7XHJcbiAgICAgICAgbGV0IGlkID0gY3R4LmlkLnRleHQ7XHJcbiAgICAgICAgbGV0IGluZGljaWVzOkV4cHJlc3Npb25Ob2RlW107XHJcbiAgICAgICAgaW5kaWNpZXMgPSBjdHguaW5kZXghPXVuZGVmaW5lZD9jdHguaW5kZXgoKS5tYXAoZnVuY3Rpb24oaXRlbTphbnkpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEluZGV4KGl0ZW0pO1xyXG4gICAgICAgIH0sdGhpcyk6W107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJJZGVudGlmaWVyTm9kZShpZCxpbmRpY2llcylcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0RUJvb2xCaW5hcnlPcGVyYXRvcihjdHg6YW55KTpCb29sRXhwcmVzc2lvbk5vZGV7XHJcbiAgICAgICAgbGV0IG9wOkJvb2xFeHByZXNzaW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoKGN0eC5vcC50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLm9kZUdyYW1tYXJQYXJzZXIuTDpcclxuICAgICAgICAgICAgICAgIG9wID0gbmV3IEJvb2xMTm9kZShcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgubGVmdGV4cCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LnJpZ2h0ZXhwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLkxFOlxyXG4gICAgICAgICAgICAgICAgb3AgPSAgbmV3IEJvb2xMRU5vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnRleHApLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5yaWdodGV4cCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIub2RlR3JhbW1hclBhcnNlci5HOlxyXG4gICAgICAgICAgICAgICAgb3AgPSAgbmV3IEJvb2xHTm9kZShcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnRleHApLFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgucmlnaHRleHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLkdFOlxyXG4gICAgICAgICAgICAgICAgb3AgPSBuZXcgQm9vbEdFTm9kZShcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnRleHApLFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgucmlnaHRleHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLkU6XHJcbiAgICAgICAgICAgICAgICBvcCA9IG5ldyBCb29sRU5vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5sZWZ0ZXhwKSxcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LnJpZ2h0ZXhwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIub2RlR3JhbW1hclBhcnNlci5ORTogIFxyXG4gICAgICAgICAgICAgICAgb3AgPSBuZXcgQm9vbE5FTm9kZShcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnRleHApLFxyXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgucmlnaHRleHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXIuYWRkKG5ldyBUZXh0UG9zaXRpb24oY3R4Lm9wLmxpbmUsY3R4Lm9wLmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCksXCJVbmtub3duIGJpbmFyeSBvcGVyYXRvclwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3Auc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0QkJvb2xCaW5hcnlPcGVyYXRvcihjdHg6YW55KTpCb29sRXhwcmVzc2lvbk5vZGV7XHJcbiAgICAgICAgbGV0IG9wOkJvb2xFeHByZXNzaW9uTm9kZSA9IG51bGw7XHJcbiAgICAgICAgc3dpdGNoKGN0eC5vcC50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLm9kZUdyYW1tYXJQYXJzZXIuQU5EOlxyXG4gICAgICAgICAgICAgICAgb3AgPSBuZXcgQm9vbEFuZE5vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRCb29sRXhwcmVzc2lvbihjdHgubGVmdCksXHJcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRCb29sRXhwcmVzc2lvbihjdHgucmlnaHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLk9SOlxyXG4gICAgICAgICAgICAgICAgb3AgPSBuZXcgQm9vbE9yTm9kZShcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEJvb2xFeHByZXNzaW9uKGN0eC5sZWZ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEJvb2xFeHByZXNzaW9uKGN0eC5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lci5hZGQobmV3IFRleHRQb3NpdGlvbihjdHgub3AubGluZSxjdHgub3AuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSxcIlVua25vd24gYmluYXJ5IG9wZXJhdG9yXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBcclxuICAgICAgICByZXR1cm4gb3Auc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0QnJhY2tldEJvb2xFeHByZXNzaW9uKGN0eDphbnkpOkJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEJvb2xFeHByZXNzaW9uKGN0eC5ib29sRXhwcmVzc2lvbigpKSBhcyBCb29sRXhwcmVzc2lvbk5vZGU7XHJcbiAgICB9XHJcbiAgICB2aXNpdEJvb2xVbmFyeU9wZXJhdG9yKGN0eDphbnkpOkJvb2xFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICByZXR1cm4gbmV3IEJvb2xOZWdhdGlvbk5vZGUodGhpcy52aXNpdEJvb2xFeHByZXNzaW9uKGN0eC5ib29sRXhwcmVzc2lvbigpKSBhcyBCb29sRXhwcmVzc2lvbk5vZGUpXHJcbiAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdEJyYWNrZXRFeHByZXNzaW9uKGN0eDphbnkpOkV4cHJlc3Npb25Ob2Rle1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZXhwcmVzc2lvbigpKTtcclxuICAgIH1cclxuICAgIHZpc2l0U3RhdGVUcmFuc2l0aW9uKGN0eDphbnkpOlRyYW5zaXRpb25Ob2Rle1xyXG4gICAgICAgIGxldCBwcmV2U3RhdGVzOnN0cmluZ1tdID0gW107XHJcbiAgICAgICAgY3R4LklEKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtOmFueSl7XHJcbiAgICAgICAgICAgIHByZXZTdGF0ZXMucHVzaChpdGVtLmdldFRleHQoKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb25Ob2RlKHByZXZTdGF0ZXMsdGhpcy52aXNpdEJvb2xFeHByZXNzaW9uKGN0eC5jb25kaXRpb24pKVxyXG4gICAgICAgIC5zZXRUZXh0UG9zKG5ldyBUZXh0UG9zaXRpb24oY3R4LnN0YXJ0LmxpbmUsY3R4LnN0YXJ0LmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRTdGF0ZURlZihjdHg6YW55KTpTdGF0ZU5vZGV7XHJcbiAgICAgICAgbGV0IHN0YXRlbWVudHM6U3RhdGVtZW50Tm9kZVtdID0gW107XHJcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGlmKGN0eC5zdGF0ZVN0YXRlbWVudCE9dW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBjdHguc3RhdGVTdGF0ZW1lbnQoKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06YW55KXtcclxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChzZWxmLnZpc2l0U3RhdGVTdGF0ZW1lbnQoaXRlbSkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBsZXQgdHJhbnNpdGlvbnM6VHJhbnNpdGlvbk5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGN0eC5zdGF0ZVRyYW5zaXRpb24oKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06YW55KXtcclxuICAgICAgICAgICAgdHJhbnNpdGlvbnMucHVzaChzZWxmLnZpc2l0U3RhdGVUcmFuc2l0aW9uKGl0ZW0pKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVOb2RlKGN0eC5uYW1lLnRleHQsY3R4LnRlcm1pbmFsIT11bmRlZmluZWQsdHJhbnNpdGlvbnMsc3RhdGVtZW50cylcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0U2V0dGVyKGN0eDphbnkpOlNldHRlck5vZGV7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTZXR0ZXJOb2RlKHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC52YXJpYWJsZSksdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cCkpXHJcbiAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdEVxdWF0aW9uKGN0eDphbnkpOkVxdWF0aW9uTm9kZXtcclxuICAgICAgICByZXR1cm4gbmV3IEVxdWF0aW9uTm9kZShjdHgubGFiZWw9PXVuZGVmaW5lZD9udWxsOnRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC5sYWJlbCksIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5sZWZ0KSwgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LnJpZ2h0KSlcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0SW5pdGlhbENvbmRpdGlvbihjdHg6YW55KTpJbml0aWFsQ29uZGl0aW9uTm9kZXtcclxuICAgICAgICByZXR1cm4gbmV3IEluaXRpYWxDb25kaXRpb25Ob2RlKHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC52YXJpYWJsZSksdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cCkpXHJcbiAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdE51bWJlcihjdHg6YW55KTpDb25zdGFudE5vZGV7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdGFudE5vZGUocGFyc2VGbG9hdChjdHguZ2V0VGV4dCgpKSlcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0Q29uc3RhbnRTdGF0ZW1lbnQoY3R4OmFueSk6Q29uc3RhbnRTdGF0ZW1lbnROb2Rle1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RhbnRTdGF0ZW1lbnROb2RlKHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC5jb25zdGFudCksdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cCkpXHJcbiAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdExvb3BCb3VuZHMoY3R4OmFueSk6Qm91bmRze1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRzKHBhcnNlSW50KGN0eC5sYm91bmQudGV4dCkscGFyc2VJbnQoY3R4LnJib3VuZC50ZXh0KSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdExvb3AoY3R4OmFueSk6TG9vcFN0YXRlbWVudE5vZGV7XHJcbiAgICAgICAgbGV0IGJvdW5kczpCb3VuZHNbXSA9IFtdO1xyXG4gICAgICAgIGxldCBzdGF0ZW1lbnRzOlN0YXRlbWVudE5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGN0eC5sb29wQm91bmRzKCkuZm9yRWFjaChmdW5jdGlvbihpdGVtOmFueSl7XHJcbiAgICAgICAgICAgIGJvdW5kcy5wdXNoKHRoaXMudmlzaXRMb29wQm91bmRzKGl0ZW0pKTtcclxuICAgICAgICB9LHRoaXMpO1xyXG4gICAgICAgIGlmKGN0eC5sb29wQm9keSgpLmxvb3BTdGF0ZW1lbnQhPXVuZGVmaW5lZClcclxuICAgICAgICAgICAgY3R4Lmxvb3BCb2R5KCkubG9vcFN0YXRlbWVudCgpLmZvckVhY2goZnVuY3Rpb24oaXRlbTphbnkpe1xyXG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHRoaXMudmlzaXRMb29wU3RhdGVtZW50KGl0ZW0pKTtcclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICByZXR1cm4gbmV3IExvb3BTdGF0ZW1lbnROb2RlKGN0eC5pdGVyYXRvci50ZXh0LGJvdW5kcyxzdGF0ZW1lbnRzKVxyXG4gICAgICAgIC5zZXRUZXh0UG9zKG5ldyBUZXh0UG9zaXRpb24oY3R4LnN0YXJ0LmxpbmUsY3R4LnN0YXJ0LmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRNYWNyb0V4cHJlc3Npb24oY3R4OmFueSk6TWFjcm9FeHByZXNzaW9uTm9kZXtcclxuICAgICAgICBsZXQgYXJnczpFeHByZXNzaW9uTm9kZVtdO1xyXG4gICAgICAgIGFyZ3MgPSBjdHguZXhwcmVzc2lvbiE9dW5kZWZpbmVkP2N0eC5leHByZXNzaW9uKCkubWFwKGZ1bmN0aW9uKGl0ZW06YW55KXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGl0ZW0pO1xyXG4gICAgICAgIH0sdGhpcyk6W107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYWNyb0V4cHJlc3Npb25Ob2RlKHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC5pZCksYXJncylcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0Q29uc3RhbnRFeHByZXNzaW9uKGN0eDphbnkpOkNvbnN0YW50Tm9kZXtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE51bWJlcihjdHgudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRTdW1tYXRpb25FeHByZXNzaW9uKGN0eDphbnkpOlN1bUV4cHJlc3Npb25Ob2Rle1xyXG4gICAgICAgIHJldHVybiBuZXcgU3VtRXhwcmVzc2lvbk5vZGUoY3R4Lml0ZXJhdG9yLnRleHQsXHJcbiAgICAgICAgICAgIHRoaXMudmlzaXRMb29wQm91bmRzKGN0eC5ib3VuZHMpLFxyXG4gICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguc3VtbWF0aW9uRXhwKSlcclxuICAgICAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICB9XHJcbiAgICB2aXNpdFRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb24oY3R4OmFueSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXJuYXJ5T3BlcmF0b3JOb2RlKHRoaXMudmlzaXRCb29sRXhwcmVzc2lvbihjdHguY29uZGl0aW9uKSx0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHguZmlyc3QpLHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5zZWNvbmQpKVxyXG4gICAgICAgIC5zZXRUZXh0UG9zKG5ldyBUZXh0UG9zaXRpb24oY3R4LnN0YXJ0LmxpbmUsY3R4LnN0YXJ0LmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRCb29sQ29uc3RhbnQoY3R4OmFueSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb29sQ29uc3RhbnROb2RlKGN0eC52YWx1ZS50ZXh0PT1cInRydWVcIilcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIC8qdmlzaXREZXJpdmF0aXZlRXhwcmVzc2lvbihjdHg6YW55KXtcclxuICAgICAgICByZXR1cm4gbmV3IERlcml2YXRpdmVOb2RlKHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC5pZCkpO1xyXG4gICAgfSovXHJcbiAgICB2aXNpdFZhcmlhYmxlRXhwcmVzc2lvbihjdHg6YW55KXtcclxuICAgICAgICBsZXQgaWRlbnQgPSB0aGlzLnZpc2l0VmFySWRlbnRpZmllcihjdHguaWQpO1xyXG4gICAgICAgIGlmKGN0eC5kZXIhPXVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZXJpdmF0aXZlTm9kZShpZGVudClcclxuICAgICAgICAgICAgLnNldFRleHRQb3MobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRWYXJJZGVudGlmaWVyKGN0eC5pZCk7XHJcbiAgICB9XHJcbiAgICB2aXNpdFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uKGN0eDphbnkpe1xyXG4gICAgICAgIHN3aXRjaChjdHgub3AudHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLlBMVVM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oKSk7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLk1JTlVTOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOZWdhdGlvbk5vZGUodGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmV4cHJlc3Npb24oKSkpXHJcbiAgICAgICAgICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lci5hZGQobmV3IFRleHRQb3NpdGlvbihjdHguc3RhcnQubGluZSxjdHguc3RhcnQuY29sdW1uLGN0eC5zdGFydC5zdGFydCxjdHguc3RvcC5zdG9wKSxcIlVua25vd24gdW5hcnkgb3BlcmF0b3JcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2aXNpdEJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbihjdHg6YW55KTpFeHByZXNzaW9uTm9kZXtcclxuICAgICAgICBsZXQgb3A6RXhwcmVzc2lvbk5vZGU7XHJcbiAgICAgICAgc3dpdGNoKGN0eC5vcC50eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLm9kZUdyYW1tYXJQYXJzZXIuRElWSVNJT046XHJcbiAgICAgICAgICAgICAgICBvcCA9IG5ldyBEaXZpc2lvbk5vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIub2RlR3JhbW1hclBhcnNlci5BU1RFUklTSzpcclxuICAgICAgICAgICAgICAgIG9wID0gbmV3IE11bHRpcGxpY2F0aW9uTm9kZShcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgubGVmdCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LnJpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLlBMVVM6XHJcbiAgICAgICAgICAgICAgICBvcCA9IG5ldyBBZGRpdGlvbk5vZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LmxlZnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5yaWdodCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIub2RlR3JhbW1hclBhcnNlci5NSU5VUzpcclxuICAgICAgICAgICAgICAgIG9wID0gbmV3IFN1YnRyYWN0aW9uTm9kZShcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgubGVmdCksXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24oY3R4LnJpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5vZGVHcmFtbWFyUGFyc2VyLkNBUkVUOlxyXG4gICAgICAgICAgICAgICAgb3AgPSBuZXcgRnVuY3Rpb25Ob2RlKFxyXG4gICAgICAgICAgICAgICAgICAgIFwicG93XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgW3RoaXMudmlzaXRFeHByZXNzaW9uKGN0eC5sZWZ0KSx0aGlzLnZpc2l0RXhwcmVzc2lvbihjdHgucmlnaHQpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvckxpc3RlbmVyLmFkZChuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApLFwiVW5rbm93biBiaW5hcnkgb3BlcmF0b3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcFxyXG4gICAgICAgIC5zZXRUZXh0UG9zKG5ldyBUZXh0UG9zaXRpb24oY3R4LnN0YXJ0LmxpbmUsY3R4LnN0YXJ0LmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRGdW5jdGlvbkRlcml2YXRpdmUoY3R4OmFueSl7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZXJpdmF0aXZlTm9kZSh0aGlzLnZpc2l0VmFySWRlbnRpZmllcihjdHguaWQpKVxyXG4gICAgICAgIC5zZXRUZXh0UG9zKG5ldyBUZXh0UG9zaXRpb24oY3R4LnN0YXJ0LmxpbmUsY3R4LnN0YXJ0LmNvbHVtbixjdHguc3RhcnQuc3RhcnQsY3R4LnN0b3Auc3RvcCkpO1xyXG4gICAgfVxyXG4gICAgdmlzaXRGdW5jdGlvbkV4cHJlc3Npb24oY3R4OmFueSl7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLnZpc2l0RnVuY3Rpb25Bcmd1bWVudHMoY3R4LmZ1bmN0aW9uQXJndW1lbnRzKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Ob2RlKGN0eC5mdW5jLnRleHQsYXJncylcclxuICAgICAgICAuc2V0VGV4dFBvcyhuZXcgVGV4dFBvc2l0aW9uKGN0eC5zdGFydC5saW5lLGN0eC5zdGFydC5jb2x1bW4sY3R4LnN0YXJ0LnN0YXJ0LGN0eC5zdG9wLnN0b3ApKTtcclxuICAgIH1cclxuICAgIHZpc2l0RnVuY3Rpb25Bcmd1bWVudHMoY3R4OmFueSk6RXhwcmVzc2lvbk5vZGVbXXtcclxuICAgICAgICB2YXIgYXJnczpFeHByZXNzaW9uTm9kZVtdID0gW107XHJcbiAgICAgICAgaWYoY3R4LmV4cHJlc3Npb24hPXVuZGVmaW5lZClcclxuICAgICAgICAgICAgY3R4LmV4cHJlc3Npb24oKS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06YW55KXtcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnZpc2l0KGl0ZW0pKTtcclxuICAgICAgICAgICAgfSx0aGlzKTtcclxuICAgICAgICByZXR1cm4gYXJncztcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFZpc2l0b3I7IiwiaW1wb3J0IHsgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtIH0gZnJvbSBcIi4vSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtXCI7XHJcbmltcG9ydCB7REFFVmVjdG9yfSBmcm9tIFwiLi4vZGFlL2RhZVZlY3RvclwiO1xyXG5cclxuY2xhc3MgUHJpb3JpdHlRdWV1ZTxUPntcclxuICAgIGl0ZW1zOnt2YWx1ZTpULHByaW9yaXR5Om51bWJlcn1bXTtcclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgaW5zZXJ0KGl0ZW06VCxwcmlvcml0eTpudW1iZXIpOnZvaWR7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLml0ZW1zLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICBpZih0aGlzLml0ZW1zW2ldLnByaW9yaXR5PHByaW9yaXR5KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksMCx7dmFsdWU6aXRlbSxwcmlvcml0eTpwcmlvcml0eX0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7dmFsdWU6aXRlbSxwcmlvcml0eTpwcmlvcml0eX0pO1xyXG4gICAgfVxyXG4gICAgZGVxdWV1ZXUoKTpUe1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLnNoaWZ0KCkudmFsdWU7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5pdGVtc1swXS52YWx1ZTtcclxuICAgIH1cclxuICAgIGxlbmd0aCgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIEVkZ2V7XHJcbiAgICBzdGFydDpudW1iZXI7XHJcbiAgICBlbmQ6bnVtYmVyO1xyXG4gICAgcG9pbnQ6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RhcnQ6bnVtYmVyLGVuZDpudW1iZXIscG9pbnQ6bnVtYmVyKXtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIERvdWdsYXNQZXVja2VyTlNpbXBsaWZpY2F0aW9uIGltcGxlbWVudHMgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhte1xyXG4gICAgbWF4UG9pbnRzOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKG1heFBvaW50czpudW1iZXIpe1xyXG4gICAgICAgIHRoaXMubWF4UG9pbnRzID0gbWF4UG9pbnRzO1xyXG4gICAgfVxyXG4gICAgcHJvY2VzcyhzdGFydDpudW1iZXIsZW5kOm51bWJlcixwb2ludHM6REFFVmVjdG9yW10scXVldWU6UHJpb3JpdHlRdWV1ZTxFZGdlPil7XHJcbiAgICAgICAgbGV0IG1heERpc3QgPSAwO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0O1xyXG4gICAgICAgIGZvcihsZXQgaT1zdGFydCsxO2k8ZW5kO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IERBRVZlY3Rvci5kaXN0YW5jZUxpbmVQb2ludChwb2ludHNbc3RhcnRdLHBvaW50c1tlbmRdLHBvaW50c1tpXSk7XHJcbiAgICAgICAgICAgIGlmKGRpc3RhbmNlPm1heERpc3Qpe1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGluZGV4IT1zdGFydClcclxuICAgICAgICAgICAgcXVldWUuaW5zZXJ0KG5ldyBFZGdlKHN0YXJ0LGVuZCxpbmRleCksbWF4RGlzdCk7XHJcbiAgICB9XHJcbiAgICBzaW1wbGlmeShwb2ludHM6IERBRVZlY3RvcltdKTogREFFVmVjdG9yW10ge1xyXG4gICAgICAgIGlmKHBvaW50cy5sZW5ndGg8PXRoaXMubWF4UG9pbnRzKXtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZTxFZGdlPigpO1xyXG4gICAgICAgIGxldCBjaG9vc2VuUG9pbnRzOm51bWJlcltdID0gW107XHJcbiAgICAgICAgY2hvb3NlblBvaW50cy5wdXNoKDApO1xyXG4gICAgICAgIGNob29zZW5Qb2ludHMucHVzaChwb2ludHMubGVuZ3RoLTEpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IDA7XHJcbiAgICAgICAgbGV0IGVuZCA9IHBvaW50cy5sZW5ndGgtMTtcclxuICAgICAgICB0aGlzLnByb2Nlc3Moc3RhcnQsZW5kLHBvaW50cyxxdWV1ZSk7XHJcbiAgICAgICAgd2hpbGUoY2hvb3NlblBvaW50cy5sZW5ndGg8dGhpcy5tYXhQb2ludHMmJnF1ZXVlLmxlbmd0aCgpPjApe1xyXG4gICAgICAgICAgICBsZXQgZWRnZSA9IHF1ZXVlLmRlcXVldWV1KCk7XHJcbiAgICAgICAgICAgIGNob29zZW5Qb2ludHMucHVzaChlZGdlLnBvaW50KTtcclxuICAgICAgICAgICAgc3RhcnQgPSBlZGdlLnN0YXJ0O1xyXG4gICAgICAgICAgICBlbmQgPSBlZGdlLnBvaW50O1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3Moc3RhcnQsZW5kLHBvaW50cyxxdWV1ZSk7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gZWRnZS5wb2ludDtcclxuICAgICAgICAgICAgZW5kID0gZWRnZS5lbmQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcyhzdGFydCxlbmQscG9pbnRzLHF1ZXVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hvb3NlblBvaW50cy5zb3J0KChhLGIpPT5hLWIpO1xyXG4gICAgICAgIGxldCByZXN1bHQ6REFFVmVjdG9yW10gPSBjaG9vc2VuUG9pbnRzLm1hcChmdW5jdGlvbihpbmRleCl7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHNbaW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBJU2ltcGxpZmljYXRpb25BbGdvcml0aG0gfSBmcm9tIFwiLi9JU2ltcGxpZmljYXRpb25BbGdvcml0aG1cIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4uL2RhZS9kYWVWZWN0b3JcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIERvdWdsYXNQZXVja2VyU2ltcGxpZmljYXRpb24gaW1wbGVtZW50cyBJU2ltcGxpZmljYXRpb25BbGdvcml0aG1cclxue1xyXG4gICAgcHJvdGVjdGVkIGVwc2lsb246bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3IoZXBzaWxvbjpudW1iZXIpe1xyXG4gICAgICAgIHRoaXMuZXBzaWxvbiA9IGVwc2lsb247XHJcbiAgICB9XHJcbiAgICBzaW1wbGlmeShwb2ludHM6REFFVmVjdG9yW10pOkRBRVZlY3Rvcltde1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bihwb2ludHMsMCxwb2ludHMubGVuZ3RoLTEpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIHJ1bihwb2ludHM6REFFVmVjdG9yW10sc3RhcnQ6bnVtYmVyLGVuZDpudW1iZXIpOkRBRVZlY3Rvcltde1xyXG4gICAgICAgIGxldCBtYXhEaXN0ID0gMC4wO1xyXG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0KzE7XHJcbiAgICAgICAgbGV0IGZpcnN0ID0gcG9pbnRzW3N0YXJ0XTtcclxuICAgICAgICBsZXQgbGFzdCA9IHBvaW50c1tlbmRdO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IHN0YXJ0ICsgMTtpPGVuZDtpKyspe1xyXG4gICAgICAgICAgICBsZXQgZGlzdCA9IERBRVZlY3Rvci5kaXN0YW5jZUxpbmVQb2ludChmaXJzdCxsYXN0LHBvaW50c1tpXSk7XHJcbiAgICAgICAgICAgIGlmKGRpc3Q+PW1heERpc3Qpe1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdCA9IGRpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobWF4RGlzdD50aGlzLmVwc2lsb24pe1xyXG4gICAgICAgICAgICBsZXQgcmVzMSA9IHRoaXMucnVuKHBvaW50cyxzdGFydCxpbmRleCk7XHJcbiAgICAgICAgICAgIGxldCByZXMyID0gdGhpcy5ydW4ocG9pbnRzLGluZGV4LGVuZCk7XHJcbiAgICAgICAgICAgIHJlczEucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXMxLmNvbmNhdChyZXMyKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIFtmaXJzdCxsYXN0XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBJU2ltcGxpZmljYXRpb25BbGdvcml0aG0gfSBmcm9tIFwiLi9JU2ltcGxpZmljYXRpb25BbGdvcml0aG1cIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4uL2RhZS9kYWVWZWN0b3JcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTGFuZ1NpbXBsaWZpY2F0aW9uIGltcGxlbWVudHMgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhte1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIHRvbGVyYW5jZTpudW1iZXIscHJvdGVjdGVkIGxvb2thaGVhZDpudW1iZXIpe1xyXG4gICAgfVxyXG4gICAgc2ltcGxpZnkocG9pbnRzOkRBRVZlY3RvcltdKTpEQUVWZWN0b3JbXXtcclxuICAgICAgICBsZXQgcmVzdWx0OkRBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzWzBdKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IDA7XHJcbiAgICAgICAgd2hpbGUoY3VycmVudDxwb2ludHMubGVuZ3RoLTEpe1xyXG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4oY3VycmVudCt0aGlzLmxvb2thaGVhZCxwb2ludHMubGVuZ3RoLTEpO1xyXG4gICAgICAgICAgICBsZXQgX2VuZCA9IGVuZDtcclxuICAgICAgICAgICAgZm9yKGxldCBpPWN1cnJlbnQrMTtpPF9lbmQ7aSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKERBRVZlY3Rvci5kaXN0YW5jZUxpbmVQb2ludChwb2ludHNbY3VycmVudF0scG9pbnRzW19lbmRdLHBvaW50c1tpXSk+dGhpcy50b2xlcmFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIF9lbmQtPTE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbX2VuZF0pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IF9lbmQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihjdXJyZW50KzE8X2VuZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzW2VuZF0pO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGVuZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJU2ltcGxpZmljYXRpb25BbGdvcml0aG0gfSBmcm9tIFwiLi9JU2ltcGxpZmljYXRpb25BbGdvcml0aG1cIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4uL2RhZS9kYWVWZWN0b3JcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTnRoUG9pbnRTaW1wbGlmaWNhdGlvbiBpbXBsZW1lbnRzIElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobXtcclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBtYXhQb2ludHM6bnVtYmVyKXtcclxuICAgIH1cclxuICAgIHNpbXBsaWZ5KHBvaW50czpEQUVWZWN0b3JbXSk6REFFVmVjdG9yW117XHJcbiAgICAgICAgaWYocG9pbnRzLmxlbmd0aDw9dGhpcy5tYXhQb2ludHMpXHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMuc2xpY2UoKTtcclxuICAgICAgICBsZXQgcmVzdWx0OkRBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzWzBdKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSAocG9pbnRzLmxlbmd0aC0xKS8odGhpcy5tYXhQb2ludHMtMSk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gZGVsdGEsaiA9IDI7aTxwb2ludHMubGVuZ3RoJiZqPHRoaXMubWF4UG9pbnRzO2krPWRlbHRhLGorKyl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tNYXRoLnJvdW5kKGkpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoLTFdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtIH0gZnJvbSBcIi4vSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtXCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuLi9kYWUvZGFlVmVjdG9yXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE9waGVpbVNpbXBsaWZpY2F0aW9uIGltcGxlbWVudHMgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhte1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIG1pblRvbGVyYW5jZTpudW1iZXIscHJvdGVjdGVkIG1heFRvbGVyYW5jZTpudW1iZXIpe1xyXG4gICAgfVxyXG4gICAgc2ltcGxpZnkocG9pbnRzOkRBRVZlY3RvcltdKTpEQUVWZWN0b3JbXXtcclxuICAgICAgICBsZXQgcmVzdWx0OkRBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgcmVzdWx0LnB1c2gocG9pbnRzWzBdKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IDA7XHJcbiAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgIGxldCBpID0gY3VycmVudCsxO1xyXG4gICAgICAgICAgICBpZihEQUVWZWN0b3IuZGlzdGFuY2UocG9pbnRzW2N1cnJlbnRdLHBvaW50c1tpXSk8dGhpcy5taW5Ub2xlcmFuY2Upe1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBqPWkrMTtqPD1wb2ludHMubGVuZ3RoLTE7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihEQUVWZWN0b3IuZGlzdGFuY2UocG9pbnRzW2N1cnJlbnRdLHBvaW50c1tqXSk8dGhpcy5tYXhUb2xlcmFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gai0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGk+PXBvaW50cy5sZW5ndGgtMSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaiA9IGkgKyAxO1xyXG4gICAgICAgICAgICBmb3IoO2o8cG9pbnRzLmxlbmd0aC0xO2orKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGVycERpc3QgPSBEQUVWZWN0b3IuZGlzdGFuY2VMaW5lUG9pbnQocG9pbnRzW2N1cnJlbnRdLHBvaW50c1tpXSxwb2ludHNbal0pO1xyXG4gICAgICAgICAgICAgICAgaWYocGVycERpc3Q+dGhpcy5taW5Ub2xlcmFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihEQUVWZWN0b3IuZGlzdGFuY2UocG9pbnRzW2N1cnJlbnRdLHBvaW50c1tqXSk+dGhpcy5tYXhUb2xlcmFuY2Upe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoaj09cG9pbnRzLmxlbmd0aC0xKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoLTFdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtIH0gZnJvbSBcIi4vSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtXCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuLi9kYWUvZGFlVmVjdG9yXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBQZXJwZW5kaWN1bGFyRGlzdGFuY2VTaW1wbGlmaWNhdGlvbiBpbXBsZW1lbnRzIElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobXtcclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB0b2xlcmFuY2U6bnVtYmVyKXtcclxuICAgIH1cclxuICAgIHNpbXBsaWZ5KHBvaW50czpEQUVWZWN0b3JbXSk6REFFVmVjdG9yW117XHJcbiAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnJ1bihwb2ludHMpO1xyXG4gICAgICAgICAgICBpZihyZXN1bHQubGVuZ3RoPT1wb2ludHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgcG9pbnRzID0gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBydW4ocG9pbnRzOkRBRVZlY3RvcltdKTpEQUVWZWN0b3JbXXtcclxuICAgICAgICBpZihwb2ludHMubGVuZ3RoPD0yKVxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLnNsaWNlKCk7XHJcbiAgICAgICAgbGV0IHJlc3VsdDpEQUVWZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1swXSk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDtpPHBvaW50cy5sZW5ndGgtMjspe1xyXG4gICAgICAgICAgICBpZihEQUVWZWN0b3IuZGlzdGFuY2VMaW5lUG9pbnQocG9pbnRzW2ldLHBvaW50c1tpKzJdLHBvaW50c1tpKzFdKTx0aGlzLnRvbGVyYW5jZSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaSsyXSk7XHJcbiAgICAgICAgICAgICAgICBpKz0yO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpKzFdKTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aC0xXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufSIsImltcG9ydCB7IElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobSB9IGZyb20gXCIuL0lTaW1wbGlmaWNhdGlvbkFsZ29yaXRobVwiO1xyXG5pbXBvcnQgeyBEQUVWZWN0b3IgfSBmcm9tIFwiLi4vZGFlL2RhZVZlY3RvclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUmFkaWFsRGlzdGFuY2VTaW1wbGlmaWNhdGlvbiBpbXBsZW1lbnRzIElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobXtcclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB0b2xlcmFuY2U6bnVtYmVyKXtcclxuICAgIH1cclxuICAgIHNpbXBsaWZ5KHBvaW50czpEQUVWZWN0b3JbXSk6REFFVmVjdG9yW117XHJcbiAgICAgICAgbGV0IHJlc3VsdDpEQUVWZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1swXSk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMTtpPHBvaW50cy5sZW5ndGgtMTtpKyspe1xyXG4gICAgICAgICAgICBpZihEQUVWZWN0b3IuZGlzdGFuY2VTcXIocG9pbnRzW2ldLGN1cnJlbnQpPnRoaXMudG9sZXJhbmNlKnRoaXMudG9sZXJhbmNlKXtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoLTFdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtIH0gZnJvbSBcIi4vSVNpbXBsaWZpY2F0aW9uQWxnb3JpdGhtXCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuLi9kYWUvZGFlVmVjdG9yXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFJldW1hbm5XaXRrYW1TaW1wbGlmaWNhdGlvbiBpbXBsZW1lbnRzIElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobXtcclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB0b2xlcmFuY2U6bnVtYmVyKXtcclxuICAgIH1cclxuICAgIHNpbXBsaWZ5KHBvaW50czpEQUVWZWN0b3JbXSk6REFFVmVjdG9yW117XHJcbiAgICAgICAgbGV0IHJlc3VsdDpEQUVWZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1swXSk7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSAxO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDE7aTxwb2ludHMubGVuZ3RoLTE7aSsrKXtcclxuICAgICAgICAgICAgaWYoREFFVmVjdG9yLmRpc3RhbmNlTGluZVBvaW50KHJlc3VsdFtyZXN1bHQubGVuZ3RoLTFdLHBvaW50c1tjdXJyZW50XSxwb2ludHNbaV0pPnRoaXMudG9sZXJhbmNlKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpLTFdKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoLTFdKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHt2ZWN0b3J9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBJREFFU29sdmVyIH0gZnJvbSBcIi4vSURBRVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4vaWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5pbXBvcnQgeyBFREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4vZWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFkYXB0aXZlU3RlcFN0cmF0ZWd5e1xyXG4gICAgZmluZFN0ZXBJREFFKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHNvbHZlcjpJREFFU29sdmVyLHN5c3RlbTpJREFFSHlicmlkU3lzdGVtKTpudW1iZXI7XHJcbiAgICBmaW5kU3RlcEVEQUUoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOkVEQUVIeWJyaWRTeXN0ZW0pOm51bWJlcjtcclxufVxyXG5leHBvcnQgY2xhc3MgQWRhcHRpdmVTdGVwTmV3dG9uIGltcGxlbWVudHMgQWRhcHRpdmVTdGVwU3RyYXRlZ3l7XHJcbiAgICBnYW1tYTpudW1iZXI7XHJcbiAgICBtaW5TdGVwOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKGdhbW1hOm51bWJlcixtaW5TdGVwOm51bWJlcil7XHJcbiAgICAgICAgdGhpcy5nYW1tYSA9IGdhbW1hO1xyXG4gICAgICAgIHRoaXMubWluU3RlcCA9IG1pblN0ZXA7XHJcbiAgICB9XHJcbiAgICBmaW5kU3RlcElEQUUoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc29sdmVyOklEQUVTb2x2ZXIsc3lzdGVtOklEQUVIeWJyaWRTeXN0ZW0pOm51bWJlcntcclxuICAgICAgICBsZXQgc3RlcCA9IDEwZTg7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IHN0YXRlLmdldExpbmtzKCk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluayk9PlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IGR4ZHQgPSBzb2x2ZXIuc29sdmVfZHgoeCx6LHQsc3RhdGUpO1xyXG4gICAgICAgICAgICBsZXQgZHpkdCA9IHNvbHZlci5zb2x2ZV9kemR0KGR4ZHQseCx6LHQsc3RhdGUpO1xyXG4gICAgICAgICAgICBsZXQgZGVub20gPSB2ZWN0b3IuZG90KGxpbmsuZHBkeCh4LHosdCksZHhkdCkgKyB2ZWN0b3IuZG90KGxpbmsuZHBkeih4LHosdCksZHpkdCkgKyBsaW5rLmRwZHQoeCx6LHQpO1xyXG4gICAgICAgICAgICBsZXQgaCA9IC10aGlzLmdhbW1hICogbGluay5wKHgseix0KS9kZW5vbTtcclxuICAgICAgICAgICAgc3RlcCA9IChoPDB8fGlzTmFOKGgpP3N0ZXA6TWF0aC5taW4oc3RlcCxoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHN0ZXAsdGhpcy5taW5TdGVwKTtcclxuICAgIH1cclxuICAgIGZpbmRTdGVwRURBRSh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IEVEQUVIeWJyaWRTeXN0ZW0pOiBudW1iZXIge1xyXG4gICAgICAgIGxldCBzdGVwID0gMTBlODtcclxuICAgICAgICBsZXQgc3RhdGUgPSBzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlKCk7XHJcbiAgICAgICAgbGV0IGxpbmtzID0gc3RhdGUuZ2V0TGlua3MoKTtcclxuICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKT0+XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBsZXQgZHhkdCA9IHN0YXRlLmYoeCx6LHQpO1xyXG4gICAgICAgICAgICBsZXQgZHpkdDp2ZWN0b3I9c3RhdGUuZGdkdCh4LHQpLmFkZFNlbGYoc3RhdGUuZGdkeCh4LHQpLm11bHRWZWMoZHhkdCkpO1xyXG4gICAgICAgICAgICBsZXQgZGVub20gPSB2ZWN0b3IuZG90KGxpbmsuZHBkeCh4LHosdCksZHhkdCkgKyB2ZWN0b3IuZG90KGxpbmsuZHBkeih4LHosdCksZHpkdCkgKyBsaW5rLmRwZHQoeCx6LHQpO1xyXG4gICAgICAgICAgICBsZXQgaCA9IC10aGlzLmdhbW1hICogbGluay5wKHgseix0KS9kZW5vbTtcclxuICAgICAgICAgICAgc3RlcCA9IChoPDB8fGlzTmFOKGgpP3N0ZXA6TWF0aC5taW4oc3RlcCxoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHN0ZXAsdGhpcy5taW5TdGVwKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgRURBRUh5YnJpZFN5c3RlbSwgRURBRUh5YnJpZFN0YXRlIH0gZnJvbSBcIi4vZWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgbWF0cml4IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vY29tcGlsZXIvZXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgeyBIeWJyaWRTdGF0ZUxpbmsgfSBmcm9tIFwiLi9oeWJyaWRTdGF0ZUxpbmtcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tRURBRUh5YnJpZFN0YXRlIGV4dGVuZHMgRURBRUh5YnJpZFN0YXRle1xyXG4gICAgX2Y6RXhwcmVzc2lvbltdO1xyXG4gICAgX2c6RXhwcmVzc2lvbltdO1xyXG4gICAgX2RmZHg6RXhwcmVzc2lvbltdW107XHJcbiAgICBfZGZkejpFeHByZXNzaW9uW11bXTtcclxuICAgIF9kZ2R4OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RnZHQ6RXhwcmVzc2lvbltdO1xyXG4gICAgaW5pdChfZjpFeHByZXNzaW9uW10sX2c6RXhwcmVzc2lvbltdLF9kZmR4OkV4cHJlc3Npb25bXVtdLFxyXG4gICAgICAgIF9kZmR6OkV4cHJlc3Npb25bXVtdLF9kZ2R4OkV4cHJlc3Npb25bXVtdLF9kZ2R0OkV4cHJlc3Npb25bXSl7XHJcbiAgICAgICAgdGhpcy5fZiA9IF9mO1xyXG4gICAgICAgIHRoaXMuX2cgPSBfZztcclxuICAgICAgICB0aGlzLl9kZmR4ID0gX2RmZHg7XHJcbiAgICAgICAgdGhpcy5fZGZkeiA9IF9kZmR6O1xyXG4gICAgICAgIHRoaXMuX2RnZHggPSBfZGdkeDtcclxuICAgICAgICB0aGlzLl9kZ2R0ID0gX2RnZHQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwdXNoTGluayhsaW5rOkh5YnJpZFN0YXRlTGluayl7XHJcbiAgICAgICAgdGhpcy5saW5rcy5wdXNoKGxpbmspO1xyXG4gICAgfVxyXG4gICAgZih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB2ZWN0b3IuZW1wdHkodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIHRoaXMuX2YuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSAsaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGcoeDp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdmVjdG9yLmVtcHR5KHRoaXMubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KFt0XSk7XHJcbiAgICAgICAgdGhpcy5fZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpICxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGZkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHlTcXVhcmUodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIC8vZm9yIGVhY2ggcm93XHJcbiAgICAgICAgdGhpcy5fZGZkeC5mb3JFYWNoKGZ1bmN0aW9uKHJvdyxqKXtcclxuICAgICAgICAgICAgLy9mb3IgZWFjaCBjZWxsIGluIHJvd1xyXG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaiwgaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRmZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5KHRoaXMubGVuZ3RoX3goKSx0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgLy9mb3IgZWFjaCByb3dcclxuICAgICAgICB0aGlzLl9kZmR4LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGdkeCh4OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHkodGhpcy5sZW5ndGhfeigpLHRoaXMubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KFt0XSk7XHJcbiAgICAgICAgLy9mb3IgZWFjaCByb3dcclxuICAgICAgICB0aGlzLl9kZ2R4LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRnZHQoeDogdmVjdG9yLCB0OiBudW1iZXIpOiB2ZWN0b3J7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZlY3Rvci5lbXB0eSh0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdChbdF0pO1xyXG4gICAgICAgIHRoaXMuX2RnZHQuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoX3goKTogbnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGxlbmd0aF96KCk6IG51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5fZy5sZW5ndGg7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBFREFFU3lzdGVtIH0gZnJvbSBcIi4vZWRhZVN5c3RlbVwiO1xyXG5pbXBvcnQgeyBFeHByZXNzaW9uIH0gZnJvbSBcIi4uL2NvbXBpbGVyL2V4cHJlc3Npb25cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7bWF0cml4fSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tRURBRVN5c3RlbSBpbXBsZW1lbnRzIEVEQUVTeXN0ZW17XHJcbiAgICBfZjpFeHByZXNzaW9uW107XHJcbiAgICBfZzpFeHByZXNzaW9uW107XHJcbiAgICBfZGZkeDpFeHByZXNzaW9uW11bXTtcclxuICAgIF9kZmR6OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RnZHg6RXhwcmVzc2lvbltdW107XHJcbiAgICBjb25zdHJ1Y3RvcihfZjpFeHByZXNzaW9uW10sX2c6RXhwcmVzc2lvbltdLFxyXG4gICAgICAgIF9kZmR4OkV4cHJlc3Npb25bXVtdLF9kZmR6OkV4cHJlc3Npb25bXVtdLF9kZ2R4OkV4cHJlc3Npb25bXVtdKXtcclxuICAgICAgICAgICAgdGhpcy5fZiA9IF9mO1xyXG4gICAgICAgICAgICB0aGlzLl9nID0gX2c7XHJcbiAgICAgICAgICAgIHRoaXMuX2RmZHggPSBfZGZkeDtcclxuICAgICAgICAgICAgdGhpcy5fZGZkeiA9IF9kZmR6O1xyXG4gICAgICAgICAgICB0aGlzLl9kZ2R4ID0gX2RnZHg7XHJcbiAgICAgICAgfVxyXG4gICAgbGVuZ3RoX3goKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2YubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoX3ooKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2cubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB2ZWN0b3IuZW1wdHkodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIHRoaXMuX2YuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSAsaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGcoeDp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdmVjdG9yLmVtcHR5KHRoaXMubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KFt0XSk7XHJcbiAgICAgICAgdGhpcy5fZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpICxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGZkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHlTcXVhcmUodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIC8vZm9yIGVhY2ggcm93XHJcbiAgICAgICAgdGhpcy5fZGZkeC5mb3JFYWNoKGZ1bmN0aW9uKHJvdyxqKXtcclxuICAgICAgICAgICAgLy9mb3IgZWFjaCBjZWxsIGluIHJvd1xyXG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaiwgaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRmZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5KHRoaXMubGVuZ3RoX3goKSx0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgLy9mb3IgZWFjaCByb3dcclxuICAgICAgICB0aGlzLl9kZmR6LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGdkeCh4OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHkodGhpcy5sZW5ndGhfeigpLHRoaXMubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KFt0XSk7XHJcbiAgICAgICAgLy9mb3IgZWFjaCByb3dcclxuICAgICAgICB0aGlzLl9kZ2R4LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vY29tcGlsZXIvZXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgeyBIeWJyaWRTdGF0ZUxpbmsgfSBmcm9tIFwiLi4vZGFlL2h5YnJpZFN0YXRlTGlua1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNldHRlcntcclxuICAgIGluZGV4Om51bWJlcjtcclxuICAgIGV4cHJlc3Npb246RXhwcmVzc2lvbjtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4Om51bWJlcixleHByZXNzaW9uOkV4cHJlc3Npb24pe1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbUh5YnJpZFN0YXRlTGluayBpbXBsZW1lbnRzIEh5YnJpZFN0YXRlTGlua3tcclxuICAgIG5ld1N0YXRlOm51bWJlcjtcclxuICAgIF9wOkV4cHJlc3Npb247XHJcbiAgICBfZHBkdDpFeHByZXNzaW9uO1xyXG4gICAgX2RwZHo6RXhwcmVzc2lvbltdO1xyXG4gICAgX2RwZHg6RXhwcmVzc2lvbltdO1xyXG4gICAgc2V0dGVyczpTZXR0ZXJbXTtcclxuICAgIGNvbnN0cnVjdG9yKG5ld1N0YXRlOm51bWJlcixzZXR0ZXJzOlNldHRlcltdLFxyXG4gICAgICAgIF9wOkV4cHJlc3Npb24sX2RwZHg6RXhwcmVzc2lvbltdLF9kcGR6OkV4cHJlc3Npb25bXSxfZHBkdDpFeHByZXNzaW9uKXtcclxuICAgICAgICB0aGlzLm5ld1N0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgdGhpcy5zZXR0ZXJzID0gc2V0dGVycztcclxuICAgICAgICB0aGlzLl9wID0gX3A7XHJcbiAgICAgICAgdGhpcy5fZHBkeCA9IF9kcGR4O1xyXG4gICAgICAgIHRoaXMuX2RwZHogPSBfZHBkejtcclxuICAgICAgICB0aGlzLl9kcGR0ID0gX2RwZHQ7XHJcbiAgICB9XHJcbiAgICBnZXROZXdTdGF0ZSgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXdTdGF0ZTtcclxuICAgIH1cclxuICAgIHByKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTpib29sZWFue1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMucCh4LHosdCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlPDA/dHJ1ZTpmYWxzZTtcclxuICAgIH1cclxuICAgIHAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm51bWJlcntcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLFt0XSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3AuZXhlY3V0ZShhcmdzKTtcclxuICAgIH1cclxuICAgIGRwZHQoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm51bWJlcntcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLFt0XSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RwZHQuZXhlY3V0ZShhcmdzKTtcclxuICAgIH1cclxuICAgIHNldENvbmRpdGlvbnMoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0ID0geC5jbG9uZSgpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsW3RdKTtcclxuICAgICAgICB0aGlzLnNldHRlcnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4cHJlc3Npb24uZXhlY3V0ZShhcmdzKSxpdGVtLmluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZHBkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB2ZWN0b3IuZW1wdHkoei5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KHouZGF0YSxbdF0pO1xyXG4gICAgICAgIHRoaXMuX2RwZHouZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZHBkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB2ZWN0b3IuZW1wdHkoeC5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KHouZGF0YSxbdF0pO1xyXG4gICAgICAgIHRoaXMuX2RwZHguZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgSURBRUh5YnJpZFN0YXRlIH0gZnJvbSBcIi4vaWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgbWF0cml4IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vY29tcGlsZXIvZXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgeyBIeWJyaWRTdGF0ZUxpbmsgfSBmcm9tIFwiLi9oeWJyaWRTdGF0ZUxpbmtcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEN1c3RvbUlEQUVIeWJyaWRTdGF0ZSBleHRlbmRzIElEQUVIeWJyaWRTdGF0ZXtcclxuICAgIF9mOkV4cHJlc3Npb25bXTtcclxuICAgIF9nOkV4cHJlc3Npb25bXTtcclxuICAgIF9kZmR4OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RmZGR4OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RmZHo6RXhwcmVzc2lvbltdW107XHJcbiAgICBfZGdkeDpFeHByZXNzaW9uW11bXTtcclxuICAgIF9kZ2R6OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RnZHQ6RXhwcmVzc2lvbltdO1xyXG4gICAgaW5pdChfZjpFeHByZXNzaW9uW10sX2c6RXhwcmVzc2lvbltdLF9kZmR4OkV4cHJlc3Npb25bXVtdLF9kZmRkeDpFeHByZXNzaW9uW11bXSxcclxuICAgICAgICBfZGZkejpFeHByZXNzaW9uW11bXSxfZGdkeDpFeHByZXNzaW9uW11bXSxfZGdkejpFeHByZXNzaW9uW11bXSxfZGdkdDpFeHByZXNzaW9uW10pOkN1c3RvbUlEQUVIeWJyaWRTdGF0ZXtcclxuICAgICAgICB0aGlzLl9mID0gX2Y7XHJcbiAgICAgICAgdGhpcy5fZyA9IF9nO1xyXG4gICAgICAgIHRoaXMuX2RmZHggPSBfZGZkeDtcclxuICAgICAgICB0aGlzLl9kZmRkeCA9IF9kZmRkeDtcclxuICAgICAgICB0aGlzLl9kZmR6ID0gX2RmZHo7XHJcbiAgICAgICAgdGhpcy5fZGdkeCA9IF9kZ2R4O1xyXG4gICAgICAgIHRoaXMuX2RnZHogPSBfZGdkejtcclxuICAgICAgICB0aGlzLl9kZ2R0ID0gX2RnZHQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBwdXNoTGluayhsaW5rOkh5YnJpZFN0YXRlTGluayl7XHJcbiAgICAgICAgdGhpcy5saW5rcy5wdXNoKGxpbmspO1xyXG4gICAgfVxyXG4gICAgZih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdmVjdG9yLmVtcHR5KHRoaXMubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KGR4LmRhdGEsIHouZGF0YSwgW3RdKTtcclxuICAgICAgICB0aGlzLl9mLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncykgLGkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBnKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZlY3Rvci5lbXB0eSh0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgdGhpcy5fZy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpICxpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGZkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5U3F1YXJlKHRoaXMubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KGR4LmRhdGEsIHouZGF0YSwgW3RdKTtcclxuICAgICAgICAvL2ZvciBlYWNoIHJvd1xyXG4gICAgICAgIHRoaXMuX2RmZHguZm9yRWFjaChmdW5jdGlvbihyb3csail7XHJcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggY2VsbCBpbiByb3dcclxuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpLGosIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZmRkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5U3F1YXJlKHRoaXMubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KGR4LmRhdGEsIHouZGF0YSwgW3RdKTtcclxuICAgICAgICAvL2ZvciBlYWNoIHJvd1xyXG4gICAgICAgIHRoaXMuX2RmZGR4LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGZkeih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5KHRoaXMubGVuZ3RoX3goKSx0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdChkeC5kYXRhLCB6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgLy9mb3IgZWFjaCByb3dcclxuICAgICAgICB0aGlzLl9kZmR6LmZvckVhY2goZnVuY3Rpb24ocm93LGope1xyXG4gICAgICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gcm93XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0saSl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSxqLCBpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZGdkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHlTcXVhcmUodGhpcy5sZW5ndGhfeigpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIHRoaXMuX2RnZHouZm9yRWFjaChmdW5jdGlvbihyb3csail7XHJcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggY2VsbCBpbiByb3dcclxuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpLGosIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZ2R4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1hdHJpeC5lbXB0eSh0aGlzLmxlbmd0aF96KCksdGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIHRoaXMuX2RnZHguZm9yRWFjaChmdW5jdGlvbihyb3csail7XHJcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggY2VsbCBpbiByb3dcclxuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpLGosIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZ2R0KHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIpOiB2ZWN0b3J7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHZlY3Rvci5lbXB0eSh0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsW3RdKTtcclxuICAgICAgICB0aGlzLl9kZ2R0LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoX3goKTogbnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGxlbmd0aF96KCk6IG51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5fZy5sZW5ndGg7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4vaWRhZVN5c3RlbVwiO1xyXG5pbXBvcnQgeyBFeHByZXNzaW9uIH0gZnJvbSBcIi4uL2NvbXBpbGVyL2V4cHJlc3Npb25cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7bWF0cml4fSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tSURBRVN5c3RlbSBpbXBsZW1lbnRzIElEQUVTeXN0ZW17XHJcbiAgICBfZjpFeHByZXNzaW9uW107XHJcbiAgICBfZzpFeHByZXNzaW9uW107XHJcbiAgICBfZGZkeDpFeHByZXNzaW9uW11bXTtcclxuICAgIF9kZmRkeDpFeHByZXNzaW9uW11bXTtcclxuICAgIF9kZmR6OkV4cHJlc3Npb25bXVtdO1xyXG4gICAgX2RnZHg6RXhwcmVzc2lvbltdW107XHJcbiAgICBfZGdkejpFeHByZXNzaW9uW11bXTtcclxuICAgIGNvbnN0cnVjdG9yKF9mOkV4cHJlc3Npb25bXSxfZzpFeHByZXNzaW9uW10sX2RmZHg6RXhwcmVzc2lvbltdW10sX2RmZGR4OkV4cHJlc3Npb25bXVtdLF9kZmR6OkV4cHJlc3Npb25bXVtdLFxyXG4gICAgICAgIF9kZ2R4OkV4cHJlc3Npb25bXVtdLF9kZ2R6OkV4cHJlc3Npb25bXVtdKXtcclxuICAgICAgICAgICAgdGhpcy5fZiA9IF9mO1xyXG4gICAgICAgICAgICB0aGlzLl9nID0gX2c7XHJcbiAgICAgICAgICAgIHRoaXMuX2RmZHggPSBfZGZkeDtcclxuICAgICAgICAgICAgdGhpcy5fZGZkZHggPSBfZGZkZHg7XHJcbiAgICAgICAgICAgIHRoaXMuX2RmZHogPSBfZGZkejtcclxuICAgICAgICAgICAgdGhpcy5fZGdkeCA9IF9kZ2R4O1xyXG4gICAgICAgICAgICB0aGlzLl9kZ2R6ID0gX2RnZHo7XHJcbiAgICB9XHJcbiAgICBsZW5ndGhfeCgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5fZi5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBsZW5ndGhfeigpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5fZy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBmKHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB2ZWN0b3IuZW1wdHkodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoZHguZGF0YSwgei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIHRoaXMuX2YuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICByZXN1bHQuc2V0KGl0ZW0uZXhlY3V0ZShhcmdzKSAsaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0ID0gdmVjdG9yLmVtcHR5KHRoaXMubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KHouZGF0YSwgW3RdKTtcclxuICAgICAgICB0aGlzLl9nLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncykgLGkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZmR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHlTcXVhcmUodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoZHguZGF0YSwgei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIC8vZm9yIGVhY2ggcm93XHJcbiAgICAgICAgdGhpcy5fZGZkeC5mb3JFYWNoKGZ1bmN0aW9uKHJvdyxqKXtcclxuICAgICAgICAgICAgLy9mb3IgZWFjaCBjZWxsIGluIHJvd1xyXG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaiwgaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRmZGR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHlTcXVhcmUodGhpcy5sZW5ndGhfeCgpKTtcclxuICAgICAgICBsZXQgYXJncyA9IHguZGF0YS5jb25jYXQoZHguZGF0YSwgei5kYXRhLCBbdF0pO1xyXG4gICAgICAgIC8vZm9yIGVhY2ggcm93XHJcbiAgICAgICAgdGhpcy5fZGZkZHguZm9yRWFjaChmdW5jdGlvbihyb3csail7XHJcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggY2VsbCBpbiByb3dcclxuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpLGosIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZmR6KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBtYXRyaXguZW1wdHkodGhpcy5sZW5ndGhfeCgpLHRoaXMubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgbGV0IGFyZ3MgPSB4LmRhdGEuY29uY2F0KGR4LmRhdGEsIHouZGF0YSwgW3RdKTtcclxuICAgICAgICAvL2ZvciBlYWNoIHJvd1xyXG4gICAgICAgIHRoaXMuX2RmZHouZm9yRWFjaChmdW5jdGlvbihyb3csail7XHJcbiAgICAgICAgICAgIC8vZm9yIGVhY2ggY2VsbCBpbiByb3dcclxuICAgICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oaXRlbSxpKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoaXRlbS5leGVjdXRlKGFyZ3MpLGosIGkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBkZ2R6KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1hdHJpeC5lbXB0eVNxdWFyZSh0aGlzLmxlbmd0aF96KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgdGhpcy5fZGdkei5mb3JFYWNoKGZ1bmN0aW9uKHJvdyxqKXtcclxuICAgICAgICAgICAgLy9mb3IgZWFjaCBjZWxsIGluIHJvd1xyXG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaiwgaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRnZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbWF0cml4LmVtcHR5KHRoaXMubGVuZ3RoX3ooKSx0aGlzLmxlbmd0aF94KCkpO1xyXG4gICAgICAgIGxldCBhcmdzID0geC5kYXRhLmNvbmNhdCh6LmRhdGEsIFt0XSk7XHJcbiAgICAgICAgdGhpcy5fZGdkeC5mb3JFYWNoKGZ1bmN0aW9uKHJvdyxqKXtcclxuICAgICAgICAgICAgLy9mb3IgZWFjaCBjZWxsIGluIHJvd1xyXG4gICAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihpdGVtLGkpe1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChpdGVtLmV4ZWN1dGUoYXJncyksaiwgaSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufSIsImltcG9ydCB7dmVjdG9yfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuZXhwb3J0IGNsYXNzIERBRVZlY3RvcntcclxuICAgIHg6dmVjdG9yO1xyXG4gICAgejp2ZWN0b3I7XHJcbiAgICB0Om51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKXtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueiA9IHo7XHJcbiAgICAgICAgdGhpcy50ID0gdDtcclxuICAgIH1cclxuICAgIGxlbmd0aFNxcigpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnQqdGhpcy50ICsgdGhpcy54Lm5vcm0yU3FyKCkgKyB0aGlzLnoubm9ybTJTcXIoKTtcclxuICAgIH1cclxuICAgIGxlbmd0aCgpe1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy50KnRoaXMudCArIHRoaXMueC5ub3JtMlNxcigpICsgdGhpcy56Lm5vcm0yU3FyKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRpc3RhbmNlKGE6REFFVmVjdG9yLGI6REFFVmVjdG9yKXtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGEudCAtIGIudCwyKSArIHZlY3Rvci5zdWIoYS54LGIueCkubm9ybTJTcXIoKSArIHZlY3Rvci5zdWIoYS56LGIueikubm9ybTJTcXIoKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGlzdGFuY2VTcXIoYTpEQUVWZWN0b3IsYjpEQUVWZWN0b3Ipe1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhhLnQgLSBiLnQsMikgKyB2ZWN0b3Iuc3ViKGEueCxiLngpLm5vcm0yU3FyKCkgKyB2ZWN0b3Iuc3ViKGEueixiLnopLm5vcm0yU3FyKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZG90KGE6REFFVmVjdG9yLGI6REFFVmVjdG9yKXtcclxuICAgICAgICByZXR1cm4gYS50ICogYi50ICsgdmVjdG9yLmRvdChhLngsYi54KSArIHZlY3Rvci5kb3QoYS56LGIueik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc3ViKGE6REFFVmVjdG9yLGI6REFFVmVjdG9yKXtcclxuICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih2ZWN0b3Iuc3ViKGEueCxiLngpLHZlY3Rvci5zdWIoYS56LGIueiksYS50IC0gYi50KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkaXN0YW5jZUxpbmVQb2ludChwMTpEQUVWZWN0b3IscDI6REFFVmVjdG9yLHBvaW50OkRBRVZlY3Rvcik6bnVtYmVye1xyXG4gICAgICAgIGxldCBhID0gREFFVmVjdG9yLmRpc3RhbmNlU3FyKHBvaW50LHAxKTsvL2Rpc3QgZnJvbSBwIHRvIHAxXHJcbiAgICAgICAgbGV0IGIgPSBEQUVWZWN0b3IuZG90KERBRVZlY3Rvci5zdWIocG9pbnQscDEpLERBRVZlY3Rvci5zdWIocDIscDEpKTtcclxuICAgICAgICBsZXQgYyA9IERBRVZlY3Rvci5kaXN0YW5jZVNxcihwMSxwMik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChhLWIqYi9jKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBFREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4vZWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5pbXBvcnQgeyBFREFFU29sdmVyIH0gZnJvbSBcIi4vZWRhZVNvbHZlclwiO1xyXG5pbXBvcnQge0RBRVZlY3Rvcn0gZnJvbSBcIi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7RXZlbnREZXRlY3Rpb259IGZyb20gXCIuL2V2ZW50RGV0ZWN0aW9uXCI7XHJcbmltcG9ydCB7QWRhcHRpdmVTdGVwU3RyYXRlZ3l9IGZyb20gXCIuL2FkYXB0aXZlU3RlcFwiO1xyXG5pbXBvcnQgeyBIeWJyaWRTb2x1dGlvbiB9IGZyb20gXCIuL2h5YnJpZFNvbHV0aW9uXCI7XHJcblxyXG5cclxuY29uc3QgbWF4RmxvYXRzID0gMjA5NzE1MjtcclxuXHJcbmV4cG9ydCBjbGFzcyBFREFFSHlicmlkU29sdmVyIHtcclxuICAgIGV2ZW50RGV0ZWN0b3I6IEV2ZW50RGV0ZWN0aW9uO1xyXG4gICAgYWRhcHRpdmVTdGVwU3RyYXRlZ3k6IEFkYXB0aXZlU3RlcFN0cmF0ZWd5IHwgbnVsbDtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50RGV0ZWN0b3I6IEV2ZW50RGV0ZWN0aW9uLCBhZGFwdGl2ZVN0ZXBTdHJhdGVneTogQWRhcHRpdmVTdGVwU3RyYXRlZ3kgfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERldGVjdG9yID0gZXZlbnREZXRlY3RvcjtcclxuICAgICAgICB0aGlzLmFkYXB0aXZlU3RlcFN0cmF0ZWd5ID0gYWRhcHRpdmVTdGVwU3RyYXRlZ3k7XHJcbiAgICB9XHJcbiAgICBzb2x2ZSh4MDogdmVjdG9yLCB0MDogbnVtYmVyLCB0MTogbnVtYmVyLCBzb2x2ZXI6IEVEQUVTb2x2ZXIsIHN5c3RlbTogRURBRUh5YnJpZFN5c3RlbSk6IEh5YnJpZFNvbHV0aW9uIHtcclxuICAgICAgICBsZXQgc29sdXRpb25WYWx1ZXM6IERBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgbGV0IHN0YXRlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBsZXQgc3RhdGVTd2l0Y2hlczogbnVtYmVyW10gPSBbXTtcclxuICAgICAgICBsZXQgdCA9IHQwO1xyXG4gICAgICAgIGxldCB4ID0geDA7XHJcbiAgICAgICAgbGV0IHogPSBzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlKCkuZyh4LCB0KTtcclxuICAgICAgICBsZXQgb2xkVmFsdWVzID0gbmV3IERBRVZlY3Rvcih4LCB6LCB0KTtcclxuICAgICAgICBzb2x1dGlvblZhbHVlcy5wdXNoKG9sZFZhbHVlcyk7XHJcblxyXG4gICAgICAgIHN0YXRlcy5wdXNoKHN5c3RlbS5nZXRDdXJyZW50U3RhdGVJbmRleCgpKTtcclxuICAgICAgICBzdGF0ZVN3aXRjaGVzLnB1c2godDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlIChvbGRWYWx1ZXMudCA8IHQxKSB7XHJcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIG5ldyBzdGVwIHNpemVcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTdGVwID0gc29sdmVyLmdldFN0ZXAoKTtcclxuICAgICAgICAgICAgbGV0IGlzU3RlcENoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRpdmVTdGVwU3RyYXRlZ3kgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGggPSB0aGlzLmFkYXB0aXZlU3RlcFN0cmF0ZWd5LmZpbmRTdGVwRURBRShvbGRWYWx1ZXMueCwgb2xkVmFsdWVzLnosIG9sZFZhbHVlcy50LCBzeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGggPiAwICYmIGggPCBzb2x2ZXIuZ2V0U3RlcCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLnNldFN0ZXAoaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGVwQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jYWxjdWxhdGUgdmFyaWFibGUgdmFsdWVzIGF0IHRfe24rMX0sIHRfe24rMX0gPSB0X24gKyBoXHJcbiAgICAgICAgICAgIGxldCBjdXJWYWx1ZXMgPSBzb2x2ZXIubWFrZVN0ZXAob2xkVmFsdWVzLngsIG9sZFZhbHVlcy56LCBvbGRWYWx1ZXMudCwgc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpKTtcclxuICAgICAgICAgICAgLy9jaGVjayBmb3Igc3RhdGUgY2hhbmdlIGluIHRoZSBpbnRlcnZhbCBbdF9uLHRfbitoXVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdG9yLmNoZWNrRXZlbnRFREFFKG9sZFZhbHVlcywgY3VyVmFsdWVzLCBzb2x2ZXIsIHN5c3RlbSkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN5c3RlbS5nZXRDdXJyZW50U3RhdGVJbmRleCgpKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlU3dpdGNoZXMucHVzaChjdXJWYWx1ZXMudCk7XHJcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGZvciB0ZXJtaW5hbCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHN5c3RlbS5pc1Rlcm1pbmFsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vcmVzZXQgbXVsdGlzdGVwIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgc29sdmVyLnNldFN0ZXAoY3VycmVudFN0ZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RlcENoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICBzb2x2ZXIuc2V0U3RlcChjdXJyZW50U3RlcCk7XHJcbiAgICAgICAgICAgIG9sZFZhbHVlcyA9IGN1clZhbHVlcztcclxuICAgICAgICAgICAgc29sdXRpb25WYWx1ZXMucHVzaChvbGRWYWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCoyK3NvbHV0aW9uVmFsdWVzLmxlbmd0aCooc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpLmxlbmd0aF94KCkrc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpLmxlbmd0aF96KCkrMSkgPiBtYXhGbG9hdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgU29sdXRpb24gd2FzIHRlcm1pbmF0ZWQgcHJlbWF0dXJlbHkgZHVlIHRvIG1lbW9yeSBsaW1pdGApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIeWJyaWRTb2x1dGlvbihzb2x1dGlvblZhbHVlcywgc3RhdGVzLHN0YXRlU3dpdGNoZXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgRURBRVN5c3RlbSB9IGZyb20gXCIuL2VkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgSHlicmlkU3RhdGVMaW5rIH0gZnJvbSBcIi4vaHlicmlkU3RhdGVMaW5rXCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vY29tcGlsZXIvZXhwcmVzc2lvblwiO1xyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFREFFSHlicmlkU3RhdGUgaW1wbGVtZW50cyBFREFFU3lzdGVte1xyXG4gICAgcHJvdGVjdGVkIG5hbWU6c3RyaW5nO1xyXG4gICAgcHJvdGVjdGVkIGxpbmtzOkh5YnJpZFN0YXRlTGlua1tdO1xyXG4gICAgcHJvdGVjdGVkIHRlcm1pbmFsOmJvb2xlYW47XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lOnN0cmluZyxsaW5rczpIeWJyaWRTdGF0ZUxpbmtbXSx0ZXJtaW5hbDpib29sZWFuKXtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMubGlua3MgPSBsaW5rcztcclxuICAgICAgICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWw7XHJcbiAgICB9XHJcbiAgICBpc1Rlcm1pbmFsKCk6Ym9vbGVhbntcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hbDtcclxuICAgIH1cclxuICAgIGdldExpbmtzKCk6SHlicmlkU3RhdGVMaW5rW117XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlua3M7XHJcbiAgICB9XHJcbiAgICBnZXROYW1lKCk6c3RyaW5ne1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9XHJcbiAgICBhYnN0cmFjdCBmKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIpOiB2ZWN0b3I7XHJcbiAgICBhYnN0cmFjdCBnKHg6IHZlY3RvciwgdDogbnVtYmVyKTogdmVjdG9yO1xyXG4gICAgYWJzdHJhY3QgZGZkeCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogbWF0cml4O1xyXG4gICAgYWJzdHJhY3QgZGZkeih4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogbWF0cml4O1xyXG4gICAgYWJzdHJhY3QgZGdkeCh4OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHQoeDogdmVjdG9yLCB0OiBudW1iZXIpOiB2ZWN0b3I7XHJcbiAgICBhYnN0cmFjdCBsZW5ndGhfeCgpOiBudW1iZXI7XHJcbiAgICBhYnN0cmFjdCBsZW5ndGhfeigpOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBFREFFSHlicmlkU3lzdGVte1xyXG4gICAgcHJvdGVjdGVkIHN0YXRlczogRURBRUh5YnJpZFN0YXRlW107XHJcbiAgICAvKnByb3RlY3RlZCBzdGF0ZXNNYXA6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47Ki9cclxuICAgIHByb3RlY3RlZCBjdXJyZW50U3RhdGU6IG51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHN0YXRlczpFREFFSHlicmlkU3RhdGVbXSl7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSAwO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFN0YXRlKHN0YXRlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xyXG4gICAgfVxyXG4gICAgZ2V0Q3VycmVudFN0YXRlSW5kZXgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGU7XHJcbiAgICB9XHJcbiAgICBnZXRDdXJyZW50U3RhdGUoKTogRURBRUh5YnJpZFN0YXRlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdGhpcy5jdXJyZW50U3RhdGVdO1xyXG4gICAgfVxyXG4gICAgaXNUZXJtaW5hbCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZXNbdGhpcy5jdXJyZW50U3RhdGVdLmlzVGVybWluYWwoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7IEVEQUVTeXN0ZW0gfSBmcm9tIFwiLi9lZGFlU3lzdGVtXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRURBRVNvbHZlciB7XHJcbiAgICBwcm90ZWN0ZWQgc3RlcDogbnVtYmVyO1xyXG4gICAgcHVibGljIHNldFN0ZXAodmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3RlcCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldFN0ZXAoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGVwO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Ioc3RlcDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IEVEQUVTeXN0ZW0pOiBEQUVWZWN0b3I7XHJcbn1cclxuIiwiaW1wb3J0IHt2ZWN0b3J9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBJREFFSHlicmlkU3lzdGVtIH0gZnJvbSBcIi4vaWRhZUh5YnJpZFN5c3RlbVwiO1xyXG5pbXBvcnQgeyBFREFFSHlicmlkU3lzdGVtLCBFREFFSHlicmlkU3RhdGUgfSBmcm9tIFwiLi9lZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi9JREFFU29sdmVyXCI7XHJcbmltcG9ydCB7IEVEQUVTb2x2ZXIgfSBmcm9tIFwiLi9FREFFU29sdmVyXCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuL2RhZVZlY3RvclwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBFdmVudERldGVjdGlvbntcclxuICAgIGNoZWNrRXZlbnRJREFFKG9sZFZhbHVlczpEQUVWZWN0b3IsY3VyVmFsdWVzOkRBRVZlY3Rvcixzb2x2ZXI6SURBRVNvbHZlcixzeXN0ZW06SURBRUh5YnJpZFN5c3RlbSk6Ym9vbGVhbjtcclxuICAgIGNoZWNrRXZlbnRFREFFKG9sZFZhbHVlczpEQUVWZWN0b3IsY3VyVmFsdWVzOkRBRVZlY3Rvcixzb2x2ZXI6RURBRVNvbHZlcixzeXN0ZW06RURBRUh5YnJpZFN5c3RlbSk6Ym9vbGVhbjtcclxufVxyXG5leHBvcnQgY2xhc3MgRXZlbnREZXRlY3Rpb25TaW1wbGUgaW1wbGVtZW50cyBFdmVudERldGVjdGlvbntcclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgZGV0ZWN0aW9uIGZvciBpbXBsaWNpdCBkYWUgaHlicmlkIHN5c3RlbVxyXG4gICAgICogQHBhcmFtIG9sZFZhbHVlcyB2YWx1ZXMgYXQgdFxyXG4gICAgICogQHBhcmFtIGN1clZhbHVlcyB2YWx1ZXMgYXQgdCtoLCB1c2VkIHRvIHN0b3JlIGluaXRpYWwgdmFsdWVzIGluIGNhc2Ugb2Ygc3RhdGUgY2hhbmdlXHJcbiAgICAgKiBAcGFyYW0gc29sdmVyIGltcGxpY2l0IGRhZSBzb2x2ZXJcclxuICAgICAqIEBwYXJhbSBzeXN0ZW0gaHlicmlkIHN5c3RlbVxyXG4gICAgICogQHJldHVybnMgdHJ1ZSB3aGVuIHN0YXRlIGhhcyBjaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRXZlbnRJREFFKG9sZFZhbHVlczpEQUVWZWN0b3IsY3VyVmFsdWVzOkRBRVZlY3Rvcixzb2x2ZXI6SURBRVNvbHZlcixzeXN0ZW06SURBRUh5YnJpZFN5c3RlbSk6Ym9vbGVhbntcclxuICAgICAgICBsZXQgdmFsdWUgPSAxMGU4O1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHN5c3RlbS5nZXRDdXJyZW50U3RhdGUoKTtcclxuICAgICAgICBsZXQgbGlua3MgPSBzdGF0ZS5nZXRMaW5rcygpO1xyXG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmssaWQpPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBwID0gbGluay5wKGN1clZhbHVlcy54LGN1clZhbHVlcy56LGN1clZhbHVlcy50KTtcclxuICAgICAgICAgICAgaWYocD49MCYmcDx2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHA7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYoaW5kZXghPS0xKXtcclxuICAgICAgICAgICAgY3VyVmFsdWVzLnggPSBsaW5rc1tpbmRleF0uc2V0Q29uZGl0aW9ucyhjdXJWYWx1ZXMueCxjdXJWYWx1ZXMueixjdXJWYWx1ZXMudCk7XHJcbiAgICAgICAgICAgIHN5c3RlbS5zZXRDdXJyZW50U3RhdGUobGlua3NbaW5kZXhdLmdldE5ld1N0YXRlKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFdmVudCBkZXRlY3Rpb24gZm9yIGV4cGxpY2l0IGRhZSBoeWJyaWQgc3lzdGVtXHJcbiAgICAgKiBAcGFyYW0gb2xkVmFsdWVzIHZhbHVlcyBhdCB0XHJcbiAgICAgKiBAcGFyYW0gY3VyVmFsdWVzIHZhbHVlcyBhdCB0K2gsIHVzZWQgdG8gc3RvcmUgaW5pdGlhbCB2YWx1ZXMgaW4gY2FzZSBvZiBzdGF0ZSBjaGFuZ2VcclxuICAgICAqIEBwYXJhbSBzb2x2ZXIgZXhwbGljaXQgZGFlIHNvbHZlclxyXG4gICAgICogQHBhcmFtIHN5c3RlbSBoeWJyaWQgc3lzdGVtXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIHdoZW4gc3RhdGUgaGFzIGNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgY2hlY2tFdmVudEVEQUUob2xkVmFsdWVzOiBEQUVWZWN0b3IsIGN1clZhbHVlczogREFFVmVjdG9yLCBzb2x2ZXI6IEVEQUVTb2x2ZXIsIHN5c3RlbTogRURBRUh5YnJpZFN5c3RlbSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IDEwZTg7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IHN0YXRlLmdldExpbmtzKCk7XHJcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluayxpZCk9PlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHAgPSBsaW5rLnAoY3VyVmFsdWVzLngsY3VyVmFsdWVzLnosY3VyVmFsdWVzLnQpO1xyXG4gICAgICAgICAgICBpZihwPj0wJiZwPHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZihpbmRleCE9LTEpe1xyXG4gICAgICAgICAgICBjdXJWYWx1ZXMueCA9IGxpbmtzW2luZGV4XS5zZXRDb25kaXRpb25zKGN1clZhbHVlcy54LGN1clZhbHVlcy56LGN1clZhbHVlcy50KTtcclxuICAgICAgICAgICAgc3lzdGVtLnNldEN1cnJlbnRTdGF0ZShsaW5rc1tpbmRleF0uZ2V0TmV3U3RhdGUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IGRldGVjdGlvbiBvbiB0aW1lIHN0ZXAgaW50ZXJ2YWwgd2l0aCBuZXd0b24gbWV0aG9kIGZvciBjYXNlcywgd2hlbiBzaWducyBvZiBldmVudCBjb25kaXRpb24gZnVuY3Rpb24gZG9lc24ndCBjaGFuZ2UgYW5kIGJpc2VjdGlvbiBtZXRob2RcclxuICogZm9yIGNhc2VzIHdpdGggY2hhbmdlIG9mIHNpZ25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudERldGVjdGlvbkNvbXBsZXggaW1wbGVtZW50cyBFdmVudERldGVjdGlvblxyXG57XHJcbiAgICBuZXd0b25JdGVyYXRpb25zOm51bWJlciA9IDMwO1xyXG4gICAgcmVsVG9sOm51bWJlciA9IDFlLTY7XHJcbiAgICBhYnNUb2w6bnVtYmVyID0gMWUtNTtcclxuICAgIGFscGhhOm51bWJlciA9IDAuOTU7XHJcbiAgICBiaXNlY3Rpb25JdGVyYXRpb25zOm51bWJlciA9IDMwO1xyXG4gICAgdGltZUFic1RvbDpudW1iZXIgPSAxZS00O1xyXG4gICAgdGltZVJlbFRvbDpudW1iZXIgPSAxZS00O1xyXG4gICAgY29uc3RydWN0b3IobmV3dG9uSXRlcmF0aW9uczpudW1iZXIgPSAzMCxyZWxUb2w6bnVtYmVyID0gMWUtNixcclxuICAgICAgICBhYnNUb2w6bnVtYmVyID0gMWUtNSxhbHBoYTpudW1iZXIgPSAwLjk1LGJpc2VjdGlvbkl0ZXJhdGlvbnM6bnVtYmVyID0gMzAsdGltZUFic1RvbDpudW1iZXIgPSAxZS00LHRpbWVSZWxUb2w6bnVtYmVyID0gMWUtNCl7XHJcbiAgICAgICAgdGhpcy5uZXd0b25JdGVyYXRpb25zID0gbmV3dG9uSXRlcmF0aW9ucztcclxuICAgICAgICB0aGlzLnJlbFRvbCA9IHJlbFRvbDtcclxuICAgICAgICB0aGlzLmFic1RvbCA9IGFic1RvbDtcclxuICAgICAgICB0aGlzLmFscGhhID0gYWxwaGE7XHJcbiAgICAgICAgdGhpcy5iaXNlY3Rpb25JdGVyYXRpb25zID0gYmlzZWN0aW9uSXRlcmF0aW9ucztcclxuICAgICAgICB0aGlzLnRpbWVBYnNUb2wgPSB0aW1lQWJzVG9sO1xyXG4gICAgICAgIHRoaXMudGltZVJlbFRvbCA9IHRpbWVSZWxUb2w7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2ZW50IGRldGVjdGlvbiBmb3IgaW1wbGljaXQgZGFlIGh5YnJpZCBzeXN0ZW1cclxuICAgICAqIEBwYXJhbSBvbGRWYWx1ZXMgdmFsdWVzIGF0IHRcclxuICAgICAqIEBwYXJhbSBjdXJWYWx1ZXMgdmFsdWVzIGF0IHQraCwgdXNlZCB0byBzdG9yZSBpbml0aWFsIHZhbHVlcyBpbiBjYXNlIG9mIHN0YXRlIGNoYW5nZVxyXG4gICAgICogQHBhcmFtIHNvbHZlciBpbXBsaWNpdCBkYWUgc29sdmVyXHJcbiAgICAgKiBAcGFyYW0gc3lzdGVtIGh5YnJpZCBzeXN0ZW1cclxuICAgICAqIEByZXR1cm5zIHRydWUgd2hlbiBzdGF0ZSBoYXMgY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBjaGVja0V2ZW50SURBRShvbGRWYWx1ZXM6REFFVmVjdG9yLGN1clZhbHVlczpEQUVWZWN0b3Isc29sdmVyOklEQUVTb2x2ZXIsc3lzdGVtOklEQUVIeWJyaWRTeXN0ZW0pOmJvb2xlYW57XHJcbiAgICAgICAgbGV0IHRpbWUgPSAxMGU4O1xyXG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xyXG4gICAgICAgIGxldCBzdGF0ZSA9IHN5c3RlbS5nZXRDdXJyZW50U3RhdGUoKTtcclxuICAgICAgICBsZXQgbGlua3MgPSBzdGF0ZS5nZXRMaW5rcygpO1xyXG4gICAgICAgIGxldCBzdGVwID0gY3VyVmFsdWVzLnQgLSBvbGRWYWx1ZXMudDtcclxuICAgICAgICBsZXQgZHggPSB2ZWN0b3Iuc3ViKGN1clZhbHVlcy54LG9sZFZhbHVlcy54KS5zY2FsZVNlbGYoMS9zdGVwKTtcclxuICAgICAgICBsZXQgZHogPSB2ZWN0b3Iuc3ViKGN1clZhbHVlcy56LG9sZFZhbHVlcy56KS5zY2FsZVNlbGYoMS9zdGVwKTtcclxuICAgICAgICAvL2Fzc3VtZSB0aGF0IHggYW5kIHogYXJlIGxpbmVhciBpbiBpbnRlcnZhbCBbb2xkVCxjdXJUXVxyXG4gICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmssaWQpPT5cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGxldCBwMCA9IGxpbmsucChvbGRWYWx1ZXMueCxvbGRWYWx1ZXMueixvbGRWYWx1ZXMudCk7XHJcbiAgICAgICAgICAgIGxldCBwMSA9IGxpbmsucChjdXJWYWx1ZXMueCxjdXJWYWx1ZXMueixjdXJWYWx1ZXMudCk7XHJcbiAgICAgICAgICAgIGlmKHAwPj0wJiZvbGRWYWx1ZXMudDx0aW1lKXtcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBvbGRWYWx1ZXMudDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHAxPj0wJiZjdXJWYWx1ZXMudDx0aW1lKXtcclxuICAgICAgICAgICAgICAgIHRpbWUgPSBjdXJWYWx1ZXMudDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IF9wMCA9IE1hdGgubWluKE1hdGguYWJzKHAxKSxNYXRoLmFicyhwMCkpO1xyXG4gICAgICAgICAgICBsZXQgcCA9IHAwO1xyXG4gICAgICAgICAgICBsZXQgdCA9IG9sZFZhbHVlcy50O1xyXG4gICAgICAgICAgICBsZXQgeCA9IG9sZFZhbHVlcy54O1xyXG4gICAgICAgICAgICBsZXQgeiA9IG9sZFZhbHVlcy56O1xyXG4gICAgICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL05ld3RvbiBtZXRob2QgZm9yIHJvb3QgZmluZGluZ1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMubmV3dG9uSXRlcmF0aW9ucztpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IGRwZHQgPSB2ZWN0b3IuZG90KGxpbmsuZHBkeCh4LHosdCksZHgpICsgXHJcbiAgICAgICAgICAgICAgICB2ZWN0b3IuZG90KGxpbmsuZHBkeih4LHosdCksZHopICsgbGluay5kcGR0KHgseix0KTtcclxuICAgICAgICAgICAgICAgIHAgPSBNYXRoLm1heChNYXRoLmFicyhwKSx0aGlzLmFic1RvbCkqTWF0aC5zaWduKHApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGR0ID0gLXRoaXMuYWxwaGEqcCAvIGRwZHQ7XHJcbiAgICAgICAgICAgICAgICAvL2R0ID0gTWF0aC5tYXgodGhpcy50aW1lQWJzVG9sLE1hdGguYWJzKGR0KSkqTWF0aC5zaWduKGR0KTtcclxuICAgICAgICAgICAgICAgIHQgKz0gZHQ7XHJcbiAgICAgICAgICAgICAgICBpZih0PG9sZFZhbHVlcy50fHx0PmN1clZhbHVlcy50KVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeCA9IHZlY3Rvci5taXgob2xkVmFsdWVzLngsY3VyVmFsdWVzLngsKHQtb2xkVmFsdWVzLnQpL3N0ZXApO1xyXG4gICAgICAgICAgICAgICAgeiA9IHZlY3Rvci5taXgob2xkVmFsdWVzLnosY3VyVmFsdWVzLnosKHQtb2xkVmFsdWVzLnQpL3N0ZXApO1xyXG4gICAgICAgICAgICAgICAgcCA9IGxpbmsucCh4LHosdCk7XHJcbiAgICAgICAgICAgICAgICBpZihwPj0wJiZNYXRoLmFicyhwKTxfcDAqdGhpcy5yZWxUb2wgKyB0aGlzLmFic1RvbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodDx0aW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2Jpc2VjdGlvblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZihwMT49MCYmcDA8PTApe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0MSA9IGN1clZhbHVlcy50O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0MCA9IG9sZFZhbHVlcy50O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5iaXNlY3Rpb25JdGVyYXRpb25zO2krKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ID0gKHQxICsgdDApLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueCxjdXJWYWx1ZXMueCwodC1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB6ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueixjdXJWYWx1ZXMueiwodC1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwID0gbGluay5wKHgseix0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGR0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocD49MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQxID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0ID0gdC10MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHA8X3AwKnRoaXMucmVsVG9sICsgdGhpcy5hYnNUb2wmJmR0PHRoaXMudGltZUFic1RvbCtzdGVwKnRoaXMudGltZVJlbFRvbCYmdDx0aW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQwID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0ID0gdDEgLSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVE9ETyBhZGQgZmFsc2UgcG9zaXRpb24gZnJvbSBtYXRsYWIgYXJ0aWNsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKGluZGV4IT0tMSl7XHJcbiAgICAgICAgICAgIGxldCB4ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueCxjdXJWYWx1ZXMueCwodGltZS1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgIGxldCB6ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueixjdXJWYWx1ZXMueiwodGltZS1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgIHogPSBzb2x2ZXIuc29sdmVfeih4LHosdGltZSxzdGF0ZSk7XHJcbiAgICAgICAgICAgIGN1clZhbHVlcy54ID0gbGlua3NbaW5kZXhdLnNldENvbmRpdGlvbnMoeCx6LHRpbWUpO1xyXG4gICAgICAgICAgICBjdXJWYWx1ZXMudCA9IHRpbWU7XHJcbiAgICAgICAgICAgIGN1clZhbHVlcy56ID0gc29sdmVyLnNvbHZlX3ooY3VyVmFsdWVzLngseixjdXJWYWx1ZXMudCxzdGF0ZSk7XHJcbiAgICAgICAgICAgIHN5c3RlbS5zZXRDdXJyZW50U3RhdGUobGlua3NbaW5kZXhdLmdldE5ld1N0YXRlKCkpO1xyXG4gICAgICAgICAgICAvL2N1clZhbHVlcy56ID0gejtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXZlbnQgZGV0ZWN0aW9uIGZvciBleHBsaWNpdCBkYWUgaHlicmlkIHN5c3RlbVxyXG4gICAgICogQHBhcmFtIG9sZFZhbHVlcyB2YWx1ZXMgYXQgdFxyXG4gICAgICogQHBhcmFtIGN1clZhbHVlcyB2YWx1ZXMgYXQgdCtoLCB1c2VkIHRvIHN0b3JlIGluaXRpYWwgdmFsdWVzIGluIGNhc2Ugb2Ygc3RhdGUgY2hhbmdlXHJcbiAgICAgKiBAcGFyYW0gc29sdmVyIGV4cGxpY2l0IGRhZSBzb2x2ZXJcclxuICAgICAqIEBwYXJhbSBzeXN0ZW0gaHlicmlkIHN5c3RlbVxyXG4gICAgICogQHJldHVybnMgdHJ1ZSB3aGVuIHN0YXRlIGhhcyBjaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIGNoZWNrRXZlbnRFREFFKG9sZFZhbHVlczogREFFVmVjdG9yLCBjdXJWYWx1ZXM6IERBRVZlY3Rvciwgc29sdmVyOiBFREFFU29sdmVyLCBzeXN0ZW06IEVEQUVIeWJyaWRTeXN0ZW0pOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgdGltZSA9IDEwZTg7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IHN0YXRlID0gc3lzdGVtLmdldEN1cnJlbnRTdGF0ZSgpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IHN0YXRlLmdldExpbmtzKCk7XHJcbiAgICAgICAgbGV0IHN0ZXAgPSBjdXJWYWx1ZXMudCAtIG9sZFZhbHVlcy50O1xyXG4gICAgICAgIGxldCBkeCA9IHZlY3Rvci5zdWIoY3VyVmFsdWVzLngsb2xkVmFsdWVzLngpLnNjYWxlU2VsZigxL3N0ZXApO1xyXG4gICAgICAgIGxldCBkeiA9IHZlY3Rvci5zdWIoY3VyVmFsdWVzLnosb2xkVmFsdWVzLnopLnNjYWxlU2VsZigxL3N0ZXApO1xyXG4gICAgICAgIC8vYXNzdW1lIHRoYXQgeCBhbmQgeiBhcmUgbGluZWFyIGluIGludGVydmFsIFtvbGRULGN1clRdXHJcbiAgICAgICAgbGlua3MuZm9yRWFjaCgobGluayxpZCk9PlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHAwID0gbGluay5wKG9sZFZhbHVlcy54LG9sZFZhbHVlcy56LG9sZFZhbHVlcy50KTtcclxuICAgICAgICAgICAgbGV0IHAxID0gbGluay5wKGN1clZhbHVlcy54LGN1clZhbHVlcy56LGN1clZhbHVlcy50KTtcclxuICAgICAgICAgICAgaWYocDA+PTAmJm9sZFZhbHVlcy50PHRpbWUpe1xyXG4gICAgICAgICAgICAgICAgdGltZSA9IG9sZFZhbHVlcy50O1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpZDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfWVsc2UgaWYocDE+PTAmJmN1clZhbHVlcy50PHRpbWUpe1xyXG4gICAgICAgICAgICAgICAgdGltZSA9IGN1clZhbHVlcy50O1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBpZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgX3AwID0gTWF0aC5taW4oTWF0aC5hYnMocDEpLE1hdGguYWJzKHAwKSk7XHJcbiAgICAgICAgICAgIGxldCBwID0gcDA7XHJcbiAgICAgICAgICAgIGxldCB0ID0gb2xkVmFsdWVzLnQ7XHJcbiAgICAgICAgICAgIGxldCB4ID0gb2xkVmFsdWVzLng7XHJcbiAgICAgICAgICAgIGxldCB6ID0gb2xkVmFsdWVzLno7XHJcbiAgICAgICAgICAgIGxldCBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vbmV3dG9uXHJcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5uZXd0b25JdGVyYXRpb25zO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHBkdCA9IHZlY3Rvci5kb3QobGluay5kcGR4KHgseix0KSxkeCkgKyBcclxuICAgICAgICAgICAgICAgIHZlY3Rvci5kb3QobGluay5kcGR6KHgseix0KSxkeikgKyBsaW5rLmRwZHQoeCx6LHQpO1xyXG4gICAgICAgICAgICAgICAgcCA9IE1hdGgubWF4KE1hdGguYWJzKHApLHRoaXMuYWJzVG9sKSpNYXRoLnNpZ24ocCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZHQgPSAtdGhpcy5hbHBoYSpwIC8gZHBkdDtcclxuICAgICAgICAgICAgICAgIC8vZHQgPSBNYXRoLm1heCh0aGlzLnRpbWVBYnNUb2wsTWF0aC5hYnMoZHQpKSpNYXRoLnNpZ24oZHQpO1xyXG4gICAgICAgICAgICAgICAgdCArPSBkdDtcclxuICAgICAgICAgICAgICAgIGlmKHQ8b2xkVmFsdWVzLnR8fHQ+Y3VyVmFsdWVzLnQpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueCxjdXJWYWx1ZXMueCwodC1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgICAgICB6ID0gdmVjdG9yLm1peChvbGRWYWx1ZXMueixjdXJWYWx1ZXMueiwodC1vbGRWYWx1ZXMudCkvc3RlcCk7XHJcbiAgICAgICAgICAgICAgICBwID0gbGluay5wKHgseix0KTtcclxuICAgICAgICAgICAgICAgIGlmKHA+PTAmJk1hdGguYWJzKHApPF9wMCp0aGlzLnJlbFRvbCArIHRoaXMuYWJzVG9sKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0PHRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vYmlzZWN0aW9uXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmKHAxPj0wJiZwMDw9MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQxID0gY3VyVmFsdWVzLnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHQwID0gb2xkVmFsdWVzLnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmJpc2VjdGlvbkl0ZXJhdGlvbnM7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHQgPSAodDEgKyB0MCkvMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSB2ZWN0b3IubWl4KG9sZFZhbHVlcy54LGN1clZhbHVlcy54LCh0LW9sZFZhbHVlcy50KS9zdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHogPSB2ZWN0b3IubWl4KG9sZFZhbHVlcy56LGN1clZhbHVlcy56LCh0LW9sZFZhbHVlcy50KS9zdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSBsaW5rLnAoeCx6LHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwPj0wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHQgPSB0LXQwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocDxfcDAqdGhpcy5yZWxUb2wgKyB0aGlzLmFic1RvbCYmZHQ8dGhpcy50aW1lQWJzVG9sK3N0ZXAqdGhpcy50aW1lUmVsVG9sJiZ0PHRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDAgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHQgPSB0MSAtIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9UT0RPIGFkZCBmYWxzZSBwb3NpdGlvbiBmcm9tIG1hdGxhYiBhcnRpY2xlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYoaW5kZXghPS0xKXtcclxuICAgICAgICAgICAgbGV0IHggPSB2ZWN0b3IubWl4KG9sZFZhbHVlcy54LGN1clZhbHVlcy54LCh0aW1lLW9sZFZhbHVlcy50KS9zdGVwKTtcclxuICAgICAgICAgICAgLy9sZXQgeiA9IHZlY3Rvci5taXgob2xkVmFsdWVzLnosY3VyVmFsdWVzLnosKHRpbWUtb2xkVmFsdWVzLnQpL3N0ZXApO1xyXG4gICAgICAgICAgICBsZXQgeiA9IHN0YXRlLmcoeCx0aW1lKTtcclxuICAgICAgICAgICAgY3VyVmFsdWVzLnggPSBsaW5rc1tpbmRleF0uc2V0Q29uZGl0aW9ucyh4LHosdGltZSk7XHJcbiAgICAgICAgICAgIGN1clZhbHVlcy50ID0gdGltZTtcclxuICAgICAgICAgICAgY3VyVmFsdWVzLnogPSBzdGF0ZS5nKGN1clZhbHVlcy54LGN1clZhbHVlcy50KTtcclxuICAgICAgICAgICAgc3lzdGVtLnNldEN1cnJlbnRTdGF0ZShsaW5rc1tpbmRleF0uZ2V0TmV3U3RhdGUoKSk7XHJcbiAgICAgICAgICAgIC8vY3VyVmFsdWVzLnogPSB6O1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQge3ZlY3Rvcn0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IElEQUVIeWJyaWRTeXN0ZW0gfSBmcm9tIFwiLi9pZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCB7IEVEQUVIeWJyaWRTeXN0ZW0sIEVEQUVIeWJyaWRTdGF0ZSB9IGZyb20gXCIuL2VkYWVIeWJyaWRTeXN0ZW1cIjtcclxuaW1wb3J0IHsgSURBRVNvbHZlciB9IGZyb20gXCIuL0lEQUVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgRURBRVNvbHZlciB9IGZyb20gXCIuL0VEQUVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4vZGFlVmVjdG9yXCI7XHJcblxyXG5cclxuLypleHBvcnQgYWJzdHJhY3QgY2xhc3MgSHlicmlkU3RhdGV7XHJcbiAgICBuYW1lOnN0cmluZztcclxuICAgIGxpbmtzOkh5YnJpZFN0YXRlTGlua1tdO1xyXG4gICAgdGVybWluYWw6Ym9vbGVhbjtcclxuICAgIGFic3RyYWN0IGYoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcjtcclxuICAgIGFic3RyYWN0IGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcjtcclxuICAgIGFic3RyYWN0IGRmZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRmZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeDtcclxufSovXHJcbmV4cG9ydCBjbGFzcyBIeWJyaWRTb2x1dGlvbntcclxuICAgIHZhbHVlczpEQUVWZWN0b3JbXTtcclxuICAgIHN0YXRlczpudW1iZXJbXTtcclxuICAgIHN0YXRlU3dpdGhlczpudW1iZXJbXTtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlczpEQUVWZWN0b3JbXSxzdGF0ZXM6bnVtYmVyW10sc3RhdGVTd2l0Y2hlczpudW1iZXJbXSl7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgSURBRUh5YnJpZFN5c3RlbSB9IGZyb20gXCIuL2lkYWVIeWJyaWRTeXN0ZW1cIjtcclxuaW1wb3J0IHsgSURBRVNvbHZlciB9IGZyb20gXCIuL0lEQUVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgIEh5YnJpZFNvbHV0aW9uIH0gZnJvbSBcIi4vaHlicmlkU29sdXRpb25cIjtcclxuaW1wb3J0IHsgRXZlbnREZXRlY3Rpb24gfSBmcm9tIFwiLi9ldmVudERldGVjdGlvblwiO1xyXG5pbXBvcnQgeyBBZGFwdGl2ZVN0ZXBTdHJhdGVneSB9IGZyb20gXCIuL2FkYXB0aXZlU3RlcFwiO1xyXG5pbXBvcnQgeyBEQUVWZWN0b3IgfSBmcm9tIFwiLi9kYWVWZWN0b3JcIjtcclxuXHJcbmNvbnN0IG1heEZsb2F0cyA9IDIwOTcxNTI7XHJcbi8vVE9ETzogdGVzdCB0aGlzIHNvbHZlclxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBJREFFSHlicmlkU29sdmVyIHtcclxuICAgIGV2ZW50RGV0ZWN0b3I6IEV2ZW50RGV0ZWN0aW9uO1xyXG4gICAgYWRhcHRpdmVTdGVwU3RyYXRlZ3k6IEFkYXB0aXZlU3RlcFN0cmF0ZWd5IHwgbnVsbDtcclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50RGV0ZWN0b3I6IEV2ZW50RGV0ZWN0aW9uLCBhZGFwdGl2ZVN0ZXBTdHJhdGVneTogQWRhcHRpdmVTdGVwU3RyYXRlZ3kgfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERldGVjdG9yID0gZXZlbnREZXRlY3RvcjtcclxuICAgICAgICB0aGlzLmFkYXB0aXZlU3RlcFN0cmF0ZWd5ID0gYWRhcHRpdmVTdGVwU3RyYXRlZ3k7XHJcbiAgICB9XHJcbiAgICBzb2x2ZSh4MDogdmVjdG9yLCB6MDp2ZWN0b3IsIHQwOiBudW1iZXIsIHQxOiBudW1iZXIsIHNvbHZlcjogSURBRVNvbHZlciwgc3lzdGVtOiBJREFFSHlicmlkU3lzdGVtKTogSHlicmlkU29sdXRpb24ge1xyXG4gICAgICAgIGxldCBzb2x1dGlvblZhbHVlczogREFFVmVjdG9yW10gPSBbXTtcclxuICAgICAgICBsZXQgc3RhdGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGxldCBzdGF0ZVN3aXRjaGVzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgICAgIGxldCB0ID0gdDA7XHJcbiAgICAgICAgbGV0IHggPSB4MDtcclxuICAgICAgICBsZXQgeiA9IHNvbHZlci5zb2x2ZV96KHgsIHowLCB0LCBzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlKCkpO1xyXG4gICAgICAgIGxldCBvbGRWYWx1ZXMgPSBuZXcgREFFVmVjdG9yKHgsIHosIHQpO1xyXG4gICAgICAgIHNvbHV0aW9uVmFsdWVzLnB1c2gob2xkVmFsdWVzKTtcclxuICAgICAgICBzdGF0ZXMucHVzaChzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlSW5kZXgoKSk7XHJcbiAgICAgICAgc3RhdGVTd2l0Y2hlcy5wdXNoKHQwKTtcclxuICAgICAgICB3aGlsZSAob2xkVmFsdWVzLnQgPCB0MSkge1xyXG4gICAgICAgICAgICAvL2ZpbmQgc3RlcFxyXG4gICAgICAgICAgICBsZXQgY3VycmVudFN0ZXAgPSBzb2x2ZXIuZ2V0U3RlcCgpO1xyXG4gICAgICAgICAgICBsZXQgaXNTdGVwQ2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZGFwdGl2ZVN0ZXBTdHJhdGVneSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaCA9IHRoaXMuYWRhcHRpdmVTdGVwU3RyYXRlZ3kuZmluZFN0ZXBJREFFKG9sZFZhbHVlcy54LCBvbGRWYWx1ZXMueiwgb2xkVmFsdWVzLnQsIHNvbHZlciwgc3lzdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChoID4gMCAmJiBoIDwgc29sdmVyLmdldFN0ZXAoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5zZXRTdGVwKGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RlcENoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZ2V0IHZhbHVlc1xyXG4gICAgICAgICAgICBsZXQgY3VyVmFsdWVzID0gc29sdmVyLm1ha2VTdGVwKG9sZFZhbHVlcy54LCBvbGRWYWx1ZXMueiwgb2xkVmFsdWVzLnQsIHN5c3RlbS5nZXRDdXJyZW50U3RhdGUoKSk7XHJcbiAgICAgICAgICAgIC8vY2hlY2sgZm9yIHN0YXRlIGNoYW5nZSBpbiB0aGUgaW50ZXJ2YWwgW3QsdCtoXVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERldGVjdG9yLmNoZWNrRXZlbnRJREFFKG9sZFZhbHVlcywgY3VyVmFsdWVzLCBzb2x2ZXIsIHN5c3RlbSkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHN5c3RlbS5nZXRDdXJyZW50U3RhdGVJbmRleCgpKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlU3dpdGNoZXMucHVzaChjdXJWYWx1ZXMudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3lzdGVtLmlzVGVybWluYWwoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9yZXNldCBtdWx0aXN0ZXAgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICBzb2x2ZXIuc2V0U3RlcChjdXJyZW50U3RlcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdGVwQ2hhbmdlZClcclxuICAgICAgICAgICAgICAgIHNvbHZlci5zZXRTdGVwKGN1cnJlbnRTdGVwKTtcclxuICAgICAgICAgICAgb2xkVmFsdWVzID0gY3VyVmFsdWVzO1xyXG4gICAgICAgICAgICBzb2x1dGlvblZhbHVlcy5wdXNoKG9sZFZhbHVlcyk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoKjIrc29sdXRpb25WYWx1ZXMubGVuZ3RoKihzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlKCkubGVuZ3RoX3goKStzeXN0ZW0uZ2V0Q3VycmVudFN0YXRlKCkubGVuZ3RoX3ooKSsxKSA+IG1heEZsb2F0cykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGBTb2x1dGlvbiB3YXMgdGVybWluYXRlZCBwcmVtYXR1cmVseSBkdWUgdG8gbWVtb3J5IGxpbWl0YCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEh5YnJpZFNvbHV0aW9uKHNvbHV0aW9uVmFsdWVzLCBzdGF0ZXMsIHN0YXRlU3dpdGNoZXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgSURBRVN5c3RlbSB9IGZyb20gXCIuL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgSHlicmlkU3RhdGVMaW5rIH0gZnJvbSBcIi4vaHlicmlkU3RhdGVMaW5rXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSURBRUh5YnJpZFN0YXRlIGltcGxlbWVudHMgSURBRVN5c3RlbXtcclxuICAgIHByb3RlY3RlZCBuYW1lOnN0cmluZztcclxuICAgIHByb3RlY3RlZCBsaW5rczpIeWJyaWRTdGF0ZUxpbmtbXTtcclxuICAgIHByb3RlY3RlZCB0ZXJtaW5hbDpib29sZWFuO1xyXG4gICAgY29uc3RydWN0b3IobmFtZTpzdHJpbmcsbGlua3M6SHlicmlkU3RhdGVMaW5rW10sdGVybWluYWw6Ym9vbGVhbil7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xyXG4gICAgfVxyXG4gICAgaXNUZXJtaW5hbCgpOmJvb2xlYW57XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVybWluYWw7XHJcbiAgICB9XHJcbiAgICBnZXRMaW5rcygpOkh5YnJpZFN0YXRlTGlua1tde1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtzO1xyXG4gICAgfVxyXG4gICAgZ2V0TmFtZSgpOnN0cmluZ3tcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgfVxyXG4gICAgYWJzdHJhY3QgZih4OiB2ZWN0b3IsIGR4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogdmVjdG9yO1xyXG4gICAgYWJzdHJhY3QgZyh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogdmVjdG9yO1xyXG4gICAgYWJzdHJhY3QgZGZkeCh4OiB2ZWN0b3IsIGR4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogbWF0cml4O1xyXG4gICAgYWJzdHJhY3QgZGZkZHgoeDogdmVjdG9yLCBkeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRmZHooeDogdmVjdG9yLCBkeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHgoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHooeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHQoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IHZlY3RvcjtcclxuICAgIGFic3RyYWN0IGxlbmd0aF96KCk6IG51bWJlcjtcclxuICAgIGFic3RyYWN0IGxlbmd0aF94KCk6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIElEQUVIeWJyaWRTeXN0ZW17XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGVzOiBJREFFSHlicmlkU3RhdGVbXTtcclxuICAgIC8qcHJvdGVjdGVkIHN0YXRlc01hcDogUmVjb3JkPHN0cmluZywgbnVtYmVyPjsqL1xyXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRTdGF0ZTogbnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RhdGVzOklEQUVIeWJyaWRTdGF0ZVtdKXtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXRDdXJyZW50U3RhdGVJbmRleCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZTtcclxuICAgIH1cclxuICAgIGdldEN1cnJlbnRTdGF0ZSgpOiBJREFFSHlicmlkU3RhdGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLmN1cnJlbnRTdGF0ZV07XHJcbiAgICB9XHJcbiAgICBpc1Rlcm1pbmFsKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1t0aGlzLmN1cnJlbnRTdGF0ZV0uaXNUZXJtaW5hbCgpO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFN0YXRlKHN0YXRlOm51bWJlcil7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBzdGF0ZTtcclxuICAgIH1cclxuICAgIC8qYWJzdHJhY3QgZih4OiB2ZWN0b3IsIGR4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogdmVjdG9yO1xyXG4gICAgYWJzdHJhY3QgZyh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogdmVjdG9yO1xyXG4gICAgYWJzdHJhY3QgZGZkeCh4OiB2ZWN0b3IsIGR4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyKTogbWF0cml4O1xyXG4gICAgYWJzdHJhY3QgZGZkZHgoeDogdmVjdG9yLCBkeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRmZHooeDogdmVjdG9yLCBkeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHgoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHooeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IG1hdHJpeDtcclxuICAgIGFic3RyYWN0IGRnZHQoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlcik6IHZlY3RvcjtcclxuICAgIGFic3RyYWN0IGxlbmd0aF96KCk6IG51bWJlcjtcclxuICAgIGFic3RyYWN0IGxlbmd0aF94KCk6IG51bWJlcjsqL1xyXG59XHJcbiIsImltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vbWF0aC9nYXVzc1wiO1xyXG5pbXBvcnQgeyBJREFFSHlicmlkU3RhdGUgfSBmcm9tIFwiLi9pZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCB7IElEQUVTeXN0ZW0gfSBmcm9tIFwiLi9pZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQge05ld3RvblNvbHZlcn0gZnJvbSBcIi4uL21hdGgvbmV3dG9uXCI7XHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSURBRVNvbHZlciB7XHJcbiAgICBwcm90ZWN0ZWQgc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcjtcclxuICAgIHByb3RlY3RlZCBzdGVwOiBudW1iZXI7XHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3Ioc3RlcDogbnVtYmVyLCBuZXd0b25Tb2x2ZXI6TmV3dG9uU29sdmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcclxuICAgICAgICB0aGlzLnN5c3RlbVNvbHZlciA9IG5ld3RvblNvbHZlcjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXRTdGVwKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLnN0ZXAgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXRTdGVwKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzb2x2ZV96KHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IHZlY3RvciB7XHJcbiAgICAgICAgaWYgKHN5c3RlbS5sZW5ndGhfeigpID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiB6O1xyXG4gICAgICAgIC8vc29sdmUgZyh4X3tuKzF9LHpfe24rMX0sdF97bisxfSkgPSAwIGZvciB6X3tuKzF9IFxyXG4gICAgICAgIHJldHVybiB0aGlzLnN5c3RlbVNvbHZlci5zb2x2ZSgoek5ldzp2ZWN0b3IpPT57XHJcbiAgICAgICAgICAgIHJldHVybiBzeXN0ZW0uZyh4LHpOZXcsdCk7XHJcbiAgICAgICAgfSwoek5ldzp2ZWN0b3IpPT57XHJcbiAgICAgICAgICAgIHJldHVybiBzeXN0ZW0uZGdkeih4LCB6TmV3LCB0KTtcclxuICAgICAgICB9LHN5c3RlbS5sZW5ndGhfeigpLHouY2xvbmUoKSk7XHJcbiAgICAgICAgLypsZXQgek5ldyA9IHouY2xvbmUoKTtcclxuICAgICAgICBsZXQgRjogdmVjdG9yID0gc3lzdGVtLmcoeCwgek5ldywgdCk7XHJcbiAgICAgICAgbGV0IGYwbm9ybTogbnVtYmVyID0gRi5ub3JtMigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0SXRlcmF0aW9ucygpOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IEo6IG1hdHJpeDtcclxuICAgICAgICAgICAgSiA9IHN5c3RlbS5kZ2R6KHgsIHpOZXcsIHQpO1xyXG4gICAgICAgICAgICBsZXQgZm5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgICAgIGxldCBkeiA9IGdhdXNzLnNvbHZlKEosIEYuc2NhbGVTZWxmKC10aGlzLnN5c3RlbVNvbHZlci5nZXRBbHBoYSgpKSk7XHJcbiAgICAgICAgICAgIHpOZXcuYWRkU2VsZihkeik7XHJcbiAgICAgICAgICAgIEYgPSBzeXN0ZW0uZyh4LCB6TmV3LCB0KTtcclxuICAgICAgICAgICAgaWYgKGZub3JtIDwgdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0QWJzVG9sKCkgKyB0aGlzLnN5c3RlbVNvbHZlci5nZXRSZWxUb2woKSAqIGYwbm9ybSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHpOZXc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgXCJkaXZlcmdlbmNlIGF0IHNvbHZlX3pcIjsqL1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNvbHZlX2R4KHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IHZlY3RvciB7XHJcbiAgICAgICAgaWYgKHN5c3RlbS5sZW5ndGhfeCgpID09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAvL3NvbHZlIGYoeCxkeCx6LHQpID0gMFxyXG4gICAgICAgIHJldHVybiB0aGlzLnN5c3RlbVNvbHZlci5zb2x2ZSgoZHg6dmVjdG9yKT0+e1xyXG4gICAgICAgICAgICByZXR1cm4gc3lzdGVtLmYoeCwgZHgsIHosIHQpO1xyXG4gICAgICAgIH0sKGR4OnZlY3Rvcik9PntcclxuICAgICAgICAgICAgcmV0dXJuIHN5c3RlbS5kZmRkeCh4LCBkeCwgeiwgdCk7XHJcbiAgICAgICAgfSxzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICBsZXQgZHggPSB2ZWN0b3IuZW1wdHkoc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgIGxldCBGOiB2ZWN0b3IgPSBzeXN0ZW0uZih4LCBkeCwgeiwgdCk7XHJcbiAgICAgICAgbGV0IGYwbm9ybTogbnVtYmVyID0gRi5ub3JtMigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0SXRlcmF0aW9ucygpOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IEo6IG1hdHJpeDtcclxuICAgICAgICAgICAgSiA9IHN5c3RlbS5kZmRkeCh4LCBkeCwgeiwgdCk7XHJcbiAgICAgICAgICAgIGxldCBmbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICAgICAgbGV0IF9keCA9IGdhdXNzLnNvbHZlKEosIEYuc2NhbGVTZWxmKC10aGlzLnN5c3RlbVNvbHZlci5nZXRBbHBoYSgpKSk7XHJcbiAgICAgICAgICAgIGR4LmFkZFNlbGYoX2R4KTtcclxuICAgICAgICAgICAgRiA9IHN5c3RlbS5mKHgsIGR4LCB6LCB0KTtcclxuICAgICAgICAgICAgaWYgKGZub3JtIDwgdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0QWJzVG9sKCkgKyB0aGlzLnN5c3RlbVNvbHZlci5nZXRSZWxUb2woKSAqIGYwbm9ybSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IFwiZGl2ZXJnZW5jZSBhdCBzb2x2ZV9keFwiOyovXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc29sdmVfZHpkdChkeDogdmVjdG9yLCB4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzdGF0ZTogSURBRUh5YnJpZFN0YXRlKTogdmVjdG9yIHtcclxuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoX3ooKSA9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gejtcclxuICAgICAgICBsZXQgQTogbWF0cml4ID0gc3RhdGUuZGdkeih4LCB6LCB0KTtcclxuICAgICAgICBsZXQgYjogdmVjdG9yO1xyXG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGhfeCgpICE9IDApXHJcbiAgICAgICAgICAgIGIgPSBzdGF0ZS5kZ2R4KHgsIHosIHQpLm11bHRWZWMoZHgpLmFkZFNlbGYoc3RhdGUuZGdkdCh4LCB6LCB0KSkuc2NhbGVTZWxmKC0xKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGIgPSBzdGF0ZS5kZ2R0KHgsIHosIHQpLnNjYWxlU2VsZigtMSk7XHJcbiAgICAgICAgLy9zb2x2ZSBsaW5lYXIgc3lzdGVtXHJcbiAgICAgICAgLy9kZy9keiBkei9kdCA9IC1kZy9keCB4JyAtIGRnL2R0XHJcbiAgICAgICAgbGV0IGR6ZHQgPSBnYXVzcy5zb2x2ZShBLCBiKTtcclxuICAgICAgICByZXR1cm4gZHpkdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IElEQUVTeXN0ZW0pOiBEQUVWZWN0b3I7XHJcbn1cclxuIiwiaW1wb3J0IHtFREFFU29sdmVyfSBmcm9tIFwiLi4vLi4vZWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgbWF0cml4IH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IEVEQUVTeXN0ZW0gfSBmcm9tIFwiLi4vLi4vZWRhZVN5c3RlbVwiO1xyXG5pbXBvcnQgeyBEQUVWZWN0b3IgfSBmcm9tIFwiLi4vLi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7RURBRV9SSzQsRURBRV9SSzZ9IGZyb20gXCIuLi9lZGFlL3JrXCI7XHJcblxyXG5jbGFzcyBFREFFX0FEQU1TX0JBU0hGT1JUSCBleHRlbmRzIEVEQUVTb2x2ZXJ7XHJcbiAgICBzdGFnZXM6bnVtYmVyO1xyXG4gICAgcHJldlZhbHVlczp2ZWN0b3JbXTtcclxuICAgIGI6bnVtYmVyW107XHJcbiAgICBzb2x2ZXI6IEVEQUVTb2x2ZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixiOm51bWJlcltdLHNvbHZlcjpFREFFU29sdmVyLHN0YWdlczpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXApO1xyXG4gICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgdGhpcy5zb2x2ZXIgPSBzb2x2ZXI7XHJcbiAgICAgICAgdGhpcy5zdGFnZXMgPSBzdGFnZXM7XHJcbiAgICAgICAgdGhpcy5wcmV2VmFsdWVzID0gW107XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0U3RlcCh2YWx1ZTpudW1iZXIpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIuc2V0U3RlcCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5wcmV2VmFsdWVzID0gW107XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlciwgc3lzdGVtOiBFREFFU3lzdGVtKTogREFFVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnByZXZWYWx1ZXMuc3BsaWNlKDAsMCwgc3lzdGVtLmYoeCx6LHQpKTtcclxuICAgICAgICBpZih0aGlzLnByZXZWYWx1ZXMubGVuZ3RoICE9IHRoaXMuc3RhZ2VzKXtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDpEQUVWZWN0b3IgPSB0aGlzLnNvbHZlci5tYWtlU3RlcCh4LCB6LCB0LHN5c3RlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuc3RhZ2VzO2krKyl7XHJcbiAgICAgICAgICAgIHhOZXcuYWRkU2VsZih2ZWN0b3Iuc2NhbGUodGhpcy5wcmV2VmFsdWVzW2ldLHRoaXMuc3RlcCp0aGlzLmJbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHpOZXcgPSBzeXN0ZW0uZyh4TmV3LHROZXcpO1xyXG4gICAgICAgIHRoaXMucHJldlZhbHVlcy5zcGxpY2UodGhpcy5wcmV2VmFsdWVzLmxlbmd0aC0xLDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBFREFFX0FCMiBleHRlbmRzIEVEQUVfQURBTVNfQkFTSEZPUlRIXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsWzMvMiwtMS8yXSwgbmV3IEVEQUVfUks0KHN0ZXApLDIpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX0FCMyBleHRlbmRzIEVEQUVfQURBTVNfQkFTSEZPUlRIXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsWzIzLzEyLC00LzMsNS8xMl0sIG5ldyBFREFFX1JLNChzdGVwKSwzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9BQjQgZXh0ZW5kcyBFREFFX0FEQU1TX0JBU0hGT1JUSFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcilcclxuICAgIHtcclxuICAgICAgICBzdXBlcihzdGVwLFs1NS8yNCwtNTkvMjQsMzcvMjQsLTMvOF0sIG5ldyBFREFFX1JLNChzdGVwKSw0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9BQjUgZXh0ZW5kcyBFREFFX0FEQU1TX0JBU0hGT1JUSFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcilcclxuICAgIHtcclxuICAgICAgICBzdXBlcihzdGVwLFsxOTAxLzcyMCwtMTM4Ny8zNjAsMTA5LzMwLC02MzcvMzYwLDI1MS83MjBdLCBuZXcgRURBRV9SSzYoc3RlcCksNSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEVEQUVfQUI2IGV4dGVuZHMgRURBRV9BREFNU19CQVNIRk9SVEhcclxue1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxbNDI3Ny8xNDQwLC0yNjQxLzQ4MCw0OTkxLzcyMCwtMzY0OS83MjAsOTU5LzQ4MCwtOTUvMjg4XSwgbmV3IEVEQUVfUks2KHN0ZXApLDYpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtcclxuICAgIERBRVZlY3RvclxyXG59IGZyb20gXCIuLi8uLi9kYWVWZWN0b3JcIjtcclxuaW1wb3J0IHsgRURBRVNvbHZlciB9IGZyb20gXCIuLi8uLi9lZGFlU29sdmVyXCI7XHJcbmltcG9ydCB7IEVEQUVTeXN0ZW0gfSBmcm9tIFwiLi4vLi4vZWRhZVN5c3RlbVwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgbWF0cml4IH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IGdhdXNzIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvZ2F1c3NcIjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIHNvbHZlciBmb3IgeiA9IGcodClcclxuICovXHJcblxyXG5leHBvcnQgY2xhc3MgRURBRV9BbGdlYnJhaWNTb2x2ZXIgZXh0ZW5kcyBFREFFU29sdmVye1xyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpFREFFU3lzdGVtKTpEQUVWZWN0b3J7XHJcbiAgICAgICAgbGV0IHhOZXcgPSB4O1xyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgek5ldyA9IHN5c3RlbS5nKHhOZXcsdE5ldyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG4iLCJpbXBvcnQge1xyXG4gICAgREFFVmVjdG9yXHJcbn0gZnJvbSBcIi4uLy4uL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQgeyBFREFFU29sdmVyIH0gZnJvbSBcIi4uLy4uL2VkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgRURBRVN5c3RlbSB9IGZyb20gXCIuLi8uLi9lZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9nYXVzc1wiO1xyXG5pbXBvcnQgeyBOZXd0b25Tb2x2ZXIgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9uZXd0b25cIjtcclxuXHJcbi8qKlxyXG4gKiBmb3J3YXJkIGV1bGVyIGZvciBleHBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFREFFX0VFdWxlciBleHRlbmRzIEVEQUVTb2x2ZXJ7XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOkVEQUVTeXN0ZW0pOkRBRVZlY3RvcntcclxuICAgICAgICBsZXQgeE5ldyA9IHN5c3RlbS5mKHgseix0KS5zY2FsZVNlbGYodGhpcy5zdGVwKS5hZGRTZWxmKHgpO1xyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgek5ldyA9IHN5c3RlbS5nKHhOZXcsdE5ldyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGJhY2t3YXJkIGV1bGVyIG1ldGhvZCBmb3IgZXhwbGljaXQgZGFlIHdpdGggaW5kZXggb25lXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRURBRV9JRXVsZXIgZXh0ZW5kcyBFREFFU29sdmVye1xyXG4gICAgcHJvdGVjdGVkIHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXApO1xyXG4gICAgICAgIHRoaXMuc3RlcFNvbHZlciA9IHN0ZXBTb2x2ZXI7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgRiA9IHhfe24rMX0gLSB4X24gLSBoZih4X3tuKzF9LGcoeF97bisxfSx0X3tuKzF9KSx0X3tuKzF9KSA9IDBcclxuICAgIGRGaS9keF97bisxfWogPSBcXGRlbHRhX2lqIC0gaCpkZi9keCAtIGgqZGYvZHoqZGcvZHhcclxuICAgICovXHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOkVEQUVTeXN0ZW0pOkRBRVZlY3RvcntcclxuICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHpOZXcgPSBzeXN0ZW0uZyh4TmV3LHROZXcpO1xyXG4gICAgICAgIGxldCBGOnZlY3RvciA9IHN5c3RlbS5mKHhOZXcsek5ldyx0TmV3KS5zY2FsZVNlbGYoLXRoaXMuc3RlcCkuYWRkU2VsZih4TmV3KS5zdWJTZWxmKHgpO1xyXG4gICAgICAgIGxldCBmMG5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN0ZXBTb2x2ZXIuZ2V0SXRlcmF0aW9ucygpO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBKOm1hdHJpeCA9IG1hdHJpeC5pZGVudGl0eShzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBKLnN1YlNlbGYoc3lzdGVtLmRmZHgoeE5ldyx6TmV3LHROZXcpLmFkZFNlbGYobWF0cml4Lm11bHQoc3lzdGVtLmRmZHooeE5ldyx6TmV3LHROZXcpLHN5c3RlbS5kZ2R4KHhOZXcsdE5ldykpKS5zY2FsZVNlbGYodGhpcy5zdGVwKSk7XHJcbiAgICAgICAgICAgIGxldCBkeCA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuc3RlcFNvbHZlci5nZXRBbHBoYSgpKSk7XHJcbiAgICAgICAgICAgIHhOZXcuYWRkU2VsZihkeCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB6TmV3ID0gc3lzdGVtLmcoeE5ldyx0TmV3KTtcclxuICAgICAgICAgICAgRiA9IHN5c3RlbS5mKHhOZXcsek5ldyx0TmV3KS5zY2FsZVNlbGYoLXRoaXMuc3RlcCkuYWRkU2VsZih4TmV3KS5zdWJTZWxmKHgpO1xyXG4gICAgICAgICAgICBsZXQgZm5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgICAgIGlmKGk+PXRoaXMuc3RlcFNvbHZlci5nZXRNaW5JdGVyYXRpb25zKCkmJmZub3JtPHRoaXMuc3RlcFNvbHZlci5nZXRBYnNUb2woKSt0aGlzLnN0ZXBTb2x2ZXIuZ2V0UmVsVG9sKCkqZjBub3JtKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsIHpOZXcsIHROZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmVyZ2VuY2Ugb2YgbmV3dG9uIG1ldGhvZFwiKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBGeCA9IHhfe24rMX0gLSB4X24gLSBoZih4X3tuKzF9LHpfe24rMX0sdF97bisxfSkgPSAwXHJcbiAgICBGeiA9IHpfe24rMX0gLSBnKHhfe24rMX0sdF97bisxfSkgPSAwXHJcbiAgICBkRngvZHggPSBcXGRlbHRhIC0gaCBkZi9keFxyXG4gICAgZEZ4L2R6ID0gLSBoIGRmZHpcclxuICAgIGRGei9keCA9IC0gZGcvZHhcclxuICAgIGRGei9keiA9IFxcZGVsdGFcclxuICAgIEogPSBcclxuICAgICAtIC0gLSAtIC0gLSAtIC0gLVxyXG4gICAgfCBkRngvZHggfCBkRngvZHogfFxyXG4gICAgfCBkRnovZHggfCBkRnovZHogfFxyXG4gICAgIC0gLSAtIC0gLSAtIC0gLSAtIFxyXG4gICAgKi9cclxuICAgLyogT0xEXHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOkVEQUVTeXN0ZW0pOkRBRVZlY3RvcntcclxuICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKTtcclxuICAgICAgICBsZXQgek5ldyA9IHouY2xvbmUoKTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IHN5c3RlbS5sZW5ndGhfeCgpICsgc3lzdGVtLmxlbmd0aF96KCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLm5ld3Rvbkl0ZXJhdGlvbnM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IEo6bWF0cml4ID0gbWF0cml4LmlkZW50aXR5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGxldCBGOnZlY3RvciA9IHZlY3Rvci5lbXB0eShsZW5ndGgpO1xyXG4gICAgICAgICAgICBsZXQgZGZkeCA9IHN5c3RlbS5kZmR4KHhOZXcsek5ldywgdE5ldyk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KGRmZHguc2NhbGVTZWxmKC10aGlzLnN0ZXApLDAsMCk7XHJcbiAgICAgICAgICAgIGxldCBkZmR6ID0gc3lzdGVtLmRmZHooeE5ldyx6TmV3LCB0TmV3KTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoZGZkei5zY2FsZSgtdGhpcy5zdGVwLGRmZHopLDAseC5sZW5ndGgoKSk7Ly/RgdGC0YDQvtC60LAg0YHRgtC+0LvQsdC10YZcclxuICAgICAgICAgICAgbGV0IGRnZHggPSBzeXN0ZW0uZGdkeCh4TmV3LCB0TmV3KTtcclxuICAgICAgICAgICAgSi5zdWJTdWJNYXRyaXgoZGdkeCx4Lmxlbmd0aCgpLDApOy8v0YHRgtGA0L7QutCwINGB0YLQvtC70LHQtdGGXHJcbiAgICAgICAgICAgIGxldCBmID0gc3lzdGVtLmYoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICAgICAgICAgIGYuc2NhbGVTZWxmKC10aGlzLnN0ZXApO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihmLmFkZFNlbGYoeE5ldykuc3ViU2VsZih4KSwwKTtcclxuICAgICAgICAgICAgbGV0IGcgPSBzeXN0ZW0uZyh4TmV3LCB0TmV3KTtcclxuICAgICAgICAgICAgRi5zdWJTdWJWZWN0b3Ioek5ldy5zdWIoZyxnKSwgeC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIGxldCBmbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICAgICAgbGV0IGR4eiA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuYWxwaGEpKTtcclxuICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGR4ei5nZXRTdWJWZWN0b3IoMCx4Lmxlbmd0aCgpKSk7XHJcbiAgICAgICAgICAgIHpOZXcuYWRkU2VsZihkeHouZ2V0U3ViVmVjdG9yKHgubGVuZ3RoKCksei5sZW5ndGgoKSkpO1xyXG4gICAgICAgICAgICBpZihmbm9ybTx0aGlzLmZBYnNUb2wpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2ZXJnZW5jZSBvZiBuZXd0b24gbWV0aG9kXCIpO1xyXG4gICAgfSovXHJcbn0iLCJpbXBvcnQge1xyXG4gICAgREFFVmVjdG9yXHJcbn0gZnJvbSBcIi4uLy4uL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQgeyBFREFFU29sdmVyIH0gZnJvbSBcIi4uLy4uL2VkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgRURBRVN5c3RlbSB9IGZyb20gXCIuLi8uLi9lZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9nYXVzc1wiO1xyXG5pbXBvcnQgeyBOZXd0b25Tb2x2ZXIgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9uZXd0b25cIjtcclxuLypcclxuZXhwbGljaXRcclxuICAgIHhfe24rMX0gPSB4X24gKyBoIGYoeF9uKzAuNWgqZih4X24sdF9uKSx0X24gKyAwLjUqaClcclxuICAgIHtcclxuICAgICAgICAxLiAga18xID0gZih4X24sel9uLHRfbilcclxuICAgICAgICBleHBsaWNpdCBOeFxyXG4gICAgICAgIDIuICB4X3tuKzF9ID0geF9uICsgaCpmKHhfbiArIDAuNSpoICoga18xLGcoeF9uICsgMC41ICpoKiBrXzEsdF9uICsgMC41KmgpLHRfbiArIDAuNSpoKVxyXG4gICAgICAgIGV4cGxpY2l0IE54XHJcbiAgICAgICAgMy4gIHpfe24rMX0gPSBnKHhfe24rMX0sdF97bisxfSlcclxuICAgICAgICBleHBsaWNpdCBOelxyXG4gICAgfVxyXG5pbXBsaWNpdFxyXG4gICAgeF97bisxfT14X24gKyBoIGYoMC41Kih4X24reF97bisxfSksdF9uKzAuNSpoKVxyXG4gICAgeyBcclxuICAgICAgICAxLiAgeF97bisxfSAtIHhfbiAtIGgqZigwLjUqKHhfbit4X3tuKzF9KSwwLjUqKHpfbit6X3tuKzF9KSx0X24rMC41KmgpID0gMFxyXG4gICAgICAgICAgICB6X3tuKzF9IC0gZyh4X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54ICsgTnpcclxuXHJcbiAgICAgICAgT1JcclxuXHJcbiAgICAgICAgMS4geF97bisxfSAtIHhfbiAtIGggKiBmKDAuNSooeF9uK3hfe24rMX0pLDAuNSooel9uICsgZyh4X3tuKzFdLHRfe24rMX0pKSx0X24gKyAwLjUqaik9MFxyXG4gICAgICAgIGltcGxpY2l0IE54XHJcbiAgICAgICAgMi4gel97bisxfSA9IGcoeF97bisxfSx0X3tuKzF9KVxyXG4gICAgICAgIGV4cGxpY2l0IE56XHJcbiAgICB9XHJcbiovXHJcblxyXG4vKipcclxuICogZXhwbGljaXQgbWlkcG9pbnQgbWV0aG9kIGZvciBleHBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFREFFX0VNaWRwb2ludCBleHRlbmRzIEVEQUVTb2x2ZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlciwgc3lzdGVtOiBFREFFU3lzdGVtKTogREFFVmVjdG9yIHtcclxuICAgICAgICBsZXQgayA9IHN5c3RlbS5mKHgseix0KS5zY2FsZVNlbGYodGhpcy5zdGVwKjAuNSkuYWRkU2VsZih4KTtcclxuICAgICAgICBsZXQga3ogPSBzeXN0ZW0uZyhrLHQrMC41KnRoaXMuc3RlcCk7XHJcbiAgICAgICAgbGV0IHhOZXcgPSBzeXN0ZW0uZihrLGt6LHQrMC41KnRoaXMuc3RlcCkuc2NhbGVTZWxmKHRoaXMuc3RlcCkuYWRkU2VsZih4KTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHpOZXcgPSBzeXN0ZW0uZyh4TmV3LHROZXcpO1xyXG4gICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogaW1wbGljaXQgbWlkcG9pbnQgbWV0aG9kIGZvciBleHBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFREFFX0lNaWRwb2ludCBleHRlbmRzIEVEQUVTb2x2ZXJ7XHJcbiAgICBwcm90ZWN0ZWQgc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzdGVwU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgICAgIHN1cGVyKHN0ZXApO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBTb2x2ZXIgPSBzdGVwU29sdmVyO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAgICB4X3tuKzF9IC0geF9uIC0gaCAqIGYoMC41Kih4X24reF97bisxfSksMC41Kih6X24gKyBnKHhfe24rMV0sdF97bisxfSkpLHRfbiArIDAuNSpqKT0wXHJcbiAgICAgICAgZEZfaS9keF97bisxfV9qID0gXFxkZWx0YV9paiAtIDAuNSpoICogZGYvZHggLSAwLjUqaCpkZi9keiAqIGRnL2R4KHhfe24rMV0sdF97bisxfSlcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogRURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCkuYWRkU2VsZih2ZWN0b3Iuc2NhbGUoc3lzdGVtLmYoeCx6LHQpLHRoaXMuc3RlcCkpOy8vYmV0dGVyIGFwcHJveGltYXRpb24gZm9yIHhOZXdcclxuICAgICAgICBsZXQgdE5ldyA9IHQrdGhpcy5zdGVwO1xyXG4gICAgICAgIGxldCB4SGFsZiA9IHZlY3Rvci5hZGQoeCx4TmV3KS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICBsZXQgekhhbGYgPSBzeXN0ZW0uZyh4TmV3LHROZXcpLmFkZFNlbGYoeikuc2NhbGVTZWxmKDAuNSk7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yID0gc3lzdGVtLmYoeEhhbGYsekhhbGYsdCswLjUqdGhpcy5zdGVwKS5zY2FsZSgtdGhpcy5zdGVwKS5hZGRTZWxmKHhOZXcpLnN1YlNlbGYoeCk7XHJcbiAgICAgICAgbGV0IGYwbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuc3RlcFNvbHZlci5nZXRJdGVyYXRpb25zKCk7aSsrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IEo6bWF0cml4ID0gbWF0cml4LmlkZW50aXR5KHN5c3RlbS5sZW5ndGhfeCgpKTtcclxuICAgICAgICAgICAgSi5zdWJTZWxmKHN5c3RlbS5kZmR4KHhIYWxmLHpIYWxmLHQrMC41KnRoaXMuc3RlcCkuYWRkU2VsZihtYXRyaXgubXVsdChzeXN0ZW0uZGZkeih4SGFsZix6SGFsZix0KzAuNSp0aGlzLnN0ZXApLHN5c3RlbS5kZ2R4KHhOZXcsdE5ldykpKS5zY2FsZVNlbGYoMC41KnRoaXMuc3RlcCkpO1xyXG4gICAgICAgICAgICBsZXQgZHggPSBnYXVzcy5zb2x2ZShKLEYuc2NhbGUoLXRoaXMuc3RlcFNvbHZlci5nZXRBbHBoYSgpKSk7XHJcbiAgICAgICAgICAgIHhOZXcuYWRkU2VsZihkeCk7XHJcblxyXG4gICAgICAgICAgICB4SGFsZiA9IHZlY3Rvci5hZGQoeCx4TmV3KS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICAgICAgekhhbGYgPSBzeXN0ZW0uZyh4TmV3LHROZXcpLmFkZFNlbGYoeikuc2NhbGVTZWxmKDAuNSk7XHJcblxyXG4gICAgICAgICAgICBGID0gc3lzdGVtLmYoeEhhbGYsekhhbGYsdCswLjUqdGhpcy5zdGVwKS5zY2FsZSgtdGhpcy5zdGVwKS5hZGRTZWxmKHhOZXcpLnN1YlNlbGYoeCk7XHJcbiAgICAgICAgICAgIGxldCBmbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICAgICAgaWYoaT49dGhpcy5zdGVwU29sdmVyLmdldE1pbkl0ZXJhdGlvbnMoKSYmZm5vcm08PXRoaXMuc3RlcFNvbHZlci5nZXRBYnNUb2woKSt0aGlzLnN0ZXBTb2x2ZXIuZ2V0UmVsVG9sKCkqZjBub3JtKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsc3lzdGVtLmcoeE5ldyx0TmV3KSx0TmV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQge1xyXG4gICAgREFFVmVjdG9yXHJcbn0gZnJvbSBcIi4uLy4uL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQgeyBFREFFU29sdmVyIH0gZnJvbSBcIi4uLy4uL2VkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgRURBRVN5c3RlbSB9IGZyb20gXCIuLi8uLi9lZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9nYXVzc1wiO1xyXG5pbXBvcnQgeyBOZXd0b25Tb2x2ZXIgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9uZXd0b25cIjtcclxuXHJcblxyXG4vKipcclxuICogZXhwbGljaXQgcmsgbWV0aG9kcyBmb3IgZXhwbGljaXQgZGFlIG9mIGluZGV4IDFcclxuICovXHJcbmFic3RyYWN0IGNsYXNzIEVEQUVfRVJLIGV4dGVuZHMgRURBRVNvbHZlclxyXG57XHJcbiAgICBwcm90ZWN0ZWQgYTpudW1iZXJbXVtdO1xyXG4gICAgcHJvdGVjdGVkIGI6bnVtYmVyW107XHJcbiAgICBwcm90ZWN0ZWQgYzpudW1iZXJbXTtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10pe1xyXG4gICAgICAgIHN1cGVyKHN0ZXApO1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLmMgPSBjO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogRURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgbGV0IGs6dmVjdG9yW10gPSBbXTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuYy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IF94ID0geC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGo9MDtqPGk7aisrKXtcclxuICAgICAgICAgICAgICAgIF94LmFkZCh2ZWN0b3Iuc2NhbGUoa1tqXSx0aGlzLnN0ZXAqdGhpcy5hW2ktMV1bal0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgX3QgPSB0ICsgdGhpcy5jW2ldICogdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBrLnB1c2goc3lzdGVtLmYoX3gsc3lzdGVtLmcoX3gsX3QpLF90KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB4TmV3ID0geC5jbG9uZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5iLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB4TmV3LmFkZChrW2ldLnNjYWxlU2VsZih0aGlzLnN0ZXAqdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHN5c3RlbS5nKHhOZXcsdE5ldyksdE5ldyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGV4cGxpY2l0IHJrIG1ldGhvZHMgd2l0aCBhZGFwdGl2ZSBzdGVwIGZvciBleHBsaWNpdCBkYWUgb2YgaW5kZXggMVxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgRURBRV9FUktBIGV4dGVuZHMgRURBRV9FUkt7XHJcbiAgICBwcm90ZWN0ZWQgX2I6bnVtYmVyW107XHJcbiAgICBwcm90ZWN0ZWQgZXJyb3JPcmRlcjpudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgZXJyb3JUb2xlcmFuY2U6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIG1heFN0ZXA6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIG1pblN0ZXA6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JPcmRlcjpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10sX2I6bnVtYmVyW10pe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsYSxiLGMpO1xyXG4gICAgICAgIHRoaXMuX2IgPSBfYjtcclxuICAgICAgICB0aGlzLmVycm9yT3JkZXIgPSBlcnJvck9yZGVyO1xyXG4gICAgICAgIHRoaXMuZXJyb3JUb2xlcmFuY2UgPSBlcnJvclRvbGVyYW5jZTtcclxuICAgICAgICB0aGlzLm1pblN0ZXAgPSBzdGVwO1xyXG4gICAgICAgIHRoaXMubWF4U3RlcCA9IG1heFN0ZXA7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlciwgc3lzdGVtOiBFREFFU3lzdGVtKTogREFFVmVjdG9yIHtcclxuICAgICAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgICAgICAgbGV0IGs6dmVjdG9yW10gPSBbXTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGo9MDtqPGk7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICBfeC5hZGQodmVjdG9yLnNjYWxlKGtbal0sdGhpcy5zdGVwKnRoaXMuYVtpLTFdW2pdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgX3QgPSB0ICsgdGhpcy5jW2ldICogdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgay5wdXNoKHN5c3RlbS5mKF94LHN5c3RlbS5nKF94LF90KSxfdCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuX2IubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlLmFkZFNlbGYodmVjdG9yLnNjYWxlKGtbaV0sdGhpcy5fYltpXS10aGlzLmJbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZGlmTm9ybSA9IGRpZmZlcmVuY2Uubm9ybTIoKTtcclxuICAgICAgICAgICAgdmFyIHN0ZXBPcHQ9TWF0aC5wb3codGhpcy5lcnJvclRvbGVyYW5jZSowLjUvZGlmTm9ybSwxL3RoaXMuZXJyb3JPcmRlcikqdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBpZihpc05hTihzdGVwT3B0KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3RlcE9wdD10aGlzLm1pblN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RlcE9wdD1NYXRoLm1pbihNYXRoLm1heCh0aGlzLm1pblN0ZXAsc3RlcE9wdCksdGhpcy5tYXhTdGVwKTtcclxuICAgICAgICAgICAgaWYoc3RlcE9wdCoyPHRoaXMuc3RlcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwPXN0ZXBPcHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwT3B0O1xyXG4gICAgICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuYi5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIHhOZXcuYWRkKHZlY3Rvci5zY2FsZShrW2ldLHRoaXMuc3RlcCp0aGlzLmJbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHN5c3RlbS5nKHhOZXcsdE5ldyksdE5ldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBpbXBsaWNpdCByayBtZXRob2RzIGZvciBleHBsaWNpdCBkYWUgb2YgaW5kZXggMVxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgRURBRV9JUksgZXh0ZW5kcyBFREFFU29sdmVye1xyXG4gICAgcHJvdGVjdGVkIGE6bnVtYmVyW11bXTtcclxuICAgIHByb3RlY3RlZCBiOm51bWJlcltdO1xyXG4gICAgcHJvdGVjdGVkIGM6bnVtYmVyW107XHJcbiAgICBwcm90ZWN0ZWQgc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhZ2VzOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyLFxyXG4gICAgICAgIGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10sc3RhZ2VzOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCk7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICAgICAgdGhpcy5zdGVwU29sdmVyID0gc3RlcFNvbHZlcjtcclxuICAgICAgICB0aGlzLnN0YWdlcyA9IHN0YWdlcztcclxuICAgIH1cclxuICAgIC8qICBVU0UgTEFURVgsIExVS0VcclxuICAgICAgICBrX2kgPSBmKHhfbiArIGggKiBzdW1fe2o9MX1ee1N9IGtfaiAqIGFfaWosIGcoeF9uICsgaCAqIHN1bV97aj0xfV57U30ga19qICogYV9paiwgdF9uICsgaCAqIGNfaSksIHRfbiArIGggKiBjX2kpXHJcblxyXG4gICAgICAgIEZfaSA9IGtfaSAtIGYoeF9uICsgaCAqIHN1bSBrX2ogKiBhaWosIGcoeF9uICsgaCAqIHN1bV97aj0xfV57U30ga19qICogYV9paiwgdF9uICsgaCAqIGNfaSksIHRfbiArIGggKiBjX2kpID0gMFxyXG5cclxuICAgICAgICBkRl9pbC9ka19qbSA9IFxcZGVsdGFfaWxfam0gLSBkZl9sL2R4X20gKiBoICogYV9paiAtIGRmX2wvZHogZGdfbC9keF9tICogaCAqIGFfaWpcclxuXHJcbiAgICAgICAgbWVtb3J5IGxheW91dDpcclxuICAgICAgICAgICAgICAgICAgai0+XHJcbiAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbiAgICAgICAgfCBkRjAvZGswIHwgZEYwL2RrMSB8XHJcbiAgICBpICAgfC0tLS0tLS0tLXwtLS0tLS0tLS18XHJcbiAgICB8ICAgfCBkRjEvZGswIHwgZEYxL2RrMSB8XHJcbiAgICB2ICAgfC0tLS0tLS0tLS0tLS0tLS0tLS18XHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBmdW5jdGlvbihrOnZlY3RvcltdLHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpFREFFU3lzdGVtKTp2ZWN0b3J7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeCgpKnRoaXMuc3RhZ2VzKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSp0aGlzLnN0ZXA7XHJcbiAgICAgICAgICAgIGxldCBfeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspXHJcbiAgICAgICAgICAgICAgICBfeC5hZGRTZWxmKHZlY3Rvci5zY2FsZShrW2pdLHRoaXMuYVtpXVtqXSp0aGlzLnN0ZXApKTtcclxuICAgICAgICAgICAgbGV0IF96ID0gc3lzdGVtLmcoX3gsX3QpO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihrW2ldLGkqc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBGLnN1YlN1YlZlY3RvcihzeXN0ZW0uZihfeCxfeixfdCksaSpzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGphY29iaU1hdHJpeChrOnZlY3RvcltdLHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpFREFFU3lzdGVtKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IEo6bWF0cml4PW1hdHJpeC5pZGVudGl0eSh0aGlzLnN0YWdlcypzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDtpPHRoaXMuc3RhZ2VzO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBfdCA9IHQgKyB0aGlzLmNbaV0qdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBsZXQgX3ggPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaj0wO2o8dGhpcy5zdGFnZXM7aisrKVxyXG4gICAgICAgICAgICAgICAgX3guYWRkU2VsZih2ZWN0b3Iuc2NhbGUoa1tqXSx0aGlzLmFbaV1bal0qdGhpcy5zdGVwKSk7XHJcbiAgICAgICAgICAgIGxldCBfeiA9IHN5c3RlbS5nKF94LF90KTtcclxuICAgICAgICAgICAgbGV0IGRmZHggPSBzeXN0ZW0uZGZkeChfeCxfeixfdCk7XHJcbiAgICAgICAgICAgIGxldCBkZmR6ID0gc3lzdGVtLmRmZHooX3gsX3osX3QpO1xyXG4gICAgICAgICAgICBsZXQgZGdkeCA9IHN5c3RlbS5kZ2R4KF94LF90KTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gbWF0cml4Lm11bHQoZGZkeixkZ2R4KS5hZGRTZWxmKGRmZHgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGo9MDtqPHRoaXMuc3RhZ2VzO2orKyl7XHJcbiAgICAgICAgICAgICAgICBKLnN1YlN1Yk1hdHJpeCh2YWx1ZS5zY2FsZVNlbGYodGhpcy5zdGVwKnRoaXMuYVtpXVtqXSksaSpzeXN0ZW0ubGVuZ3RoX3goKSxqKnN5c3RlbS5sZW5ndGhfeCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IEVEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG4gICAgICAgIGxldCBrOnZlY3RvcltdID0gW107XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN0YWdlcztpKyspe1xyXG4gICAgICAgICAgICBrLnB1c2godmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeCgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgRjp2ZWN0b3IgPSB0aGlzLmZ1bmN0aW9uKGsseCx6LHQsc3lzdGVtKTtcclxuICAgICAgICBsZXQgZjBub3JtID0gRi5ub3JtMigpO1xyXG4gICAgICAgIGZvcihsZXQgaXQgPSAwO2l0PHRoaXMuc3RlcFNvbHZlci5nZXRJdGVyYXRpb25zKCk7aXQrKyl7XHJcbiAgICAgICAgICAgIGxldCBKOm1hdHJpeCA9IHRoaXMuamFjb2JpTWF0cml4KGsseCx6LHQsc3lzdGVtKTtcclxuICAgICAgICAgICAgbGV0IGRrID0gZ2F1c3Muc29sdmUoSixGLnNjYWxlU2VsZigtdGhpcy5zdGVwU29sdmVyLmdldEFscGhhKCkpKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN0YWdlcztpKyspe1xyXG4gICAgICAgICAgICAgICAga1tpXS5hZGRTZWxmKGRrLmdldFN1YlZlY3RvcihpKnN5c3RlbS5sZW5ndGhfeCgpLHN5c3RlbS5sZW5ndGhfeCgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRiA9IHRoaXMuZnVuY3Rpb24oayx4LHosdCxzeXN0ZW0pO1xyXG4gICAgICAgICAgICBsZXQgZm5vcm0gPSBGLm5vcm0yKCk7XHJcblxyXG4gICAgICAgICAgICBpZihpdD49dGhpcy5zdGVwU29sdmVyLmdldE1pbkl0ZXJhdGlvbnMoKSYmZm5vcm08dGhpcy5zdGVwU29sdmVyLmdldEFic1RvbCgpK3RoaXMuc3RlcFNvbHZlci5nZXRSZWxUb2woKSpmMG5vcm0pe1xyXG4gICAgICAgICAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGo9MDtqPHRoaXMuc3RhZ2VzO2orKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGtbal0uc2NhbGVTZWxmKHRoaXMuc3RlcCAqIHRoaXMuYltqXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldyxzeXN0ZW0uZyh4TmV3LHROZXcpLHROZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmVyZ2VuY2VcIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGltcGxpY2l0IHJrIG1ldGhvZHMgd2l0aCBhZGFwdGl2ZSBzdGVwIGZvciBleHBsaWNpdCBkYWUgb2YgaW5kZXggMVxyXG4gKi9cclxuYWJzdHJhY3QgY2xhc3MgRURBRV9JUktBIGV4dGVuZHMgRURBRV9JUkt7XHJcbiAgICBwcm90ZWN0ZWQgX2I6bnVtYmVyW107XHJcbiAgICBwcm90ZWN0ZWQgZXJyb3JPcmRlcjpudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgZXJyb3JUb2xlcmFuY2U6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIG1pblN0ZXA6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIG1heFN0ZXA6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JPcmRlcjpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyLGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10sX2I6bnVtYmVyW10sc3RhZ2VzOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzdGVwU29sdmVyLGEsYixjLHN0YWdlcyk7XHJcbiAgICAgICAgdGhpcy5fYiA9IF9iO1xyXG4gICAgICAgIHRoaXMuZXJyb3JPcmRlciA9IGVycm9yT3JkZXI7XHJcbiAgICAgICAgdGhpcy5lcnJvclRvbGVyYW5jZSA9IGVycm9yVG9sZXJhbmNlO1xyXG4gICAgICAgIHRoaXMubWluU3RlcCA9IHN0ZXA7XHJcbiAgICAgICAgdGhpcy5tYXhTdGVwID0gbWF4U3RlcDtcclxuICAgIH1cclxuICAgIHByb3RlY3RlZCBmdW5jdGlvbihrOnZlY3RvcltdLHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpFREFFU3lzdGVtKTp2ZWN0b3J7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeCgpKnRoaXMuc3RhZ2VzKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSp0aGlzLnN0ZXA7XHJcbiAgICAgICAgICAgIGxldCBfeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspXHJcbiAgICAgICAgICAgICAgICBfeC5hZGRTZWxmKHZlY3Rvci5zY2FsZShrW2pdLHRoaXMuYVtpXVtqXSp0aGlzLnN0ZXApKTtcclxuICAgICAgICAgICAgbGV0IF96ID0gc3lzdGVtLmcoX3gsX3QpO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihrW2ldLGkqc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBGLnN1YlN1YlZlY3RvcihzeXN0ZW0uZihfeCxfeixfdCksaSpzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGphY29iaU1hdHJpeChrOnZlY3RvcltdLHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpFREFFU3lzdGVtKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IEo6bWF0cml4PW1hdHJpeC5pZGVudGl0eSh0aGlzLnN0YWdlcypzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDtpPHRoaXMuc3RhZ2VzO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBfdCA9IHQgKyB0aGlzLmNbaV0qdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBsZXQgX3ggPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaj0wO2o8dGhpcy5zdGFnZXM7aisrKVxyXG4gICAgICAgICAgICAgICAgX3guYWRkU2VsZih2ZWN0b3Iuc2NhbGUoa1tqXSx0aGlzLmFbaV1bal0qdGhpcy5zdGVwKSk7XHJcbiAgICAgICAgICAgIGxldCBfeiA9IHN5c3RlbS5nKF94LF90KTtcclxuICAgICAgICAgICAgbGV0IGRmZHggPSBzeXN0ZW0uZGZkeChfeCxfeixfdCk7XHJcbiAgICAgICAgICAgIGxldCBkZmR6ID0gc3lzdGVtLmRmZHooX3gsX3osX3QpO1xyXG4gICAgICAgICAgICBsZXQgZGdkeCA9IHN5c3RlbS5kZ2R4KF94LF90KTtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gbWF0cml4Lm11bHQoZGZkeixkZ2R4KS5hZGRTZWxmKGRmZHgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGo9MDtqPHRoaXMuc3RhZ2VzO2orKyl7XHJcbiAgICAgICAgICAgICAgICBKLnN1YlN1Yk1hdHJpeCh2YWx1ZS5zY2FsZVNlbGYodGhpcy5zdGVwKnRoaXMuYVtpXVtqXSksaSpzeXN0ZW0ubGVuZ3RoX3goKSxqKnN5c3RlbS5sZW5ndGhfeCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gSjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IEVEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG4gICAgICAgIHdoaWxlKHRydWUpe1xyXG4gICAgICAgICAgICBsZXQgc2hvdWxkVGhyb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgazp2ZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuc3RhZ2VzO2krKyl7XHJcbiAgICAgICAgICAgICAgICBrLnB1c2godmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeCgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IEY6dmVjdG9yID0gdGhpcy5mdW5jdGlvbihrLHgseix0LHN5c3RlbSk7XHJcbiAgICAgICAgICAgIGxldCBmMG5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaXQgPSAwO2l0PHRoaXMuc3RlcFNvbHZlci5nZXRJdGVyYXRpb25zKCk7aXQrKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgSjptYXRyaXggPSB0aGlzLmphY29iaU1hdHJpeChrLHgseix0LHN5c3RlbSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGsgPSBnYXVzcy5zb2x2ZShKLEYuc2NhbGVTZWxmKC10aGlzLnN0ZXBTb2x2ZXIuZ2V0QWxwaGEoKSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN0YWdlcztpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGtbaV0uYWRkU2VsZihkay5nZXRTdWJWZWN0b3IoaSpzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3goKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRiA9IHRoaXMuZnVuY3Rpb24oayx4LHosdCxzeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZub3JtID0gRi5ub3JtMigpO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICBpZihpdD49dGhpcy5zdGVwU29sdmVyLmdldE1pbkl0ZXJhdGlvbnMoKSYmZm5vcm08dGhpcy5zdGVwU29sdmVyLmdldEFic1RvbCgpK3RoaXMuc3RlcFNvbHZlci5nZXRSZWxUb2woKSpmMG5vcm0pe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5fYi5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmVyZW5jZS5hZGRTZWxmKHZlY3Rvci5zY2FsZShrW2ldLHRoaXMuX2JbaV0tdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZOb3JtID0gZGlmZmVyZW5jZS5ub3JtMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGVwT3B0PU1hdGgucG93KHRoaXMuZXJyb3JUb2xlcmFuY2UqMC41L2RpZk5vcm0sMS90aGlzLmVycm9yT3JkZXIpKnRoaXMuc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZihpc05hTihzdGVwT3B0KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBPcHQ9dGhpcy5taW5TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGVwT3B0PU1hdGgubWluKE1hdGgubWF4KHRoaXMubWluU3RlcCxzdGVwT3B0KSx0aGlzLm1heFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN0ZXBPcHQqMjx0aGlzLnN0ZXApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZXA9c3RlcE9wdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcCA9IHN0ZXBPcHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaj0wO2o8dGhpcy5zdGFnZXM7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGtbal0uc2NhbGVTZWxmKHRoaXMuc3RlcCAqIHRoaXMuYltqXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHN5c3RlbS5nKHhOZXcsdE5ldyksdE5ldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hvdWxkVGhyb3cpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogY2xhc3NpYyBSSzRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFREFFX1JLNCBleHRlbmRzIEVEQUVfRVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFswLjVdLFxyXG4gICAgICAgICAgICAgICAgWzAsMC41XSxcclxuICAgICAgICAgICAgICAgIFswLDAsMV1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvNiwxLzMsMS8zLDEvNl0sXHJcbiAgICAgICAgICAgIFswLDAuNSwwLjUsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9SSzRfMiBleHRlbmRzIEVEQUVfRVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzNdLFxyXG4gICAgICAgICAgICAgICAgWy0xLzMsMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwtMSwxXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS84LDMvOCwzLzgsMS84XSxcclxuICAgICAgICAgICAgWzAsMS8zLDIvMywxXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX1JLNF9SQUxTVE9OIGV4dGVuZHMgRURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzAuNF0sXHJcbiAgICAgICAgICAgICAgICBbMC4yOTY5Nzc2MSwwLjE1ODc1OTY0XSxcclxuICAgICAgICAgICAgICAgIFswLjIxODEwMDQsLTMuMDUwOTY1MTYsMy44MzI4NjQ3Nl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzAuMTc0NzYwMjgsLTAuNTUxNDgwNjYsMS4yMDU1MzU2MCwwLjE3MTE4NDc4XSxcclxuICAgICAgICAgICAgWzAsMC40LDAuNDU1NzM3MjUsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9SSzYgZXh0ZW5kcyBFREFFX0VSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMi81XSxcclxuICAgICAgICAgICAgICAgIFswLDQvNV0sXHJcbiAgICAgICAgICAgICAgICBbMTY5LzE0NTgsMTEwLzcyOSwtNjUvMTQ1OF0sXHJcbiAgICAgICAgICAgICAgICBbLTQ0LzY3NSwtODgvMTM1LDc2LzM1MSwzMzYvMzI1XSxcclxuICAgICAgICAgICAgICAgIFsyMS8xMDYsMCwtMTA1LzY4OSwtMzI0LzY4OSw0NS8xMDZdLFxyXG4gICAgICAgICAgICAgICAgWy0yNTE3LzQ4NjQsLTU1LzM4LDEwNjE1LzMxNjE2LDU2Ny83OTA0LDcyNDUvNDg2NCwyNTk3LzI0MzJdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFswLDAsMTM3NS80OTkyLDY1NjEvMjAzODQsMzM3NS8xMjU0NCw1My83NjgsMTkvMjk0XSxcclxuICAgICAgICAgICAgWzAsMi81LDQvNSwyLzksOC8xNSwwLDFdXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX1JLNl8yIGV4dGVuZHMgRURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvM10sXHJcbiAgICAgICAgICAgICAgICBbMCwyLzNdLFxyXG4gICAgICAgICAgICAgICAgWzEvMTIsMS8zLC0xLzEyXSxcclxuICAgICAgICAgICAgICAgIFsyNS80OCwtNTUvMjQsMzUvNDgsMTUvOF0sXHJcbiAgICAgICAgICAgICAgICBbMy8yMCwtMTEvMjQsLTEvOCwxLzIsMS8xMF0sXHJcbiAgICAgICAgICAgICAgICBbLTI2MS8yNjAsMzMvMTMsNDMvMTU2LC0xMTgvMzksMzIvMTk1LDgwLzM5XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMTMvMjAwLDAsMTEvNDAsMTEvNDAsNC8yNSw0LzI1LDEzLzIwMF0sXHJcbiAgICAgICAgICAgIFswLDEvMywyLzMsMS8zLDUvNiwxLzYsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbn1cclxuZXhwb3J0IGNsYXNzIEVEQUVfUks4IGV4dGVuZHMgRURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcil7XHJcbiAgICAgICAgdmFyIHJvb3QyMT1NYXRoLnNxcnQoMjEpO1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzJdLFxyXG4gICAgICAgICAgICAgICAgWzEvNCwxLzRdLFxyXG4gICAgICAgICAgICAgICAgWzEvNywoLTctMypyb290MjEpLzk4LDAsKDIxKzUqcm9vdDIxKS80OV0sXHJcbiAgICAgICAgICAgICAgICBbKDExK3Jvb3QyMSkvODQsMCwoMTgrNCpyb290MjEpLzYzLCgyMS1yb290MjEpLzI1Ml0sXHJcbiAgICAgICAgICAgICAgICBbKDUrcm9vdDIxKS80OCwwLCg5K3Jvb3QyMSkvMzYsKC0yMzErMTQqcm9vdDIxKS8zNjAsKDYzLTcqcm9vdDIxKS84MF0sXHJcbiAgICAgICAgICAgICAgICBbKDEwLXJvb3QyMSkvNDIsMCwoLTQzMis5Mipyb290MjEpLzMxNSwoNjMzLTE0NSpyb290MjEpLzkwLCgtNTAzKzExNSpyb290MjEpLzcwLCg2My0xMypyb290MjEpLzM1XSxcclxuICAgICAgICAgICAgICAgIFsxLzE0LDAsMCwwLCgxNC0zKnJvb3QyMSkvMTI2LCgxMy0zKnJvb3QyMSkvNjMsMS85XSxcclxuICAgICAgICAgICAgICAgIFsxLzMyLDAsMCwwLCg5MS0yMSpyb290MjEpLzU3NiwxMS83MiwoLTM4NS03NSpyb290MjEpLzExNTIsKDYzKzEzKnJvb3QyMSkvMTI4XSxcclxuICAgICAgICAgICAgICAgIFsxLzE0LDAsMCwwLDEvOSwoLTczMy0xNDcqcm9vdDIxKS8yMjA1LCg1MTUrMTExKnJvb3QyMSkvNTA0LCgtNTEtMTEqcm9vdDIxKS81NiwoMTMyKzI4KnJvb3QyMSkvMjQ1XSxcclxuICAgICAgICAgICAgICAgIFswLDAsMCwwLCgtNDIrNypyb290MjEpLzE4LCgtMTgrMjgqcm9vdDIxKS80NSwoLTI3My01Mypyb290MjEpLzcyLCgzMDErNTMqcm9vdDIxKS83MiwoMjgtMjgqcm9vdDIxKS80NSwoNDktNypyb290MjEpLzE4XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yMCwwLDAsMCwwLDAsMCw0OS8xODAsMTYvNDUsNDkvMTgwLDEvMjBdLFxyXG4gICAgICAgICAgICBbMCwxLzIsMS8yLCg3K3Jvb3QyMSkvMTQsKDcrcm9vdDIxKS8xNCwxLzIsKDctcm9vdDIxKS8xNCxcclxuICAgICAgICAgICAgICAgICg3LXJvb3QyMSkvMTQsMS8yLCg3K3Jvb3QyMSkvMTQsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBFREFFX0RPUFJJNSBleHRlbmRzIEVEQUVfRVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDUsZXJyb3JUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzVdLFxyXG4gICAgICAgICAgICAgICAgWzMvNDAsOS80MF0sXHJcbiAgICAgICAgICAgICAgICBbNDQvNDUsLTU2LzE1LCAzMi85XSxcclxuICAgICAgICAgICAgICAgIFsxOTM3Mi82NTYxLC0yNTM2MC8yMTg3LCA2NDQ0OC82NTYxLC0yMTIvNzI5XSxcclxuICAgICAgICAgICAgICAgIFs5MDE3LzMxNjgsLTM1NS8zMywgNDY3MzIvNTI0Nyw0OS8xNzYsLTUxMDMvMTg2NTZdLFxyXG4gICAgICAgICAgICAgICAgWzM1LzM4NCwwLDUwMC8xMTEzLDEyNS8xOTIsLTIxODcvNjc4NCwxMS84NF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzM1LzM4NCwwLDUwMC8xMTEzLDEyNS8xOTIsLTIxODcvNjc4NCwxMS84NCwwXSxcclxuICAgICAgICAgICAgWzAsMS81LDMvMTAsNC81LDgvOSwxLDFdLFxyXG4gICAgICAgICAgICBbNTE3OS81NzYwMCwwLDc1NzEvMTY2OTUsMzkzLzY0MCwtOTIwOTcvMzM5MjAwLDE4Ny8yMTAwLDEvNDBdLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCb2dhY2tpU2hhbXBpbmUyM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVEQUVfQlMyMyBleHRlbmRzIEVEQUVfRVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDMsZXJyb3JUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzJdLFxyXG4gICAgICAgICAgICAgICAgWzAsMy80XSxcclxuICAgICAgICAgICAgICAgIFsyLzksMS8zLCA0LzldXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsyLzksMS8zLDQvOSwwXSxcclxuICAgICAgICAgICAgWzAsMC41LDAuNzUsMV0sXHJcbiAgICAgICAgICAgIFs3LzI0LDEvNCwxLzMsMS84XVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBFREFFX0hldW5FdWxlciBleHRlbmRzIEVEQUVfRVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDIsZXJyb3JUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yLDEvMl0sXHJcbiAgICAgICAgICAgIFswLDFdLFxyXG4gICAgICAgICAgICBbMSwwXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX01pZHBvaW50RXVsZXIgZXh0ZW5kcyBFREFFX0VSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCwyLGVycm9yVG9sZXJhbmNlLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS8yXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMCwxXSxcclxuICAgICAgICAgICAgWzAsMC41XSxcclxuICAgICAgICAgICAgWzEsMF1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEVEQUVfUkFEQVVJQTUgZXh0ZW5kcyBFREFFX0lSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBsZXQgcm9vdDY9TWF0aC5zcXJ0KDYpO1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3RlcFNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvOSwoLTEtcm9vdDYpLzE4LCgtMStyb290NikvMThdLFxyXG4gICAgICAgICAgICAgICAgWzEvOSwoODgrNypyb290NikvMzYwLCg4OC00Mypyb290NikvMzYwXSxcclxuICAgICAgICAgICAgICAgIFsxLzksKDg4KzQzKnJvb3Q2KS8zNjAsKDgwLTcqcm9vdDYpLzM2MF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvOSwoMTYrcm9vdDYpLzM2LCgxNi1yb290NikvMzZdLFxyXG4gICAgICAgICAgICBbMCwoNi1yb290NikvMTAsKDYrcm9vdDYpLzEwXSxcclxuICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX1JBREFVSUlBMyBleHRlbmRzIEVEQUVfSVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIGxldCByb290Nj1NYXRoLnNxcnQoNik7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzdGVwU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbNS8xMiwtMS8xMl0sXHJcbiAgICAgICAgICAgICAgICBbMy80LDEvNF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzMvNCwxLzRdLFxyXG4gICAgICAgICAgICBbMS8zLDFdLFxyXG4gICAgICAgICAgICAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9SQURBVUlJQTUgZXh0ZW5kcyBFREFFX0lSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBsZXQgcm9vdDY9TWF0aC5zcXJ0KDYpO1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3RlcFNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzExLzQ1LTcqcm9vdDYvMzYwLDM3LzIyNS0xNjkqcm9vdDYvMTgwMCwtMi8yMjUrcm9vdDYvNzVdLFxyXG4gICAgICAgICAgICAgICAgWzM3LzIyNSsxNjkqcm9vdDYvMTgwMCwxMS80NSs3KnJvb3Q2LzM2MCwtMi8yMjUtcm9vdDYvNzVdLFxyXG4gICAgICAgICAgICAgICAgWzQvOS1yb290Ni8zNiw0Lzkrcm9vdDYvMzYsMS85XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbNC85LXJvb3Q2LzM2LDQvOStyb290Ni8zNiwxLzldLFxyXG4gICAgICAgICAgICBbMi81LXJvb3Q2LzEwLDIvNStyb290Ni8xMCwxXSxcclxuICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuLyoqXHJcbiAqIEVtYmVkZGVkIGdhdXNzLWxlZ2VuZHJlIDR0aCBvcmRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVEQUVfR0FVU1NMRUdFTkRSRTQgZXh0ZW5kcyBFREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIGxldCBzcXJ0MyA9IE1hdGguc3FydCgzKTsgXHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDQsZXJyb3JUb2xlcmFuY2Usc3RlcFNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvNCwxLzQtc3FydDMvNl0sXHJcbiAgICAgICAgICAgICAgICBbMS80K3NxcnQzLzYsMS80XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMC41LDAuNV0sXHJcbiAgICAgICAgICAgIFsoMy1zcXJ0MykvNiwoMytzcXJ0MykvNl0sXHJcbiAgICAgICAgICAgIFsoMStzcXJ0MykvMiwoMS1zcXJ0MykvMl0sXHJcbiAgICAgICAgICAgIDJcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRW1iZWRkZWQgZ2F1c3MtbGVnZW5kcmUgNnRoIG9yZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRURBRV9HQVVTU0xFR0VORFJFNiBleHRlbmRzIEVEQUVfSVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixzdGVwU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgbGV0IHNxcnQxNSA9IE1hdGguc3FydCgxNSk7IFxyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCw2LGVycm9yVG9sZXJhbmNlLHN0ZXBTb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFs1LzM2LDIvOS1zcXJ0MTUvMTUsNS8zNi1zcXJ0MTUvMzBdLFxyXG4gICAgICAgICAgICAgICAgWzUvMzYrc3FydDE1LzI0LDIvOSw1LzM2LC1zcXJ0MTUvMjRdLFxyXG4gICAgICAgICAgICAgICAgWzUvMzYrc3FydDE1LzMwLDIvOStzcXJ0MTUvMTUsNS8zNl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzUvMTgsNC85LDUvMThdLFxyXG4gICAgICAgICAgICBbMC41LXNxcnQxNS8xMCwwLjUsMC41K3NxcnQxNS8xMF0sXHJcbiAgICAgICAgICAgIFstNS82LDgvMywtNS82XSxcclxuICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBFREFFX0xPQkFUVE9JSUlBMiBleHRlbmRzIEVEQUVfSVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixzdGVwU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDIsZXJyb3JUb2xlcmFuY2Usc3RlcFNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzAsMF0sXHJcbiAgICAgICAgICAgICAgICBbMS8yLDEvMl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvMiwxLzJdLFxyXG4gICAgICAgICAgICBbMCwxXSxcclxuICAgICAgICAgICAgWzEsMF0sXHJcbiAgICAgICAgICAgIDJcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9MT0JBVFRPSUlJQTQgZXh0ZW5kcyBFREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCw0LGVycm9yVG9sZXJhbmNlLHN0ZXBTb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFswLDAsMF0sXHJcbiAgICAgICAgICAgICAgICBbNS8yNCwxLzMsLTEvMjRdLFxyXG4gICAgICAgICAgICAgICAgWzEvNiwyLzMsMS8zNl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvNiwyLzMsMS82XSxcclxuICAgICAgICAgICAgWzAsMC41LDFdLFxyXG4gICAgICAgICAgICBbLTEvMiwyLC0xLzJdLFxyXG4gICAgICAgICAgICAzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEVEQUVfTE9CQVRUT0lJSUIyIGV4dGVuZHMgRURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsMixlcnJvclRvbGVyYW5jZSxzdGVwU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS8yLDBdLFxyXG4gICAgICAgICAgICAgICAgWzEvMiwwXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yLDEvMl0sXHJcbiAgICAgICAgICAgIFsxLzIsMS8yXSxcclxuICAgICAgICAgICAgWzEsMF0sXHJcbiAgICAgICAgICAgIDJcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgRURBRV9MT0JBVFRPSUlJQjQgZXh0ZW5kcyBFREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCw0LGVycm9yVG9sZXJhbmNlLHN0ZXBTb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzYsLTEvNiwwXSxcclxuICAgICAgICAgICAgICAgIFsxLzYsMS8zLDBdLFxyXG4gICAgICAgICAgICAgICAgWzEvNiw1LzYsMF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvNiwyLzMsMS82XSxcclxuICAgICAgICAgICAgWzAsMC41LDFdLFxyXG4gICAgICAgICAgICBbLTEvMiwyLC0xLzJdLFxyXG4gICAgICAgICAgICAzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEVEQUVfTE9CQVRUT0lJSUMyIGV4dGVuZHMgRURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsMixlcnJvclRvbGVyYW5jZSxzdGVwU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS8yLC0xLzJdLFxyXG4gICAgICAgICAgICAgICAgWzEvMiwxLzJdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsxLzIsMS8yXSxcclxuICAgICAgICAgICAgWzAsMV0sXHJcbiAgICAgICAgICAgIFsxLDBdLFxyXG4gICAgICAgICAgICAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIEVEQUVfTE9CQVRUT0lJSUM0IGV4dGVuZHMgRURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsNCxlcnJvclRvbGVyYW5jZSxzdGVwU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS82LC0xLzMsMS82XSxcclxuICAgICAgICAgICAgICAgIFsxLzYsNS8xMiwtMS8xMl0sXHJcbiAgICAgICAgICAgICAgICBbMS82LDIvMywxLzZdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsxLzYsMi8zLDEvNl0sXHJcbiAgICAgICAgICAgIFswLDAuNSwxXSxcclxuICAgICAgICAgICAgWy0xLzIsMiwtMS8yXSxcclxuICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtcclxuICAgIERBRVZlY3RvclxyXG59IGZyb20gXCIuLi8uLi9kYWVWZWN0b3JcIjtcclxuaW1wb3J0IHsgRURBRVNvbHZlciB9IGZyb20gXCIuLi8uLi9lZGFlU29sdmVyXCI7XHJcbmltcG9ydCB7IEVEQUVTeXN0ZW0gfSBmcm9tIFwiLi4vLi4vZWRhZVN5c3RlbVwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgbWF0cml4IH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IGdhdXNzIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvZ2F1c3NcIjtcclxuaW1wb3J0IHsgTmV3dG9uU29sdmVyIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvbmV3dG9uXCI7XHJcblxyXG4vKlxyXG5leHBsaWNpdFxyXG4gICAgeF97bisxfSA9IHhfbiArIDAuNSpoKGYoeF9uLHRfbikrZih4X24raGYoeF9uLHRfbiksdF97bisxfSkpXHJcbiAgICB7XHJcbiAgICAgICAgMS4gIGtfMSA9IGYoeF9uLHpfbix0X24pXHJcbiAgICAgICAgZXhwbGljaXQgTnhcclxuICAgICAgICAyLiAga18yID0gZih4X24gKyBoKmtfMSxnKHhfbiArIGgqa18xLHRfe24rMX0pLHRfe24rMX0pXHJcbiAgICAgICAgZXhwbGljaXQgTnhcclxuICAgICAgICAzLiAgeF97bisxfSA9IHhfbiArIDAuNSpoKGtfMSArIGtfMilcclxuICAgICAgICBleHBsaWNpdCBOeFxyXG4gICAgICAgIDQuICB6X3tuKzF9ID0gZyh4X3tuKzF9LHRfe24rMX0pXHJcbiAgICAgICAgZXhwbGljaXQgTnpcclxuICAgIH1cclxuaW1wbGljaXRcclxuICAgIHhfe24rMX0gPSB4X24gKyAwLjUqaChmKHhfbix0X24pK2YoeF97bisxfSx0X3tuKzF9KSlcclxuICAgIHtcclxuICAgICAgICAxLiAga18xID0gZih4X24sel9uLHRfbilcclxuICAgICAgICBleHBsaWNpdCBOeFxyXG4gICAgICAgIDIuICB4X3tuKzF9IC0geF9uIC0gMC41Kmgoa18xK2YoeF97bisxfSxnKHhfe24rMX0sdF97bisxfSksdF97bisxfSkpID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54XHJcbiAgICAgICAgMy4gIHpfe24rMX0gPSBnKHhfe24rMX0sdF97bisxfSlcclxuICAgICAgICBleHBsaWNpdCBOelxyXG4gICAgfVxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIGV4cGxpY2l0IHRyYXBlem9pZGFsIG1ldGhvZCBmb3IgZXhwbGljaXQgZGFlIHdpdGggaW5kZXggb25lXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRURBRV9FVHJhcGV6b2lkYWwgZXh0ZW5kcyBFREFFU29sdmVye1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogRURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgbGV0IHROZXcgPSB0K3RoaXMuc3RlcDtcclxuICAgICAgICBsZXQga18xID0gc3lzdGVtLmYoeCx6LHQpLnNjYWxlU2VsZih0aGlzLnN0ZXApO1xyXG4gICAgICAgIGxldCBfeCA9IHZlY3Rvci5hZGQoeCxrXzEpO1xyXG4gICAgICAgIGxldCBrXzIgPSBzeXN0ZW0uZihfeCxzeXN0ZW0uZyhfeCx0TmV3KSx0TmV3KS5zY2FsZVNlbGYodGhpcy5zdGVwKTtcclxuICAgICAgICBsZXQgeE5ldyA9IGtfMS5hZGRTZWxmKGtfMikuc2NhbGVTZWxmKDAuNSkuYWRkU2VsZih4KTtcclxuICAgICAgICBsZXQgek5ldyA9IHN5c3RlbS5nKHhOZXcsdE5ldyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldyx6TmV3LHROZXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBpbXBsaWNpdCB0cmFwZXpvaWRhbCBtZXRob2QgZm9yIGV4cGxpY2l0IGRhZSB3aXRoIGluZGV4IG9uZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEVEQUVfSVRyYXBlem9pZGFsIGV4dGVuZHMgRURBRVNvbHZlcntcclxuICAgIHByb3RlY3RlZCBzdGVwU29sdmVyOk5ld3RvblNvbHZlcjtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICAgICAgc3VwZXIoc3RlcCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcFNvbHZlciA9IHN0ZXBTb2x2ZXI7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgICAgIHhfe24rMX0gLSB4X24gLSAwLjUqIGggKiAoa18xK2YoeF97bisxfSxnKHhfe24rMX0sdF97bisxfSksdF97bisxfSkpID0gMFxyXG4gICAgICAgIGRGX2kvZHhfe24rMX1faiA9IFxcZGVsdGFfaWogLSAwLjUqaCAqIGRmL2R4IC0gMC41KmgqZGYvZHogKiBkZy9keCh4X3tuKzFdLHRfe24rMX0pXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IEVEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG4gICAgICAgIGxldCBrXzEgPSBzeXN0ZW0uZih4LHosdCk7XHJcbiAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCkuYWRkU2VsZih2ZWN0b3Iuc2NhbGUoa18xLHRoaXMuc3RlcCkpOy8vYmV0dGVyIGFwcHJveGltYXRpb24gZm9yIHhOZXdcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHpOZXcgPSBzeXN0ZW0uZyh4TmV3LHROZXcpO1xyXG4gICAgICAgIGxldCBGID0gc3lzdGVtLmYoeE5ldyx6TmV3LHROZXcpLmFkZFNlbGYoa18xKS5zY2FsZVNlbGYoLTAuNSp0aGlzLnN0ZXApLmFkZFNlbGYoeE5ldykuc3ViU2VsZih4KTtcclxuICAgICAgICBsZXQgZjBub3JtID0gRi5ub3JtMigpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5zdGVwU29sdmVyLmdldEl0ZXJhdGlvbnMoKTtpKyspe1xyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBtYXRyaXguaWRlbnRpdHkoc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBKLnN1YlNlbGYoc3lzdGVtLmRmZHgoeE5ldyx6TmV3LHROZXcpLmFkZFNlbGYobWF0cml4Lm11bHQoc3lzdGVtLmRmZHooeE5ldyx6TmV3LHROZXcpLHN5c3RlbS5kZ2R4KHhOZXcsdE5ldykpKS5zY2FsZVNlbGYoMC41KnRoaXMuc3RlcCkpO1xyXG4gICAgICAgICAgICBsZXQgZHggPSBnYXVzcy5zb2x2ZShKLEYuc2NhbGVTZWxmKC10aGlzLnN0ZXBTb2x2ZXIuZ2V0QWxwaGEoKSkpO1xyXG4gICAgICAgICAgICB4TmV3LmFkZFNlbGYoZHgpO1xyXG5cclxuICAgICAgICAgICAgek5ldyA9IHN5c3RlbS5nKHhOZXcsdE5ldyk7XHJcblxyXG4gICAgICAgICAgICBGID0gc3lzdGVtLmYoeE5ldyx6TmV3LHROZXcpLmFkZFNlbGYoa18xKS5zY2FsZVNlbGYoLTAuNSp0aGlzLnN0ZXApLmFkZFNlbGYoeE5ldykuc3ViU2VsZih4KTtcclxuICAgICAgICAgICAgbGV0IGZub3JtID0gRi5ub3JtMigpO1xyXG4gICAgICAgICAgICBpZihpPj10aGlzLnN0ZXBTb2x2ZXIuZ2V0TWluSXRlcmF0aW9ucygpJiZmbm9ybTx0aGlzLnN0ZXBTb2x2ZXIuZ2V0QWJzVG9sKCkgKyB0aGlzLnN0ZXBTb2x2ZXIuZ2V0UmVsVG9sKCkgKiBmMG5vcm0pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2ZXJnZW5jZVwiKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7SURBRVNvbHZlcn0gZnJvbSBcIi4uLy4uL2lkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4uLy4uL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgREFFVmVjdG9yIH0gZnJvbSBcIi4uLy4uL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQgeyBOZXd0b25Tb2x2ZXIgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9uZXd0b25cIjtcclxuaW1wb3J0IHsgZ2F1c3N9IGZyb20gXCIuLi8uLi8uLi9tYXRoL2dhdXNzXCI7XHJcbmltcG9ydCB7SURBRV9SSzQsSURBRV9SSzZ9IGZyb20gXCIuLi9pZGFlL3JrXCI7XHJcblxyXG5jbGFzcyBJREFFX0FEQU1TX0JBU0hGT1JUSCBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBzdGFnZXM6bnVtYmVyO1xyXG4gICAgcHJldlZhbHVlczp2ZWN0b3JbXTtcclxuICAgIGI6bnVtYmVyW107XHJcbiAgICBzb2x2ZXI6IElEQUVTb2x2ZXJcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIsYjpudW1iZXJbXSxzb2x2ZXI6SURBRVNvbHZlcixzdGFnZXM6bnVtYmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcik7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLnNvbHZlciA9IHNvbHZlcjtcclxuICAgICAgICB0aGlzLnN0YWdlcyA9IHN0YWdlcztcclxuICAgICAgICB0aGlzLnByZXZWYWx1ZXMgPSBbXTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXRTdGVwKHZhbHVlOm51bWJlcik6dm9pZHtcclxuICAgICAgICBzdXBlci5zZXRTdGVwKHZhbHVlKTtcclxuICAgICAgICB0aGlzLnByZXZWYWx1ZXMgPSBbXTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IElEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG4gICAgICAgIHRoaXMucHJldlZhbHVlcy5zcGxpY2UoMCwwLCB0aGlzLnNvbHZlX2R4KHgseix0LHN5c3RlbSkpO1xyXG4gICAgICAgIGlmKHRoaXMucHJldlZhbHVlcy5sZW5ndGggIT0gdGhpcy5zdGFnZXMpe1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0OkRBRVZlY3RvciA9IHRoaXMuc29sdmVyLm1ha2VTdGVwKHgsIHosIHQsc3lzdGVtKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgIGxldCB4TmV3ID0geC5jbG9uZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgeE5ldy5hZGRTZWxmKHZlY3Rvci5zY2FsZSh0aGlzLnByZXZWYWx1ZXNbaV0sdGhpcy5zdGVwKnRoaXMuYltpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgek5ldyA9IHRoaXMuc29sdmVfeih4TmV3LHosdE5ldyxzeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMucHJldlZhbHVlcy5zcGxpY2UodGhpcy5wcmV2VmFsdWVzLmxlbmd0aC0xLDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBJREFFX0FCMiBleHRlbmRzIElEQUVfQURBTVNfQkFTSEZPUlRIXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsWzMvMiwtMS8yXSwgbmV3IElEQUVfUks0KHN0ZXAsc3lzdGVtU29sdmVyKSwyKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9BQjMgZXh0ZW5kcyBJREFFX0FEQU1TX0JBU0hGT1JUSFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyLFsyMy8xMiwtNC8zLDUvMTJdLCBuZXcgSURBRV9SSzQoc3RlcCxzeXN0ZW1Tb2x2ZXIpLDMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX0FCNCBleHRlbmRzIElEQUVfQURBTVNfQkFTSEZPUlRIXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsWzU1LzI0LC01OS8yNCwzNy8yNCwtMy84XSwgbmV3IElEQUVfUks0KHN0ZXAsc3lzdGVtU29sdmVyKSw0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9BQjUgZXh0ZW5kcyBJREFFX0FEQU1TX0JBU0hGT1JUSFxyXG57XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKVxyXG4gICAge1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyLFsxOTAxLzcyMCwtMTM4Ny8zNjAsMTA5LzMwLC02MzcvMzYwLDI1MS83MjBdLCBuZXcgSURBRV9SSzYoc3RlcCxzeXN0ZW1Tb2x2ZXIpLDUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX0FCNiBleHRlbmRzIElEQUVfQURBTVNfQkFTSEZPUlRIXHJcbntcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpXHJcbiAgICB7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsWzQyNzcvMTQ0MCwtMjY0MS80ODAsNDk5MS83MjAsLTM2NDkvNzIwLDk1OS80ODAsLTk1LzI4OF0sIG5ldyBJREFFX1JLNihzdGVwLHN5c3RlbVNvbHZlciksNik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge1xyXG4gICAgREFFVmVjdG9yXHJcbn0gZnJvbSBcIi4uLy4uL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQgeyBJREFFU29sdmVyIH0gZnJvbSBcIi4uLy4uL2lkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgSURBRVN5c3RlbSB9IGZyb20gXCIuLi8uLi9pZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IHZlY3RvciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9nYXVzc1wiO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogc29sdmVyIGZvciBwdXJlbHkgYWxnZWJyYWljIHN5c3RlbSBnKHosdCkgPSAwXHJcbiAqL1xyXG5cclxuZXhwb3J0IGNsYXNzIElEQUVfQWxnZWJyYWljU29sdmVyIGV4dGVuZHMgSURBRVNvbHZlcntcclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcixzeXN0ZW06SURBRVN5c3RlbSk6REFFVmVjdG9ye1xyXG4gICAgICAgIGxldCB4TmV3ID0geDtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHpOZXcgPSB0aGlzLnNvbHZlX3ooeCx6LHROZXcsc3lzdGVtKTtcclxuICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LCB6TmV3LCB0TmV3KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7XHJcbiAgICBEQUVWZWN0b3JcclxufSBmcm9tIFwiLi4vLi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi4vLi4vaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4uLy4uL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBnYXVzcyB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL2dhdXNzXCI7XHJcbmltcG9ydCB7TmV3dG9uU29sdmVyfSBmcm9tIFwiLi4vLi4vLi4vbWF0aC9uZXd0b25cIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBJREFFX0VFdWxlciBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzb2x2ZV94KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpJREFFU3lzdGVtKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeXN0ZW1Tb2x2ZXIuc29sdmUoKHhOZXc6dmVjdG9yKT0+e1xyXG4gICAgICAgICAgICBsZXQgZGVyeCA9IHZlY3Rvci5zdWIoeE5ldyx4KS5zY2FsZSgxL3RoaXMuc3RlcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzeXN0ZW0uZih4LGRlcngseix0KS5zY2FsZVNlbGYodGhpcy5zdGVwKTtcclxuICAgICAgICB9LCh4TmV3OnZlY3Rvcik9PntcclxuICAgICAgICAgICAgbGV0IGRlcnggPSB2ZWN0b3Iuc3ViKHhOZXcseCkuc2NhbGUoMS90aGlzLnN0ZXApO1xyXG4gICAgICAgICAgICByZXR1cm4gc3lzdGVtLmRmZGR4KHgsZGVyeCx6LHQpO1xyXG4gICAgICAgIH0seC5sZW5ndGgoKSx4KTtcclxuXHJcbiAgICAgICAgLyovL3NvbHZlIGZvciB4X3tuKzF9XHJcbiAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yO1xyXG4gICAgICAgIGxldCBkZXJ4ID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkpO1xyXG4gICAgICAgIEYgPSBzeXN0ZW0uZih4LGRlcngseix0KS5zY2FsZVNlbGYoLXRoaXMuc3RlcCAqIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgIGxldCBmMG5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLm5ld3Rvbkl0ZXJhdGlvbnM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IEo6bWF0cml4O1xyXG4gICAgICAgICAgICBKID0gc3lzdGVtLmRmZGR4KHgsZGVyeCx6LHQpO1xyXG4gICAgICAgICAgICBsZXQgZHggPSBnYXVzcy5zb2x2ZShKLEYpO1xyXG4gICAgICAgICAgICB4TmV3LmFkZFNlbGYoZHgpO1xyXG5cclxuICAgICAgICAgICAgZGVyeCA9IHZlY3Rvci5zdWIoeE5ldyx4KS5zY2FsZSgxL3RoaXMuc3RlcCk7XHJcbiAgICAgICAgICAgIEYgPSBzeXN0ZW0uZih4LGRlcngseix0KS5zY2FsZVNlbGYoLXRoaXMuc3RlcCAqIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBsZXQgZm5vcm0gPSBGLm5vcm0yKCkvdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICBpZihmbm9ybTx0aGlzLmZBYnNUb2wrdGhpcy5mUmVsVG9sKmYwbm9ybSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geE5ldztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXZlcmdlbmNlIGF0IHNvbHZlX3hcIik7Ki9cclxuICAgIH1cclxuICAgIC8qcHJpdmF0ZSBzb2x2ZV96KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpJREFFU3lzdGVtKXtcclxuICAgICAgICAvL3NvbHZlIGcoeF97bisxfSwgel97bisxfSwgdF97bisxfSkgPSAwIGZvciB6X3tuKzF9IFxyXG4gICAgICAgIGxldCB6TmV3ID0gei5jbG9uZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5uZXd0b25JdGVyYXRpb25zO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBKOm1hdHJpeDtcclxuICAgICAgICAgICAgSiA9IHN5c3RlbS5kZ2R6KHgsIHpOZXcsIHQpO1xyXG4gICAgICAgICAgICBsZXQgRjp2ZWN0b3I7XHJcbiAgICAgICAgICAgIEYgPSBzeXN0ZW0uZyh4LHpOZXcsdCkuc2NhbGVTZWxmKHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBsZXQgZHogPSBnYXVzcy5zb2x2ZShKLCBGKTtcclxuICAgICAgICAgICAgek5ldy5hZGRTZWxmKGR6KTtcclxuICAgICAgICAgICAgaWYoRi5ub3JtMigpPHRoaXMuZkFic1RvbCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gek5ldztcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgXCJkaXZlcmdlbmNlIGF0IHNvbHZlX3pcIjtcclxuICAgIH0qL1xyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyLHN5c3RlbTpJREFFU3lzdGVtKTpEQUVWZWN0b3J7XHJcbiAgICAgICAgbGV0IHhOZXcgPSB0aGlzLnNvbHZlX3goeCx6LHQsc3lzdGVtKTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHpOZXcgPSB0aGlzLnNvbHZlX3ooeE5ldyx6LHROZXcsc3lzdGVtKTtcclxuICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LCB6TmV3LCB0TmV3KTtcclxuICAgIH1cclxufVxyXG4gICAgLypcclxuICAgIGRmL2R4X3tuKzF9ID0gZGYvZHggKyBkZi9kZHggKiAxL2hcclxuICAgIGRmL2R6X3tuKzF9ID0gZGYvZHpcclxuICAgIGRnL2R4X3tuKzF9ID0gZGcvZHhcclxuICAgIGRnL2R6X3tuKzF9ID0gZGcvZHpcclxuICAgIEYgPSB7XHJcbiAgICAgICAgZih4X3tuKzF9LCh4X3tuKzF9LXhfe259KS9oLCB6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgIGcoeF97bisxfSwgel97bisxfSwgdF97bisxfSkgPSAwXHJcbiAgICB9XHJcbiAgICBPUlxyXG4gICAgZGYvZHhfe24rMX0gPSBkZi9keCAqIGggKyBkZi9kZHhcclxuICAgIGRmL2R6X3tuKzF9ID0gZGYvZHogKiBoXHJcbiAgICBkZy9keF97bisxfSA9IGRnL2R4ICogaFxyXG4gICAgZGcvZHpfe24rMX0gPSBkZy9keiAqIGhcclxuICAgIEYgPSB7XHJcbiAgICAgICAgZih4X3tuKzF9LCh4X3tuKzF9LXhfe259KS9oLCB6X3tuKzF9LCB0X3tuKzF9KSAqIGggPSAwXHJcbiAgICAgICAgZyh4X3tuKzF9LHpfe24rMX0sIHRfe24rMX0pICogaCA9IDBcclxuICAgIH1cclxuICAgICovXHJcbmV4cG9ydCBjbGFzcyBJREFFX0lFdWxlciBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOklEQUVTeXN0ZW0pOkRBRVZlY3RvcntcclxuICAgICAgICAvKmxldCB4ejAgPSB2ZWN0b3IuY29uY2F0KFt4LHpdKTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHh6TmV3ID0gdGhpcy5zdGVwU29sdmVyLnNvbHZlKCh4ek5ldzp2ZWN0b3IpPT57XHJcbiAgICAgICAgICAgIGxldCB4TmV3ID0geHpOZXcuZ2V0U3ViVmVjdG9yKDAsc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBsZXQgek5ldyA9IHh6TmV3LmdldFN1YlZlY3RvcihzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgICAgIGxldCBkZXJ4ID0gdmVjdG9yLnN1Yih4TmV3LHgpLnNjYWxlKDEvdGhpcy5zdGVwKTtcclxuICAgICAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeCgpK3N5c3RlbS5sZW5ndGhfeigpKTtcclxuICAgICAgICAgICAgRi5hZGRTdWJWZWN0b3Ioc3lzdGVtLmYoeE5ldyxkZXJ4LHpOZXcsdE5ldyksMCk7XHJcbiAgICAgICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5nKHhOZXcsek5ldyx0TmV3KSxzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBGO1xyXG4gICAgICAgIH0sICh4ek5ldzp2ZWN0b3IpPT57XHJcbiAgICAgICAgICAgIGxldCB4TmV3ID0geHpOZXcuZ2V0U3ViVmVjdG9yKDAsc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBsZXQgek5ldyA9IHh6TmV3LmdldFN1YlZlY3RvcihzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgICAgIGxldCBKOm1hdHJpeDtcclxuICAgICAgICAgICAgSiA9IG1hdHJpeC5lbXB0eVNxdWFyZSh4Lmxlbmd0aCgpK3oubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICAvL3NjYWxlIGJvdGggcGFydCBvZiAoSiBkeCA9IC1GKSBieSBzdGVwXHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZmR4KHhOZXcsZGVyeCx6TmV3LHROZXcpLmFkZFNlbGYoc3lzdGVtLmRmZGR4KHhOZXcsZGVyeCx6TmV3LHROZXcpLnNjYWxlU2VsZigxL3RoaXMuc3RlcCkpLDAsMCk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZmR6KHhOZXcsZGVyeCx6TmV3LHROZXcpLDAseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R4KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLDApO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChzeXN0ZW0uZGdkeih4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIEo7XHJcbiAgICAgICAgfSwgc3lzdGVtLmxlbmd0aF94KCkrc3lzdGVtLmxlbmd0aF96KCksIHh6MCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeHpOZXcuZ2V0U3ViVmVjdG9yKDAsc3lzdGVtLmxlbmd0aF94KCkpLHh6TmV3LmdldFN1YlZlY3RvcihzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3ooKSksdE5ldyk7Ki9cclxuICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKTtcclxuICAgICAgICBsZXQgek5ldyA9IHouY2xvbmUoKTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IGRlcnggPSB2ZWN0b3IuZW1wdHkoeC5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yO1xyXG4gICAgICAgIEYgPSB2ZWN0b3IuZW1wdHkoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZih4TmV3LGRlcngsek5ldyx0TmV3KSwwKTtcclxuICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZyh4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IGYwbm9ybSA9IEYubm9ybTIoKTs7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN5c3RlbVNvbHZlci5nZXRJdGVyYXRpb25zKCk7aSsrKXtcclxuICAgICAgICAgICAgbGV0IEo6bWF0cml4O1xyXG4gICAgICAgICAgICBKID0gbWF0cml4LmVtcHR5U3F1YXJlKHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIC8vc2NhbGUgYm90aCBwYXJ0IG9mIChKIGR4ID0gLUYpIGJ5IHN0ZXBcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHgoeE5ldyxkZXJ4LHpOZXcsdE5ldykuYWRkU2VsZihzeXN0ZW0uZGZkZHgoeE5ldyxkZXJ4LHpOZXcsdE5ldykuc2NhbGVTZWxmKDEvdGhpcy5zdGVwKSksMCwwKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHooeE5ldyxkZXJ4LHpOZXcsdE5ldyksMCx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRnZHgoeE5ldyx6TmV3LHROZXcpLHgubGVuZ3RoKCksMCk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R6KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLHgubGVuZ3RoKCkpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGR4eiA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuc3lzdGVtU29sdmVyLmdldEFscGhhKCkpKTtcclxuICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGR4ei5nZXRTdWJWZWN0b3IoMCx4Lmxlbmd0aCgpKSk7XHJcbiAgICAgICAgICAgIHpOZXcuYWRkU2VsZihkeHouZ2V0U3ViVmVjdG9yKHgubGVuZ3RoKCksei5sZW5ndGgoKSkpO1xyXG5cclxuICAgICAgICAgICAgZGVyeCA9IHZlY3Rvci5zdWIoeE5ldyx4KS5zY2FsZSgxL3RoaXMuc3RlcCk7XHJcblxyXG4gICAgICAgICAgICBGID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5mKHhOZXcsZGVyeCx6TmV3LHROZXcpLDApO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZyh4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIGxldCBmbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICAgICAgaWYoaT49dGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0TWluSXRlcmF0aW9ucygpJiZmbm9ybTx0aGlzLnN5c3RlbVNvbHZlci5nZXRBYnNUb2woKSt0aGlzLnN5c3RlbVNvbHZlci5nZXRSZWxUb2woKSpmMG5vcm0pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldywgek5ldywgdE5ldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2ZXJnZW5jZVwiKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7XHJcbiAgICBEQUVWZWN0b3JcclxufSBmcm9tIFwiLi4vLi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi4vLi4vaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4uLy4uL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBnYXVzcyB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL2dhdXNzXCI7XHJcbmltcG9ydCB7IE5ld3RvblNvbHZlciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL25ld3RvblwiO1xyXG4vKlxyXG5leHBsaWNpdFxyXG4gICAgeF97bisxfSA9IHhfbiArIGggZih4X24rMC41aCpmKHhfbiwgdF9uKSwgdF9uICsgMC41KmgpXHJcbiAgICB7XHJcbiAgICAgICAgMS4gIGYoeF9uLCBrXzEsIHpfbiwgdF9uKSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeFxyXG4gICAgICAgIDIuICBnKHhfbiArIDAuNSAqIGggKiBrXzEsIHpeMV9uLCB0X24rMC41KmgpID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE56XHJcbiAgICAgICAgMy4gIGYoeF9uICsgMC41ICogaCAqIGtfMSwga18yLCB6XjFfbiwgdF9uKzAuNSpoKSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeFxyXG4gICAgICAgIDQuICB4X3tuKzF9ID0geF9uICsgaCprXzJcclxuICAgICAgICBleHBsaWNpdCBOeFxyXG4gICAgICAgIDUuICBnKHhfe24rMX0sIHpfe24rMX0sIHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE56XHJcbiAgICB9XHJcbmltcGxpY2l0XHJcbiAgICB4X3tuKzF9PXhfbiArIGggZigwLjUqKHhfbit4X3tuKzF9KSx0X24rMC41KmgpXHJcbiAgICB7XHJcbiAgICAgICAgMS4gIGYoMC41Kih4X3tufSt4X3tuKzF9KSwgKHhfe24rMX0gLSB4X24pL2gsIDAuNSooel97bn0rel97bisxfSksIHRfbiArIDAuNSpoKSA9IDBcclxuICAgICAgICAgICAgZyh4X3tuKzF9LCB6X3tuKzF9LCB0X3tuKzF9KSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeCArIE56XHJcbiAgICB9XHJcbiovXHJcblxyXG4vKipcclxuICogZXhwbGljaXQgbWlkcG9pbnQgbWV0aG9kIGZvciBpbXBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJREFFX0VNaWRwb2ludCBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgbGV0IHgxID0gdGhpcy5zb2x2ZV9keCh4LHosdCxzeXN0ZW0pLnNjYWxlU2VsZigwLjUqdGhpcy5zdGVwKS5hZGRTZWxmKHgpO1xyXG4gICAgICAgIGxldCB6MSA9IHRoaXMuc29sdmVfeih4MSx6LHQgKyAwLjUqdGhpcy5zdGVwLHN5c3RlbSk7XHJcbiAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgIGxldCB4TmV3ID0gdGhpcy5zb2x2ZV9keCh4MSx6MSx0ICsgMC41KnRoaXMuc3RlcCxzeXN0ZW0pLnNjYWxlU2VsZih0aGlzLnN0ZXApLmFkZFNlbGYoeCk7XHJcbiAgICAgICAgbGV0IHpOZXcgPSB0aGlzLnNvbHZlX3ooeE5ldyx6MSx0TmV3LHN5c3RlbSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldyx6TmV3LHROZXcpO1xyXG4gICAgICAgIC8qeF97bisxfSA9IHhfbiArIGggZih4X24rMC41aCpmKHhfbiwgdF9uKSwgdF9uICsgMC41KmgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAxLiAgZih4X24sIGtfMSwgel9uLCB0X24pID0gMFxyXG4gICAgICAgICAgICBpbXBsaWNpdCBOeFxyXG4gICAgICAgICAgICAyLiAgZyh4X24gKyAwLjUgKiBoICoga18xLCB6XjFfbiwgdF9uKzAuNSpoKSA9IDBcclxuICAgICAgICAgICAgaW1wbGljaXQgTnpcclxuICAgICAgICAgICAgMy4gIGYoeF9uICsgMC41ICogaCAqIGtfMSwga18yLCB6XjFfbiwgdF9uKzAuNSpoKSA9IDBcclxuICAgICAgICAgICAgaW1wbGljaXQgTnhcclxuICAgICAgICAgICAgNC4gIHhfe24rMX0gPSB4X24gKyBoKmtfMlxyXG4gICAgICAgICAgICBleHBsaWNpdCBOeFxyXG4gICAgICAgICAgICA1LiAgZyh4X3tuKzF9LCB6X3tuKzF9LCB0X3tuKzF9KSA9IDBcclxuICAgICAgICAgICAgaW1wbGljaXQgTnpcclxuICAgICAgICB9Ki9cclxuICAgIH1cclxufVxyXG4vKipcclxuICogaW1wbGljaXQgbWlkcG9pbnQgbWV0aG9kIGZvciBpbXBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbi8qXHJcbkZ4ID0gZigwLjUqKHhfe259K3hfe24rMX0pLCAoeF97bisxfSAtIHhfbikvaCwgMC41Kih6X3tufSt6X3tuKzF9KSwgdF9uICsgMC41KmgpID0gMFxyXG5GeiA9IGcoeF97bisxfSwgel97bisxfSwgdF97bisxfSkgPSAwXHJcbmRGeC9keF97bisxfSA9IDAuNSpkZi9keCArIGRmL2RkeCAqMS9oXHJcbmRGeC9kel97bisxfSA9IDAuNSpkZi9kelxyXG5kRnovZHhfe24rMX0gPSBkZy9keFxyXG5kRnovZHpfe24rMX0gPSBkZy9kelxyXG4qL1xyXG5leHBvcnQgY2xhc3MgSURBRV9JTWlkcG9pbnQgZXh0ZW5kcyBJREFFU29sdmVye1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IElEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG5cclxuICAgICAgICAvKmxldCB4ejAgPSB2ZWN0b3IuY29uY2F0KFt4LHpdKTtcclxuICAgICAgICBsZXQgdEhhbGYgPSB0ICsgdGhpcy5zdGVwKjAuNTtcclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHh6TmV3ID0gdGhpcy5zdGVwU29sdmVyLnNvbHZlKCh4ek5ldzp2ZWN0b3IpPT57XHJcbiAgICAgICAgICAgIGxldCB4TmV3ID0geHpOZXcuZ2V0U3ViVmVjdG9yKDAsc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBsZXQgek5ldyA9IHh6TmV3LmdldFN1YlZlY3RvcihzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3ooKSk7XHJcbiAgICAgICAgICAgIGxldCBkeCA9IHZlY3Rvci5zdWIoeE5ldyx4KS5zY2FsZSgxL3RoaXMuc3RlcCk7XHJcbiAgICAgICAgICAgIGxldCB4SGFsZiA9IHZlY3Rvci5hZGQoeCx4TmV3KS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICAgICAgbGV0IHpIYWxmID0gdmVjdG9yLmFkZCh6LHpOZXcpLnNjYWxlU2VsZigwLjUpO1xyXG5cclxuICAgICAgICAgICAgbGV0IEYgPSB2ZWN0b3IuZW1wdHkoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgRi5hZGRTdWJWZWN0b3Ioc3lzdGVtLmYoeEhhbGYsZHgsekhhbGYsdEhhbGYpLDApO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZyh4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBGO1xyXG4gICAgICAgIH0sKHh6TmV3OnZlY3Rvcik9PntcclxuICAgICAgICAgICAgbGV0IHhOZXcgPSB4ek5ldy5nZXRTdWJWZWN0b3IoMCxzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgICAgIGxldCB6TmV3ID0geHpOZXcuZ2V0U3ViVmVjdG9yKHN5c3RlbS5sZW5ndGhfeCgpLHN5c3RlbS5sZW5ndGhfeigpKTtcclxuICAgICAgICAgICAgbGV0IGR4ID0gdmVjdG9yLnN1Yih4TmV3LHgpLnNjYWxlKDEvdGhpcy5zdGVwKTtcclxuICAgICAgICAgICAgbGV0IHhIYWxmID0gdmVjdG9yLmFkZCh4LHhOZXcpLnNjYWxlU2VsZigwLjUpO1xyXG4gICAgICAgICAgICBsZXQgekhhbGYgPSB2ZWN0b3IuYWRkKHosek5ldykuc2NhbGVTZWxmKDAuNSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBtYXRyaXguZW1wdHlTcXVhcmUoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHgoeEhhbGYsZHgsekhhbGYsdEhhbGYpLnNjYWxlU2VsZigwLjUpLmFkZFNlbGYoc3lzdGVtLmRmZGR4KHhIYWxmLGR4LHpIYWxmLHRIYWxmKS5zY2FsZVNlbGYoMS90aGlzLnN0ZXApKSwwLDApO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChzeXN0ZW0uZGZkeih4SGFsZixkeCx6SGFsZix0SGFsZikuc2NhbGVTZWxmKDAuNSksMCx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRnZHgoeE5ldyx6TmV3LHROZXcpLHgubGVuZ3RoKCksMCk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R6KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gSjtcclxuICAgICAgICB9LHN5c3RlbS5sZW5ndGhfeCgpK3N5c3RlbS5sZW5ndGhfeigpLHh6MCk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHh6TmV3LmdldFN1YlZlY3RvcigwLHN5c3RlbS5sZW5ndGhfeCgpKSx4ek5ldy5nZXRTdWJWZWN0b3Ioc3lzdGVtLmxlbmd0aF94KCksc3lzdGVtLmxlbmd0aF96KCkpLHROZXcpOyovXHJcblxyXG5cclxuICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgbGV0IHpOZXcgPSB6LmNsb25lKCk7XHJcbiAgICAgICAgbGV0IHRIYWxmID0gdCArIDAuNSp0aGlzLnN0ZXA7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IGR4ID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkpO1xyXG4gICAgICAgIGxldCB4SGFsZiA9IHZlY3Rvci5hZGQoeCx4TmV3KS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICBsZXQgekhhbGYgPSB2ZWN0b3IuYWRkKHosek5ldykuc2NhbGVTZWxmKDAuNSk7XHJcblxyXG4gICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5mKHhIYWxmLGR4LHpIYWxmLHRIYWxmKSwwKTtcclxuICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZyh4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgbGV0IGYwbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuc3lzdGVtU29sdmVyLmdldEl0ZXJhdGlvbnMoKTtpKyspe1xyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBtYXRyaXguZW1wdHlTcXVhcmUoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZmR4KHhIYWxmLGR4LHpIYWxmLHRIYWxmKS5zY2FsZVNlbGYoMC41KS5hZGRTZWxmKHN5c3RlbS5kZmRkeCh4SGFsZixkeCx6SGFsZix0SGFsZikuc2NhbGVTZWxmKDEvdGhpcy5zdGVwKSksMCwwKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHooeEhhbGYsZHgsekhhbGYsdEhhbGYpLnNjYWxlU2VsZigwLjUpLDAseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R4KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLDApO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChzeXN0ZW0uZGdkeih4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgbGV0IGR4eiA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuc3lzdGVtU29sdmVyLmdldEFscGhhKCkpKTtcclxuICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGR4ei5nZXRTdWJWZWN0b3IoMCx4Lmxlbmd0aCgpKSk7XHJcbiAgICAgICAgICAgIHpOZXcuYWRkU2VsZihkeHouZ2V0U3ViVmVjdG9yKHgubGVuZ3RoKCksei5sZW5ndGgoKSkpO1xyXG5cclxuICAgICAgICAgICAgZHggPSB2ZWN0b3Iuc3ViKHhOZXcseCkuc2NhbGUoMS90aGlzLnN0ZXApO1xyXG4gICAgICAgICAgICB4SGFsZiA9IHZlY3Rvci5hZGQoeCx4TmV3KS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICAgICAgekhhbGYgPSB2ZWN0b3IuYWRkKHosek5ldykuc2NhbGVTZWxmKDAuNSk7XHJcblxyXG4gICAgICAgICAgICBGID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5mKHhIYWxmLGR4LHpIYWxmLHRIYWxmKSwwKTtcclxuICAgICAgICAgICAgRi5hZGRTdWJWZWN0b3Ioc3lzdGVtLmcoeE5ldyx6TmV3LHROZXcpLHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICBsZXQgZm5vcm0gPSBGLm5vcm0yKCk7XHJcbiAgICAgICAgICAgIGlmKGk+PXRoaXMuc3lzdGVtU29sdmVyLmdldE1pbkl0ZXJhdGlvbnMoKSYmZm5vcm08dGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0QWJzVG9sKCkrdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0UmVsVG9sKCkqZjBub3JtKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlXCIpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgICBEQUVWZWN0b3JcclxufSBmcm9tIFwiLi4vLi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi4vLi4vaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4uLy4uL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBnYXVzcyB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL2dhdXNzXCI7XHJcbmltcG9ydCB7IE5ld3RvblNvbHZlciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL25ld3RvblwiO1xyXG4vKipcclxuICogZXhwbGljaXQgcmsgbWV0aG9kcyBmb3IgaW1wbGljaXQgZGFlIG9mIGluZGV4IDFcclxuICovXHJcbmFic3RyYWN0IGNsYXNzIElEQUVfRVJLIGV4dGVuZHMgSURBRVNvbHZlcntcclxuICAgIHByb3RlY3RlZCBhOm51bWJlcltdW107XHJcbiAgICBwcm90ZWN0ZWQgYjpudW1iZXJbXTtcclxuICAgIHByb3RlY3RlZCBjOm51bWJlcltdO1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcixcclxuICAgICAgICBhOm51bWJlcltdW10sYjpudW1iZXJbXSxjOm51bWJlcltdKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcik7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgbWFrZVN0ZXAoeDogdmVjdG9yLCB6OiB2ZWN0b3IsIHQ6IG51bWJlciwgc3lzdGVtOiBJREFFU3lzdGVtKTogREFFVmVjdG9yIHtcclxuICAgICAgICBsZXQgazp2ZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIGxldCBfeiA9IHo7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBfeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajxpO2orKyl7XHJcbiAgICAgICAgICAgICAgICBfeC5hZGQodmVjdG9yLnNjYWxlKGtbal0sdGhpcy5zdGVwKnRoaXMuYVtpLTFdW2pdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSAqIHRoaXMuc3RlcDtcclxuICAgICAgICAgICAgX3ogPSB0aGlzLnNvbHZlX3ooX3gsX3osX3Qsc3lzdGVtKTtcclxuICAgICAgICAgICAgay5wdXNoKHRoaXMuc29sdmVfZHgoX3gsX3osX3Qsc3lzdGVtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB4TmV3ID0geC5jbG9uZSgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5iLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICB4TmV3LmFkZChrW2ldLnNjYWxlU2VsZih0aGlzLnN0ZXAqdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgek5ldyA9IHRoaXMuc29sdmVfeih4TmV3LF96LHROZXcsc3lzdGVtKTtcclxuICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHpOZXcsdE5ldyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBleHBsaWNpdCByayBtZXRob2RzIHdpdGggYWRhcHRpdmUgc3RlcCBmb3IgaW1wbGljaXQgZGFlIG9mIGluZGV4IDFcclxuICovXHJcbmFic3RyYWN0IGNsYXNzIElEQUVfRVJLQSBleHRlbmRzIElEQUVfRVJLe1xyXG4gICAgcHJvdGVjdGVkIF9iOm51bWJlcltdO1xyXG4gICAgcHJvdGVjdGVkIGVycm9yT3JkZXI6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGVycm9yVG9sZXJhbmNlOm51bWJlcjtcclxuICAgIHByb3RlY3RlZCBtYXhTdGVwOm51bWJlcjtcclxuICAgIHByb3RlY3RlZCBtaW5TdGVwOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLFxyXG4gICAgICAgIGVycm9yT3JkZXI6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyLFxyXG4gICAgICAgIGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10sXHJcbiAgICAgICAgX2I6bnVtYmVyW10pe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyLGEsYixjKTtcclxuICAgICAgICB0aGlzLl9iID0gX2I7XHJcbiAgICAgICAgdGhpcy5lcnJvck9yZGVyID0gZXJyb3JPcmRlcjtcclxuICAgICAgICB0aGlzLmVycm9yVG9sZXJhbmNlID0gZXJyb3JUb2xlcmFuY2U7XHJcbiAgICAgICAgdGhpcy5taW5TdGVwID0gc3RlcDtcclxuICAgICAgICB0aGlzLm1heFN0ZXAgPSBtYXhTdGVwO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgd2hpbGUodHJ1ZSl7XHJcbiAgICAgICAgICAgIGxldCBrOnZlY3RvcltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBfeiA9IHo7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5jLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IF94ID0geC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBqPTA7ajxpO2orKyl7XHJcbiAgICAgICAgICAgICAgICAgICAgX3guYWRkKHZlY3Rvci5zY2FsZShrW2pdLHRoaXMuc3RlcCp0aGlzLmFbaS0xXVtqXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSAqIHRoaXMuc3RlcDtcclxuICAgICAgICAgICAgICAgIF96ID0gdGhpcy5zb2x2ZV96KF94LF96LF90LHN5c3RlbSk7XHJcbiAgICAgICAgICAgICAgICBrLnB1c2godGhpcy5zb2x2ZV9keChfeCxfeixfdCxzeXN0ZW0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZGlmZmVyZW5jZSA9IHZlY3Rvci5lbXB0eSh4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLl9iLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZS5hZGRTZWxmKHZlY3Rvci5zY2FsZShrW2ldLHRoaXMuX2JbaV0tdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGRpZk5vcm0gPSBkaWZmZXJlbmNlLm5vcm0yKCk7XHJcbiAgICAgICAgICAgIHZhciBzdGVwT3B0PU1hdGgucG93KHRoaXMuZXJyb3JUb2xlcmFuY2UqMC41L2RpZk5vcm0sMS90aGlzLmVycm9yT3JkZXIpKnRoaXMuc3RlcDtcclxuICAgICAgICAgICAgaWYoaXNOYU4oc3RlcE9wdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN0ZXBPcHQ9dGhpcy5taW5TdGVwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ZXBPcHQ9TWF0aC5taW4oTWF0aC5tYXgodGhpcy5taW5TdGVwLHN0ZXBPcHQpLHRoaXMubWF4U3RlcCk7XHJcbiAgICAgICAgICAgIGlmKHN0ZXBPcHQqMjx0aGlzLnN0ZXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcD1zdGVwT3B0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcE9wdDtcclxuICAgICAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmIubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICB4TmV3LmFkZCh2ZWN0b3Iuc2NhbGUoa1tpXSx0aGlzLnN0ZXAqdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHpOZXcgPSB0aGlzLnNvbHZlX3ooeE5ldyxfeix0TmV3LHN5c3RlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGltcGxpY2l0IHJrIG1ldGhvZHMgZm9yIGV4cGxpY2l0IGRhZSBvZiBpbmRleCAxXHJcbiAqL1xyXG5hYnN0cmFjdCBjbGFzcyBJREFFX0lSSyBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBwcm90ZWN0ZWQgYTpudW1iZXJbXVtdO1xyXG4gICAgcHJvdGVjdGVkIGI6bnVtYmVyW107XHJcbiAgICBwcm90ZWN0ZWQgYzpudW1iZXJbXTtcclxuICAgIHByb3RlY3RlZCBzdGFnZXM6bnVtYmVyO1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcixcclxuICAgICAgICBhOm51bWJlcltdW10sYjpudW1iZXJbXSxjOm51bWJlcltdLHN0YWdlczpudW1iZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyKTtcclxuICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgdGhpcy5jID0gYztcclxuICAgICAgICB0aGlzLnN0YWdlcyA9IHN0YWdlcztcclxuICAgIH1cclxuICAgIC8qICBJIEtORVcgVVIgRkFUSEVSLCBMVUtFLCBJIENVVFRFRCBISVMgTEVHUyBBTkQgTEVGVCBISU0gSU4gTEFWQSwgSEUgV0FTIEEgR09PRCBGUklFTkRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZfe3hpfTogZih4X24gKyBoICogc3VtX3tqPTF9XntTfSBrX2ogKiBhX2lqLCBrX2ksIGtfe3ppfSwgdF9uICsgaCAqIGNfaSkgPSAwXHJcbiAgICAgICAgICAgIEZfe2dpfTogZyh4X24gKyBoICogc3VtX3tqPTF9XntTfSBrX2ogKiBhX2lqLCBrX3t6aX0sIHRfbiArIGggKiBjX2kpID0gMFxyXG4gICAgICAgIH1cclxuICAgICAgICBTICogKE5feCArIE5feilcclxuICAgICAgICBkRl97eGlsfS9ka19qbSA9IFxcZGVsdGFfaWogKiBkZi9kZHggKyBkZi9keCAqIGggKiBhX2lqO1xyXG4gICAgICAgIGRGX3t4aWx9L2RrX3pqID0gXFxkZWx0YV9paiAqIGRmL2R6O1xyXG4gICAgICAgIGRGX3tnaX0vZGtfam0gPSBkZy9keCAqIGggKiBhX2lqO1xyXG4gICAgICAgIGRGX3tnaX0vZGtfemogPSBcXGRlbHRhX2lqICogZGcvZHo7XHJcblxyXG4gICAgICAgIG1lbW9yeSBsYXlvdXQ6XHJcbiAgICAgICAgICAgICAgICAgIGotPlxyXG4gICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAgICB8IGRGeDAvZGswIHwgZEZ4MC9ka3owICAgICB8IGRGeDAvZGsxIHwgZEZ4MC9ka3oxID0gMCB8XHJcbiAgICBpICAgfC0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgfCAgIHwgZEZnMC9kazAgfCBkRmcwL2RrejAgICAgIHwgZEZnMC9kazEgfCBkRmcwL2RrejEgPSAwIHxcclxuICAgIHYgICB8LS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18XHJcbiAgICAgICAgfCBkRngxL2RrMCB8IGRGeDEvZGt6MCA9IDAgfCBkRngxL2RrMSB8IGRGeDEvZGt6MSAgICAgfFxyXG4gICAgICAgIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLXxcclxuICAgICAgICB8IGRGZzEvZGswIHwgZEZnMS9ka3owID0gMCB8IGRGZzEvZGsxIHwgZEZnMS9ka3oxICAgICB8XHJcbiAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZnVuY3Rpb24oa3g6dmVjdG9yW10sa3o6dmVjdG9yW10seDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIsc3lzdGVtOklEQUVTeXN0ZW0pOnZlY3RvcntcclxuICAgICAgICBsZXQgbGVuZ3RoID0gc3lzdGVtLmxlbmd0aF94KCkgKyBzeXN0ZW0ubGVuZ3RoX3ooKTtcclxuICAgICAgICBsZXQgRjp2ZWN0b3IgPSB2ZWN0b3IuZW1wdHkodGhpcy5zdGFnZXMqbGVuZ3RoKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSp0aGlzLnN0ZXA7XHJcbiAgICAgICAgICAgIGxldCBfeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspXHJcbiAgICAgICAgICAgICAgICBfeC5hZGRTZWxmKHZlY3Rvci5zY2FsZShreFtqXSx0aGlzLmFbaV1bal0qdGhpcy5zdGVwKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZihfeCxreFtpXSxreltpXSxfdCksaSpsZW5ndGgpO1xyXG4gICAgICAgICAgICBGLnN1YlN1YlZlY3RvcihzeXN0ZW0uZyhfeCxreltpXSxfdCksaSpsZW5ndGggKyBzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIGphY29iaU1hdHJpeChreDp2ZWN0b3JbXSxrejp2ZWN0b3JbXSx4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcixzeXN0ZW06SURBRVN5c3RlbSk6bWF0cml4e1xyXG4gICAgICAgIGxldCBsZW5ndGggPSBzeXN0ZW0ubGVuZ3RoX3goKSArIHN5c3RlbS5sZW5ndGhfeigpO1xyXG4gICAgICAgIGxldCBKOm1hdHJpeD1tYXRyaXguZW1wdHlTcXVhcmUodGhpcy5zdGFnZXMqbGVuZ3RoKTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgbGV0IF90ID0gdCArIHRoaXMuY1tpXSp0aGlzLnN0ZXA7XHJcbiAgICAgICAgICAgIGxldCBfeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspXHJcbiAgICAgICAgICAgICAgICBfeC5hZGRTZWxmKHZlY3Rvci5zY2FsZShreFtqXSx0aGlzLmFbaV1bal0qdGhpcy5zdGVwKSk7XHJcbiAgICAgICAgICAgIGxldCBkZmR4ID0gc3lzdGVtLmRmZHgoX3gsa3hbaV0sa3pbaV0sX3QpO1xyXG4gICAgICAgICAgICBsZXQgZGZkZHggPSBzeXN0ZW0uZGZkZHgoX3gsa3hbaV0sa3pbaV0sX3QpO1xyXG4gICAgICAgICAgICBsZXQgZGZkeiA9IHN5c3RlbS5kZmR6KF94LGt4W2ldLGt6W2ldLF90KTtcclxuICAgICAgICAgICAgbGV0IGRnZHggPSBzeXN0ZW0uZGdkeChfeCxreltpXSxfdCk7XHJcbiAgICAgICAgICAgIGxldCBkZ2R6ID0gc3lzdGVtLmRnZHooX3gsa3pbaV0sX3QpO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChkZmRkeCxpKmxlbmd0aCxpKmxlbmd0aCk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KGRmZHosaSpsZW5ndGgsaSpsZW5ndGgrc3lzdGVtLmxlbmd0aF94KCkpO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChkZ2R6LGkqbGVuZ3RoK3N5c3RlbS5sZW5ndGhfeCgpLGkqbGVuZ3RoK3N5c3RlbS5sZW5ndGhfeCgpKTtcclxuICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspe1xyXG4gICAgICAgICAgICAgICAgSi5zdWJTdWJNYXRyaXgoZGZkeC5zY2FsZVNlbGYodGhpcy5zdGVwKnRoaXMuYVtpXVtqXSksaSpsZW5ndGgsaipsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgSi5zdWJTdWJNYXRyaXgoZGdkeC5zY2FsZVNlbGYodGhpcy5zdGVwKnRoaXMuYVtpXVtqXSksaSpsZW5ndGgrc3lzdGVtLmxlbmd0aF94KCksaipsZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IHN5c3RlbS5sZW5ndGhfeCgpK3N5c3RlbS5sZW5ndGhfeigpO1xyXG4gICAgICAgIGxldCBreDp2ZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIGxldCBrejp2ZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAga3gucHVzaCh2ZWN0b3IuZW1wdHkoc3lzdGVtLmxlbmd0aF94KCkpKTtcclxuICAgICAgICAgICAga3oucHVzaCh6LmNsb25lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgRjp2ZWN0b3IgPSB0aGlzLmZ1bmN0aW9uKGt4LGt6LHgseix0LHN5c3RlbSk7XHJcbiAgICAgICAgbGV0IGYwbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICBmb3IobGV0IGl0ID0gMDtpdDx0aGlzLnN5c3RlbVNvbHZlci5nZXRJdGVyYXRpb25zKCk7aXQrKyl7XHJcbiAgICAgICAgICAgIGxldCBKOm1hdHJpeCA9IHRoaXMuamFjb2JpTWF0cml4KGt4LGt6LHgseix0LHN5c3RlbSk7XHJcbiAgICAgICAgICAgIGxldCBkayA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuc3lzdGVtU29sdmVyLmdldEFscGhhKCkpKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLnN0YWdlcztpKyspe1xyXG4gICAgICAgICAgICAgICAga3hbaV0uYWRkU2VsZihkay5nZXRTdWJWZWN0b3IoaSpsZW5ndGgsc3lzdGVtLmxlbmd0aF94KCkpKTtcclxuICAgICAgICAgICAgICAgIGt6W2ldLmFkZFNlbGYoZGsuZ2V0U3ViVmVjdG9yKGkqbGVuZ3RoK3N5c3RlbS5sZW5ndGhfeCgpLHN5c3RlbS5sZW5ndGhfeigpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRiA9IHRoaXMuZnVuY3Rpb24oa3gsa3oseCx6LHQsc3lzdGVtKTtcclxuICAgICAgICAgICAgbGV0IGZub3JtID0gRi5ub3JtMigpO1xyXG5cclxuICAgICAgICAgICAgaWYoaXQ+PXRoaXMuc3lzdGVtU29sdmVyLmdldE1pbkl0ZXJhdGlvbnMoKSYmZm5vcm08dGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0QWJzVG9sKCkrdGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0UmVsVG9sKCkqZjBub3JtKXtcclxuICAgICAgICAgICAgICAgIGxldCB4TmV3ID0geC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBqPTA7ajx0aGlzLnN0YWdlcztqKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIHhOZXcuYWRkU2VsZihreFtqXS5zY2FsZVNlbGYodGhpcy5zdGVwICogdGhpcy5iW2pdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgdE5ldyA9IHQgKyB0aGlzLnN0ZXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHRoaXMuc29sdmVfeih4TmV3LGt6W3RoaXMuc3RhZ2VzLTFdLHROZXcsc3lzdGVtKSx0TmV3KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBpbXBsaWNpdCByayBtZXRob2RzIHdpdGggYWRhcHRpdmUgc3RlcCBmb3IgaW1wbGljaXQgZGFlIG9mIGluZGV4IDFcclxuICovXHJcbmFic3RyYWN0IGNsYXNzIElEQUVfSVJLQSBleHRlbmRzIElEQUVfSVJLe1xyXG4gICAgcHJvdGVjdGVkIF9iOm51bWJlcltdO1xyXG4gICAgcHJvdGVjdGVkIGVycm9yT3JkZXI6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGVycm9yVG9sZXJhbmNlOm51bWJlcjtcclxuICAgIHByb3RlY3RlZCBtaW5TdGVwOm51bWJlcjtcclxuICAgIHByb3RlY3RlZCBtYXhTdGVwOm51bWJlcjtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLFxyXG4gICAgICAgIGVycm9yT3JkZXI6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixcclxuICAgICAgICBzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyLFxyXG4gICAgICAgIGE6bnVtYmVyW11bXSxiOm51bWJlcltdLGM6bnVtYmVyW10sX2I6bnVtYmVyW10sc3RhZ2VzOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsYSxiLGMsc3RhZ2VzKTtcclxuICAgICAgICB0aGlzLl9iID0gX2I7XHJcbiAgICAgICAgdGhpcy5lcnJvck9yZGVyID0gZXJyb3JPcmRlcjtcclxuICAgICAgICB0aGlzLmVycm9yVG9sZXJhbmNlID0gZXJyb3JUb2xlcmFuY2U7XHJcbiAgICAgICAgdGhpcy5taW5TdGVwID0gc3RlcDtcclxuICAgICAgICB0aGlzLm1heFN0ZXAgPSBtYXhTdGVwO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcbiAgICAgICAgLy90aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICAgICAgICB3aGlsZSh0cnVlKXtcclxuICAgICAgICAgICAgbGV0IHNob3VsZFRocm93ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBzeXN0ZW0ubGVuZ3RoX3goKStzeXN0ZW0ubGVuZ3RoX3ooKTtcclxuICAgICAgICAgICAgbGV0IGt4OnZlY3RvcltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBrejp2ZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuc3RhZ2VzO2krKyl7XHJcbiAgICAgICAgICAgICAgICBreC5wdXNoKHZlY3Rvci5lbXB0eShzeXN0ZW0ubGVuZ3RoX3goKSkpO1xyXG4gICAgICAgICAgICAgICAga3oucHVzaCh6LmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBGOnZlY3RvciA9IHRoaXMuZnVuY3Rpb24oa3gsa3oseCx6LHQsc3lzdGVtKTtcclxuICAgICAgICAgICAgbGV0IGYwbm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpdCA9IDA7aXQ8dGhpcy5zeXN0ZW1Tb2x2ZXIuZ2V0SXRlcmF0aW9ucygpO2l0Kyspe1xyXG4gICAgICAgICAgICAgICAgbGV0IEo6bWF0cml4ID0gdGhpcy5qYWNvYmlNYXRyaXgoa3gsa3oseCx6LHQsc3lzdGVtKTtcclxuICAgICAgICAgICAgICAgIGxldCBkayA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuc3lzdGVtU29sdmVyLmdldEFscGhhKCkpKTtcclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5zdGFnZXM7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICBreFtpXS5hZGRTZWxmKGRrLmdldFN1YlZlY3RvcihpKmxlbmd0aCxzeXN0ZW0ubGVuZ3RoX3goKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGt6W2ldLmFkZFNlbGYoZGsuZ2V0U3ViVmVjdG9yKGkqbGVuZ3RoK3N5c3RlbS5sZW5ndGhfeCgpLHN5c3RlbS5sZW5ndGhfeigpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBGID0gdGhpcy5mdW5jdGlvbihreCxreix4LHosdCxzeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZub3JtID0gRi5ub3JtMigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGl0Pj10aGlzLnN5c3RlbVNvbHZlci5nZXRNaW5JdGVyYXRpb25zKCkmJmZub3JtPHRoaXMuc3lzdGVtU29sdmVyLmdldEFic1RvbCgpK3RoaXMuc3lzdGVtU29sdmVyLmdldFJlbFRvbCgpKmYwbm9ybSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSB2ZWN0b3IuZW1wdHkoeC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLl9iLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmZXJlbmNlLmFkZFNlbGYodmVjdG9yLnNjYWxlKGt4W2ldLHRoaXMuX2JbaV0tdGhpcy5iW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZOb3JtID0gZGlmZmVyZW5jZS5ub3JtMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGVwT3B0PU1hdGgucG93KHRoaXMuZXJyb3JUb2xlcmFuY2UqMC41L2RpZk5vcm0sMS90aGlzLmVycm9yT3JkZXIpKnRoaXMuc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZihpc05hTihzdGVwT3B0KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBPcHQ9dGhpcy5taW5TdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGVwT3B0PU1hdGgubWluKE1hdGgubWF4KHRoaXMubWluU3RlcCxzdGVwT3B0KSx0aGlzLm1heFN0ZXApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN0ZXBPcHQqMjx0aGlzLnN0ZXApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZXA9c3RlcE9wdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGhyb3cgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcCA9IHN0ZXBPcHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhOZXcgPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHROZXcgPSB0ICsgdGhpcy5zdGVwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaj0wO2o8dGhpcy5zdGFnZXM7aisrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeE5ldy5hZGRTZWxmKGt4W2pdLnNjYWxlU2VsZih0aGlzLnN0ZXAgKiB0aGlzLmJbal0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeE5ldyx0aGlzLnNvbHZlX3ooeE5ldyxrelt0aGlzLnN0YWdlcy0xXSx0TmV3LHN5c3RlbSksdE5ldyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hvdWxkVGhyb3cpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogY2xhc3NpYyBSSzRcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJREFFX1JLNCBleHRlbmRzIElEQUVfRVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFswLjVdLFxyXG4gICAgICAgICAgICAgICAgWzAsMC41XSxcclxuICAgICAgICAgICAgICAgIFswLDAsMV1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvNiwxLzMsMS8zLDEvNl0sXHJcbiAgICAgICAgICAgIFswLDAuNSwwLjUsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9SSzRfMiBleHRlbmRzIElEQUVfRVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzNdLFxyXG4gICAgICAgICAgICAgICAgWy0xLzMsMV0sXHJcbiAgICAgICAgICAgICAgICBbMSwtMSwxXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS84LDMvOCwzLzgsMS84XSxcclxuICAgICAgICAgICAgWzAsMS8zLDIvMywxXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX1JLNF9SQUxTVE9OIGV4dGVuZHMgSURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzAuNF0sXHJcbiAgICAgICAgICAgICAgICBbMC4yOTY5Nzc2MSwwLjE1ODc1OTY0XSxcclxuICAgICAgICAgICAgICAgIFswLjIxODEwMDQsLTMuMDUwOTY1MTYsMy44MzI4NjQ3Nl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzAuMTc0NzYwMjgsLTAuNTUxNDgwNjYsMS4yMDU1MzU2MCwwLjE3MTE4NDc4XSxcclxuICAgICAgICAgICAgWzAsMC40LDAuNDU1NzM3MjUsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9SSzYgZXh0ZW5kcyBJREFFX0VSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMi81XSxcclxuICAgICAgICAgICAgICAgIFswLDQvNV0sXHJcbiAgICAgICAgICAgICAgICBbMTY5LzE0NTgsMTEwLzcyOSwtNjUvMTQ1OF0sXHJcbiAgICAgICAgICAgICAgICBbLTQ0LzY3NSwtODgvMTM1LDc2LzM1MSwzMzYvMzI1XSxcclxuICAgICAgICAgICAgICAgIFsyMS8xMDYsMCwtMTA1LzY4OSwtMzI0LzY4OSw0NS8xMDZdLFxyXG4gICAgICAgICAgICAgICAgWy0yNTE3LzQ4NjQsLTU1LzM4LDEwNjE1LzMxNjE2LDU2Ny83OTA0LDcyNDUvNDg2NCwyNTk3LzI0MzJdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFswLDAsMTM3NS80OTkyLDY1NjEvMjAzODQsMzM3NS8xMjU0NCw1My83NjgsMTkvMjk0XSxcclxuICAgICAgICAgICAgWzAsMi81LDQvNSwyLzksOC8xNSwwLDFdXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcblxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX1JLNl8yIGV4dGVuZHMgSURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvM10sXHJcbiAgICAgICAgICAgICAgICBbMCwyLzNdLFxyXG4gICAgICAgICAgICAgICAgWzEvMTIsMS8zLC0xLzEyXSxcclxuICAgICAgICAgICAgICAgIFsyNS80OCwtNTUvMjQsMzUvNDgsMTUvOF0sXHJcbiAgICAgICAgICAgICAgICBbMy8yMCwtMTEvMjQsLTEvOCwxLzIsMS8xMF0sXHJcbiAgICAgICAgICAgICAgICBbLTI2MS8yNjAsMzMvMTMsNDMvMTU2LC0xMTgvMzksMzIvMTk1LDgwLzM5XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMTMvMjAwLDAsMTEvNDAsMTEvNDAsNC8yNSw0LzI1LDEzLzIwMF0sXHJcbiAgICAgICAgICAgIFswLDEvMywyLzMsMS8zLDUvNiwxLzYsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbn1cclxuZXhwb3J0IGNsYXNzIElEQUVfUks4IGV4dGVuZHMgSURBRV9FUkt7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICB2YXIgcm9vdDIxPU1hdGguc3FydCgyMSk7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzJdLFxyXG4gICAgICAgICAgICAgICAgWzEvNCwxLzRdLFxyXG4gICAgICAgICAgICAgICAgWzEvNywoLTctMypyb290MjEpLzk4LDAsKDIxKzUqcm9vdDIxKS80OV0sXHJcbiAgICAgICAgICAgICAgICBbKDExK3Jvb3QyMSkvODQsMCwoMTgrNCpyb290MjEpLzYzLCgyMS1yb290MjEpLzI1Ml0sXHJcbiAgICAgICAgICAgICAgICBbKDUrcm9vdDIxKS80OCwwLCg5K3Jvb3QyMSkvMzYsKC0yMzErMTQqcm9vdDIxKS8zNjAsKDYzLTcqcm9vdDIxKS84MF0sXHJcbiAgICAgICAgICAgICAgICBbKDEwLXJvb3QyMSkvNDIsMCwoLTQzMis5Mipyb290MjEpLzMxNSwoNjMzLTE0NSpyb290MjEpLzkwLCgtNTAzKzExNSpyb290MjEpLzcwLCg2My0xMypyb290MjEpLzM1XSxcclxuICAgICAgICAgICAgICAgIFsxLzE0LDAsMCwwLCgxNC0zKnJvb3QyMSkvMTI2LCgxMy0zKnJvb3QyMSkvNjMsMS85XSxcclxuICAgICAgICAgICAgICAgIFsxLzMyLDAsMCwwLCg5MS0yMSpyb290MjEpLzU3NiwxMS83MiwoLTM4NS03NSpyb290MjEpLzExNTIsKDYzKzEzKnJvb3QyMSkvMTI4XSxcclxuICAgICAgICAgICAgICAgIFsxLzE0LDAsMCwwLDEvOSwoLTczMy0xNDcqcm9vdDIxKS8yMjA1LCg1MTUrMTExKnJvb3QyMSkvNTA0LCgtNTEtMTEqcm9vdDIxKS81NiwoMTMyKzI4KnJvb3QyMSkvMjQ1XSxcclxuICAgICAgICAgICAgICAgIFswLDAsMCwwLCgtNDIrNypyb290MjEpLzE4LCgtMTgrMjgqcm9vdDIxKS80NSwoLTI3My01Mypyb290MjEpLzcyLCgzMDErNTMqcm9vdDIxKS83MiwoMjgtMjgqcm9vdDIxKS80NSwoNDktNypyb290MjEpLzE4XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yMCwwLDAsMCwwLDAsMCw0OS8xODAsMTYvNDUsNDkvMTgwLDEvMjBdLFxyXG4gICAgICAgICAgICBbMCwxLzIsMS8yLCg3K3Jvb3QyMSkvMTQsKDcrcm9vdDIxKS8xNCwxLzIsKDctcm9vdDIxKS8xNCxcclxuICAgICAgICAgICAgICAgICg3LXJvb3QyMSkvMTQsMS8yLCg3K3Jvb3QyMSkvMTQsMV1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9ET1BSSTUgZXh0ZW5kcyBJREFFX0VSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDUsZXJyb3JUb2xlcmFuY2Usc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS81XSxcclxuICAgICAgICAgICAgICAgIFszLzQwLDkvNDBdLFxyXG4gICAgICAgICAgICAgICAgWzQ0LzQ1LC01Ni8xNSwgMzIvOV0sXHJcbiAgICAgICAgICAgICAgICBbMTkzNzIvNjU2MSwtMjUzNjAvMjE4NywgNjQ0NDgvNjU2MSwtMjEyLzcyOV0sXHJcbiAgICAgICAgICAgICAgICBbOTAxNy8zMTY4LC0zNTUvMzMsIDQ2NzMyLzUyNDcsNDkvMTc2LC01MTAzLzE4NjU2XSxcclxuICAgICAgICAgICAgICAgIFszNS8zODQsMCw1MDAvMTExMywxMjUvMTkyLC0yMTg3LzY3ODQsMTEvODRdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFszNS8zODQsMCw1MDAvMTExMywxMjUvMTkyLC0yMTg3LzY3ODQsMTEvODQsMF0sXHJcbiAgICAgICAgICAgIFswLDEvNSwzLzEwLDQvNSw4LzksMSwxXSxcclxuICAgICAgICAgICAgWzUxNzkvNTc2MDAsMCw3NTcxLzE2Njk1LDM5My82NDAsLTkyMDk3LzMzOTIwMCwxODcvMjEwMCwxLzQwXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCb2dhY2tpU2hhbXBpbmUyM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElEQUVfQlMyMyBleHRlbmRzIElEQUVfRVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsMyxlcnJvclRvbGVyYW5jZSxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzJdLFxyXG4gICAgICAgICAgICAgICAgWzAsMy80XSxcclxuICAgICAgICAgICAgICAgIFsyLzksMS8zLCA0LzldXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsyLzksMS8zLDQvOSwwXSxcclxuICAgICAgICAgICAgWzAsMC41LDAuNzUsMV0sXHJcbiAgICAgICAgICAgIFs3LzI0LDEvNCwxLzMsMS84XVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX0hldW5FdWxlciBleHRlbmRzIElEQUVfRVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsMixlcnJvclRvbGVyYW5jZSxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yLDEvMl0sXHJcbiAgICAgICAgICAgIFswLDFdLFxyXG4gICAgICAgICAgICBbMSwwXVxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX01pZHBvaW50RXVsZXIgZXh0ZW5kcyBJREFFX0VSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDIsZXJyb3JUb2xlcmFuY2Usc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS8yXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMCwxXSxcclxuICAgICAgICAgICAgWzAsMC41XSxcclxuICAgICAgICAgICAgWzEsMF1cclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIElEQUVfUkFEQVVJQTUgZXh0ZW5kcyBJREFFX0lSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIGxldCByb290Nj1NYXRoLnNxcnQoNik7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzksKC0xLXJvb3Q2KS8xOCwoLTErcm9vdDYpLzE4XSxcclxuICAgICAgICAgICAgICAgIFsxLzksKDg4Kzcqcm9vdDYpLzM2MCwoODgtNDMqcm9vdDYpLzM2MF0sXHJcbiAgICAgICAgICAgICAgICBbMS85LCg4OCs0Mypyb290NikvMzYwLCg4MC03KnJvb3Q2KS8zNjBdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsxLzksKDE2K3Jvb3Q2KS8zNiwoMTYtcm9vdDYpLzM2XSxcclxuICAgICAgICAgICAgWzAsKDYtcm9vdDYpLzEwLCg2K3Jvb3Q2KS8xMF0sXHJcbiAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9SQURBVUlJQTMgZXh0ZW5kcyBJREFFX0lSS3tcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIGxldCByb290Nj1NYXRoLnNxcnQoNik7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFs1LzEyLC0xLzEyXSxcclxuICAgICAgICAgICAgICAgIFszLzQsMS80XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMy80LDEvNF0sXHJcbiAgICAgICAgICAgIFsxLzMsMV0sXHJcbiAgICAgICAgICAgIDJcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxuICAgIFxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX1JBREFVSUlBNSBleHRlbmRzIElEQUVfSVJLe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgbGV0IHJvb3Q2PU1hdGguc3FydCg2KTtcclxuICAgICAgICBzdXBlcihzdGVwLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzExLzQ1LTcqcm9vdDYvMzYwLDM3LzIyNS0xNjkqcm9vdDYvMTgwMCwtMi8yMjUrcm9vdDYvNzVdLFxyXG4gICAgICAgICAgICAgICAgWzM3LzIyNSsxNjkqcm9vdDYvMTgwMCwxMS80NSs3KnJvb3Q2LzM2MCwtMi8yMjUtcm9vdDYvNzVdLFxyXG4gICAgICAgICAgICAgICAgWzQvOS1yb290Ni8zNiw0Lzkrcm9vdDYvMzYsMS85XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbNC85LXJvb3Q2LzM2LDQvOStyb290Ni8zNiwxLzldLFxyXG4gICAgICAgICAgICBbMi81LXJvb3Q2LzEwLDIvNStyb290Ni8xMCwxXSxcclxuICAgICAgICAgICAgM1xyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuLyoqXHJcbiAqIEVtYmVkZGVkIGdhdXNzLWxlZ2VuZHJlIDR0aCBvcmRlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIElEQUVfR0FVU1NMRUdFTkRSRTQgZXh0ZW5kcyBJREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsXHJcbiAgICAgICAgc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgbGV0IHNxcnQzID0gTWF0aC5zcXJ0KDMpOyBcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsNCxlcnJvclRvbGVyYW5jZSxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFsxLzQsMS80LXNxcnQzLzZdLFxyXG4gICAgICAgICAgICAgICAgWzEvNCtzcXJ0My82LDEvNF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzAuNSwwLjVdLFxyXG4gICAgICAgICAgICBbKDMtc3FydDMpLzYsKDMrc3FydDMpLzZdLFxyXG4gICAgICAgICAgICBbKDErc3FydDMpLzIsKDEtc3FydDMpLzJdLDJcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRW1iZWRkZWQgZ2F1c3MtbGVnZW5kcmUgNnRoIG9yZGVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSURBRV9HQVVTU0xFR0VORFJFNiBleHRlbmRzIElEQUVfSVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixcclxuICAgICAgICBzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBsZXQgc3FydDE1ID0gTWF0aC5zcXJ0KDE1KTsgXHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDYsZXJyb3JUb2xlcmFuY2Usc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbNS8zNiwyLzktc3FydDE1LzE1LDUvMzYtc3FydDE1LzMwXSxcclxuICAgICAgICAgICAgICAgIFs1LzM2K3NxcnQxNS8yNCwyLzksNS8zNiwtc3FydDE1LzI0XSxcclxuICAgICAgICAgICAgICAgIFs1LzM2K3NxcnQxNS8zMCwyLzkrc3FydDE1LzE1LDUvMzZdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFs1LzE4LDQvOSw1LzE4XSxcclxuICAgICAgICAgICAgWzAuNS1zcXJ0MTUvMTAsMC41LDAuNStzcXJ0MTUvMTBdLFxyXG4gICAgICAgICAgICBbLTUvNiw4LzMsLTUvNl0sXHJcbiAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9MT0JBVFRPSUlJQTIgZXh0ZW5kcyBJREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsXHJcbiAgICAgICAgc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDIsZXJyb3JUb2xlcmFuY2Usc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMCwwXSxcclxuICAgICAgICAgICAgICAgIFsxLzIsMS8yXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS8yLDEvMl0sXHJcbiAgICAgICAgICAgIFswLDFdLFxyXG4gICAgICAgICAgICBbMSwwXSxcclxuICAgICAgICAgICAgMlxyXG4gICAgICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBJREFFX0xPQkFUVE9JSUlBNCBleHRlbmRzIElEQUVfSVJLQXtcclxuICAgIGNvbnN0cnVjdG9yKHN0ZXA6bnVtYmVyLG1heFN0ZXA6bnVtYmVyLGVycm9yVG9sZXJhbmNlOm51bWJlcixcclxuICAgICAgICBzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICBzdXBlcihzdGVwLG1heFN0ZXAsNCxlcnJvclRvbGVyYW5jZSxzeXN0ZW1Tb2x2ZXIsXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgIFswLDAsMF0sXHJcbiAgICAgICAgICAgICAgICBbNS8yNCwxLzMsLTEvMjRdLFxyXG4gICAgICAgICAgICAgICAgWzEvNiwyLzMsMS8zNl1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvNiwyLzMsMS82XSxcclxuICAgICAgICAgICAgWzAsMC41LDFdLFxyXG4gICAgICAgICAgICBbLTEvMiwyLC0xLzJdLFxyXG4gICAgICAgICAgICAzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIElEQUVfTE9CQVRUT0lJSUIyIGV4dGVuZHMgSURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLFxyXG4gICAgICAgIHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCwyLGVycm9yVG9sZXJhbmNlLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvMiwwXSxcclxuICAgICAgICAgICAgICAgIFsxLzIsMF1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgWzEvMiwxLzJdLFxyXG4gICAgICAgICAgICBbMS8yLDEvMl0sXHJcbiAgICAgICAgICAgIFsxLDBdLFxyXG4gICAgICAgICAgICAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIElEQUVfTE9CQVRUT0lJSUI0IGV4dGVuZHMgSURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLFxyXG4gICAgICAgIHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCw0LGVycm9yVG9sZXJhbmNlLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvNiwtMS82LDBdLFxyXG4gICAgICAgICAgICAgICAgWzEvNiwxLzMsMF0sXHJcbiAgICAgICAgICAgICAgICBbMS82LDUvNiwwXVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS82LDIvMywxLzZdLFxyXG4gICAgICAgICAgICBbMCwwLjUsMV0sXHJcbiAgICAgICAgICAgIFstMS8yLDIsLTEvMl0sXHJcbiAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSURBRV9MT0JBVFRPSUlJQzIgZXh0ZW5kcyBJREFFX0lSS0F7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixtYXhTdGVwOm51bWJlcixlcnJvclRvbGVyYW5jZTpudW1iZXIsXHJcbiAgICAgICAgc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgc3VwZXIoc3RlcCxtYXhTdGVwLDIsZXJyb3JUb2xlcmFuY2Usc3lzdGVtU29sdmVyLFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICBbMS8yLC0xLzJdLFxyXG4gICAgICAgICAgICAgICAgWzEvMiwxLzJdXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFsxLzIsMS8yXSxcclxuICAgICAgICAgICAgWzAsMV0sXHJcbiAgICAgICAgICAgIFsxLDBdLFxyXG4gICAgICAgICAgICAyXHJcbiAgICAgICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIElEQUVfTE9CQVRUT0lJSUM0IGV4dGVuZHMgSURBRV9JUktBe1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsbWF4U3RlcDpudW1iZXIsZXJyb3JUb2xlcmFuY2U6bnVtYmVyLFxyXG4gICAgICAgIHN5c3RlbVNvbHZlcjpOZXd0b25Tb2x2ZXIpe1xyXG4gICAgICAgIHN1cGVyKHN0ZXAsbWF4U3RlcCw0LGVycm9yVG9sZXJhbmNlLHN5c3RlbVNvbHZlcixcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgWzEvNiwtMS8zLDEvNl0sXHJcbiAgICAgICAgICAgICAgICBbMS82LDUvMTIsLTEvMTJdLFxyXG4gICAgICAgICAgICAgICAgWzEvNiwyLzMsMS82XVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbMS82LDIvMywxLzZdLFxyXG4gICAgICAgICAgICBbMCwwLjUsMV0sXHJcbiAgICAgICAgICAgIFstMS8yLDIsLTEvMl0sXHJcbiAgICAgICAgICAgIDNcclxuICAgICAgICAgICAgKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7XHJcbiAgICBEQUVWZWN0b3JcclxufSBmcm9tIFwiLi4vLi4vZGFlVmVjdG9yXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi4vLi4vaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFU3lzdGVtIH0gZnJvbSBcIi4uLy4uL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uLy4uLy4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBnYXVzcyB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL2dhdXNzXCI7XHJcbmltcG9ydCB7IE5ld3RvblNvbHZlciB9IGZyb20gXCIuLi8uLi8uLi9tYXRoL25ld3RvblwiO1xyXG4vKlxyXG5leHBsaWNpdFxyXG4gICAgeF97bisxfSA9IHhfbiArIDAuNSpoKGYoeF9uLHRfbikrZih4X24raGYoeF9uLHRfbiksdF97bisxfSkpXHJcbiAgICB7XHJcbiAgICAgICAgMS4gIGYoeF9uLGtfMSx6X24sdF9uKSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeFxyXG4gICAgICAgIDIuICBnKHhfbitoa18xLHpeMV9uLHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE56XHJcbiAgICAgICAgMy4gIGYoeF9uK2hrXzEsa18yLHpeMV9uLHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54XHJcbiAgICAgICAgNC4gIHhfe24rMX0gPSB4X24gKyAwLjUqaChrXzEgKyBrXzIpXHJcbiAgICAgICAgZXhwbGljaXQgTnhcclxuICAgICAgICA1LiAgZyh4X3tuKzF9LHpfe24rMX0sdF97bisxfSkgPSAwXHJcbiAgICAgICAgaW1wbGljaXQgTnpcclxuICAgIH1cclxuaW1wbGljaXRcclxuICAgIHhfe24rMX0gPSB4X24gKyAwLjUqaChmKHhfbix0X24pK2YoeF97bisxfS50X3tuKzF9KSlcclxuICAgIHtcclxuICAgICAgICAxLiAgZih4X24sa18xLHpfbix0X24pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54XHJcbiAgICAgICAgMi4gIGcoeF97bisxfSx6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgICAgICBmKHhfe24rMX0sKHhfe24rMX0teF9uKS8oMmgpLWtfMSx6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54ICsgTnogc3lzdGVtXHJcbiAgICB9XHJcbiovXHJcblxyXG5cclxuLyoqXHJcbiAqIGV4cGxpY2l0IHRyYXBlem9pZGFsIG1ldGhvZCBmb3IgaW1wbGljaXQgZGFlIHdpdGggaW5kZXggb25lXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSURBRV9FVHJhcGV6b2lkYWwgZXh0ZW5kcyBJREFFU29sdmVye1xyXG4gICAgY29uc3RydWN0b3Ioc3RlcDpudW1iZXIsc3lzdGVtU29sdmVyOk5ld3RvblNvbHZlcil7XHJcbiAgICAgICAgICAgIHN1cGVyKHN0ZXAsc3lzdGVtU29sdmVyKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBtYWtlU3RlcCh4OiB2ZWN0b3IsIHo6IHZlY3RvciwgdDogbnVtYmVyLCBzeXN0ZW06IElEQUVTeXN0ZW0pOiBEQUVWZWN0b3Ige1xyXG4gICAgICAgIC8vMS4gICAgZih4X24sa18xLHpfbix0X24pID0gMFxyXG4gICAgICAgIGxldCB4MSA9IHRoaXMuc29sdmVfZHgoeCx6LHQsc3lzdGVtKS5zY2FsZVNlbGYodGhpcy5zdGVwKS5hZGRTZWxmKHgpO1xyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICAvLzIuICAgIGcoeF9uK2hrXzEsel4xX24sdF97bisxfSkgPSAwXHJcbiAgICAgICAgbGV0IHoxID0gdGhpcy5zb2x2ZV96KHgxLHosdE5ldyxzeXN0ZW0pO1xyXG4gICAgICAgIC8vMy4gICAgZih4X24raGtfMSxrXzIsel4xX24sdF97bisxfSkgPSAwXHJcbiAgICAgICAgbGV0IHgyID0gdGhpcy5zb2x2ZV9keCh4MSx6MSx0TmV3LHN5c3RlbSkuc2NhbGVTZWxmKHRoaXMuc3RlcCkuYWRkU2VsZih4KTtcclxuICAgICAgICAvLzQuICAgIHhfe24rMX0gPSB4X24gKyAwLjUqaChrXzEgKyBrXzIpXHJcbiAgICAgICAgbGV0IHhOZXcgPSB4MS5hZGRTZWxmKHgyKS5zY2FsZVNlbGYoMC41KTtcclxuICAgICAgICAvLzUuICAgIGcoeF97bisxfSx6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgIGxldCB6TmV3ID0gdGhpcy5zb2x2ZV96KHhOZXcsejEsdE5ldyxzeXN0ZW0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgREFFVmVjdG9yKHhOZXcsek5ldyx0TmV3KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogaW1wbGljaXQgdHJhcGV6b2lkYWwgbWV0aG9kIGZvciBpbXBsaWNpdCBkYWUgd2l0aCBpbmRleCBvbmVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBJREFFX0lUcmFwZXpvaWRhbCBleHRlbmRzIElEQUVTb2x2ZXJ7XHJcbiAgICBwcm90ZWN0ZWQgc3RlcFNvbHZlcjpOZXd0b25Tb2x2ZXI7XHJcbiAgICBjb25zdHJ1Y3RvcihzdGVwOm51bWJlcixzeXN0ZW1Tb2x2ZXI6TmV3dG9uU29sdmVyLHN0ZXBTb2x2ZXI6TmV3dG9uU29sdmVyKXtcclxuICAgICAgICAgICAgc3VwZXIoc3RlcCxzeXN0ZW1Tb2x2ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBTb2x2ZXIgPSBzdGVwU29sdmVyO1xyXG4gICAgfVxyXG4gICAgLyp4X3tuKzF9ID0geF9uICsgMC41KmgoZih4X24sdF9uKStmKHhfe24rMX0udF97bisxfSkpXHJcbiAgICB7XHJcbiAgICAgICAgMS4gIGYoeF9uLGtfMSx6X24sdF9uKSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeFxyXG4gICAgICAgIDIuICBGeCA9IGYoeF97bisxfSwoeF97bisxfS14X24pKjIvaC1rXzEsel97bisxfSx0X3tuKzF9KSA9IDBcclxuICAgICAgICAgICAgRnogPSBnKHhfe24rMX0sel97bisxfSx0X3tuKzF9KSA9IDBcclxuICAgICAgICBpbXBsaWNpdCBOeCArIE56IHN5c3RlbVxyXG4gICAgICAgIGRGeC9keF97bisxfSA9IGRmL2R4ICsgZGYvZGR4ICoyL2hcclxuICAgICAgICBkRngvZHpfe24rMX0gPSBkZi9kelxyXG4gICAgICAgIGRGei9keF97bisxfSA9IGRnL2R4XHJcbiAgICAgICAgZEZ6L2R6X3tuKzF9ID0gZGcvZHpcclxuICAgIH0qL1xyXG4gICAgcHVibGljIG1ha2VTdGVwKHg6IHZlY3RvciwgejogdmVjdG9yLCB0OiBudW1iZXIsIHN5c3RlbTogSURBRVN5c3RlbSk6IERBRVZlY3RvciB7XHJcblxyXG4gICAgICAgIC8qbGV0IGsxID0gdGhpcy5zb2x2ZV9keCh4LHosdCxzeXN0ZW0pO1xyXG4gICAgICAgIGxldCB4ejAgPSB2ZWN0b3IuY29uY2F0KFt4LmNsb25lKCkuYWRkU2VsZih2ZWN0b3Iuc2NhbGUoazEsdGhpcy5zdGVwKSksel0pO1xyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgeHpOZXcgPSB0aGlzLnN0ZXBTb2x2ZXIuc29sdmUoKHh6TmV3OnZlY3Rvcik9PntcclxuICAgICAgICAgICAgbGV0IHhOZXcgPSB4ek5ldy5nZXRTdWJWZWN0b3IoMCxzeXN0ZW0ubGVuZ3RoX3goKSk7XHJcbiAgICAgICAgICAgIGxldCB6TmV3ID0geHpOZXcuZ2V0U3ViVmVjdG9yKHN5c3RlbS5sZW5ndGhfeCgpLHN5c3RlbS5sZW5ndGhfeigpKTtcclxuICAgICAgICAgICAgbGV0IGR4ID0gdmVjdG9yLnN1Yih4TmV3LHgpLnNjYWxlKDIvdGhpcy5zdGVwKS5zdWIoazEpO1xyXG5cclxuICAgICAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5mKHhOZXcsZHgsek5ldyx0TmV3KSwwKTtcclxuICAgICAgICAgICAgRi5hZGRTdWJWZWN0b3Ioc3lzdGVtLmcoeE5ldyx6TmV3LHROZXcpLHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gRjtcclxuXHJcbiAgICAgICAgfSwoeHpOZXc6dmVjdG9yKT0+e1xyXG4gICAgICAgICAgICBsZXQgeE5ldyA9IHh6TmV3LmdldFN1YlZlY3RvcigwLHN5c3RlbS5sZW5ndGhfeCgpKTtcclxuICAgICAgICAgICAgbGV0IHpOZXcgPSB4ek5ldy5nZXRTdWJWZWN0b3Ioc3lzdGVtLmxlbmd0aF94KCksc3lzdGVtLmxlbmd0aF96KCkpO1xyXG4gICAgICAgICAgICBsZXQgZHggPSB2ZWN0b3Iuc3ViKHhOZXcseCkuc2NhbGUoMi90aGlzLnN0ZXApLnN1YihrMSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBtYXRyaXguZW1wdHlTcXVhcmUoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHgoeE5ldyxkeCx6TmV3LHROZXcpLmFkZFNlbGYoc3lzdGVtLmRmZGR4KHhOZXcsZHgsek5ldyx0TmV3KS5zY2FsZVNlbGYoMi90aGlzLnN0ZXApKSwwLDApO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChzeXN0ZW0uZGZkeih4TmV3LGR4LHpOZXcsdE5ldyksMCx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRnZHgoeE5ldyx6TmV3LHROZXcpLHgubGVuZ3RoKCksMCk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R6KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLHgubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gSjtcclxuICAgICAgICB9LHN5c3RlbS5sZW5ndGhfeCgpICsgc3lzdGVtLmxlbmd0aF96KCksIHh6MCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEQUVWZWN0b3IoeHpOZXcuZ2V0U3ViVmVjdG9yKDAsc3lzdGVtLmxlbmd0aF94KCkpLHh6TmV3LmdldFN1YlZlY3RvcihzeXN0ZW0ubGVuZ3RoX3goKSxzeXN0ZW0ubGVuZ3RoX3ooKSksdE5ldyk7Ki9cclxuXHJcbiAgICAvKnhfe24rMX0gPSB4X24gKyAwLjUqaChmKHhfbix0X24pK2YoeF97bisxfS50X3tuKzF9KSlcclxuICAgIHtcclxuICAgICAgICAxLiAgZih4X24sa18xLHpfbix0X24pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54XHJcbiAgICAgICAgMi4gIEZ4ID0gZih4X3tuKzF9LCh4X3tuKzF9LXhfbikqMi9oLWtfMSx6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgICAgICBGeiA9IGcoeF97bisxfSx6X3tuKzF9LHRfe24rMX0pID0gMFxyXG4gICAgICAgIGltcGxpY2l0IE54ICsgTnogc3lzdGVtXHJcbiAgICAgICAgZEZ4L2R4X3tuKzF9ID0gZGYvZHggKyBkZi9kZHggKjIvaFxyXG4gICAgICAgIGRGeC9kel97bisxfSA9IGRmL2R6XHJcbiAgICAgICAgZEZ6L2R4X3tuKzF9ID0gZGcvZHhcclxuICAgICAgICBkRnovZHpfe24rMX0gPSBkZy9kelxyXG4gICAgfSovXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8xLiAgICBmKHhfbixrXzEsel9uLHRfbikgPSAwXHJcbiAgICAgICAgbGV0IGsxID0gdGhpcy5zb2x2ZV9keCh4LHosdCxzeXN0ZW0pO1xyXG4gICAgICAgIGxldCB0TmV3ID0gdCArIHRoaXMuc3RlcDtcclxuICAgICAgICBsZXQgeE5ldyA9IHguY2xvbmUoKS5hZGRTZWxmKHZlY3Rvci5zY2FsZShrMSx0aGlzLnN0ZXApKTsvL2JldHRlciBhcHByb3hpbWF0aW9uIGZvciB4TmV3XHJcbiAgICAgICAgbGV0IHpOZXcgPSB6LmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGR4ID0gdmVjdG9yLnN1Yih4TmV3LHgpLnNjYWxlU2VsZigyL3RoaXMuc3RlcCkuc3ViU2VsZihrMSk7XHJcbiAgICAgICAgbGV0IEY6dmVjdG9yID0gdmVjdG9yLmVtcHR5KHgubGVuZ3RoKCkrei5sZW5ndGgoKSk7XHJcbiAgICAgICAgRi5hZGRTdWJWZWN0b3Ioc3lzdGVtLmYoeE5ldyxkeCx6TmV3LHROZXcpLDApO1xyXG4gICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5nKHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpKTtcclxuICAgICAgICBsZXQgZjBub3JtID0gRi5ub3JtMigpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5zdGVwU29sdmVyLmdldEl0ZXJhdGlvbnMoKTtpKyspe1xyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBtYXRyaXguZW1wdHlTcXVhcmUoeC5sZW5ndGgoKSt6Lmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZmR4KHhOZXcsZHgsek5ldyx0TmV3KS5hZGRTZWxmKHN5c3RlbS5kZmRkeCh4TmV3LGR4LHpOZXcsdE5ldykuc2NhbGVTZWxmKDIvdGhpcy5zdGVwKSksMCwwKTtcclxuICAgICAgICAgICAgSi5hZGRTdWJNYXRyaXgoc3lzdGVtLmRmZHooeE5ldyxkeCx6TmV3LHROZXcpLDAseC5sZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIEouYWRkU3ViTWF0cml4KHN5c3RlbS5kZ2R4KHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpLDApO1xyXG4gICAgICAgICAgICBKLmFkZFN1Yk1hdHJpeChzeXN0ZW0uZGdkeih4TmV3LHpOZXcsdE5ldykseC5sZW5ndGgoKSx4Lmxlbmd0aCgpKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBkeHogPSBnYXVzcy5zb2x2ZShKLEYuc2NhbGVTZWxmKC10aGlzLnN0ZXBTb2x2ZXIuZ2V0QWxwaGEoKSkpO1xyXG4gICAgICAgICAgICB4TmV3LmFkZFNlbGYoZHh6LmdldFN1YlZlY3RvcigwLHgubGVuZ3RoKCkpKTtcclxuICAgICAgICAgICAgek5ldy5hZGRTZWxmKGR4ei5nZXRTdWJWZWN0b3IoeC5sZW5ndGgoKSx6Lmxlbmd0aCgpKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkeCA9IHZlY3Rvci5zdWIoeE5ldyx4KS5zY2FsZVNlbGYoMi90aGlzLnN0ZXApLnN1YlNlbGYoazEpO1xyXG5cclxuICAgICAgICAgICAgRiA9IHZlY3Rvci5lbXB0eSh4Lmxlbmd0aCgpK3oubGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICBGLmFkZFN1YlZlY3RvcihzeXN0ZW0uZih4TmV3LGR4LHpOZXcsdE5ldyksMCk7XHJcbiAgICAgICAgICAgIEYuYWRkU3ViVmVjdG9yKHN5c3RlbS5nKHhOZXcsek5ldyx0TmV3KSx4Lmxlbmd0aCgpKTtcclxuICAgICAgICAgICAgbGV0IGZub3JtID0gRi5ub3JtMigpO1xyXG4gICAgICAgICAgICBpZihpPj10aGlzLnN0ZXBTb2x2ZXIuZ2V0TWluSXRlcmF0aW9ucygpJiZmbm9ybTx0aGlzLnN0ZXBTb2x2ZXIuZ2V0UmVsVG9sKCkrdGhpcy5zdGVwU29sdmVyLmdldEFic1RvbCgpKmYwbm9ybSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERBRVZlY3Rvcih4TmV3LHpOZXcsdE5ldyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2ZXJnZW5jZVwiKTtcclxuICAgIH1cclxufSIsIlxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBleGFtcGxlczp7ZGFlOlJlY29yZDxzdHJpbmcse25hbWU6c3RyaW5nLHRleHQ6c3RyaW5nfT4saHlicmlkOlJlY29yZDxzdHJpbmcse25hbWU6c3RyaW5nLHRleHQ6c3RyaW5nfT59ID0ge1xyXG4gICAgICAgIGRhZTp7XHJcbiAgICAgICAgICAgICAgICAvL2h0dHBzOi8vd3d3Lm1hdGh3b3Jrcy5jb20vaGVscC9tYXRsYWIvbWF0aC9zb2x2ZS1kaWZmZXJlbnRpYWwtYWxnZWJyYWljLWVxdWF0aW9ucy1kYWVzLmh0bWxcclxuICAgICAgICAgICAgICAgIFwicm9iZXJ0c29uLXByb2JsZW1cIjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTpcIlJvYmVydHNvbiBwcm9ibGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL2h0dHBzOi8vd3d3Lm1hdGh3b3Jrcy5jb20vaGVscC9tYXRsYWIvbWF0aC9zb2x2ZS1kaWZmZXJlbnRpYWwtYWxnZWJyYWljLWVxdWF0aW9ucy1kYWVzLmh0bWxcclxuLy9Sb2JlcnRzb24gcHJvYmxlbVxyXG5cclxueDEodDApID0gMTtcclxueDIodDApID0gMDtcclxueDEnPS0wLjA0KngxKzEwXjQqeDIqeDM7XHJcbngyJz0wLjA0LTFlNCp4Mip4My0zZTcqeDJeMjtcclxueDMgPSAxIC0geDEgLSB4MjtgXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwid2Vpc3NpbmdlclwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIldlaXNzaW5nZXIgaW1wbGljaXQgREVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL1dlaXNzaW5nZXIgaW1wbGljaXQgZGlmLiBlcS5cclxuLy90MCA9IDFcclxuXHJcbngodDApID0gc3FydCgzLzIpO1xyXG50ICogeF4yKmRlcih4KV4zIC0geF4zKmRlcih4KV4yICsgdCoodF4yKzEpKmRlcih4KS10KnQqeCA9IDA7XHJcbnogPSBzcXJ0KHQqdCswLjUpOyAgLy9leGFjdCBzb2x1dGlvbmBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInN0aWZmLWVxdWF0aW9uXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6XCJTdGlmZiBlcXVhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmAvL3N0aWZmIGVxdWF0aW9uXHJcblxyXG5jb25zdGFudCB4MCA9IDA7XHJcbmNvbnN0YW50IGEgPSAtMjE7XHJcbmNvbnN0YW50IGMxID0geDAgKyAxLyhhICsgMSk7XHJcblxyXG54JyA9IGEqeCtleHAoLXQpO1xyXG56ID0gYzEgKiBleHAoYSp0KSAtIGV4cCgtdCkvKGErMSk7Ly9hbmFseXRpY2FsIHNvbHV0aW9uXHJcbngodDApID0geDA7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwibG9yZW56LXN5c3RlbVwiOntcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOlwiTG9yZW56IHN5c3RlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmBcclxuLy9Mb3Jlbnogc3lzdGVtXHJcblxyXG5jb25zdGFudCBzaWdtYSA9IDEwO1xyXG5jb25zdGFudCByaG89Mjg7XHJcbmNvbnN0YW50IGJldGE9OC8zO1xyXG5cclxueCh0MCkgPSAxO1xyXG55KHQwKSA9IDE7XHJcbnoodDApID0gMTtcclxuXHJcbngnID0gc2lnbWEqICh5LXgpO1xyXG55JyA9IHggKiAocmhvIC0geikgLSB5O1xyXG56JyA9IHgqei1iZXRhKno7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiZGFscXVpc3QtZXF1YXRpb25cIjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkRhbHF1aXN0IGVxdWF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL0RhbHF1aXN0IGVxdWF0aW9uXHJcbi8vdDAgPSAwLCB0MSA9IDJcclxuXHJcbmNvbnN0YW50IGEgPSAyO1xyXG5jb25zdGFudCB4MCA9IDE7XHJcbmNvbnN0YW50IHQwID0gMDtcclxuXHJcbngodDApID0geDA7XHJcbngnID0gYSAqIHg7XHJcbnogPSB4MCpleHAoYSp4LWEqdDApOy8vYW5hbHl0aWMgc29sdXRpb25cclxuYFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwidmFuLWRlci1wb2wtb3NjaWxsYXRvclwiOntcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOlwiVmFuIGRlciBQb2wgb3NjaWxsYXRvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmBcclxuLy9WYW4gZGVyIFBvbCBvc2NpbGxhdG9yXHJcblxyXG5jb25zdGFudCBtdSA9IDIwO1xyXG5jb25zdGFudCBhID0gMDtcclxuY29uc3RhbnQgb21lZ2EgPSAxO1xyXG5cclxueDEodDApID0gMTtcclxueDIodDApID0gMDtcclxuXHJcbngxJyA9IHgyO1xyXG54MicgPSBtdSooMS14MSp4MSkqeDIteDEgKyBhKnNpbihvbWVnYSp0KTtgXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJpbXBsaWNpZCB2YW4tZGVyLXBvbFwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkltcGxpY2l0IFZhbiBkZXIgUG9sIG9zY2lsbGF0b3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL1ZhbiBkZXIgUG9sIG9zY2lsbGF0b3JcclxuXHJcbmNvbnN0YW50IG11ID0gMjA7XHJcbmNvbnN0YW50IGEgPSAwO1xyXG5jb25zdGFudCBvbWVnYSA9IDE7XHJcblxyXG54MSh0MCkgPSAxO1xyXG54Mih0MCkgPSAwO1xyXG5cclxueDEnIC0geDIgPTA7XHJcbngyJyA9IG11KigxLXgxKngxKSp4Mi14MSArIGEqc2luKG9tZWdhKnQpO1xyXG5gXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJhaXJ5LWVxdWF0aW9uXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6XCJBaXJ5IGVxdWF0aW9uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL0FpcnkgZXF1YXRpb25cclxuLy94JyctdHg9MFxyXG4vL3QwID0gLTE1XHJcblxyXG54Mih0MCk9MC4wO1xyXG54MSh0MCk9MC4yNTU7XHJcblxyXG54Mic9IHQqeDE7XHJcbngxJz0geDI7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwibG90a2Etdm9sdGVycmFcIjp7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkxvdGthLVZvbHRlcnJhIGVxdWF0aW9uc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmBcclxuLy9wcmV5IGh1bnRlciBMb3RrYeKAk1ZvbHRlcnJhXHJcblxyXG5jb25zdGFudCBhbHBoYSA9IDEuMTtcclxuY29uc3RhbnQgYmV0YSA9IDAuNDtcclxuY29uc3RhbnQgZGVsdGEgPSAwLjE7XHJcbmNvbnN0YW50IGdhbW1hID0gMC40O1xyXG5cclxueCh0MCkgPSAxMDtcclxueSh0MCkgPSAxMDtcclxuXHJcbngnID0geCphbHBoYS1iZXRhKngqeTtcclxueScgPSBkZWx0YSp4KnkgLSBnYW1tYSp5O2BcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcImxvZ2lzdGljLWVxdWF0aW9uXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6XCJMb2dpc3RpYyBkaWZmZXJlbnRpYWwgZXF1YXRpb25cIixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vTG9naXN0aWMgZGlmZmVyZW50aWFsIGVxdWF0aW9uXHJcbmNvbnN0YW50IGsgPSAxO1xyXG5jb25zdGFudCBhID0gMTtcclxuXHJcbngodDApID0gMC41O1xyXG5cclxueCcgPSBrKngqKGEteCk7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiZG91YmxlLXBlbmR1bHVtXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiRG91YmxlIHBlbmR1bHVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmAvL2RvdWJsZSBwZW5kdWx1bVxyXG5cclxuY29uc3RhbnQgbSA9IDE7XHJcbmNvbnN0YW50IHIgPSAxO1xyXG5jb25zdGFudCBnID0gOS44MjtcclxuXHJcbnAxKHQwKSA9IDA7XHJcbnAyKHQwKSA9IDA7XHJcbnRoZXRhMSh0MCkgPSAxLjU7XHJcbnRoZXRhMih0MCkgPSAzLjtcclxuXHJcbm1hY3JvIGR0aGV0YTEoKSA2LyhtKnJeMikqKDIqcDEgLSAzKmNvcyh0aGV0YTEgLSB0aGV0YTIpKnAyKS8oMTYtOSpjb3ModGhldGExIC0gdGhldGEyKV4yKTtcclxubWFjcm8gZHRoZXRhMigpIDYvKG0qcl4yKSooOCpwMiAtIDMqY29zKHRoZXRhMSAtIHRoZXRhMikqcDEpLygxNi05KmNvcyh0aGV0YTEgLSB0aGV0YTIpXjIpO1xyXG5cclxuZGVyKHRoZXRhMSkgPSNkdGhldGExKCkgO1xyXG5kZXIodGhldGEyKSA9ICNkdGhldGEyKCk7XHJcbmRlcihwMSkgPSAtMC41Km0qKHJeMikqKCNkdGhldGExKCkqI2R0aGV0YTIoKSpzaW4odGhldGExLXRoZXRhMikrMypnL3Iqc2luKHRoZXRhMSkpO1xyXG5kZXIocDIpID0gLTAuNSptKihyXjIpKigtI2R0aGV0YTEoKSojZHRoZXRhMigpKnNpbih0aGV0YTEtdGhldGEyKStnL3Iqc2luKHRoZXRhMikpO1xyXG5cclxueDEgPXIqc2luKHRoZXRhMSk7XHJcbnkxID0gLXIqY29zKHRoZXRhMSk7XHJcbngyID0gcipzaW4odGhldGExKSArIHIqc2luKHRoZXRhMik7XHJcbnkyID0gLXIqY29zKHRoZXRhMSkgLSByKmNvcyh0aGV0YTIpO1xyXG5gXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJtYXRoaWV1XCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiTWF0aGlldSdzIGRpZmZlcmVudGlhbCBlcXVhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gLy9NZXRoaWV1J3MgZGlmZmVyZW50aWFsIGVxdWF0aW9uXHJcblxyXG5jb25zdGFudCBxID0gMTtcclxuY29uc3RhbnQgYSA9IDI7XHJcblxyXG55KHQwKSA9IDA7XHJcbmR5dCh0MCkgPSAwO1xyXG5cclxuZHl0JyA9IHkqKDIqcSpjb3MoMip0KS1hKTtcclxueScgPSBkeXQ7XHJcblxyXG5gXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJsaW5lYXItc3lzdGVtXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiTGluZWFyIHN5c3RlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gLy9MaW5lYXIgc3lzdGVtXHJcbi8qXHJcbnhfaScgPSBzdW1faiB4X2ogKiBhX3tpan0gKyB0ICogYl9pXHJcbiovXHJcblxyXG5tYWNybyBhWzFdWzFdKCkgIDE7XHJcbm1hY3JvICBhWzFdWzJdKCkgLTE7XHJcbm1hY3JvIGFbMV1bM10oKSAgLTI7XHJcblxyXG5tYWNybyBhWzJdWzFdKCkgLTM7XHJcbm1hY3JvIGFbMl1bMl0oKSAtMTtcclxubWFjcm8gYVsyXVszXSgpIC0wLjI7XHJcblxyXG5tYWNybyBhWzNdWzFdKCkgMC4xMjtcclxubWFjcm8gYVszXVsyXSgpIDAuMTU7XHJcbm1hY3JvIGFbM11bM10oKSAzO1xyXG5cclxubWFjcm8gYlsxXSgpIDE7XHJcbm1hY3JvIGJbMl0oKSAtMC4xMztcclxubWFjcm8gYlszXSgpIDAuNTtcclxuXHJcbnhbMV0odDApID0gMTtcclxueFsyXSh0MCkgPSAtMC4zO1xyXG54WzNdKHQwKSA9IDAuMDtcclxuXHJcbmZvcihpIGluIFsxOjNdKXtcclxuICAgICAgICBkZXIoeFtpXSkgPSBzdW0oaiBpbiBbMTozXSl7IHhbal0qI2FbaV1bal0oKSB9KyNiW2ldKCkqdDtcclxufVxyXG5gXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJwZW5kdWx1bVwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIlBlbmR1bHVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmAvL3BlbmR1bHV1bVxyXG4vL3QgPSBbMCwwLjVdXHJcblxyXG5jb25zdGFudCBtID0gMTtcclxuY29uc3RhbnQgciA9IDE7XHJcbmNvbnN0YW50IGcgPSA5Ljg7XHJcbmNvbnN0YW50IGFuZ2xlID0gcGkoKS82O1xyXG5cclxueDEodDApID0gcipzaW4oYW5nbGUpO1xyXG55MSh0MCkgPSAtcipjb3MoYW5nbGUpO1xyXG54Mih0MCkgPSAwO1xyXG55Mih0MCkgPSAwO1xyXG5UKHQwKSA9IDAuMDtcclxueDModDApID0gMC4wO1xyXG55Myh0MCkgPSAwLjA7XHJcblxyXG55MScgPSB5MjtcclxueTInID0geTM7XHJcbm0qeDMgPSBUKngxL3I7XHJcbm0qeTMgPSBUKnkxL3IgLSBnO1xyXG54MV4yICsgeTFeMiA9IHJeMjtcclxueDEqeDIgKyB5MSp5MiA9IDA7XHJcbngyXjIgKyB5Ml4yKyB4MSp4MyArIHkzKnkxID0gMDtgXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJvcmJpdFwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkFuIEFyZW5zdG9yZiBvcmJpdFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vcGVyaW9kIGlzIDE3LjA2NTIxNjU2MDE1Nzk2MjU1ODg5MTcyMDYyNDlcclxuY29uc3RhbnQgbTEgPSAwLjAxMjI3NzQ3MTtcclxuY29uc3RhbnQgbTIgPSAxIC0gbTE7XHJcblxyXG54MScgPSB4MjtcclxueDInID0geDEgKyAyKnkyIC0gbTIqKHgxK20xKS9EMS1tMSooeDEtbTIpL0QyO1xyXG55MScgPSB5MjtcclxueTInID0geTEgLSAyKngyIC0gbTIqeTEvRDEtbTEqeTEvRDI7XHJcblxyXG5EMSA9ICgoeDEgKyBtMSleMiArIHkxXjIpXjEuNTtcclxuRDIgPSAoKHgxIC0gbTIpXjIgKyB5MV4yKV4xLjU7XHJcbngxKHQwKSA9IDAuOTk0O1xyXG54Mih0MCkgPSAwO1xyXG55MSh0MCkgPSAwO1xyXG55Mih0MCkgPSAtMi4wMDE1ODUxMDYzNzkwODI1MjI0MDUzNzg2MjIyNDtcclxuYFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwib3JlZ29uYXRvclwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIk9yZWdvbmF0b3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDpcclxuYFxyXG4vL3QgPSBbMCw0MDBdXHJcbmNvbnN0YW50IGExID0gNzcuMjc7XHJcbmNvbnN0YW50IGEyID0gOC4zNzVlLTU7XHJcbmNvbnN0YW50IGEzID0gMC4xNjE7XHJcblxyXG54MScgPSBhMSAqIHgyICsgYTEgKiB4MSAtIGExICogYTIgKiB4MV4yIC0gYTEgKiB4MSAqIHgyO1xyXG54MicgPSAoLXgyICsgeDEqeDIgKyB4MykgLyBhMTtcclxueDMnID0gYTMgKiAoeDEgLSB4Myk7XHJcblxyXG54MSh0MCkgPSA0MDA7XHJcbngyKHQwKSA9IDE7XHJcbngzKHQwKSA9IDQwMDtcclxuYFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiYnJ1c3NlbGF0b3JcIjp7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6XCJCcnVzc2VsYXRvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vdCA9IFswLDMwXVxyXG54MSh0MCkgPSAxLjU7XHJcbngyKHQwKSA9IDM7XHJcblxyXG54MScgPSAxICsgeDFeMiAqIHgyIC0gNCp4MTtcclxueDInID0gMyp4MSAtIHgxXjIgKiB4MjtcclxuYFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaHlicmlkOntcclxuICAgICAgICAgICAgICAgIFwianVtcGluZy1iYWxsXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiSnVtcGluZyBiYWxsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmBcclxuLy9KdW1waW5nIGJhbGxcclxuY29uc3RhbnQgbSA9IDE7XHJcbmNvbnN0YW50IGcgPSA5LjgyO1xyXG5jb25zdGFudCBrID0gMTtcclxuXHJcbngodDApID0gMTtcclxudih0MCkgPSAwO1xyXG5cclxudicgPSAtbSpnO1xyXG54JyA9IHY7XHJcblxyXG5zdGF0ZSBqdW1we1xyXG4gICAgICAgIHNldCB2ID0gLXYqaztcclxufSBmcm9tIGluaXRpYWwsIGp1bXAgb24odjwwIGFuZCB4PDApO1xyXG5cclxudGVybWluYWwgc3RhdGUgZW5ke1xyXG59ZnJvbSBpbml0aWFsLCBqdW1wIG9uKGFicyh2KT0wIGFuZCBhYnMoeCk9MCk7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwianVtcGluZy1iYWxsLXNwcmluZ1wiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkp1bXBpbmcgYmFsbCBvbiBhIHNwcmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gLy9KdW1waW5nIGJhbGwgb24gYSBzcHJpbmdcclxuY29uc3RhbnQgbSA9IDE7XHJcbmNvbnN0YW50IGcgPSA5LjgyO1xyXG5jb25zdGFudCBrID0gMTtcclxuY29uc3RhbnQga19zcHJpbmcgPSAwLjE7XHJcbmNvbnN0YW50IGgwO1xyXG5cclxueCh0MCkgPSAxO1xyXG52KHQwKSA9IDA7XHJcblxyXG52JyA9IC1tKmcgLSBrX3NwcmluZyooeCAtIGgwKTtcclxueCcgPSB2O1xyXG5cclxuc3RhdGUganVtcHtcclxuICAgICAgICBzZXQgdiA9IC12Kms7XHJcbn0gZnJvbSBpbml0aWFsLCBqdW1wIG9uKHY8MCBhbmQgeDwwKTtcclxuXHJcbnRlcm1pbmFsIHN0YXRlIGVuZHtcclxufWZyb20gaW5pdGlhbCwganVtcCBvbihhYnModik9MCBhbmQgYWJzKHgpPTApO1xyXG5gXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0d28tbWFzc2VzXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiVHdvIG1hc3Nlc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vVHdvIG1hc3Nlc1xyXG5jb25zdGFudCBrMSA9IG4xID0gbTEgPSBtMiA9IDEsIGsyID0gbjIgPSAyO1xyXG5cclxueDEodDApID0gMDtcclxueDIodDApID0gMztcclxuc3QodDApID0gMDtcclxuXHJcbnN0YXRlIHNlcGFyYXRle1xyXG4gICAgICAgIHgxJyA9IHYxO1xyXG4gICAgICAgIHYxJyA9IGsxKihuMS14MSkvbTE7XHJcbiAgICAgICAgeDInID0gdjI7XHJcbiAgICAgICAgdjInID0gazIqKG4yLXgyKS9tMjtcclxuICAgICAgICBzZXQgc3QgPSAxMDtcclxuICAgICAgICBhMSA9IGsxKihuMSAtIHgxKS9tMTtcclxuICAgICAgICBhMiA9IGsyKihuMiAtIHgyKS9tMjtcclxufSBmcm9tIGluaXRpYWwsIHRvZ2V0aGVyIG9uKHN0PCk7XHJcblxyXG5zdGF0ZSB0b2dldGhlcntcclxuICAgICAgICBzZXQgc3QgPSAxMDtcclxuICAgICAgICBzZXQgdjEgPSAobTEgKiB2MSArIG0yKnYyKS8obTEgKyBtMik7XHJcbiAgICAgICAgc2V0IHYyID0gdjE7XHJcbiAgICAgICAgdjEnID0gKGsxKm4xK2syKm4yLXgxKihrMStrMikpLyhtMSttMik7XHJcbiAgICAgICAgdjInID0gKGsxKm4xK2syKm4yLXgyKihrMStrMikpLyhtMSttMik7XHJcbiAgICAgICAgeDEnID0gdjE7XHJcbiAgICAgICAgeDInID0gdjI7XHJcbiAgICAgICAgYTEgPSAoazEqbjEgKyBrMipuMi14MSooazErazIpKS8obTErbTIpO1xyXG4gICAgICAgIGEyID0gKGsxKm4xICsgazIqbjIteDIqKGsxK2syKSkvKG0xK20yKTtcclxufSBmcm9tIGluaXRpYWwsIHNlcGFyYXRlIG9uKHgxPngyJiZ2MT52Mik7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwiYWJzLWVxdWF0aW9uXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiQWJzIHZhbHVlIGRpZmZlcmVudGlhbCBlcXVhdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vYWJzIHZhbHVlXHJcbi8vdCA9IFswLDQwXVxyXG54KHQwKSA9IDE7XHJcblxyXG54JyA9IC1hYnMoeCk7XHJcbnogPSBleHAoLXQpOy8vYW5hbHl0aWMgc29sdXRpb25cclxuXHJcbnN0YXRlIHplcm97XHJcblx0c2V0IHggPSBhYnMoeCk7XHJcbn0gZnJvbSBpbml0aWFsLCB6ZXJvIG9uKHg8MCk7YFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwia25lZS1wcm9ibGVtXCI6e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOlwiS25lZSBwcm9ibGVtXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6XHJcbmBcclxuLy9rbmVlIHByb2JsZW1cclxuLy90ID0gWzAsMl1cclxuXHJcbmNvbnN0YW50IGVwc2lsb24gPSAxZS02O1xyXG5cclxueCh0MCkgPSAxO1xyXG56ID0ge3Q8MT8xIC0geDowfTtcclxuZXBzaWxvbip4JyA9ICgxIC0gdCkqeCAtIHheMjtcclxuXHJcbnN0YXRlIHplcm8gb24oeDwwKXtcclxuXHRzZXQgeCA9IGFicyh4KTtcclxufSBmcm9tIGluaXRpYWwgb24oeDwwKSwgemVybyBvbih4PDApO2BcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcImZhbGxpbmctYm9keVwiOntcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTpcIkZhbGxpbmcgYm9keVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OlxyXG5gXHJcbi8vZmFsbGluZyBib2R5XHJcbi8veCcnID0gLTEgKyB4J14yXHJcblxyXG54MSh0MCkgPSAxO1xyXG54Mih0MCkgPSAwO1xyXG5cclxuZXFfMTp4MScgPSB4MjtcclxuZXFfMjp4MicgPSAtMSArIHgyXjI7XHJcblxyXG50ZXJtaW5hbCBzdGF0ZSB6ZXJve1xyXG4gICAgICAgIGVxXzE6eDEnID0gMDtcclxuICAgICAgICBlcV8yOngyJyA9IDA7XHJcbn0gZnJvbSBpbml0aWFsIG9uKHg8PTApO2BcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbn07XHJcbiIsIi8vIEdlbmVyYXRlZCBmcm9tIGU6XFxwcm9qZWN0c1xcU29sdmVyc0pTXFxzcmNcXGdyYW1tYXJcXG9kZUdyYW1tYXIuZzQgYnkgQU5UTFIgNC44XHJcbi8vIGpzaGludCBpZ25vcmU6IHN0YXJ0XHJcbnZhciBhbnRscjQgPSByZXF1aXJlKCdhbnRscjQvaW5kZXgnKTtcclxuXHJcblxyXG5cclxudmFyIHNlcmlhbGl6ZWRBVE4gPSBbXCJcXHUwMDAzXFx1NjA4YlxcdWE3MmFcXHU4MTMzXFx1YjllZFxcdTQxN2NcXHUzYmU3XFx1Nzc4NlxcdTU5NjRcIixcclxuICAgIFwiXFx1MDAwMjRcXHUwMThlXFxiXFx1MDAwMVxcdTAwMDRcXHUwMDAyXFx0XFx1MDAwMlxcdTAwMDRcXHUwMDAzXFx0XFx1MDAwM1xcdTAwMDRcIixcclxuICAgIFwiXFx1MDAwNFxcdFxcdTAwMDRcXHUwMDA0XFx1MDAwNVxcdFxcdTAwMDVcXHUwMDA0XFx1MDAwNlxcdFxcdTAwMDZcXHUwMDA0XFx1MDAwN1xcdFwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAwNFxcYlxcdFxcYlxcdTAwMDRcXHRcXHRcXHRcXHUwMDA0XFxuXFx0XFxuXFx1MDAwNFxcdTAwMGJcXHRcXHUwMDBiXFx1MDAwNFwiLFxyXG4gICAgXCJcXGZcXHRcXGZcXHUwMDA0XFxyXFx0XFxyXFx1MDAwNFxcdTAwMGVcXHRcXHUwMDBlXFx1MDAwNFxcdTAwMGZcXHRcXHUwMDBmXFx1MDAwNFxcdTAwMTBcIixcclxuICAgIFwiXFx0XFx1MDAxMFxcdTAwMDRcXHUwMDExXFx0XFx1MDAxMVxcdTAwMDRcXHUwMDEyXFx0XFx1MDAxMlxcdTAwMDRcXHUwMDEzXFx0XFx1MDAxM1wiLFxyXG4gICAgXCJcXHUwMDA0XFx1MDAxNFxcdFxcdTAwMTRcXHUwMDA0XFx1MDAxNVxcdFxcdTAwMTVcXHUwMDA0XFx1MDAxNlxcdFxcdTAwMTZcXHUwMDA0XFx1MDAxN1wiLFxyXG4gICAgXCJcXHRcXHUwMDE3XFx1MDAwNFxcdTAwMThcXHRcXHUwMDE4XFx1MDAwNFxcdTAwMTlcXHRcXHUwMDE5XFx1MDAwNFxcdTAwMWFcXHRcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMDRcXHUwMDFiXFx0XFx1MDAxYlxcdTAwMDRcXHUwMDFjXFx0XFx1MDAxY1xcdTAwMDRcXHUwMDFkXFx0XFx1MDAxZFxcdTAwMDRcXHUwMDFlXCIsXHJcbiAgICBcIlxcdFxcdTAwMWVcXHUwMDA0XFx1MDAxZlxcdFxcdTAwMWZcXHUwMDA0IFxcdCBcXHUwMDA0IVxcdCFcXHUwMDA0XFxcIlxcdFxcXCJcXHUwMDA0I1wiLFxyXG4gICAgXCJcXHQjXFx1MDAwNCRcXHQkXFx1MDAwNCVcXHQlXFx1MDAwNCZcXHQmXFx1MDAwNFxcJ1xcdFxcJ1xcdTAwMDQoXFx0KFxcdTAwMDQpXFx0KVxcdTAwMDRcIixcclxuICAgIFwiKlxcdCpcXHUwMDA0K1xcdCtcXHUwMDA0LFxcdCxcXHUwMDA0LVxcdC1cXHUwMDA0LlxcdC5cXHUwMDA0L1xcdC9cXHUwMDA0MFxcdDBcXHUwMDA0XCIsXHJcbiAgICBcIjFcXHQxXFx1MDAwNDJcXHQyXFx1MDAwNDNcXHQzXFx1MDAwNDRcXHQ0XFx1MDAwNDVcXHQ1XFx1MDAwNDZcXHQ2XFx1MDAwM1xcdTAwMDJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDRcXHUwMDAzXFx1MDAwNFxcdTAwMDNcXHUwMDA1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXGJcXHUwMDAzXFxiXFx1MDAwM1xcYlxcdTAwMDNcIixcclxuICAgIFwiXFx0XFx1MDAwM1xcdFxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDNcXG5cXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXGZcXHUwMDAzXFxmXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXCIsXHJcbiAgICBcIlxcZlxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcXHUwMDBlXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTFcXHUwMDAzXFx1MDAxMVxcdTAwMDNcXHUwMDExXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDExXFx1MDAwM1xcdTAwMTJcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTNcXHUwMDAzXFx1MDAxM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxM1xcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTdcXHUwMDA1XFx1MDAxN1xcdTAwZDFcXG5cXHUwMDE3XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFxcdTAwMDNcXHUwMDE4XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDA1XFx1MDAxOFxcdTAwZDhcXG5cXHUwMDE4XFx1MDAwM1xcdTAwMTlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTlcXHUwMDAzXFx1MDAxOVxcdTAwMDNcXHUwMDE5XFx1MDAwNVxcdTAwMTlcXHUwMGRlXFxuXFx1MDAxOVxcdTAwMDNcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDFhXFx1MDAwM1xcdTAwMWJcXHUwMDAzXFx1MDAxYlxcdTAwMDNcXHUwMDFjXFx1MDAwNlxcdTAwMWNcXHUwMGU1XFxuXCIsXHJcbiAgICBcIlxcdTAwMWNcXHJcXHUwMDFjXFx1MDAwZVxcdTAwMWNcXHUwMGU2XFx1MDAwM1xcdTAwMWNcXHUwMDAzXFx1MDAxY1xcdTAwMDdcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAwZWJcXG5cXHUwMDFjXFxmXFx1MDAxY1xcdTAwMGVcXHUwMDFjXFx1MDBlZVxcdTAwMGJcXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWNcXHUwMDA1XFx1MDAxY1xcdTAwZjJcXG5cXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDA2XFx1MDAxY1xcdTAwZjVcXG5cXHUwMDFjXCIsXHJcbiAgICBcIlxcclxcdTAwMWNcXHUwMDBlXFx1MDAxY1xcdTAwZjZcXHUwMDA1XFx1MDAxY1xcdTAwZjlcXG5cXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWNcXHUwMDA2XFx1MDAxY1xcdTAwZmRcXG5cXHUwMDFjXFxyXFx1MDAxY1xcdTAwMGVcXHUwMDFjXFx1MDBmZVxcdTAwMDNcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDFjXFx1MDAwNVxcdTAwMWNcXHUwMTAzXFxuXFx1MDAxY1xcdTAwMDNcXHUwMDFjXFx1MDAwNlxcdTAwMWNcXHUwMTA2XCIsXHJcbiAgICBcIlxcblxcdTAwMWNcXHJcXHUwMDFjXFx1MDAwZVxcdTAwMWNcXHUwMTA3XFx1MDAwNVxcdTAwMWNcXHUwMTBhXFxuXFx1MDAxY1xcdTAwMDNcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAwMDZcXHUwMDFjXFx1MDEwZFxcblxcdTAwMWNcXHJcXHUwMDFjXFx1MDAwZVxcdTAwMWNcXHUwMTBlXFx1MDAwM1xcdTAwMWNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWNcXHUwMDA1XFx1MDAxY1xcdTAxMTNcXG5cXHUwMDFjXFx1MDAwM1xcdTAwMWNcXHUwMDA2XFx1MDAxY1xcdTAxMTZcXG5cXHUwMDFjXCIsXHJcbiAgICBcIlxcclxcdTAwMWNcXHUwMDBlXFx1MDAxY1xcdTAxMTdcXHUwMDA1XFx1MDAxY1xcdTAxMWFcXG5cXHUwMDFjXFx1MDAwM1xcdTAwMWRcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMWRcXHUwMTFkXFxuXFx1MDAxZFxcclxcdTAwMWRcXHUwMDBlXFx1MDAxZFxcdTAxMWVcXHUwMDAzXFx1MDAxZVxcdTAwMDdcXHUwMDFlXCIsXHJcbiAgICBcIlxcdTAxMjJcXG5cXHUwMDFlXFxmXFx1MDAxZVxcdTAwMGVcXHUwMDFlXFx1MDEyNVxcdTAwMGJcXHUwMDFlXFx1MDAwM1xcdTAwMWVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMWVcXHUwMDA1XFx1MDAxZVxcdTAxMjlcXG5cXHUwMDFlXFx1MDAwM1xcdTAwMWVcXHUwMDA3XFx1MDAxZVxcdTAxMmNcXG5cXHUwMDFlXCIsXHJcbiAgICBcIlxcZlxcdTAwMWVcXHUwMDBlXFx1MDAxZVxcdTAxMmZcXHUwMDBiXFx1MDAxZVxcdTAwMDNcXHUwMDFmXFx1MDAwM1xcdTAwMWZcXHUwMDAzXCIsXHJcbiAgICBcIiBcXHUwMDAzIFxcdTAwMDMhXFx1MDAwMyFcXHUwMDAzXFxcIlxcdTAwMDNcXFwiXFx1MDAwMyNcXHUwMDAzI1xcdTAwMDMkXFx1MDAwMyRcXHUwMDAzXCIsXHJcbiAgICBcIiVcXHUwMDAzJVxcdTAwMDMmXFx1MDAwMyZcXHUwMDAzXFwnXFx1MDAwM1xcJ1xcdTAwMDMoXFx1MDAwMyhcXHUwMDAzKVxcdTAwMDMpXFx1MDAwM1wiLFxyXG4gICAgXCIqXFx1MDAwMypcXHUwMDAzKlxcdTAwMDMrXFx1MDAwMytcXHUwMDAzK1xcdTAwMDMsXFx1MDAwMyxcXHUwMDAzLFxcdTAwMDMtXFx1MDAwM1wiLFxyXG4gICAgXCItXFx1MDAwMy5cXHUwMDAzLlxcdTAwMDMvXFx1MDAwMy9cXHUwMDAzMFxcdTAwMDMwXFx1MDAwMzFcXHUwMDAzMVxcdTAwMDMyXFx1MDAwM1wiLFxyXG4gICAgXCIyXFx1MDAwMzNcXHUwMDAzM1xcdTAwMDM0XFx1MDAwNTRcXHUwMTVmXFxuNFxcdTAwMDM0XFx1MDAwMzRcXHUwMDA2NFxcdTAxNjNcXG5cIixcclxuICAgIFwiNFxccjRcXHUwMDBlNFxcdTAxNjRcXHUwMDAzNFxcdTAwMDM0XFx1MDAwMzVcXHUwMDA2NVxcdTAxNmFcXG41XFxyNVxcdTAwMGU1XFx1MDE2YlwiLFxyXG4gICAgXCJcXHUwMDAzNVxcdTAwMDM1XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDA3NlxcdTAxNzRcXG42XFxmNlxcdTAwMGVcIixcclxuICAgIFwiNlxcdTAxNzdcXHUwMDBiNlxcdTAwMDM2XFx1MDAwNTZcXHUwMTdhXFxuNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDA1NlxcdTAxN2VcXG42XCIsXHJcbiAgICBcIlxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzNlxcdTAwMDM2XFx1MDAwNzZcXHUwMTg0XFxuNlxcZjZcXHUwMDBlNlxcdTAxODdcXHUwMDBiNlwiLFxyXG4gICAgXCJcXHUwMDAzNlxcdTAwMDM2XFx1MDAwNTZcXHUwMThiXFxuNlxcdTAwMDM2XFx1MDAwMzZcXHUwMDAzXFx1MDE4NVxcdTAwMDI3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwNVxcdTAwMDJcXHUwMDA3XFx1MDAwMlxcdFxcdTAwMDJcXHUwMDBiXFx1MDAwNFxcclxcdTAwMDVcXHUwMDBmXFx1MDAwNlwiLFxyXG4gICAgXCJcXHUwMDExXFx1MDAwN1xcdTAwMTNcXGJcXHUwMDE1XFx0XFx1MDAxN1xcblxcdTAwMTlcXHUwMDBiXFx1MDAxYlxcZlxcdTAwMWRcXHJcXHUwMDFmXCIsXHJcbiAgICBcIlxcdTAwMGUhXFx1MDAwZiNcXHUwMDEwJVxcdTAwMTFcXCdcXHUwMDEyKVxcdTAwMTMrXFx1MDAxNC1cXHUwMDE1L1xcdTAwMTYxXFx1MDAxN1wiLFxyXG4gICAgXCIzXFx1MDAxODVcXHUwMDE5N1xcdTAwMWE5XFx1MDAxYjtcXHUwMDFjPVxcdTAwMWQ/XFx1MDAxZUFcXHUwMDFmQyBFIUdcXFwiSSNLJFwiLFxyXG4gICAgXCJNJU8mUVxcJ1MoVSlXKlkrWyxdLV8uYS9jMGUxZzJpM2s0XFx1MDAwM1xcdTAwMDJcXHUwMDBiXFx1MDAwM1xcdTAwMDJjfFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMkNcXFxcXFx1MDAwM1xcdTAwMDIyO1xcdTAwMDRcXHUwMDAyR0dnZ1xcdTAwMDRcXHUwMDAyLS0vL1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcImFhXFx1MDAwNlxcdTAwMDIyO0NcXFxcYWFjfFxcdTAwMDRcXHUwMDAyXFx1MDAwYlxcdTAwMGJcXFwiXFxcIlxcdTAwMDRcXHUwMDAyXFxmXFxmXCIsXHJcbiAgICBcIlxcdTAwMGZcXHUwMDBmXFx1MDAwMlxcdTAxYThcXHUwMDAyXFx1MDAwM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwYlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcclxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwZlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxYlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyJVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFwnXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyKVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyK1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMi1cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMi9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDIxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDIzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMjtcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMj1cXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDI/XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJBXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyQ1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyRVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMkdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMklcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJLXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJNXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJPXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyUVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyU1xcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMldcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJZXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJbXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyX1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcImFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMmNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwMmVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJnXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMDJpXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAya1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDAzbVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwNW9cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwN3FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdHNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwYnVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFxyelxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwZn5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxMVxcdTAwODFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTNcXHUwMDg2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTVcXHUwMDhhXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE3XFx1MDA5M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDE5XFx1MDA5OFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxYlxcdTAwOWVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxZFxcdTAwYTJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMWZcXHUwMGE4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMiFcXHUwMGFlXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDIjXFx1MDBiMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIlXFx1MDBiNVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFwnXFx1MDBiOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIpXFx1MDBiZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyK1xcdTAwYzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyLVxcdTAwZDBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIi9cXHUwMGQ3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjFcXHUwMGRkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjNcXHUwMGRmXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI1XFx1MDBlMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI3XFx1MDExOVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyOVxcdTAxMWNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyO1xcdTAxMjNcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMj1cXHUwMTMwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMj9cXHUwMTMyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJBXFx1MDEzNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJDXFx1MDEzNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiRVxcdTAxMzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyR1xcdTAxM2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAySVxcdTAxM2NcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMktcXHUwMTNlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk1cXHUwMTQwXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJPXFx1MDE0MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJRXFx1MDE0NFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyU1xcdTAxNDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyVVxcdTAxNDlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMldcXHUwMTRjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMllcXHUwMTRmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJbXFx1MDE1MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJdXFx1MDE1M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJfXFx1MDE1NVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyYVxcdTAxNTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyY1xcdTAxNTlcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMmVcXHUwMTViXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmdcXHUwMTYyXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJpXFx1MDE2OVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJrXFx1MDE4YVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAybW5cXHUwMDA3JVxcdTAwMDJcXHUwMDAyblxcdTAwMDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyb3BcXHRcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAycFxcdTAwMDZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAycXJcXHRcXHUwMDAzXFx1MDAwMlxcdTAwMDJyXFxiXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJzdFxcdFxcdTAwMDRcXHUwMDAyXFx1MDAwMnRcXG5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMnV2XFx1MDAwNypcXHUwMDAyXFx1MDAwMnZ3XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMnd4XFx1MDAwNzJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJ4eVxcdTAwMDcrXFx1MDAwMlxcdTAwMDJ5XFxmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMnp7XFx1MDAwN3VcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJ7fFxcdTAwMDdnXFx1MDAwMlxcdTAwMDJ8fVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJ9XFx1MDAwZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyflxcdTAwN2ZcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDA3ZlxcdTAwODBcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDA4MFwiLFxyXG4gICAgXCJcXHUwMDEwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODFcXHUwMDgyXFx1MDAwN2hcXHUwMDAyXFx1MDAwMlxcdTAwODJcIixcclxuICAgIFwiXFx1MDA4M1xcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMDgzXFx1MDA4NFxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMDg0XFx1MDA4NVwiLFxyXG4gICAgXCJcXHUwMDA3b1xcdTAwMDJcXHUwMDAyXFx1MDA4NVxcdTAwMTJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4NlxcdTAwODdcIixcclxuICAgIFwiXFx1MDAwN2ZcXHUwMDAyXFx1MDAwMlxcdTAwODdcXHUwMDg4XFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAwODhcXHUwMDg5XFx1MDAwN1wiLFxyXG4gICAgXCJ0XFx1MDAwMlxcdTAwMDJcXHUwMDg5XFx1MDAxNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhhXFx1MDA4YlxcdTAwMDdcIixcclxuICAgIFwidlxcdTAwMDJcXHUwMDAyXFx1MDA4YlxcdTAwOGNcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDA4Y1xcdTAwOGRcXHUwMDA3dFxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwOGRcXHUwMDhlXFx1MDAwN29cXHUwMDAyXFx1MDAwMlxcdTAwOGVcXHUwMDhmXFx1MDAwN2tcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDhmXFx1MDA5MFxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMDkwXFx1MDA5MVxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMDkxXCIsXHJcbiAgICBcIlxcdTAwOTJcXHUwMDA3blxcdTAwMDJcXHUwMDAyXFx1MDA5MlxcdTAwMTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5M1wiLFxyXG4gICAgXCJcXHUwMDk0XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAwOTRcXHUwMDk1XFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAwOTVcXHUwMDk2XCIsXHJcbiAgICBcIlxcdTAwMDd3XFx1MDAwMlxcdTAwMDJcXHUwMDk2XFx1MDA5N1xcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMDk3XFx1MDAxOFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5OFxcdTAwOTlcXHUwMDA3aFxcdTAwMDJcXHUwMDAyXFx1MDA5OVxcdTAwOWFcXHUwMDA3XCIsXHJcbiAgICBcImNcXHUwMDAyXFx1MDAwMlxcdTAwOWFcXHUwMDliXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAwOWJcXHUwMDljXFx1MDAwN3VcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDljXFx1MDA5ZFxcdTAwMDdnXFx1MDAwMlxcdTAwMDJcXHUwMDlkXFx1MDAxYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDA5ZVxcdTAwOWZcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDA5ZlxcdTAwYTBcXHUwMDA3d1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYTBcXHUwMGExXFx1MDAwN29cXHUwMDAyXFx1MDAwMlxcdTAwYTFcXHUwMDFjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGEyXFx1MDBhM1xcdTAwMDdvXFx1MDAwMlxcdTAwMDJcXHUwMGEzXFx1MDBhNFxcdTAwMDdjXFx1MDAwMlxcdTAwMDJcXHUwMGE0XCIsXHJcbiAgICBcIlxcdTAwYTVcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDBhNVxcdTAwYTZcXHUwMDA3dFxcdTAwMDJcXHUwMDAyXFx1MDBhNlxcdTAwYTdcIixcclxuICAgIFwiXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAwYTdcXHUwMDFlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYThcXHUwMGE5XCIsXHJcbiAgICBcIlxcdTAwMDd1XFx1MDAwMlxcdTAwMDJcXHUwMGE5XFx1MDBhYVxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMGFhXFx1MDBhYlxcdTAwMDdcIixcclxuICAgIFwiY1xcdTAwMDJcXHUwMDAyXFx1MDBhYlxcdTAwYWNcXHUwMDA3dlxcdTAwMDJcXHUwMDAyXFx1MDBhY1xcdTAwYWRcXHUwMDA3Z1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwYWQgXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYWVcXHUwMGFmXFx1MDAwN2hcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGFmXFx1MDBiMFxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMGIwXFx1MDBiMVxcdTAwMDd0XFx1MDAwMlxcdTAwMDJcXHUwMGIxXCIsXHJcbiAgICBcIlxcXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiMlxcdTAwYjNcXHUwMDA3a1xcdTAwMDJcXHUwMDAyXFx1MDBiM1xcdTAwYjRcIixcclxuICAgIFwiXFx1MDAwN3BcXHUwMDAyXFx1MDAwMlxcdTAwYjQkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjVcXHUwMGI2XFx1MDAwN1wiLFxyXG4gICAgXCJrXFx1MDAwMlxcdTAwMDJcXHUwMGI2XFx1MDBiN1xcdTAwMDdoXFx1MDAwMlxcdTAwMDJcXHUwMGI3JlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBiOFxcdTAwYjlcXHUwMDA3Z1xcdTAwMDJcXHUwMDAyXFx1MDBiOVxcdTAwYmFcXHUwMDA3blxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYmFcXHUwMGJiXFx1MDAwN3VcXHUwMDAyXFx1MDAwMlxcdTAwYmJcXHUwMGJjXFx1MDAwN2dcXHUwMDAyXFx1MDAwMlxcdTAwYmNcIixcclxuICAgIFwiKFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJkXFx1MDBiZVxcdTAwMDduXFx1MDAwMlxcdTAwMDJcXHUwMGJlXFx1MDBiZlwiLFxyXG4gICAgXCJcXHUwMDA3cVxcdTAwMDJcXHUwMDAyXFx1MDBiZlxcdTAwYzBcXHUwMDA3ZVxcdTAwMDJcXHUwMDAyXFx1MDBjMFxcdTAwYzFcXHUwMDA3XCIsXHJcbiAgICBcImNcXHUwMDAyXFx1MDAwMlxcdTAwYzFcXHUwMGMyXFx1MDAwN25cXHUwMDAyXFx1MDAwMlxcdTAwYzIqXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGMzXFx1MDBjNFxcdTAwMDdlXFx1MDAwMlxcdTAwMDJcXHUwMGM0XFx1MDBjNVxcdTAwMDdxXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBjNVxcdTAwYzZcXHUwMDA3cFxcdTAwMDJcXHUwMDAyXFx1MDBjNlxcdTAwYzdcXHUwMDA3dVxcdTAwMDJcXHUwMDAyXFx1MDBjN1wiLFxyXG4gICAgXCJcXHUwMGM4XFx1MDAwN3ZcXHUwMDAyXFx1MDAwMlxcdTAwYzhcXHUwMGM5XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAwYzlcXHUwMGNhXCIsXHJcbiAgICBcIlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMGNhXFx1MDBjYlxcdTAwMDd2XFx1MDAwMlxcdTAwMDJcXHUwMGNiLFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBjY1xcdTAwY2RcXHUwMDA3flxcdTAwMDJcXHUwMDAyXFx1MDBjZFxcdTAwZDFcXHUwMDA3flxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwY2VcXHUwMGNmXFx1MDAwN3FcXHUwMDAyXFx1MDAwMlxcdTAwY2ZcXHUwMGQxXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGQwXFx1MDBjY1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGQwXFx1MDBjZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBkMS5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkMlxcdTAwZDNcXHUwMDA3KFxcdTAwMDJcXHUwMDAyXFx1MDBkM1wiLFxyXG4gICAgXCJcXHUwMGQ4XFx1MDAwNyhcXHUwMDAyXFx1MDAwMlxcdTAwZDRcXHUwMGQ1XFx1MDAwN2NcXHUwMDAyXFx1MDAwMlxcdTAwZDVcXHUwMGQ2XCIsXHJcbiAgICBcIlxcdTAwMDdwXFx1MDAwMlxcdTAwMDJcXHUwMGQ2XFx1MDBkOFxcdTAwMDdmXFx1MDAwMlxcdTAwMDJcXHUwMGQ3XFx1MDBkMlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkN1xcdTAwZDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkODBcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZDlcXHUwMGRlXFx1MDAwNyNcXHUwMDAyXFx1MDAwMlxcdTAwZGFcXHUwMGRiXFx1MDAwN1wiLFxyXG4gICAgXCJwXFx1MDAwMlxcdTAwMDJcXHUwMGRiXFx1MDBkY1xcdTAwMDdxXFx1MDAwMlxcdTAwMDJcXHUwMGRjXFx1MDBkZVxcdTAwMDd2XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBkZFxcdTAwZDlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkZFxcdTAwZGFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwZGUyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGZcXHUwMGUwXFx1MDAwN11cXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGUwNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGUxXFx1MDBlMlxcdTAwMDdfXFx1MDAwMlxcdTAwMDJcXHUwMGUyXCIsXHJcbiAgICBcIjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlM1xcdTAwZTVcXHUwMDA1XFx0XFx1MDAwNVxcdTAwMDJcXHUwMGU0XFx1MDBlM1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlNVxcdTAwZTZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlNlxcdTAwZTRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTZcXHUwMGU3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTdcXHUwMGU4XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGU4XFx1MDBlY1xcdTAwMDVJJVxcdTAwMDJcXHUwMGU5XFx1MDBlYlxcdTAwMDVcIixcclxuICAgIFwiXFx0XFx1MDAwNVxcdTAwMDJcXHUwMGVhXFx1MDBlOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGViXFx1MDBlZVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlY1xcdTAwZWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlY1xcdTAwZWRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWRcXHUwMGY4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWVcXHUwMGVjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGVmXFx1MDBmMVxcdFxcdTAwMDVcXHUwMDAyXFx1MDAwMlxcdTAwZjBcXHUwMGYyXFx0XFx1MDAwNlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZjFcXHUwMGYwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjFcXHUwMGYyXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGYyXFx1MDBmNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGYzXFx1MDBmNVxcdTAwMDVcXHRcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMDJcXHUwMGY0XFx1MDBmM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGY1XFx1MDBmNlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBmNlxcdTAwZjRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBmNlxcdTAwZjdcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwZjdcXHUwMGY5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjhcXHUwMGVmXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGY4XFx1MDBmOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGY5XFx1MDExYVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBmYVxcdTAwZmNcXHUwMDA1SSVcXHUwMDAyXFx1MDBmYlxcdTAwZmRcXHUwMDA1XFx0XFx1MDAwNVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBmY1xcdTAwZmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBmZFxcdTAwZmVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwZmVcXHUwMGZjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZmVcXHUwMGZmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGZmXFx1MDEwOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTAwXFx1MDEwMlxcdFxcdTAwMDVcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTAxXFx1MDEwM1xcdFxcdTAwMDZcXHUwMDAyXFx1MDAwMlxcdTAxMDJcXHUwMTAxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTAyXFx1MDEwM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTAzXFx1MDEwNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEwNFxcdTAxMDZcXHUwMDA1XFx0XFx1MDAwNVxcdTAwMDJcXHUwMTA1XFx1MDEwNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEwNlxcdTAxMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwN1xcdTAxMDVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMDdcXHUwMTA4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMDhcXHUwMTBhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTA5XFx1MDEwMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTA5XFx1MDEwYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEwYVxcdTAxMWFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwYlxcdTAxMGRcXHUwMDA1XFx0XFx1MDAwNVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEwY1xcdTAxMGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwZFxcdTAxMGVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMGVcXHUwMTBjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMGVcXHUwMTBmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTBmXFx1MDExMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTEwXFx1MDExMlxcdFxcdTAwMDVcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTExXFx1MDExM1xcdFxcdTAwMDZcXHUwMDAyXFx1MDAwMlxcdTAxMTJcXHUwMTExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTEyXFx1MDExM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTEzXFx1MDExNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDExNFxcdTAxMTZcXHUwMDA1XFx0XFx1MDAwNVxcdTAwMDJcXHUwMTE1XFx1MDExNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDExNlxcdTAxMTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExN1xcdTAxMTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMTdcXHUwMTE4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMThcXHUwMTFhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTE5XFx1MDBlNFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTE5XFx1MDBmYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDExOVxcdTAxMGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExYThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMWJcXHUwMTFkXFx1MDAwNVxcdFxcdTAwMDVcXHUwMDAyXFx1MDExY1xcdTAxMWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMWRcXHUwMTFlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMWVcXHUwMTFjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTFlXFx1MDExZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTFmOlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyMFxcdTAxMjJcXHRcXHUwMDA3XFx1MDAwMlxcdTAwMDJcXHUwMTIxXFx1MDEyMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyMlxcdTAxMjVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyM1xcdTAxMjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMjNcXHUwMTI0XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjRcXHUwMTI4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTI1XFx1MDEyM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTI2XFx1MDEyOVxcdTAwMDVcXHUwMDA1XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDEyN1xcdTAxMjlcXHUwMDA1XFx1MDAwN1xcdTAwMDRcXHUwMDAyXFx1MDEyOFxcdTAxMjZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMjhcXHUwMTI3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMjlcXHUwMTJkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTJhXFx1MDEyY1xcdFxcYlxcdTAwMDJcXHUwMDAyXFx1MDEyYlxcdTAxMmFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyY1wiLFxyXG4gICAgXCJcXHUwMTJmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmRcXHUwMTJiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmRcIixcclxuICAgIFwiXFx1MDEyZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJlPFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJmXCIsXHJcbiAgICBcIlxcdTAxMmRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzMFxcdTAxMzFcXHUwMDA3LVxcdTAwMDJcXHUwMDAyXFx1MDEzMVwiLFxyXG4gICAgXCI+XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzJcXHUwMTMzXFx1MDAwNy9cXHUwMDAyXFx1MDAwMlxcdTAxMzNAXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTM0XFx1MDEzNVxcdTAwMDcsXFx1MDAwMlxcdTAwMDJcXHUwMTM1QlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDEzNlxcdTAxMzdcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDEzN0RcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMzhcXHUwMTM5XFx1MDAwNypcXHUwMDAyXFx1MDAwMlxcdTAxMzlGXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTNhXFx1MDEzYlxcdTAwMDcrXFx1MDAwMlxcdTAwMDJcXHUwMTNiSFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTNjXCIsXHJcbiAgICBcIlxcdTAxM2RcXHUwMDA3MFxcdTAwMDJcXHUwMDAyXFx1MDEzZEpcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzZVxcdTAxM2ZcIixcclxuICAgIFwiXFx1MDAwNy5cXHUwMDAyXFx1MDAwMlxcdTAxM2ZMXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDBcXHUwMTQxXFx1MDAwN1wiLFxyXG4gICAgXCJgXFx1MDAwMlxcdTAwMDJcXHUwMTQxTlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTQyXFx1MDE0M1xcdTAwMDc+XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE0M1BcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE0NFxcdTAxNDVcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNDVSXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDZcXHUwMTQ3XFx1MDAwNz5cXHUwMDAyXFx1MDAwMlxcdTAxNDdcIixcclxuICAgIFwiXFx1MDE0OFxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcXHUwMTQ4VFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTQ5XFx1MDE0YVwiLFxyXG4gICAgXCJcXHUwMDA3QFxcdTAwMDJcXHUwMDAyXFx1MDE0YVxcdTAxNGJcXHUwMDA3P1xcdTAwMDJcXHUwMDAyXFx1MDE0YlZcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxNGNcXHUwMTRkXFx1MDAwNyNcXHUwMDAyXFx1MDAwMlxcdTAxNGRcXHUwMTRlXFx1MDAwNz9cXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTRlWFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTRmXFx1MDE1MFxcdTAwMDc/XFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE1MFpcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE1MVxcdTAxNTJcXHUwMDA3PVxcdTAwMDJcXHUwMDAyXFx1MDE1MlwiLFxyXG4gICAgXCJcXFxcXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNTNcXHUwMTU0XFx1MDAwNzxcXHUwMDAyXFx1MDAwMlxcdTAxNTReXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTU1XFx1MDE1NlxcdTAwMDd9XFx1MDAwMlxcdTAwMDJcXHUwMTU2YFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDE1N1xcdTAxNThcXHUwMDA3XFx1MDA3ZlxcdTAwMDJcXHUwMDAyXFx1MDE1OGJcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAxNTlcXHUwMTVhXFx1MDAwNylcXHUwMDAyXFx1MDAwMlxcdTAxNWFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTViXFx1MDE1Y1xcdTAwMDdBXFx1MDAwMlxcdTAwMDJcXHUwMTVjZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE1ZFxcdTAxNWZcXHUwMDA3XFx1MDAwZlxcdTAwMDJcXHUwMDAyXFx1MDE1ZVxcdTAxNWRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNWVcXHUwMTVmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNWZcXHUwMTYwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTYwXFx1MDE2M1xcdTAwMDdcXGZcXHUwMDAyXFx1MDAwMlxcdTAxNjFcXHUwMTYzXFx1MDAwN1xcdTAwMGZcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTYyXFx1MDE1ZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTYyXFx1MDE2MVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE2M1xcdTAxNjRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE2NFxcdTAxNjJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNjRcXHUwMTY1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNjVcXHUwMTY2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTY2XFx1MDE2N1xcYjRcXHUwMDAyXFx1MDAwMlxcdTAxNjdoXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNjhcXHUwMTZhXCIsXHJcbiAgICBcIlxcdFxcdFxcdTAwMDJcXHUwMDAyXFx1MDE2OVxcdTAxNjhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE2YVxcdTAxNmJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNmJcXHUwMTY5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNmJcXHUwMTZjXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTZjXFx1MDE2ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTZkXFx1MDE2ZVxcYlwiLFxyXG4gICAgXCI1XFx1MDAwMlxcdTAwMDJcXHUwMTZlalxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTZmXFx1MDE3MFxcdTAwMDcxXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE3MFxcdTAxNzFcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDE3MVxcdTAxNzVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNzJcXHUwMTc0XFxuXFxuXFx1MDAwMlxcdTAwMDJcXHUwMTczXFx1MDE3MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE3NFxcdTAxNzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE3NVxcdTAxNzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxNzVcXHUwMTc2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNzZcXHUwMTdkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTc3XFx1MDE3NVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTc4XFx1MDE3YVxcdTAwMDdcXHUwMDBmXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE3OVxcdTAxNzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE3OVxcdTAxN2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxN2FcXHUwMTdiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxN2JcXHUwMTdlXFx1MDAwN1xcZlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxN2NcXHUwMTdlXFx1MDAwN3RcXHUwMDAyXFx1MDAwMlxcdTAxN2RcXHUwMTc5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTdkXFx1MDE3Y1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTdlXFx1MDE4YlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDE3ZlxcdTAxODBcXHUwMDA3MVxcdTAwMDJcXHUwMDAyXFx1MDE4MFxcdTAxODFcXHUwMDA3LFxcdTAwMDJcXHUwMDAyXFx1MDE4MVwiLFxyXG4gICAgXCJcXHUwMTg1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODJcXHUwMTg0XFx1MDAwYlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODNcIixcclxuICAgIFwiXFx1MDE4MlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTg0XFx1MDE4N1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTg1XCIsXHJcbiAgICBcIlxcdTAxODZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4NVxcdTAxODNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4NlwiLFxyXG4gICAgXCJcXHUwMTg4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODdcXHUwMTg1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxODhcIixcclxuICAgIFwiXFx1MDE4OVxcdTAwMDcsXFx1MDAwMlxcdTAwMDJcXHUwMTg5XFx1MDE4YlxcdTAwMDcxXFx1MDAwMlxcdTAwMDJcXHUwMThhXFx1MDE2ZlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4YVxcdTAxN2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE4YlxcdTAxOGNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxOGNcXHUwMThkXFxiNlxcdTAwMDJcXHUwMDAyXFx1MDE4ZGxcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMiBcXHUwMDAyXFx1MDBkMFxcdTAwZDdcXHUwMGRkXFx1MDBlNlxcdTAwZWNcXHUwMGYxXFx1MDBmNlxcdTAwZjhcIixcclxuICAgIFwiXFx1MDBmZVxcdTAxMDJcXHUwMTA3XFx1MDEwOVxcdTAxMGVcXHUwMTEyXFx1MDExN1xcdTAxMTlcXHUwMTFlXFx1MDEyM1xcdTAxMjhcXHUwMTJkXCIsXHJcbiAgICBcIlxcdTAxNWVcXHUwMTYyXFx1MDE2NFxcdTAxNmJcXHUwMTc1XFx1MDE3OVxcdTAxN2RcXHUwMTg1XFx1MDE4YVxcdTAwMDNcXGJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcIl0uam9pbihcIlwiKTtcclxuXHJcblxyXG52YXIgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XHJcblxyXG52YXIgZGVjaXNpb25zVG9ERkEgPSBhdG4uZGVjaXNpb25Ub1N0YXRlLm1hcCggZnVuY3Rpb24oZHMsIGluZGV4KSB7IHJldHVybiBuZXcgYW50bHI0LmRmYS5ERkEoZHMsIGluZGV4KTsgfSk7XHJcblxyXG5mdW5jdGlvbiBvZGVHcmFtbWFyTGV4ZXIoaW5wdXQpIHtcclxuXHRhbnRscjQuTGV4ZXIuY2FsbCh0aGlzLCBpbnB1dCk7XHJcbiAgICB0aGlzLl9pbnRlcnAgPSBuZXcgYW50bHI0LmF0bi5MZXhlckFUTlNpbXVsYXRvcih0aGlzLCBhdG4sIGRlY2lzaW9uc1RvREZBLCBuZXcgYW50bHI0LlByZWRpY3Rpb25Db250ZXh0Q2FjaGUoKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxub2RlR3JhbW1hckxleGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LkxleGVyLnByb3RvdHlwZSk7XHJcbm9kZUdyYW1tYXJMZXhlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvZGVHcmFtbWFyTGV4ZXI7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkob2RlR3JhbW1hckxleGVyLnByb3RvdHlwZSwgXCJhdG5cIiwge1xyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0bjtcclxuICAgICAgICB9XHJcbn0pO1xyXG5cclxub2RlR3JhbW1hckxleGVyLkVPRiA9IGFudGxyNC5Ub2tlbi5FT0Y7XHJcbm9kZUdyYW1tYXJMZXhlci5UX18wID0gMTtcclxub2RlR3JhbW1hckxleGVyLlQwID0gMjtcclxub2RlR3JhbW1hckxleGVyLlNFVCA9IDM7XHJcbm9kZUdyYW1tYXJMZXhlci5PTiA9IDQ7XHJcbm9kZUdyYW1tYXJMZXhlci5GUk9NID0gNTtcclxub2RlR3JhbW1hckxleGVyLkRFUiA9IDY7XHJcbm9kZUdyYW1tYXJMZXhlci5URVJNSU5BTCA9IDc7XHJcbm9kZUdyYW1tYXJMZXhlci5UUlVFID0gODtcclxub2RlR3JhbW1hckxleGVyLkZBTFNFID0gOTtcclxub2RlR3JhbW1hckxleGVyLlNVTSA9IDEwO1xyXG5vZGVHcmFtbWFyTGV4ZXIuTUFDUk8gPSAxMTtcclxub2RlR3JhbW1hckxleGVyLlNUQVRFID0gMTI7XHJcbm9kZUdyYW1tYXJMZXhlci5GT1IgPSAxMztcclxub2RlR3JhbW1hckxleGVyLklOID0gMTQ7XHJcbm9kZUdyYW1tYXJMZXhlci5JRiA9IDE1O1xyXG5vZGVHcmFtbWFyTGV4ZXIuRUxTRSA9IDE2O1xyXG5vZGVHcmFtbWFyTGV4ZXIuTE9DQUwgPSAxNztcclxub2RlR3JhbW1hckxleGVyLkNPTlNUQU5UID0gMTg7XHJcbm9kZUdyYW1tYXJMZXhlci5PUiA9IDE5O1xyXG5vZGVHcmFtbWFyTGV4ZXIuQU5EID0gMjA7XHJcbm9kZUdyYW1tYXJMZXhlci5OT1QgPSAyMTtcclxub2RlR3JhbW1hckxleGVyLkxTUVIgPSAyMjtcclxub2RlR3JhbW1hckxleGVyLlJTUVIgPSAyMztcclxub2RlR3JhbW1hckxleGVyLkZMT0FUID0gMjQ7XHJcbm9kZUdyYW1tYXJMZXhlci5JTlQgPSAyNTtcclxub2RlR3JhbW1hckxleGVyLklEID0gMjY7XHJcbm9kZUdyYW1tYXJMZXhlci5QTFVTID0gMjc7XHJcbm9kZUdyYW1tYXJMZXhlci5NSU5VUyA9IDI4O1xyXG5vZGVHcmFtbWFyTGV4ZXIuQVNURVJJU0sgPSAyOTtcclxub2RlR3JhbW1hckxleGVyLkRJVklTSU9OID0gMzA7XHJcbm9kZUdyYW1tYXJMZXhlci5MUEFSRU4gPSAzMTtcclxub2RlR3JhbW1hckxleGVyLlJQQVJFTiA9IDMyO1xyXG5vZGVHcmFtbWFyTGV4ZXIuRE9UID0gMzM7XHJcbm9kZUdyYW1tYXJMZXhlci5DT01NQSA9IDM0O1xyXG5vZGVHcmFtbWFyTGV4ZXIuQ0FSRVQgPSAzNTtcclxub2RlR3JhbW1hckxleGVyLkwgPSAzNjtcclxub2RlR3JhbW1hckxleGVyLkcgPSAzNztcclxub2RlR3JhbW1hckxleGVyLkxFID0gMzg7XHJcbm9kZUdyYW1tYXJMZXhlci5HRSA9IDM5O1xyXG5vZGVHcmFtbWFyTGV4ZXIuTkUgPSA0MDtcclxub2RlR3JhbW1hckxleGVyLkUgPSA0MTtcclxub2RlR3JhbW1hckxleGVyLlNFTUlDT0xPTiA9IDQyO1xyXG5vZGVHcmFtbWFyTGV4ZXIuQ09MT04gPSA0Mztcclxub2RlR3JhbW1hckxleGVyLkxDUkwgPSA0NDtcclxub2RlR3JhbW1hckxleGVyLlJDUkwgPSA0NTtcclxub2RlR3JhbW1hckxleGVyLkFQT1NUUk9QSEUgPSA0Njtcclxub2RlR3JhbW1hckxleGVyLlFVRVNUSU9OTUFSSyA9IDQ3O1xyXG5vZGVHcmFtbWFyTGV4ZXIuTkVXTElORSA9IDQ4O1xyXG5vZGVHcmFtbWFyTGV4ZXIuV0hJVEVTUEFDRSA9IDQ5O1xyXG5vZGVHcmFtbWFyTGV4ZXIuQ09NTUVOVCA9IDUwO1xyXG5cclxub2RlR3JhbW1hckxleGVyLnByb3RvdHlwZS5jaGFubmVsTmFtZXMgPSBbIFwiREVGQVVMVF9UT0tFTl9DSEFOTkVMXCIsIFwiSElEREVOXCIgXTtcclxuXHJcbm9kZUdyYW1tYXJMZXhlci5wcm90b3R5cGUubW9kZU5hbWVzID0gWyBcIkRFRkFVTFRfTU9ERVwiIF07XHJcblxyXG5vZGVHcmFtbWFyTGV4ZXIucHJvdG90eXBlLmxpdGVyYWxOYW1lcyA9IFsgbnVsbCwgXCInIydcIiwgXCInKHQwKSdcIiwgXCInc2V0J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ29uJ1wiLCBcIidmcm9tJ1wiLCBcIidkZXInXCIsIFwiJ3Rlcm1pbmFsJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJ3RydWUnXCIsIFwiJ2ZhbHNlJ1wiLCBcIidzdW0nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInbWFjcm8nXCIsIFwiJ3N0YXRlJ1wiLCBcIidmb3InXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInaW4nXCIsIFwiJ2lmJ1wiLCBcIidlbHNlJ1wiLCBcIidsb2NhbCdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidjb25zdGFudCdcIiwgbnVsbCwgbnVsbCwgbnVsbCwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIidbJ1wiLCBcIiddJ1wiLCBudWxsLCBudWxsLCBudWxsLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJysnXCIsIFwiJy0nXCIsIFwiJyonXCIsIFwiJy8nXCIsIFwiJygnXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInKSdcIiwgXCInLidcIiwgXCInLCdcIiwgXCInXidcIiwgXCInPCdcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIic+J1wiLCBcIic8PSdcIiwgXCInPj0nXCIsIFwiJyE9J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJz0nXCIsIFwiJzsnXCIsIFwiJzonXCIsIFwiJ3snXCIsIFwiJ30nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInJydcIiwgXCInPydcIiBdO1xyXG5cclxub2RlR3JhbW1hckxleGVyLnByb3RvdHlwZS5zeW1ib2xpY05hbWVzID0gWyBudWxsLCBudWxsLCBcIlQwXCIsIFwiU0VUXCIsIFwiT05cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJGUk9NXCIsIFwiREVSXCIsIFwiVEVSTUlOQUxcIiwgXCJUUlVFXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRkFMU0VcIiwgXCJTVU1cIiwgXCJNQUNST1wiLCBcIlNUQVRFXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRk9SXCIsIFwiSU5cIiwgXCJJRlwiLCBcIkVMU0VcIiwgXCJMT0NBTFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNPTlNUQU5UXCIsIFwiT1JcIiwgXCJBTkRcIiwgXCJOT1RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJMU1FSXCIsIFwiUlNRUlwiLCBcIkZMT0FUXCIsIFwiSU5UXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSURcIiwgXCJQTFVTXCIsIFwiTUlOVVNcIiwgXCJBU1RFUklTS1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRJVklTSU9OXCIsIFwiTFBBUkVOXCIsIFwiUlBBUkVOXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRE9UXCIsIFwiQ09NTUFcIiwgXCJDQVJFVFwiLCBcIkxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJHXCIsIFwiTEVcIiwgXCJHRVwiLCBcIk5FXCIsIFwiRVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNFTUlDT0xPTlwiLCBcIkNPTE9OXCIsIFwiTENSTFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlJDUkxcIiwgXCJBUE9TVFJPUEhFXCIsIFwiUVVFU1RJT05NQVJLXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTkVXTElORVwiLCBcIldISVRFU1BBQ0VcIiwgXCJDT01NRU5UXCIgXTtcclxuXHJcbm9kZUdyYW1tYXJMZXhlci5wcm90b3R5cGUucnVsZU5hbWVzID0gWyBcIlRfXzBcIiwgXCJMT1dFUkNBU0VcIiwgXCJVUFBFUkNBU0VcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRJR0lUXCIsIFwiVDBcIiwgXCJTRVRcIiwgXCJPTlwiLCBcIkZST01cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkRFUlwiLCBcIlRFUk1JTkFMXCIsIFwiVFJVRVwiLCBcIkZBTFNFXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTVU1cIiwgXCJNQUNST1wiLCBcIlNUQVRFXCIsIFwiRk9SXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJTlwiLCBcIklGXCIsIFwiRUxTRVwiLCBcIkxPQ0FMXCIsIFwiQ09OU1RBTlRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk9SXCIsIFwiQU5EXCIsIFwiTk9UXCIsIFwiTFNRUlwiLCBcIlJTUVJcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkZMT0FUXCIsIFwiSU5UXCIsIFwiSURcIiwgXCJQTFVTXCIsIFwiTUlOVVNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFTVEVSSVNLXCIsIFwiRElWSVNJT05cIiwgXCJMUEFSRU5cIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlJQQVJFTlwiLCBcIkRPVFwiLCBcIkNPTU1BXCIsIFwiQ0FSRVRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxcIiwgXCJHXCIsIFwiTEVcIiwgXCJHRVwiLCBcIk5FXCIsIFwiRVwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiU0VNSUNPTE9OXCIsIFwiQ09MT05cIiwgXCJMQ1JMXCIsIFwiUkNSTFwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQVBPU1RST1BIRVwiLCBcIlFVRVNUSU9OTUFSS1wiLCBcIk5FV0xJTkVcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIldISVRFU1BBQ0VcIiwgXCJDT01NRU5UXCIgXTtcclxuXHJcbm9kZUdyYW1tYXJMZXhlci5wcm90b3R5cGUuZ3JhbW1hckZpbGVOYW1lID0gXCJvZGVHcmFtbWFyLmc0XCI7XHJcblxyXG5cclxuZXhwb3J0cy5vZGVHcmFtbWFyTGV4ZXIgPSBvZGVHcmFtbWFyTGV4ZXI7XHJcblxyXG4iLCIvLyBHZW5lcmF0ZWQgZnJvbSBlOlxccHJvamVjdHNcXFNvbHZlcnNKU1xcc3JjXFxncmFtbWFyXFxvZGVHcmFtbWFyLmc0IGJ5IEFOVExSIDQuOFxyXG4vLyBqc2hpbnQgaWdub3JlOiBzdGFydFxyXG52YXIgYW50bHI0ID0gcmVxdWlyZSgnYW50bHI0L2luZGV4Jyk7XHJcbnZhciBvZGVHcmFtbWFyVmlzaXRvciA9IHJlcXVpcmUoJy4vb2RlR3JhbW1hclZpc2l0b3InKS5vZGVHcmFtbWFyVmlzaXRvcjtcclxuXHJcbnZhciBncmFtbWFyRmlsZU5hbWUgPSBcIm9kZUdyYW1tYXIuZzRcIjtcclxuXHJcblxyXG52YXIgc2VyaWFsaXplZEFUTiA9IFtcIlxcdTAwMDNcXHU2MDhiXFx1YTcyYVxcdTgxMzNcXHViOWVkXFx1NDE3Y1xcdTNiZTdcXHU3Nzg2XFx1NTk2NFwiLFxyXG4gICAgXCJcXHUwMDAzNFxcdTAxNDZcXHUwMDA0XFx1MDAwMlxcdFxcdTAwMDJcXHUwMDA0XFx1MDAwM1xcdFxcdTAwMDNcXHUwMDA0XFx1MDAwNFxcdFwiLFxyXG4gICAgXCJcXHUwMDA0XFx1MDAwNFxcdTAwMDVcXHRcXHUwMDA1XFx1MDAwNFxcdTAwMDZcXHRcXHUwMDA2XFx1MDAwNFxcdTAwMDdcXHRcXHUwMDA3XFx1MDAwNFwiLFxyXG4gICAgXCJcXGJcXHRcXGJcXHUwMDA0XFx0XFx0XFx0XFx1MDAwNFxcblxcdFxcblxcdTAwMDRcXHUwMDBiXFx0XFx1MDAwYlxcdTAwMDRcXGZcXHRcXGZcXHUwMDA0XCIsXHJcbiAgICBcIlxcclxcdFxcclxcdTAwMDRcXHUwMDBlXFx0XFx1MDAwZVxcdTAwMDRcXHUwMDBmXFx0XFx1MDAwZlxcdTAwMDRcXHUwMDEwXFx0XFx1MDAxMFxcdTAwMDRcIixcclxuICAgIFwiXFx1MDAxMVxcdFxcdTAwMTFcXHUwMDA0XFx1MDAxMlxcdFxcdTAwMTJcXHUwMDA0XFx1MDAxM1xcdFxcdTAwMTNcXHUwMDA0XFx1MDAxNFxcdFwiLFxyXG4gICAgXCJcXHUwMDE0XFx1MDAwNFxcdTAwMTVcXHRcXHUwMDE1XFx1MDAwNFxcdTAwMTZcXHRcXHUwMDE2XFx1MDAwNFxcdTAwMTdcXHRcXHUwMDE3XFx1MDAwNFwiLFxyXG4gICAgXCJcXHUwMDE4XFx0XFx1MDAxOFxcdTAwMDNcXHUwMDAyXFx1MDAwN1xcdTAwMDIyXFxuXFx1MDAwMlxcZlxcdTAwMDJcXHUwMDBlXFx1MDAwMlwiLFxyXG4gICAgXCI1XFx1MDAwYlxcdTAwMDJcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcXHUwMDAzXFx1MDAwM1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDVcXHUwMDAzPFxcblxcdTAwMDNcXHUwMDAzXFx1MDAwNFxcdTAwMDdcXHUwMDA0P1xcblxcdTAwMDRcXGZcXHUwMDA0XCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDA0QlxcdTAwMGJcXHUwMDA0XFx1MDAwM1xcdTAwMDVcXHUwMDAzXFx1MDAwNVxcdTAwMDNcXHUwMDA2XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDAzXFx1MDAwNlxcdTAwMDNcXHUwMDA2XFx1MDAwM1xcdTAwMDZcXHUwMDA1XFx1MDAwNkxcIixcclxuICAgIFwiXFxuXFx1MDAwNlxcdTAwMDNcXHUwMDA3XFx1MDAwM1xcdTAwMDdcXHUwMDAzXFx1MDAwN1xcdTAwMDNcXHUwMDA3XFx1MDAwM1xcYlxcdTAwMDNcIixcclxuICAgIFwiXFxiXFx1MDAwN1xcYlRcXG5cXGJcXGZcXGJcXHUwMDBlXFxiV1xcdTAwMGJcXGJcXHUwMDAzXFx0XFx1MDAwM1xcdFxcdTAwMDNcXHRcXHUwMDAzXFx0XCIsXHJcbiAgICBcIlxcdTAwMDNcXHRcXHUwMDAzXFx0XFx1MDAwNVxcdF9cXG5cXHRcXHUwMDAzXFxuXFx1MDAwM1xcblxcdTAwMDdcXG5jXFxuXFxuXFxmXFxuXFx1MDAwZVwiLFxyXG4gICAgXCJcXG5mXFx1MDAwYlxcblxcdTAwMDNcXG5cXHUwMDAzXFxuXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBiXFx1MDAwM1xcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDVcXHUwMDBicFxcblxcdTAwMGJcXHUwMDAzXFx1MDAwYlxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwYlxcdTAwMDNcXHUwMDBiXFx1MDAwM1xcZlxcdTAwMDNcXGZcXHUwMDAzXFxmXFx1MDAwN1xcZnhcXG5cXGZcXGZcXGZcXHUwMDBlXFxmXCIsXHJcbiAgICBcIntcXHUwMDBiXFxmXFx1MDAwM1xcZlxcdTAwMDVcXGZ+XFxuXFxmXFx1MDAwM1xcclxcdTAwMDNcXHJcXHUwMDAzXFxyXFx1MDAwM1xcclxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDA2XCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDhhXFxuXFx1MDAwZVxcclxcdTAwMGVcXHUwMDBlXFx1MDAwZVxcdTAwOGJcXHUwMDAzXFx1MDAwZVxcdTAwMDNcXHUwMDBlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDBlXFx1MDAwM1xcdTAwMGVcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDA1XFx1MDAwZlwiLFxyXG4gICAgXCJcXHUwMDk1XFxuXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1xcdTAwMGZcXHUwMDAzXFx1MDAwZlxcdTAwMDNcXHUwMDBmXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDBmXFx1MDAwM1xcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcXHUwMDEwXFx1MDAwM1xcdTAwMTBcXHUwMDAzXFx1MDAxMFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxMFxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXFx1MDAxMVxcdTAwMDNcXHUwMDExXFx1MDAwM1xcdTAwMTFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTFcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1xcdTAwMTJcXHUwMDAzXFx1MDAxMlxcdTAwMDNcXHUwMDEyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDEyXFx1MDAwM1xcdTAwMTNcXHUwMDAzXFx1MDAxM1xcdTAwMDNcXHUwMDEzXFx1MDAwM1xcdTAwMTNcXHUwMDAzXFx1MDAxM1xcdTAwMDVcIixcclxuICAgIFwiXFx1MDAxM1xcdTAwYjNcXG5cXHUwMDEzXFx1MDAwM1xcdTAwMTRcXHUwMDA1XFx1MDAxNFxcdTAwYjZcXG5cXHUwMDE0XFx1MDAwM1xcdTAwMTRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwN1xcdTAwMTRcXHUwMGJjXFxuXFx1MDAxNFxcZlxcdTAwMTRcIixcclxuICAgIFwiXFx1MDAwZVxcdTAwMTRcXHUwMGJmXFx1MDAwYlxcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDNcXHUwMDE0XFx1MDAwM1xcdTAwMTRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTRcXHUwMDAzXFx1MDAxNFxcdTAwMDdcXHUwMDE0XFx1MDBjNlxcblxcdTAwMTRcXGZcXHUwMDE0XFx1MDAwZVxcdTAwMTRcXHUwMGM5XCIsXHJcbiAgICBcIlxcdTAwMGJcXHUwMDE0XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XFx1MDAwN1xcdTAwMTVcXHUwMGNlXFxuXCIsXHJcbiAgICBcIlxcdTAwMTVcXGZcXHUwMDE1XFx1MDAwZVxcdTAwMTVcXHUwMGQxXFx1MDAwYlxcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE1XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDE1XFx1MDAwM1xcdTAwMTVcXHUwMDAzXFx1MDAxNVxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDE2XFx1MDAwNVxcdTAwMTZcXHUwMGU4XFxuXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTZcXHUwMDAzXFx1MDAxNlxcdTAwMDNcXHUwMDE2XFx1MDAwM1xcdTAwMTZcXHUwMDA3XFx1MDAxNlxcdTAwZjBcXG5cXHUwMDE2XCIsXHJcbiAgICBcIlxcZlxcdTAwMTZcXHUwMDBlXFx1MDAxNlxcdTAwZjNcXHUwMDBiXFx1MDAxNlxcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcIixcclxuICAgIFwiXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwNVxcdTAwMTdcXHUwMTA4XCIsXHJcbiAgICBcIlxcblxcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDdcXHUwMDE3XFx1MDEwZlxcblxcdTAwMTdcXGZcXHUwMDE3XFx1MDAwZVxcdTAwMTdcXHUwMTEyXFx1MDAwYlxcdTAwMTdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTdcXHUwMDA1XFx1MDAxN1xcdTAxMTVcXG5cXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1wiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDVcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAxMmJcXG5cXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDNcXHUwMDE3XFx1MDAwM1xcdTAwMTdcXHUwMDAzXFx1MDAxN1xcdTAwMDdcXHUwMDE3XFx1MDEzNlwiLFxyXG4gICAgXCJcXG5cXHUwMDE3XFxmXFx1MDAxN1xcdTAwMGVcXHUwMDE3XFx1MDEzOVxcdTAwMGJcXHUwMDE3XFx1MDAwM1xcdTAwMThcXHUwMDAzXFx1MDAxOFwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAxOFxcdTAwMDdcXHUwMDE4XFx1MDEzZVxcblxcdTAwMThcXGZcXHUwMDE4XFx1MDAwZVxcdTAwMThcXHUwMTQxXFx1MDAwYlwiLFxyXG4gICAgXCJcXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDA1XFx1MDAxOFxcdTAxNDRcXG5cXHUwMDE4XFx1MDAwM1xcdTAwMThcXHUwMDAyXFx1MDAwNFwiLFxyXG4gICAgXCIqLFxcdTAwMTlcXHUwMDAyXFx1MDAwNFxcdTAwMDZcXGJcXG5cXGZcXHUwMDBlXFx1MDAxMFxcdTAwMTJcXHUwMDE0XFx1MDAxNlxcdTAwMThcIixcclxuICAgIFwiXFx1MDAxYVxcdTAwMWNcXHUwMDFlIFxcXCIkJigqLC5cXHUwMDAyXFxiXFx1MDAwM1xcdTAwMDJcXHUwMDFhXFx1MDAxYlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIiYpXFx1MDAwM1xcdTAwMDIqK1xcdTAwMDNcXHUwMDAyXFxuXFx1MDAwYlxcdTAwMDNcXHUwMDAyXFx1MDAxZFxcdTAwMWVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDFmIFxcdTAwMDJcXHUwMTYzXFx1MDAwMjNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAwNDtcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDZAXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcYkNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcbktcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFxmTVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDBlUVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxMF5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxMmBcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMTRpXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwMTZ9XFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDE4XFx1MDA3ZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDFhXFx1MDA4M1xcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAxY1xcdTAwOTRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDAxZVxcdTAwOWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMiBcXHUwMGExXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcXCJcXHUwMGE3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCIkXFx1MDBiMlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDImXFx1MDBiNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIoXFx1MDBjYVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyKlxcdTAwZTdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyLFxcdTAxMmFcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMi5cXHUwMTQzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjAyXFx1MDAwNVxcdTAwMDRcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDIxMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIyNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDIzMVxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyMzRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyNFxcdTAwMDNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIjUzXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjY8XFx1MDAwNVxcdTAwMWNcXHUwMDBmXFx1MDAwMjc8XFx1MDAwNSBcXHUwMDExXCIsXHJcbiAgICBcIlxcdTAwMDI4PFxcdTAwMDVcXFwiXFx1MDAxMlxcdTAwMDI5PFxcdTAwMDVcXHUwMDE0XFx1MDAwYlxcdTAwMDI6PFxcdTAwMDVcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDAyOzZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyOzdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyOzhcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMjs5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMjs6XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCI8XFx1MDAwNVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDI9P1xcdTAwMDVcXG5cXHUwMDA2XFx1MDAwMj49XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDI/QlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJAPlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJAQVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyQVxcdTAwMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyQkBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMkNEXFx0XFx1MDAwMlxcdTAwMDJcXHUwMDAyRFxcdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJFTFxcdTAwMDVcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAwMGZcXHUwMDAyRkxcXHUwMDA1IFxcdTAwMTFcXHUwMDAyR0xcXHUwMDA1XFxcIlxcdTAwMTJcXHUwMDAySExcXHUwMDA1XFx1MDAxNFwiLFxyXG4gICAgXCJcXHUwMDBiXFx1MDAwMklMXFx1MDAwNVxcdTAwMWFcXHUwMDBlXFx1MDAwMkpMXFx1MDAwNSZcXHUwMDE0XFx1MDAwMktFXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJLRlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJLR1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiS0hcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyS0lcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyS0pcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMkxcXHUwMDBiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMk1OXFx1MDAwN1xcdTAwMThcXHUwMDAyXFx1MDAwMk5PXFx1MDAwNVwiLFxyXG4gICAgXCIsXFx1MDAxN1xcdTAwMDJPUFxcdTAwMDdcXHUwMDE5XFx1MDAwMlxcdTAwMDJQXFxyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlFcIixcclxuICAgIFwiVVxcdTAwMDdcXHUwMDFjXFx1MDAwMlxcdTAwMDJSVFxcdTAwMDVcXGZcXHUwMDA3XFx1MDAwMlNSXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJUV1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJVU1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJVVlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyVlxcdTAwMGZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyV1VcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlhfXFx1MDAwNVxcdTAwMWNcXHUwMDBmXFx1MDAwMllfXFx1MDAwNSBcXHUwMDExXFx1MDAwMlpfXFx1MDAwNVxcdTAwMTRcXHUwMDBiXCIsXHJcbiAgICBcIlxcdTAwMDJbX1xcdTAwMDVcXFwiXFx1MDAxMlxcdTAwMDJcXFxcX1xcdTAwMDVcXHUwMDFlXFx1MDAxMFxcdTAwMDJdX1xcdTAwMDVcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDAyXlhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXllcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXlpcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMl5bXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMl5cXFxcXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJeXVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJfXFx1MDAxMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJgZFxcdTAwMDcuXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyYWNcXHUwMDA1XFx1MDAxMFxcdFxcdTAwMDJiYVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJjZlxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyZGJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyZGVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyZWdcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMmZkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMmdoXFx1MDAwNy9cXHUwMDAyXFx1MDAwMmhcXHUwMDEzXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJpalxcdTAwMDdcXHJcXHUwMDAyXFx1MDAwMmpvXFx1MDAwNVxcdTAwMGVcXGJcXHUwMDAyXCIsXHJcbiAgICBcImtsXFx1MDAwNyFcXHUwMDAyXFx1MDAwMmxtXFx1MDAwNVxcdTAwMTZcXGZcXHUwMDAybW5cXHUwMDA3XFxcIlxcdTAwMDJcXHUwMDAybnBcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMm9rXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMm9wXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJwcVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJxclxcdTAwMDUsXFx1MDAxN1xcdTAwMDJyc1xcdTAwMDcsXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyc1xcdTAwMTVcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAydHlcXHUwMDA3XFx1MDAxY1xcdTAwMDJcXHUwMDAydXZcXHUwMDA3XCIsXHJcbiAgICBcIiRcXHUwMDAyXFx1MDAwMnZ4XFx1MDAwN1xcdTAwMWNcXHUwMDAyXFx1MDAwMnd1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMnh7XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJ5d1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJ5elxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyen5cXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAye3lcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyfH5cXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMn10XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMn18XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMn5cXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDdmXFx1MDA4MFxcdTAwMDdcXHUwMDFiXFx1MDAwMlxcdTAwMDJcXHUwMDgwXFx1MDA4MVwiLFxyXG4gICAgXCJcXHUwMDA3LVxcdTAwMDJcXHUwMDAyXFx1MDA4MVxcdTAwODJcXHUwMDA3XFx1MDAxYlxcdTAwMDJcXHUwMDAyXFx1MDA4MlxcdTAwMTlcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwODNcXHUwMDg0XFx1MDAwN1xcdTAwMGZcXHUwMDAyXFx1MDAwMlxcdTAwODRcXHUwMDg1XCIsXHJcbiAgICBcIlxcdTAwMDchXFx1MDAwMlxcdTAwMDJcXHUwMDg1XFx1MDA4NlxcdTAwMDdcXHUwMDFjXFx1MDAwMlxcdTAwMDJcXHUwMDg2XFx1MDA4N1wiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAxMFxcdTAwMDJcXHUwMDAyXFx1MDA4N1xcdTAwODlcXHUwMDA3XFx1MDAxOFxcdTAwMDJcXHUwMDAyXFx1MDA4OFxcdTAwOGFcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMThcXHJcXHUwMDAyXFx1MDA4OVxcdTAwODhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA4YVxcdTAwOGJcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOGJcXHUwMDg5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOGJcXHUwMDhjXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhjXFx1MDA4ZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDhkXFx1MDA4ZVwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAxOVxcdTAwMDJcXHUwMDAyXFx1MDA4ZVxcdTAwOGZcXHUwMDA3XFxcIlxcdTAwMDJcXHUwMDAyXFx1MDA4ZlxcdTAwOTBcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMTJcXG5cXHUwMDAyXFx1MDA5MFxcdTAwMWJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDA5MVxcdTAwOTJcIixcclxuICAgIFwiXFx1MDAwNVxcdTAwMGVcXGJcXHUwMDAyXFx1MDA5MlxcdTAwOTNcXHUwMDA3LVxcdTAwMDJcXHUwMDAyXFx1MDA5M1xcdTAwOTVcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTRcXHUwMDkxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwOTRcXHUwMDk1XFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk1XFx1MDA5NlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMDk2XFx1MDA5N1xcdTAwMDVcIixcclxuICAgIFwiLFxcdTAwMTdcXHUwMDAyXFx1MDA5N1xcdTAwOThcXHUwMDA3K1xcdTAwMDJcXHUwMDAyXFx1MDA5OFxcdTAwOTlcXHUwMDA1LFxcdTAwMTdcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwOTlcXHUwMDlhXFx1MDAwNyxcXHUwMDAyXFx1MDAwMlxcdTAwOWFcXHUwMDFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDliXFx1MDA5Y1xcdTAwMDdcXHUwMDA1XFx1MDAwMlxcdTAwMDJcXHUwMDljXFx1MDA5ZFxcdTAwMDVcXHUwMDBlXFxiXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDlkXFx1MDA5ZVxcdTAwMDcrXFx1MDAwMlxcdTAwMDJcXHUwMDllXFx1MDA5ZlxcdTAwMDUsXFx1MDAxN1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDA5ZlxcdTAwYTBcXHUwMDA3LFxcdTAwMDJcXHUwMDAyXFx1MDBhMFxcdTAwMWZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYTFcXHUwMGEyXFx1MDAwNVxcdTAwMGVcXGJcXHUwMDAyXFx1MDBhMlxcdTAwYTNcXHUwMDA3XFx1MDAwNFxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYTNcXHUwMGE0XFx1MDAwNytcXHUwMDAyXFx1MDAwMlxcdTAwYTRcXHUwMGE1XFx1MDAwNSxcXHUwMDE3XFx1MDAwMlxcdTAwYTVcIixcclxuICAgIFwiXFx1MDBhNlxcdTAwMDcsXFx1MDAwMlxcdTAwMDJcXHUwMGE2IVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGE3XFx1MDBhOFwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAxNFxcdTAwMDJcXHUwMDAyXFx1MDBhOFxcdTAwYTlcXHUwMDA1XFx1MDAwZVxcYlxcdTAwMDJcXHUwMGE5XFx1MDBhYVwiLFxyXG4gICAgXCJcXHUwMDA3K1xcdTAwMDJcXHUwMDAyXFx1MDBhYVxcdTAwYWJcXHUwMDA1LFxcdTAwMTdcXHUwMDAyXFx1MDBhYlxcdTAwYWNcXHUwMDA3XCIsXHJcbiAgICBcIixcXHUwMDAyXFx1MDAwMlxcdTAwYWMjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYWRcXHUwMGIzXFx1MDAwNVxcdTAwMWNcIixcclxuICAgIFwiXFx1MDAwZlxcdTAwMDJcXHUwMGFlXFx1MDBiM1xcdTAwMDVcXHUwMDFlXFx1MDAxMFxcdTAwMDJcXHUwMGFmXFx1MDBiM1xcdTAwMDVcXHUwMDFhXCIsXHJcbiAgICBcIlxcdTAwMGVcXHUwMDAyXFx1MDBiMFxcdTAwYjNcXHUwMDA1XFx1MDAxNFxcdTAwMGJcXHUwMDAyXFx1MDBiMVxcdTAwYjNcXHUwMDA1XFxcIlwiLFxyXG4gICAgXCJcXHUwMDEyXFx1MDAwMlxcdTAwYjJcXHUwMGFkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjJcXHUwMGFlXFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGIyXFx1MDBhZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGIyXFx1MDBiMFxcdTAwMDNcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiMlxcdTAwYjFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiMyVcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYjRcXHUwMGI2XFx1MDAwN1xcdFxcdTAwMDJcXHUwMDAyXFx1MDBiNVxcdTAwYjRcXHUwMDAzXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwYjVcXHUwMGI2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYjZcXHUwMGI3XFx1MDAwM1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMGI3XFx1MDBiOFxcdTAwMDdcXHUwMDBlXFx1MDAwMlxcdTAwMDJcXHUwMGI4XFx1MDBiOVxcdTAwMDdcXHUwMDFjXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDBiOVxcdTAwYmRcXHUwMDA3LlxcdTAwMDJcXHUwMDAyXFx1MDBiYVxcdTAwYmNcXHUwMDA1JFxcdTAwMTNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwYmJcXHUwMGJhXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYmNcXHUwMGJmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGJkXFx1MDBiYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGJkXFx1MDBiZVxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBiZVxcdTAwYzBcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBiZlxcdTAwYmRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwYzBcXHUwMGMxXFx1MDAwNy9cXHUwMDAyXFx1MDAwMlxcdTAwYzFcXHUwMGMyXFx1MDAwN1xcdTAwMDdcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGMyXFx1MDBjN1xcdTAwMDUoXFx1MDAxNVxcdTAwMDJcXHUwMGMzXFx1MDBjNFxcdTAwMDckXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBjNFxcdTAwYzZcXHUwMDA1KFxcdTAwMTVcXHUwMDAyXFx1MDBjNVxcdTAwYzNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwYzZcXHUwMGM5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwYzdcXHUwMGM1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGM3XFx1MDBjOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGM4XFwnXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGM5XFx1MDBjN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGNhXFx1MDBjZlxcdTAwMDdcXHUwMDFjXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBjYlxcdTAwY2NcXHUwMDA3JFxcdTAwMDJcXHUwMDAyXFx1MDBjY1xcdTAwY2VcXHUwMDA3XFx1MDAxY1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwY2RcXHUwMGNiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwY2VcXHUwMGQxXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGNmXFx1MDBjZFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGNmXFx1MDBkMFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDBkMFxcdTAwZDJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkMVxcdTAwY2ZcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwZDJcXHUwMGQzXFx1MDAwN1xcdTAwMDZcXHUwMDAyXFx1MDAwMlxcdTAwZDNcXHUwMGQ0XFx1MDAwNyFcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGQ0XFx1MDBkNVxcdTAwMDUqXFx1MDAxNlxcdTAwMDJcXHUwMGQ1XFx1MDBkNlxcdTAwMDdcXFwiXFx1MDAwMlxcdTAwMDJcXHUwMGQ2XCIsXHJcbiAgICBcIilcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBkN1xcdTAwZDhcXGJcXHUwMDE2XFx1MDAwMVxcdTAwMDJcXHUwMGQ4XFx1MDBkOVwiLFxyXG4gICAgXCJcXHUwMDA3IVxcdTAwMDJcXHUwMDAyXFx1MDBkOVxcdTAwZGFcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXFx1MDBkYVxcdTAwZGJcXHUwMDA3XCIsXHJcbiAgICBcIlxcXCJcXHUwMDAyXFx1MDAwMlxcdTAwZGJcXHUwMGU4XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZGNcXHUwMGRkXFx1MDAwN1wiLFxyXG4gICAgXCJcXHUwMDE3XFx1MDAwMlxcdTAwMDJcXHUwMGRkXFx1MDBlOFxcdTAwMDUqXFx1MDAxNlxcYlxcdTAwZGVcXHUwMGRmXFx1MDAwNSxcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMGRmXFx1MDBlMFxcdFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwZTBcXHUwMGUxXFx1MDAwNSxcXHUwMDE3XFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMGUxXFx1MDBlOFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGUyXFx1MDBlM1xcdTAwMDUsXFx1MDAxN1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDBlM1xcdTAwZTRcXHRcXHUwMDA0XFx1MDAwMlxcdTAwMDJcXHUwMGU0XFx1MDBlNVxcdTAwMDUsXFx1MDAxN1xcdTAwMDJcXHUwMGU1XCIsXHJcbiAgICBcIlxcdTAwZThcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlNlxcdTAwZThcXHRcXHUwMDA1XFx1MDAwMlxcdTAwMDJcXHUwMGU3XCIsXHJcbiAgICBcIlxcdTAwZDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlN1xcdTAwZGNcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBlN1wiLFxyXG4gICAgXCJcXHUwMGRlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTdcXHUwMGUyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZTdcIixcclxuICAgIFwiXFx1MDBlNlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGU4XFx1MDBmMVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGU5XCIsXHJcbiAgICBcIlxcdTAwZWFcXGZcXHUwMDA1XFx1MDAwMlxcdTAwMDJcXHUwMGVhXFx1MDBlYlxcdTAwMDdcXHUwMDE2XFx1MDAwMlxcdTAwMDJcXHUwMGViXCIsXHJcbiAgICBcIlxcdTAwZjBcXHUwMDA1KlxcdTAwMTZcXHUwMDA2XFx1MDBlY1xcdTAwZWRcXGZcXHUwMDA0XFx1MDAwMlxcdTAwMDJcXHUwMGVkXFx1MDBlZVwiLFxyXG4gICAgXCJcXHUwMDA3XFx1MDAxNVxcdTAwMDJcXHUwMDAyXFx1MDBlZVxcdTAwZjBcXHUwMDA1KlxcdTAwMTZcXHUwMDA1XFx1MDBlZlxcdTAwZTlcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZWZcXHUwMGVjXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjBcXHUwMGYzXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGYxXFx1MDBlZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGYxXFx1MDBmMlwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBmMitcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDBmM1xcdTAwZjFcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAwZjRcXHUwMGY1XFxiXFx1MDAxN1xcdTAwMDFcXHUwMDAyXFx1MDBmNVxcdTAwZjZcIixcclxuICAgIFwiXFx1MDAwNyFcXHUwMDAyXFx1MDAwMlxcdTAwZjZcXHUwMGY3XFx1MDAwNSxcXHUwMDE3XFx1MDAwMlxcdTAwZjdcXHUwMGY4XFx1MDAwN1wiLFxyXG4gICAgXCJcXFwiXFx1MDAwMlxcdTAwMDJcXHUwMGY4XFx1MDEyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMGY5XFx1MDBmYVxcdTAwMDdcIixcclxuICAgIFwiXFxiXFx1MDAwMlxcdTAwMDJcXHUwMGZhXFx1MDBmYlxcdTAwMDchXFx1MDAwMlxcdTAwMDJcXHUwMGZiXFx1MDBmY1xcdTAwMDVcXHUwMDBlXCIsXHJcbiAgICBcIlxcYlxcdTAwMDJcXHUwMGZjXFx1MDBmZFxcdTAwMDdcXFwiXFx1MDAwMlxcdTAwMDJcXHUwMGZkXFx1MDEyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDBmZVxcdTAwZmZcXHUwMDA3XFx1MDAxY1xcdTAwMDJcXHUwMDAyXFx1MDBmZlxcdTAxMDBcXHUwMDA3IVxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMDBcXHUwMTAxXFx1MDAwNS5cXHUwMDE4XFx1MDAwMlxcdTAxMDFcXHUwMTAyXFx1MDAwN1xcXCJcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTAyXFx1MDEyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTAzXFx1MDEwNFxcdFxcdTAwMDZcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMTA0XFx1MDEyYlxcdTAwMDUsXFx1MDAxN1xcblxcdTAxMDVcXHUwMTA3XFx1MDAwNVxcdTAwMGVcXGJcXHUwMDAyXFx1MDEwNlxcdTAxMDhcIixcclxuICAgIFwiXFx1MDAwNzBcXHUwMDAyXFx1MDAwMlxcdTAxMDdcXHUwMTA2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMDdcXHUwMTA4XCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTA4XFx1MDEyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTA5XFx1MDEyYlwiLFxyXG4gICAgXCJcXHUwMDA1XFxiXFx1MDAwNVxcdTAwMDJcXHUwMTBhXFx1MDEwYlxcdTAwMDdcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMTBiXFx1MDExNFwiLFxyXG4gICAgXCJcXHUwMDA1XFx1MDAwZVxcYlxcdTAwMDJcXHUwMTBjXFx1MDExMFxcdTAwMDchXFx1MDAwMlxcdTAwMDJcXHUwMTBkXFx1MDEwZlxcdTAwMDVcIixcclxuICAgIFwiLFxcdTAwMTdcXHUwMDAyXFx1MDEwZVxcdTAxMGRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEwZlxcdTAxMTJcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTBcXHUwMTBlXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTBcXHUwMTExXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTExXFx1MDExM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTEyXFx1MDExMFxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDExM1xcdTAxMTVcXHUwMDA3XFxcIlxcdTAwMDJcXHUwMDAyXFx1MDExNFxcdTAxMGNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTRcXHUwMTE1XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMTVcXHUwMTJiXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTE2XFx1MDExN1xcdTAwMDdcXGZcXHUwMDAyXFx1MDAwMlxcdTAxMTdcXHUwMTE4XFx1MDAwN1wiLFxyXG4gICAgXCIhXFx1MDAwMlxcdTAwMDJcXHUwMTE4XFx1MDExOVxcdTAwMDdcXHUwMDFjXFx1MDAwMlxcdTAwMDJcXHUwMTE5XFx1MDExYVxcdTAwMDdcIixcclxuICAgIFwiXFx1MDAxMFxcdTAwMDJcXHUwMDAyXFx1MDExYVxcdTAxMWJcXHUwMDA3XFx1MDAxOFxcdTAwMDJcXHUwMDAyXFx1MDExYlxcdTAxMWNcXHUwMDA1XCIsXHJcbiAgICBcIlxcdTAwMThcXHJcXHUwMDAyXFx1MDExY1xcdTAxMWRcXHUwMDA3XFx1MDAxOVxcdTAwMDJcXHUwMDAyXFx1MDExZFxcdTAxMWVcXHUwMDA3XCIsXHJcbiAgICBcIlxcXCJcXHUwMDAyXFx1MDAwMlxcdTAxMWVcXHUwMTFmXFx1MDAwNy5cXHUwMDAyXFx1MDAwMlxcdTAxMWZcXHUwMTIwXFx1MDAwNSxcXHUwMDE3XCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTIwXFx1MDEyMVxcdTAwMDcvXFx1MDAwMlxcdTAwMDJcXHUwMTIxXFx1MDEyYlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEyMlxcdTAxMjNcXHUwMDA3LlxcdTAwMDJcXHUwMDAyXFx1MDEyM1xcdTAxMjRcXHUwMDA1KlxcdTAwMTZcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAxMjRcXHUwMTI1XFx1MDAwNzFcXHUwMDAyXFx1MDAwMlxcdTAxMjVcXHUwMTI2XFx1MDAwNSxcXHUwMDE3XFx1MDAwMlxcdTAxMjZcIixcclxuICAgIFwiXFx1MDEyN1xcdTAwMDctXFx1MDAwMlxcdTAwMDJcXHUwMTI3XFx1MDEyOFxcdTAwMDUsXFx1MDAxN1xcdTAwMDJcXHUwMTI4XFx1MDEyOVwiLFxyXG4gICAgXCJcXHUwMDA3L1xcdTAwMDJcXHUwMDAyXFx1MDEyOVxcdTAxMmJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyYVxcdTAwZjRcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmFcXHUwMGY5XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmFcXHUwMGZlXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJhXFx1MDEwM1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJhXFx1MDEwNVwiLFxyXG4gICAgXCJcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyYVxcdTAxMDlcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEyYVxcdTAxMGFcIixcclxuICAgIFwiXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmFcXHUwMTE2XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMmFcXHUwMTIyXCIsXHJcbiAgICBcIlxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJiXFx1MDEzN1xcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTJjXFx1MDEyZFwiLFxyXG4gICAgXCJcXGZcXHUwMDBiXFx1MDAwMlxcdTAwMDJcXHUwMTJkXFx1MDEyZVxcdTAwMDclXFx1MDAwMlxcdTAwMDJcXHUwMTJlXFx1MDEzNlxcdTAwMDVcIixcclxuICAgIFwiLFxcdTAwMTdcXHUwMDBiXFx1MDEyZlxcdTAxMzBcXGZcXHRcXHUwMDAyXFx1MDAwMlxcdTAxMzBcXHUwMTMxXFx0XFx1MDAwN1xcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxMzFcXHUwMTM2XFx1MDAwNSxcXHUwMDE3XFxuXFx1MDEzMlxcdTAxMzNcXGZcXGJcXHUwMDAyXFx1MDAwMlxcdTAxMzNcIixcclxuICAgIFwiXFx1MDEzNFxcdFxcdTAwMDZcXHUwMDAyXFx1MDAwMlxcdTAxMzRcXHUwMTM2XFx1MDAwNSxcXHUwMDE3XFx0XFx1MDEzNVxcdTAxMmNcXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzVcXHUwMTJmXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzVcXHUwMTMyXFx1MDAwM1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTM2XFx1MDEzOVxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTM3XFx1MDEzNVxcdTAwMDNcIixcclxuICAgIFwiXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzN1xcdTAxMzhcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzOC1cXHUwMDAzXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxMzlcXHUwMTM3XFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxM2FcXHUwMTNmXFx1MDAwNVwiLFxyXG4gICAgXCIsXFx1MDAxN1xcdTAwMDJcXHUwMTNiXFx1MDEzY1xcdTAwMDckXFx1MDAwMlxcdTAwMDJcXHUwMTNjXFx1MDEzZVxcdTAwMDUsXFx1MDAxN1wiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDEzZFxcdTAxM2JcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDEzZVxcdTAxNDFcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxM2ZcXHUwMTNkXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxM2ZcXHUwMTQwXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMTQwXFx1MDE0NFxcdTAwMDNcXHUwMDAyXFx1MDAwMlxcdTAwMDJcXHUwMTQxXFx1MDEzZlxcdTAwMDNcXHUwMDAyXFx1MDAwMlwiLFxyXG4gICAgXCJcXHUwMDAyXFx1MDE0MlxcdTAxNDRcXHUwMDAzXFx1MDAwMlxcdTAwMDJcXHUwMDAyXFx1MDE0M1xcdTAxM2FcXHUwMDAzXFx1MDAwMlxcdTAwMDJcIixcclxuICAgIFwiXFx1MDAwMlxcdTAxNDNcXHUwMTQyXFx1MDAwM1xcdTAwMDJcXHUwMDAyXFx1MDAwMlxcdTAxNDQvXFx1MDAwM1xcdTAwMDJcXHUwMDAyXCIsXHJcbiAgICBcIlxcdTAwMDJcXHUwMDFlMztAS1VeZG95fVxcdTAwOGJcXHUwMDk0XFx1MDBiMlxcdTAwYjVcXHUwMGJkXFx1MDBjN1xcdTAwY2ZcXHUwMGU3XCIsXHJcbiAgICBcIlxcdTAwZWZcXHUwMGYxXFx1MDEwN1xcdTAxMTBcXHUwMTE0XFx1MDEyYVxcdTAxMzVcXHUwMTM3XFx1MDEzZlxcdTAxNDNcIl0uam9pbihcIlwiKTtcclxuXHJcblxyXG52YXIgYXRuID0gbmV3IGFudGxyNC5hdG4uQVRORGVzZXJpYWxpemVyKCkuZGVzZXJpYWxpemUoc2VyaWFsaXplZEFUTik7XHJcblxyXG52YXIgZGVjaXNpb25zVG9ERkEgPSBhdG4uZGVjaXNpb25Ub1N0YXRlLm1hcCggZnVuY3Rpb24oZHMsIGluZGV4KSB7IHJldHVybiBuZXcgYW50bHI0LmRmYS5ERkEoZHMsIGluZGV4KTsgfSk7XHJcblxyXG52YXIgc2hhcmVkQ29udGV4dENhY2hlID0gbmV3IGFudGxyNC5QcmVkaWN0aW9uQ29udGV4dENhY2hlKCk7XHJcblxyXG52YXIgbGl0ZXJhbE5hbWVzID0gWyBudWxsLCBcIicjJ1wiLCBcIicodDApJ1wiLCBcIidzZXQnXCIsIFwiJ29uJ1wiLCBcIidmcm9tJ1wiLCBcIidkZXInXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIid0ZXJtaW5hbCdcIiwgXCIndHJ1ZSdcIiwgXCInZmFsc2UnXCIsIFwiJ3N1bSdcIiwgXCInbWFjcm8nXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICBcIidzdGF0ZSdcIiwgXCInZm9yJ1wiLCBcIidpbidcIiwgXCInaWYnXCIsIFwiJ2Vsc2UnXCIsIFwiJ2xvY2FsJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInY29uc3RhbnQnXCIsIG51bGwsIG51bGwsIG51bGwsIFwiJ1snXCIsIFwiJ10nXCIsIG51bGwsIFxyXG4gICAgICAgICAgICAgICAgICAgICBudWxsLCBudWxsLCBcIicrJ1wiLCBcIictJ1wiLCBcIicqJ1wiLCBcIicvJ1wiLCBcIicoJ1wiLCBcIicpJ1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInLidcIiwgXCInLCdcIiwgXCInXidcIiwgXCInPCdcIiwgXCInPidcIiwgXCInPD0nXCIsIFwiJz49J1wiLCBcclxuICAgICAgICAgICAgICAgICAgICAgXCInIT0nXCIsIFwiJz0nXCIsIFwiJzsnXCIsIFwiJzonXCIsIFwiJ3snXCIsIFwiJ30nXCIsIFwiJycnXCIsIFwiJz8nXCIgXTtcclxuXHJcbnZhciBzeW1ib2xpY05hbWVzID0gWyBudWxsLCBudWxsLCBcIlQwXCIsIFwiU0VUXCIsIFwiT05cIiwgXCJGUk9NXCIsIFwiREVSXCIsIFwiVEVSTUlOQUxcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlRSVUVcIiwgXCJGQUxTRVwiLCBcIlNVTVwiLCBcIk1BQ1JPXCIsIFwiU1RBVEVcIiwgXCJGT1JcIiwgXCJJTlwiLCBcclxuICAgICAgICAgICAgICAgICAgICAgIFwiSUZcIiwgXCJFTFNFXCIsIFwiTE9DQUxcIiwgXCJDT05TVEFOVFwiLCBcIk9SXCIsIFwiQU5EXCIsIFwiTk9UXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJMU1FSXCIsIFwiUlNRUlwiLCBcIkZMT0FUXCIsIFwiSU5UXCIsIFwiSURcIiwgXCJQTFVTXCIsIFwiTUlOVVNcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkFTVEVSSVNLXCIsIFwiRElWSVNJT05cIiwgXCJMUEFSRU5cIiwgXCJSUEFSRU5cIiwgXCJET1RcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkNPTU1BXCIsIFwiQ0FSRVRcIiwgXCJMXCIsIFwiR1wiLCBcIkxFXCIsIFwiR0VcIiwgXCJORVwiLCBcIkVcIiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlNFTUlDT0xPTlwiLCBcIkNPTE9OXCIsIFwiTENSTFwiLCBcIlJDUkxcIiwgXCJBUE9TVFJPUEhFXCIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJRVUVTVElPTk1BUktcIiwgXCJORVdMSU5FXCIsIFwiV0hJVEVTUEFDRVwiLCBcIkNPTU1FTlRcIiBdO1xyXG5cclxudmFyIHJ1bGVOYW1lcyA9ICBbIFwiZGFlXCIsIFwiZGFlU3RhdGVtZW50XCIsIFwiaHlicmlkXCIsIFwibnVtYmVyXCIsIFwiaHlicmlkU3RhdGVtZW50XCIsIFxyXG4gICAgICAgICAgICAgICAgICAgXCJpbmRleFwiLCBcInZhcklkZW50aWZpZXJcIiwgXCJsb29wU3RhdGVtZW50XCIsIFwibG9vcEJvZHlcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcIm1hY3JvU3RhdGVtZW50XCIsIFwibWFjcm9Bcmd1bWVudHNcIiwgXCJsb29wQm91bmRzXCIsIFwibG9vcFwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZXF1YXRpb25cIiwgXCJzZXR0ZXJcIiwgXCJpbml0aWFsQ29uZGl0aW9uXCIsIFwiY29uc3RhbnRTdGF0ZW1lbnRcIiwgXHJcbiAgICAgICAgICAgICAgICAgICBcInN0YXRlU3RhdGVtZW50XCIsIFwic3RhdGVEZWZcIiwgXCJzdGF0ZVRyYW5zaXRpb25cIiwgXCJib29sRXhwcmVzc2lvblwiLCBcclxuICAgICAgICAgICAgICAgICAgIFwiZXhwcmVzc2lvblwiLCBcImZ1bmN0aW9uQXJndW1lbnRzXCIgXTtcclxuXHJcbmZ1bmN0aW9uIG9kZUdyYW1tYXJQYXJzZXIgKGlucHV0KSB7XHJcblx0YW50bHI0LlBhcnNlci5jYWxsKHRoaXMsIGlucHV0KTtcclxuICAgIHRoaXMuX2ludGVycCA9IG5ldyBhbnRscjQuYXRuLlBhcnNlckFUTlNpbXVsYXRvcih0aGlzLCBhdG4sIGRlY2lzaW9uc1RvREZBLCBzaGFyZWRDb250ZXh0Q2FjaGUpO1xyXG4gICAgdGhpcy5ydWxlTmFtZXMgPSBydWxlTmFtZXM7XHJcbiAgICB0aGlzLmxpdGVyYWxOYW1lcyA9IGxpdGVyYWxOYW1lcztcclxuICAgIHRoaXMuc3ltYm9saWNOYW1lcyA9IHN5bWJvbGljTmFtZXM7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXIucHJvdG90eXBlKTtcclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBvZGVHcmFtbWFyUGFyc2VyO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLCBcImF0blwiLCB7XHJcblx0Z2V0IDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gYXRuO1xyXG5cdH1cclxufSk7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkVPRiA9IGFudGxyNC5Ub2tlbi5FT0Y7XHJcbm9kZUdyYW1tYXJQYXJzZXIuVF9fMCA9IDE7XHJcbm9kZUdyYW1tYXJQYXJzZXIuVDAgPSAyO1xyXG5vZGVHcmFtbWFyUGFyc2VyLlNFVCA9IDM7XHJcbm9kZUdyYW1tYXJQYXJzZXIuT04gPSA0O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkZST00gPSA1O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkRFUiA9IDY7XHJcbm9kZUdyYW1tYXJQYXJzZXIuVEVSTUlOQUwgPSA3O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlRSVUUgPSA4O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkZBTFNFID0gOTtcclxub2RlR3JhbW1hclBhcnNlci5TVU0gPSAxMDtcclxub2RlR3JhbW1hclBhcnNlci5NQUNSTyA9IDExO1xyXG5vZGVHcmFtbWFyUGFyc2VyLlNUQVRFID0gMTI7XHJcbm9kZUdyYW1tYXJQYXJzZXIuRk9SID0gMTM7XHJcbm9kZUdyYW1tYXJQYXJzZXIuSU4gPSAxNDtcclxub2RlR3JhbW1hclBhcnNlci5JRiA9IDE1O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkVMU0UgPSAxNjtcclxub2RlR3JhbW1hclBhcnNlci5MT0NBTCA9IDE3O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkNPTlNUQU5UID0gMTg7XHJcbm9kZUdyYW1tYXJQYXJzZXIuT1IgPSAxOTtcclxub2RlR3JhbW1hclBhcnNlci5BTkQgPSAyMDtcclxub2RlR3JhbW1hclBhcnNlci5OT1QgPSAyMTtcclxub2RlR3JhbW1hclBhcnNlci5MU1FSID0gMjI7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlNRUiA9IDIzO1xyXG5vZGVHcmFtbWFyUGFyc2VyLkZMT0FUID0gMjQ7XHJcbm9kZUdyYW1tYXJQYXJzZXIuSU5UID0gMjU7XHJcbm9kZUdyYW1tYXJQYXJzZXIuSUQgPSAyNjtcclxub2RlR3JhbW1hclBhcnNlci5QTFVTID0gMjc7XHJcbm9kZUdyYW1tYXJQYXJzZXIuTUlOVVMgPSAyODtcclxub2RlR3JhbW1hclBhcnNlci5BU1RFUklTSyA9IDI5O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkRJVklTSU9OID0gMzA7XHJcbm9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOID0gMzE7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOID0gMzI7XHJcbm9kZUdyYW1tYXJQYXJzZXIuRE9UID0gMzM7XHJcbm9kZUdyYW1tYXJQYXJzZXIuQ09NTUEgPSAzNDtcclxub2RlR3JhbW1hclBhcnNlci5DQVJFVCA9IDM1O1xyXG5vZGVHcmFtbWFyUGFyc2VyLkwgPSAzNjtcclxub2RlR3JhbW1hclBhcnNlci5HID0gMzc7XHJcbm9kZUdyYW1tYXJQYXJzZXIuTEUgPSAzODtcclxub2RlR3JhbW1hclBhcnNlci5HRSA9IDM5O1xyXG5vZGVHcmFtbWFyUGFyc2VyLk5FID0gNDA7XHJcbm9kZUdyYW1tYXJQYXJzZXIuRSA9IDQxO1xyXG5vZGVHcmFtbWFyUGFyc2VyLlNFTUlDT0xPTiA9IDQyO1xyXG5vZGVHcmFtbWFyUGFyc2VyLkNPTE9OID0gNDM7XHJcbm9kZUdyYW1tYXJQYXJzZXIuTENSTCA9IDQ0O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJDUkwgPSA0NTtcclxub2RlR3JhbW1hclBhcnNlci5BUE9TVFJPUEhFID0gNDY7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUVVFU1RJT05NQVJLID0gNDc7XHJcbm9kZUdyYW1tYXJQYXJzZXIuTkVXTElORSA9IDQ4O1xyXG5vZGVHcmFtbWFyUGFyc2VyLldISVRFU1BBQ0UgPSA0OTtcclxub2RlR3JhbW1hclBhcnNlci5DT01NRU5UID0gNTA7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfZGFlID0gMDtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2RhZVN0YXRlbWVudCA9IDE7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlVMRV9oeWJyaWQgPSAyO1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfbnVtYmVyID0gMztcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2h5YnJpZFN0YXRlbWVudCA9IDQ7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlVMRV9pbmRleCA9IDU7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlVMRV92YXJJZGVudGlmaWVyID0gNjtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BTdGF0ZW1lbnQgPSA3O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfbG9vcEJvZHkgPSA4O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfbWFjcm9TdGF0ZW1lbnQgPSA5O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfbWFjcm9Bcmd1bWVudHMgPSAxMDtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BCb3VuZHMgPSAxMTtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3AgPSAxMjtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2VxdWF0aW9uID0gMTM7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlVMRV9zZXR0ZXIgPSAxNDtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2luaXRpYWxDb25kaXRpb24gPSAxNTtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2NvbnN0YW50U3RhdGVtZW50ID0gMTY7XHJcbm9kZUdyYW1tYXJQYXJzZXIuUlVMRV9zdGF0ZVN0YXRlbWVudCA9IDE3O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfc3RhdGVEZWYgPSAxODtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX3N0YXRlVHJhbnNpdGlvbiA9IDE5O1xyXG5vZGVHcmFtbWFyUGFyc2VyLlJVTEVfYm9vbEV4cHJlc3Npb24gPSAyMDtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2V4cHJlc3Npb24gPSAyMTtcclxub2RlR3JhbW1hclBhcnNlci5SVUxFX2Z1bmN0aW9uQXJndW1lbnRzID0gMjI7XHJcblxyXG5cclxuZnVuY3Rpb24gRGFlQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX2RhZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5EYWVDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkRhZUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGFlQ29udGV4dDtcclxuXHJcbkRhZUNvbnRleHQucHJvdG90eXBlLmRhZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRGFlU3RhdGVtZW50Q29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRGFlU3RhdGVtZW50Q29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRhZUNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGFlKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5EYWVDb250ZXh0ID0gRGFlQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmRhZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBEYWVDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMCwgb2RlR3JhbW1hclBhcnNlci5SVUxFX2RhZSk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA0OTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgd2hpbGUoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuVF9fMCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLkRFUikgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLlNVTSkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1BQ1JPKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuRk9SKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5GTE9BVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklOVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklEKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuUExVUykgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1JTlVTKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKSkpICE9PSAwKSB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkxDUkwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDQ2O1xyXG4gICAgICAgICAgICB0aGlzLmRhZVN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTE7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBEYWVTdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfZGFlU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkRhZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRGFlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEYWVTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuRGFlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXF1YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXF1YXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuRGFlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuaW5pdGlhbENvbmRpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0aWFsQ29uZGl0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkRhZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0YW50U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50U3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkRhZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLm1hY3JvU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KE1hY3JvU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkRhZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9vcENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5EYWVTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERhZVN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuRGFlU3RhdGVtZW50Q29udGV4dCA9IERhZVN0YXRlbWVudENvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLnByb3RvdHlwZS5kYWVTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRGFlU3RhdGVtZW50Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDIsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9kYWVTdGF0ZW1lbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNTc7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDEsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTI7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDUzO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxDb25kaXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU0O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50U3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA1NTtcclxuICAgICAgICAgICAgdGhpcy5tYWNyb1N0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNTY7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBIeWJyaWRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfaHlicmlkO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkh5YnJpZENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSHlicmlkQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIeWJyaWRDb250ZXh0O1xyXG5cclxuSHlicmlkQ29udGV4dC5wcm90b3R5cGUuaHlicmlkU3RhdGVtZW50ID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhIeWJyaWRTdGF0ZW1lbnRDb250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChIeWJyaWRTdGF0ZW1lbnRDb250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuSHlicmlkQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRIeWJyaWQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkh5YnJpZENvbnRleHQgPSBIeWJyaWRDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuaHlicmlkID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEh5YnJpZENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCA0LCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfaHlicmlkKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDYyO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB3aGlsZSgoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgb2RlR3JhbW1hclBhcnNlci5UX18wKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuREVSKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuVEVSTUlOQUwpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5TVU0pIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5NQUNSTykgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLlNUQVRFKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuRk9SKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5GTE9BVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklOVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklEKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuUExVUykgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1JTlVTKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKSkpICE9PSAwKSB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkxDUkwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDU5O1xyXG4gICAgICAgICAgICB0aGlzLmh5YnJpZFN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBOdW1iZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbnVtYmVyO1xyXG4gICAgdGhpcy52YWx1ZSA9IG51bGw7IC8vIFRva2VuXHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuTnVtYmVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5OdW1iZXJDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE51bWJlckNvbnRleHQ7XHJcblxyXG5OdW1iZXJDb250ZXh0LnByb3RvdHlwZS5GTE9BVCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5GTE9BVCwgMCk7XHJcbn07XHJcblxyXG5OdW1iZXJDb250ZXh0LnByb3RvdHlwZS5JTlQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuSU5ULCAwKTtcclxufTtcclxuXHJcbk51bWJlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TnVtYmVyKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5OdW1iZXJDb250ZXh0ID0gTnVtYmVyQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLm51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBOdW1iZXJDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNiwgb2RlR3JhbW1hclBhcnNlci5SVUxFX251bWJlcik7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA2NTtcclxuICAgICAgICBsb2NhbGN0eC52YWx1ZSA9IHRoaXMuX2lucHV0LkxUKDEpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGlmKCEoX2xhPT09b2RlR3JhbW1hclBhcnNlci5GTE9BVCB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLklOVCkpIHtcclxuICAgICAgICAgICAgbG9jYWxjdHgudmFsdWUgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBIeWJyaWRTdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfaHlicmlkU3RhdGVtZW50O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkh5YnJpZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSHlicmlkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIeWJyaWRTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxuSHlicmlkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXF1YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXF1YXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuSHlicmlkU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuaW5pdGlhbENvbmRpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChJbml0aWFsQ29uZGl0aW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkh5YnJpZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0YW50U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50U3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkh5YnJpZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLm1hY3JvU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KE1hY3JvU3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkh5YnJpZFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9vcENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5IeWJyaWRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5zdGF0ZURlZiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChTdGF0ZURlZkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5IeWJyaWRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEh5YnJpZFN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuSHlicmlkU3RhdGVtZW50Q29udGV4dCA9IEh5YnJpZFN0YXRlbWVudENvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLnByb3RvdHlwZS5oeWJyaWRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgSHlicmlkU3RhdGVtZW50Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDgsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9oeWJyaWRTdGF0ZW1lbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzM7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDMsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNjc7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY4O1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxDb25kaXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDY5O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50U3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA3MDtcclxuICAgICAgICAgICAgdGhpcy5tYWNyb1N0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzE7XHJcbiAgICAgICAgICAgIHRoaXMubG9vcCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDYpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gNzI7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVEZWYoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gSW5kZXhDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfaW5kZXg7XHJcbiAgICB0aGlzLmV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSW5kZXhDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkluZGV4Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleENvbnRleHQ7XHJcblxyXG5JbmRleENvbnRleHQucHJvdG90eXBlLkxTUVIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTFNRUiwgMCk7XHJcbn07XHJcblxyXG5JbmRleENvbnRleHQucHJvdG90eXBlLlJTUVIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUlNRUiwgMCk7XHJcbn07XHJcblxyXG5JbmRleENvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5JbmRleENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5kZXgodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkluZGV4Q29udGV4dCA9IEluZGV4Q29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IEluZGV4Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDEwLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfaW5kZXgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA3NTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFNRUik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDc2O1xyXG4gICAgICAgIGxvY2FsY3R4LmV4cCA9IHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gNzc7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJTUVIpO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBWYXJJZGVudGlmaWVyQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX3ZhcklkZW50aWZpZXI7XHJcbiAgICB0aGlzLmlkID0gbnVsbDsgLy8gVG9rZW5cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5WYXJJZGVudGlmaWVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5WYXJJZGVudGlmaWVyQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYXJJZGVudGlmaWVyQ29udGV4dDtcclxuXHJcblZhcklkZW50aWZpZXJDb250ZXh0LnByb3RvdHlwZS5JRCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5JRCwgMCk7XHJcbn07XHJcblxyXG5WYXJJZGVudGlmaWVyQ29udGV4dC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEluZGV4Q29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSW5kZXhDb250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVmFySWRlbnRpZmllckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFySWRlbnRpZmllcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuVmFySWRlbnRpZmllckNvbnRleHQgPSBWYXJJZGVudGlmaWVyQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLnZhcklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgVmFySWRlbnRpZmllckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxMiwgb2RlR3JhbW1hclBhcnNlci5SVUxFX3ZhcklkZW50aWZpZXIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA3OTtcclxuICAgICAgICBsb2NhbGN0eC5pZCA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JRCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDgzO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsNCx0aGlzLl9jdHgpXHJcbiAgICAgICAgd2hpbGUoX2FsdCE9MiAmJiBfYWx0IT1hbnRscjQuYXRuLkFUTi5JTlZBTElEX0FMVF9OVU1CRVIpIHtcclxuICAgICAgICAgICAgaWYoX2FsdD09PTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4MDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgoKTsgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg1O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDQsdGhpcy5fY3R4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBMb29wU3RhdGVtZW50Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BTdGF0ZW1lbnQ7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuTG9vcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuTG9vcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9vcFN0YXRlbWVudENvbnRleHQ7XHJcblxyXG5Mb29wU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXF1YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXF1YXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuTG9vcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmluaXRpYWxDb25kaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoSW5pdGlhbENvbmRpdGlvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5Mb29wU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUubWFjcm9TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTWFjcm9TdGF0ZW1lbnRDb250ZXh0LDApO1xyXG59O1xyXG5cclxuTG9vcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmNvbnN0YW50U3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KENvbnN0YW50U3RhdGVtZW50Q29udGV4dCwwKTtcclxufTtcclxuXHJcbkxvb3BTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU2V0dGVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkxvb3BTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KExvb3BDb250ZXh0LDApO1xyXG59O1xyXG5cclxuTG9vcFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TG9vcFN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuTG9vcFN0YXRlbWVudENvbnRleHQgPSBMb29wU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmxvb3BTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgTG9vcFN0YXRlbWVudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxNCwgb2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BTdGF0ZW1lbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gOTI7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDUsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gODY7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAyKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg3O1xyXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxDb25kaXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAzKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDg4O1xyXG4gICAgICAgICAgICB0aGlzLm1hY3JvU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA4OTtcclxuICAgICAgICAgICAgdGhpcy5jb25zdGFudFN0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gOTA7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0dGVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgNik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSA5MTtcclxuICAgICAgICAgICAgdGhpcy5sb29wKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIExvb3BCb2R5Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BCb2R5O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkxvb3BCb2R5Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Mb29wQm9keUNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTG9vcEJvZHlDb250ZXh0O1xyXG5cclxuTG9vcEJvZHlDb250ZXh0LnByb3RvdHlwZS5MQ1JMID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkxDUkwsIDApO1xyXG59O1xyXG5cclxuTG9vcEJvZHlDb250ZXh0LnByb3RvdHlwZS5SQ1JMID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJDUkwsIDApO1xyXG59O1xyXG5cclxuTG9vcEJvZHlDb250ZXh0LnByb3RvdHlwZS5sb29wU3RhdGVtZW50ID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhMb29wU3RhdGVtZW50Q29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9vcFN0YXRlbWVudENvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Mb29wQm9keUNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TG9vcEJvZHkodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkxvb3BCb2R5Q29udGV4dCA9IExvb3BCb2R5Q29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmxvb3BCb2R5ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IExvb3BCb2R5Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDE2LCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbG9vcEJvZHkpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gOTQ7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLkxDUkwpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSA5ODtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgd2hpbGUoKCgoX2xhKSAmIH4weDFmKSA9PSAwICYmICgoMSA8PCBfbGEpICYgKCgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuVF9fMCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLlNFVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLkRFUikgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLlNVTSkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1BQ1JPKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuRk9SKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5GTE9BVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklOVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklEKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuUExVUykgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1JTlVTKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKSkpICE9PSAwKSB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkxDUkwpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDk1O1xyXG4gICAgICAgICAgICB0aGlzLmxvb3BTdGF0ZW1lbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwMTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuUkNSTCk7XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIE1hY3JvU3RhdGVtZW50Q29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX21hY3JvU3RhdGVtZW50O1xyXG4gICAgdGhpcy5pZCA9IG51bGw7IC8vIFZhcklkZW50aWZpZXJDb250ZXh0XHJcbiAgICB0aGlzLmV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuTWFjcm9TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbk1hY3JvU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYWNyb1N0YXRlbWVudENvbnRleHQ7XHJcblxyXG5NYWNyb1N0YXRlbWVudENvbnRleHQucHJvdG90eXBlLk1BQ1JPID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLk1BQ1JPLCAwKTtcclxufTtcclxuXHJcbk1hY3JvU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuU0VNSUNPTE9OID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlNFTUlDT0xPTiwgMCk7XHJcbn07XHJcblxyXG5NYWNyb1N0YXRlbWVudENvbnRleHQucHJvdG90eXBlLnZhcklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVmFySWRlbnRpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5NYWNyb1N0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5NYWNyb1N0YXRlbWVudENvbnRleHQucHJvdG90eXBlLkxQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MUEFSRU4sIDApO1xyXG59O1xyXG5cclxuTWFjcm9TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5tYWNyb0FyZ3VtZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChNYWNyb0FyZ3VtZW50c0NvbnRleHQsMCk7XHJcbn07XHJcblxyXG5NYWNyb1N0YXRlbWVudENvbnRleHQucHJvdG90eXBlLlJQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5SUEFSRU4sIDApO1xyXG59O1xyXG5cclxuTWFjcm9TdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1hY3JvU3RhdGVtZW50KHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5NYWNyb1N0YXRlbWVudENvbnRleHQgPSBNYWNyb1N0YXRlbWVudENvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLnByb3RvdHlwZS5tYWNyb1N0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBNYWNyb1N0YXRlbWVudENvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAxOCwgb2RlR3JhbW1hclBhcnNlci5SVUxFX21hY3JvU3RhdGVtZW50KTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTAzO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5NQUNSTyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEwNDtcclxuICAgICAgICBsb2NhbGN0eC5pZCA9IHRoaXMudmFySWRlbnRpZmllcigpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMDk7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDcsdGhpcy5fY3R4KTtcclxuICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MUEFSRU4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTA2O1xyXG4gICAgICAgICAgICB0aGlzLm1hY3JvQXJndW1lbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMDc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5SUEFSRU4pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExMTtcclxuICAgICAgICBsb2NhbGN0eC5leHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDExMjtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuU0VNSUNPTE9OKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gTWFjcm9Bcmd1bWVudHNDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbWFjcm9Bcmd1bWVudHM7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuTWFjcm9Bcmd1bWVudHNDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbk1hY3JvQXJndW1lbnRzQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYWNyb0FyZ3VtZW50c0NvbnRleHQ7XHJcblxyXG5NYWNyb0FyZ3VtZW50c0NvbnRleHQucHJvdG90eXBlLklEID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmKGk9PT11bmRlZmluZWQpIHtcclxuXHRcdGkgPSBudWxsO1xyXG5cdH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKG9kZUdyYW1tYXJQYXJzZXIuSUQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklELCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5NYWNyb0FyZ3VtZW50c0NvbnRleHQucHJvdG90eXBlLkNPTU1BID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmKGk9PT11bmRlZmluZWQpIHtcclxuXHRcdGkgPSBudWxsO1xyXG5cdH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkNPTU1BLCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5NYWNyb0FyZ3VtZW50c0NvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWFjcm9Bcmd1bWVudHModGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLk1hY3JvQXJndW1lbnRzQ29udGV4dCA9IE1hY3JvQXJndW1lbnRzQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLm1hY3JvQXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IE1hY3JvQXJndW1lbnRzQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDIwLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbWFjcm9Bcmd1bWVudHMpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMztcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgc3dpdGNoKHRoaXMuX2lucHV0LkxBKDEpKSB7XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLklEOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE0O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuSUQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE5O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICB3aGlsZShfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkNPTU1BKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMTE1O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLkNPTU1BKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMTY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuSUQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEyMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5SUEFSRU46XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMik7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLk5vVmlhYmxlQWx0RXhjZXB0aW9uKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gTG9vcEJvdW5kc0NvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9sb29wQm91bmRzO1xyXG4gICAgdGhpcy5sYm91bmQgPSBudWxsOyAvLyBUb2tlblxyXG4gICAgdGhpcy5yYm91bmQgPSBudWxsOyAvLyBUb2tlblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkxvb3BCb3VuZHNDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkxvb3BCb3VuZHNDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvb3BCb3VuZHNDb250ZXh0O1xyXG5cclxuTG9vcEJvdW5kc0NvbnRleHQucHJvdG90eXBlLkNPTE9OID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkNPTE9OLCAwKTtcclxufTtcclxuXHJcbkxvb3BCb3VuZHNDb250ZXh0LnByb3RvdHlwZS5JTlQgPSBmdW5jdGlvbihpKSB7XHJcblx0aWYoaT09PXVuZGVmaW5lZCkge1xyXG5cdFx0aSA9IG51bGw7XHJcblx0fVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMob2RlR3JhbW1hclBhcnNlci5JTlQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklOVCwgaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuTG9vcEJvdW5kc0NvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TG9vcEJvdW5kcyh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuTG9vcEJvdW5kc0NvbnRleHQgPSBMb29wQm91bmRzQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmxvb3BCb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgTG9vcEJvdW5kc0NvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAyMiwgb2RlR3JhbW1hclBhcnNlci5SVUxFX2xvb3BCb3VuZHMpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjU7XHJcbiAgICAgICAgbG9jYWxjdHgubGJvdW5kID0gdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLklOVCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEyNjtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQ09MT04pO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjc7XHJcbiAgICAgICAgbG9jYWxjdHgucmJvdW5kID0gdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLklOVCk7XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIExvb3BDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbG9vcDtcclxuICAgIHRoaXMuaXRlcmF0b3IgPSBudWxsOyAvLyBUb2tlblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkxvb3BDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkxvb3BDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvb3BDb250ZXh0O1xyXG5cclxuTG9vcENvbnRleHQucHJvdG90eXBlLkZPUiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5GT1IsIDApO1xyXG59O1xyXG5cclxuTG9vcENvbnRleHQucHJvdG90eXBlLkxQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MUEFSRU4sIDApO1xyXG59O1xyXG5cclxuTG9vcENvbnRleHQucHJvdG90eXBlLklOID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklOLCAwKTtcclxufTtcclxuXHJcbkxvb3BDb250ZXh0LnByb3RvdHlwZS5MU1FSID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkxTUVIsIDApO1xyXG59O1xyXG5cclxuTG9vcENvbnRleHQucHJvdG90eXBlLlJTUVIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUlNRUiwgMCk7XHJcbn07XHJcblxyXG5Mb29wQ29udGV4dC5wcm90b3R5cGUuUlBBUkVOID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTiwgMCk7XHJcbn07XHJcblxyXG5Mb29wQ29udGV4dC5wcm90b3R5cGUubG9vcEJvZHkgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9vcEJvZHlDb250ZXh0LDApO1xyXG59O1xyXG5cclxuTG9vcENvbnRleHQucHJvdG90eXBlLklEID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklELCAwKTtcclxufTtcclxuXHJcbkxvb3BDb250ZXh0LnByb3RvdHlwZS5sb29wQm91bmRzID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhMb29wQm91bmRzQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTG9vcEJvdW5kc0NvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5Mb29wQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMb29wKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5Mb29wQ29udGV4dCA9IExvb3BDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBMb29wQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDI0LCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfbG9vcCk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMjk7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLkZPUik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEzMDtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTMxO1xyXG4gICAgICAgIGxvY2FsY3R4Lml0ZXJhdG9yID0gdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLklEKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTMyO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JTik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEzMztcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFNRUik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDEzNTsgXHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEzNDtcclxuICAgICAgICAgICAgdGhpcy5sb29wQm91bmRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxMzc7IFxyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIH0gd2hpbGUoX2xhPT09b2RlR3JhbW1hclBhcnNlci5JTlQpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxMzk7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJTUVIpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxNDA7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE0MTtcclxuICAgICAgICB0aGlzLmxvb3BCb2R5KCk7XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIEVxdWF0aW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX2VxdWF0aW9uO1xyXG4gICAgdGhpcy5sYWJlbCA9IG51bGw7IC8vIFZhcklkZW50aWZpZXJDb250ZXh0XHJcbiAgICB0aGlzLmxlZnQgPSBudWxsOyAvLyBFeHByZXNzaW9uQ29udGV4dFxyXG4gICAgdGhpcy5yaWdodCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRXF1YXRpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkVxdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbkNvbnRleHQ7XHJcblxyXG5FcXVhdGlvbkNvbnRleHQucHJvdG90eXBlLkUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuRSwgMCk7XHJcbn07XHJcblxyXG5FcXVhdGlvbkNvbnRleHQucHJvdG90eXBlLlNFTUlDT0xPTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5TRU1JQ09MT04sIDApO1xyXG59O1xyXG5cclxuRXF1YXRpb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5FcXVhdGlvbkNvbnRleHQucHJvdG90eXBlLkNPTE9OID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkNPTE9OLCAwKTtcclxufTtcclxuXHJcbkVxdWF0aW9uQ29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkVxdWF0aW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFcXVhdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuRXF1YXRpb25Db250ZXh0ID0gRXF1YXRpb25Db250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuZXF1YXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRXF1YXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMjYsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9lcXVhdGlvbik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE0NjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMTEsdGhpcy5fY3R4KTtcclxuICAgICAgICBpZihsYV89PT0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNDM7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LmxhYmVsID0gdGhpcy52YXJJZGVudGlmaWVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNDQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5DT0xPTik7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gMTQ4O1xyXG4gICAgICAgIGxvY2FsY3R4LmxlZnQgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE0OTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuRSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE1MDtcclxuICAgICAgICBsb2NhbGN0eC5yaWdodCA9IHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTUxO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5TRU1JQ09MT04pO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBTZXR0ZXJDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfc2V0dGVyO1xyXG4gICAgdGhpcy52YXJpYWJsZSA9IG51bGw7IC8vIFZhcklkZW50aWZpZXJDb250ZXh0XHJcbiAgICB0aGlzLmV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuU2V0dGVyQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUpO1xyXG5TZXR0ZXJDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldHRlckNvbnRleHQ7XHJcblxyXG5TZXR0ZXJDb250ZXh0LnByb3RvdHlwZS5TRVQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuU0VULCAwKTtcclxufTtcclxuXHJcblNldHRlckNvbnRleHQucHJvdG90eXBlLkUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuRSwgMCk7XHJcbn07XHJcblxyXG5TZXR0ZXJDb250ZXh0LnByb3RvdHlwZS5TRU1JQ09MT04gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuU0VNSUNPTE9OLCAwKTtcclxufTtcclxuXHJcblNldHRlckNvbnRleHQucHJvdG90eXBlLnZhcklkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoVmFySWRlbnRpZmllckNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TZXR0ZXJDb250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuU2V0dGVyQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTZXR0ZXIodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLlNldHRlckNvbnRleHQgPSBTZXR0ZXJDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFNldHRlckNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAyOCwgb2RlR3JhbW1hclBhcnNlci5SVUxFX3NldHRlcik7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE1MztcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuU0VUKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTU0O1xyXG4gICAgICAgIGxvY2FsY3R4LnZhcmlhYmxlID0gdGhpcy52YXJJZGVudGlmaWVyKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE1NTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuRSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE1NjtcclxuICAgICAgICBsb2NhbGN0eC5leHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE1NztcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuU0VNSUNPTE9OKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gSW5pdGlhbENvbmRpdGlvbkNvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9pbml0aWFsQ29uZGl0aW9uO1xyXG4gICAgdGhpcy52YXJpYWJsZSA9IG51bGw7IC8vIFZhcklkZW50aWZpZXJDb250ZXh0XHJcbiAgICB0aGlzLmV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuSW5pdGlhbENvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuSW5pdGlhbENvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5pdGlhbENvbmRpdGlvbkNvbnRleHQ7XHJcblxyXG5Jbml0aWFsQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuVDAgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuVDAsIDApO1xyXG59O1xyXG5cclxuSW5pdGlhbENvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlLkUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuRSwgMCk7XHJcbn07XHJcblxyXG5Jbml0aWFsQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUuU0VNSUNPTE9OID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlNFTUlDT0xPTiwgMCk7XHJcbn07XHJcblxyXG5Jbml0aWFsQ29uZGl0aW9uQ29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkluaXRpYWxDb25kaXRpb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuSW5pdGlhbENvbmRpdGlvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5pdGlhbENvbmRpdGlvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuSW5pdGlhbENvbmRpdGlvbkNvbnRleHQgPSBJbml0aWFsQ29uZGl0aW9uQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmluaXRpYWxDb25kaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgSW5pdGlhbENvbmRpdGlvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCB0aGlzLnN0YXRlKTtcclxuICAgIHRoaXMuZW50ZXJSdWxlKGxvY2FsY3R4LCAzMCwgb2RlR3JhbW1hclBhcnNlci5SVUxFX2luaXRpYWxDb25kaXRpb24pO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxNTk7XHJcbiAgICAgICAgbG9jYWxjdHgudmFyaWFibGUgPSB0aGlzLnZhcklkZW50aWZpZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTYwO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5UMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE2MTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuRSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE2MjtcclxuICAgICAgICBsb2NhbGN0eC5leHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE2MztcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuU0VNSUNPTE9OKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfY29uc3RhbnRTdGF0ZW1lbnQ7XHJcbiAgICB0aGlzLmNvbnN0YW50ID0gbnVsbDsgLy8gVmFySWRlbnRpZmllckNvbnRleHRcclxuICAgIHRoaXMuZXhwID0gbnVsbDsgLy8gRXhwcmVzc2lvbkNvbnRleHRcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5Db25zdGFudFN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0YW50U3RhdGVtZW50Q29udGV4dDtcclxuXHJcbkNvbnN0YW50U3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuQ09OU1RBTlQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQsIDApO1xyXG59O1xyXG5cclxuQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5FID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkUsIDApO1xyXG59O1xyXG5cclxuQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5TRU1JQ09MT04gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuU0VNSUNPTE9OLCAwKTtcclxufTtcclxuXHJcbkNvbnN0YW50U3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkNvbnN0YW50U3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkNvbnN0YW50U3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25zdGFudFN0YXRlbWVudCh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0ID0gQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuY29uc3RhbnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQ29uc3RhbnRTdGF0ZW1lbnRDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMzIsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9jb25zdGFudFN0YXRlbWVudCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE2NTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxNjY7XHJcbiAgICAgICAgbG9jYWxjdHguY29uc3RhbnQgPSB0aGlzLnZhcklkZW50aWZpZXIoKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTY3O1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5FKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTY4O1xyXG4gICAgICAgIGxvY2FsY3R4LmV4cCA9IHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTY5O1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5TRU1JQ09MT04pO1xyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBTdGF0ZVN0YXRlbWVudENvbnRleHQocGFyc2VyLCBwYXJlbnQsIGludm9raW5nU3RhdGUpIHtcclxuXHRpZihwYXJlbnQ9PT11bmRlZmluZWQpIHtcclxuXHQgICAgcGFyZW50ID0gbnVsbDtcclxuXHR9XHJcblx0aWYoaW52b2tpbmdTdGF0ZT09PXVuZGVmaW5lZCB8fCBpbnZva2luZ1N0YXRlPT09bnVsbCkge1xyXG5cdFx0aW52b2tpbmdTdGF0ZSA9IC0xO1xyXG5cdH1cclxuXHRhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQuY2FsbCh0aGlzLCBwYXJlbnQsIGludm9raW5nU3RhdGUpO1xyXG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcbiAgICB0aGlzLnJ1bGVJbmRleCA9IG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9zdGF0ZVN0YXRlbWVudDtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5TdGF0ZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3RhdGVTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXRlU3RhdGVtZW50Q29udGV4dDtcclxuXHJcblN0YXRlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUuZXF1YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXF1YXRpb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RhdGVTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoU2V0dGVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChMb29wQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN0YXRlU3RhdGVtZW50Q29udGV4dC5wcm90b3R5cGUubWFjcm9TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTWFjcm9TdGF0ZW1lbnRDb250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RhdGVTdGF0ZW1lbnRDb250ZXh0LnByb3RvdHlwZS5jb25zdGFudFN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChDb25zdGFudFN0YXRlbWVudENvbnRleHQsMCk7XHJcbn07XHJcblxyXG5TdGF0ZVN0YXRlbWVudENvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGVTdGF0ZW1lbnQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLlN0YXRlU3RhdGVtZW50Q29udGV4dCA9IFN0YXRlU3RhdGVtZW50Q29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLnN0YXRlU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0YXRlU3RhdGVtZW50Q29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDM0LCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfc3RhdGVTdGF0ZW1lbnQpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxNzY7XHJcbiAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgIHN3aXRjaCh0aGlzLl9pbnB1dC5MQSgxKSkge1xyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5UX18wOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5ERVI6XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLlNVTTpcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuRkxPQVQ6XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLklOVDpcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuSUQ6XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLlBMVVM6XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLk1JTlVTOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5MUEFSRU46XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLkxDUkw6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNzE7XHJcbiAgICAgICAgICAgIHRoaXMuZXF1YXRpb24oKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLlNFVDpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE3MjtcclxuICAgICAgICAgICAgdGhpcy5zZXR0ZXIoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLkZPUjpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE3MztcclxuICAgICAgICAgICAgdGhpcy5sb29wKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5NQUNSTzpcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDE3NDtcclxuICAgICAgICAgICAgdGhpcy5tYWNyb1N0YXRlbWVudCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuQ09OU1RBTlQ6XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNzU7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRTdGF0ZW1lbnQoKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIFN0YXRlRGVmQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX3N0YXRlRGVmO1xyXG4gICAgdGhpcy5uYW1lID0gbnVsbDsgLy8gVG9rZW5cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5TdGF0ZURlZkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0YXRlRGVmQ29udGV4dDtcclxuXHJcblN0YXRlRGVmQ29udGV4dC5wcm90b3R5cGUuU1RBVEUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuU1RBVEUsIDApO1xyXG59O1xyXG5cclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5MQ1JMID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkxDUkwsIDApO1xyXG59O1xyXG5cclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5SQ1JMID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJDUkwsIDApO1xyXG59O1xyXG5cclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5GUk9NID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkZST00sIDApO1xyXG59O1xyXG5cclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5zdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKFN0YXRlVHJhbnNpdGlvbkNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KFN0YXRlVHJhbnNpdGlvbkNvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdGF0ZURlZkNvbnRleHQucHJvdG90eXBlLklEID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklELCAwKTtcclxufTtcclxuXHJcblN0YXRlRGVmQ29udGV4dC5wcm90b3R5cGUuVEVSTUlOQUwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuVEVSTUlOQUwsIDApO1xyXG59O1xyXG5cclxuU3RhdGVEZWZDb250ZXh0LnByb3RvdHlwZS5zdGF0ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoU3RhdGVTdGF0ZW1lbnRDb250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChTdGF0ZVN0YXRlbWVudENvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TdGF0ZURlZkNvbnRleHQucHJvdG90eXBlLkNPTU1BID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmKGk9PT11bmRlZmluZWQpIHtcclxuXHRcdGkgPSBudWxsO1xyXG5cdH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkNPTU1BLCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5TdGF0ZURlZkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGVEZWYodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLlN0YXRlRGVmQ29udGV4dCA9IFN0YXRlRGVmQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLnN0YXRlRGVmID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgdmFyIGxvY2FsY3R4ID0gbmV3IFN0YXRlRGVmQ29udGV4dCh0aGlzLCB0aGlzLl9jdHgsIHRoaXMuc3RhdGUpO1xyXG4gICAgdGhpcy5lbnRlclJ1bGUobG9jYWxjdHgsIDM2LCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfc3RhdGVEZWYpO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTc5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICBpZihfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLlRFUk1JTkFMKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxNzg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5URVJNSU5BTCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gMTgxO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5TVEFURSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDE4MjtcclxuICAgICAgICBsb2NhbGN0eC5uYW1lID0gdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLklEKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTgzO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MQ1JMKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTg3O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB3aGlsZSgoKChfbGEpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IF9sYSkgJiAoKDEgPDwgb2RlR3JhbW1hclBhcnNlci5UX18wKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuU0VUKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuREVSKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuU1VNKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTUFDUk8pIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5GT1IpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5DT05TVEFOVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLkZMT0FUKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuSU5UKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuSUQpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5QTFVTKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTUlOVVMpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5MUEFSRU4pKSkgIT09IDApIHx8IF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuTENSTCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMTg0O1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlU3RhdGVtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxODk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxOTA7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJDUkwpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxOTE7XHJcbiAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLkZST00pO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSAxOTI7XHJcbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMTk3O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICB3aGlsZShfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkNPTU1BKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxOTM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5DT01NQSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxOTQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAxOTk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAocmUpIHtcclxuICAgIFx0aWYocmUgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IHJlO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCByZSk7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgcmUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IHJlO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMuZXhpdFJ1bGUoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBTdGF0ZVRyYW5zaXRpb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfc3RhdGVUcmFuc2l0aW9uO1xyXG4gICAgdGhpcy5jb25kaXRpb24gPSBudWxsOyAvLyBCb29sRXhwcmVzc2lvbkNvbnRleHRcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5TdGF0ZVRyYW5zaXRpb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcblN0YXRlVHJhbnNpdGlvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3RhdGVUcmFuc2l0aW9uQ29udGV4dDtcclxuXHJcblN0YXRlVHJhbnNpdGlvbkNvbnRleHQucHJvdG90eXBlLklEID0gZnVuY3Rpb24oaSkge1xyXG5cdGlmKGk9PT11bmRlZmluZWQpIHtcclxuXHRcdGkgPSBudWxsO1xyXG5cdH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5zKG9kZUdyYW1tYXJQYXJzZXIuSUQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklELCBpKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5TdGF0ZVRyYW5zaXRpb25Db250ZXh0LnByb3RvdHlwZS5PTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5PTiwgMCk7XHJcbn07XHJcblxyXG5TdGF0ZVRyYW5zaXRpb25Db250ZXh0LnByb3RvdHlwZS5MUEFSRU4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOLCAwKTtcclxufTtcclxuXHJcblN0YXRlVHJhbnNpdGlvbkNvbnRleHQucHJvdG90eXBlLlJQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5SUEFSRU4sIDApO1xyXG59O1xyXG5cclxuU3RhdGVUcmFuc2l0aW9uQ29udGV4dC5wcm90b3R5cGUuYm9vbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQm9vbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuU3RhdGVUcmFuc2l0aW9uQ29udGV4dC5wcm90b3R5cGUuQ09NTUEgPSBmdW5jdGlvbihpKSB7XHJcblx0aWYoaT09PXVuZGVmaW5lZCkge1xyXG5cdFx0aSA9IG51bGw7XHJcblx0fVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMob2RlR3JhbW1hclBhcnNlci5DT01NQSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEsIGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblN0YXRlVHJhbnNpdGlvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhdGVUcmFuc2l0aW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5TdGF0ZVRyYW5zaXRpb25Db250ZXh0ID0gU3RhdGVUcmFuc2l0aW9uQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBsb2NhbGN0eCA9IG5ldyBTdGF0ZVRyYW5zaXRpb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgMzgsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9zdGF0ZVRyYW5zaXRpb24pO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMjAwO1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JRCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIwNTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgd2hpbGUoX2xhPT09b2RlR3JhbW1hclBhcnNlci5DT01NQSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjAxO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjAyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuSUQpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjA3O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlID0gMjA4O1xyXG4gICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5PTik7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIwOTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMjEwO1xyXG4gICAgICAgIGxvY2FsY3R4LmNvbmRpdGlvbiA9IHRoaXMuYm9vbEV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIxMTtcclxuICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOKTtcclxuICAgIH0gY2F0Y2ggKHJlKSB7XHJcbiAgICBcdGlmKHJlIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSByZTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgcmUpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIHJlKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyByZTtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLmV4aXRSdWxlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gQm9vbEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfYm9vbEV4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQm9vbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb29sRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5cclxuIFxyXG5Cb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgICBhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tLmNhbGwodGhpcywgY3R4KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIEJvb2xDb25zdGFudENvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRCb29sRXhwcmVzc2lvbkNvbnRleHQuY2FsbCh0aGlzLCBwYXJzZXIpO1xyXG4gICAgdGhpcy52YWx1ZSA9IG51bGw7IC8vIFRva2VuO1xyXG4gICAgQm9vbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbS5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQm9vbENvbnN0YW50Q29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Cb29sQ29uc3RhbnRDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvb2xDb25zdGFudENvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkJvb2xDb25zdGFudENvbnRleHQgPSBCb29sQ29uc3RhbnRDb250ZXh0O1xyXG5cclxuQm9vbENvbnN0YW50Q29udGV4dC5wcm90b3R5cGUuVFJVRSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5UUlVFLCAwKTtcclxufTtcclxuXHJcbkJvb2xDb25zdGFudENvbnRleHQucHJvdG90eXBlLkZBTFNFID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkZBTFNFLCAwKTtcclxufTtcclxuQm9vbENvbnN0YW50Q29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb29sQ29uc3RhbnQodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gQm9vbFVuYXJ5T3BlcmF0b3JDb250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0Qm9vbEV4cHJlc3Npb25Db250ZXh0LmNhbGwodGhpcywgcGFyc2VyKTtcclxuICAgIHRoaXMub3AgPSBudWxsOyAvLyBUb2tlbjtcclxuICAgIEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkJvb2xVbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5Cb29sVW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9vbFVuYXJ5T3BlcmF0b3JDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5Cb29sVW5hcnlPcGVyYXRvckNvbnRleHQgPSBCb29sVW5hcnlPcGVyYXRvckNvbnRleHQ7XHJcblxyXG5Cb29sVW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmJvb2xFeHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEJvb2xFeHByZXNzaW9uQ29udGV4dCwwKTtcclxufTtcclxuXHJcbkJvb2xVbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuTk9UID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLk5PVCwgMCk7XHJcbn07XHJcbkJvb2xVbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb29sVW5hcnlPcGVyYXRvcih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBCcmFja2V0Qm9vbEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0Qm9vbEV4cHJlc3Npb25Db250ZXh0LmNhbGwodGhpcywgcGFyc2VyKTtcclxuICAgIEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkJyYWNrZXRCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlKTtcclxuQnJhY2tldEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCcmFja2V0Qm9vbEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5CcmFja2V0Qm9vbEV4cHJlc3Npb25Db250ZXh0ID0gQnJhY2tldEJvb2xFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbkJyYWNrZXRCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkxQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MUEFSRU4sIDApO1xyXG59O1xyXG5cclxuQnJhY2tldEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYm9vbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQm9vbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQnJhY2tldEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuUlBBUkVOID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTiwgMCk7XHJcbn07XHJcbkJyYWNrZXRCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnJhY2tldEJvb2xFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIEJCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0Qm9vbEV4cHJlc3Npb25Db250ZXh0LmNhbGwodGhpcywgcGFyc2VyKTtcclxuICAgIHRoaXMubGVmdCA9IG51bGw7IC8vIEJvb2xFeHByZXNzaW9uQ29udGV4dDtcclxuICAgIHRoaXMub3AgPSBudWxsOyAvLyBUb2tlbjtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsOyAvLyBCb29sRXhwcmVzc2lvbkNvbnRleHQ7XHJcbiAgICBCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tLmNhbGwodGhpcywgY3R4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5CQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJvb2xFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5CQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuQkJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQgPSBCQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dDtcclxuXHJcbkJCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0LnByb3RvdHlwZS5ib29sRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoQm9vbEV4cHJlc3Npb25Db250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChCb29sRXhwcmVzc2lvbkNvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5CQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuQU5EID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkFORCwgMCk7XHJcbn07XHJcblxyXG5CQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuT1IgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuT1IsIDApO1xyXG59O1xyXG5CQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCQm9vbEJpbmFyeU9wZXJhdG9yKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIEVCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0Qm9vbEV4cHJlc3Npb25Db250ZXh0LmNhbGwodGhpcywgcGFyc2VyKTtcclxuICAgIHRoaXMubGVmdGV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0O1xyXG4gICAgdGhpcy5vcCA9IG51bGw7IC8vIFRva2VuO1xyXG4gICAgdGhpcy5yaWdodGV4cCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0O1xyXG4gICAgQm9vbEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbS5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb29sRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlKTtcclxuRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkVCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0ID0gRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQ7XHJcblxyXG5FQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGkpIHtcclxuICAgIGlmKGk9PT11bmRlZmluZWQpIHtcclxuICAgICAgICBpID0gbnVsbDtcclxuICAgIH1cclxuICAgIGlmKGk9PT1udWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dHMoRXhwcmVzc2lvbkNvbnRleHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLkwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTCwgMCk7XHJcbn07XHJcblxyXG5FQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuTEUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTEUsIDApO1xyXG59O1xyXG5cclxuRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLkcgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuRywgMCk7XHJcbn07XHJcblxyXG5FQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuR0UgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuR0UsIDApO1xyXG59O1xyXG5cclxuRUJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQucHJvdG90eXBlLkUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuRSwgMCk7XHJcbn07XHJcblxyXG5FQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuTkUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTkUsIDApO1xyXG59O1xyXG5FQm9vbEJpbmFyeU9wZXJhdG9yQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFQm9vbEJpbmFyeU9wZXJhdG9yKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLnByb3RvdHlwZS5ib29sRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgQm9vbEV4cHJlc3Npb25Db250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgX3BhcmVudFN0YXRlKTtcclxuICAgIHZhciBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgdmFyIF9zdGFydFN0YXRlID0gNDA7XHJcbiAgICB0aGlzLmVudGVyUmVjdXJzaW9uUnVsZShsb2NhbGN0eCwgNDAsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9ib29sRXhwcmVzc2lvbiwgX3ApO1xyXG4gICAgdmFyIF9sYSA9IDA7IC8vIFRva2VuIHR5cGVcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5lbnRlck91dGVyQWx0KGxvY2FsY3R4LCAxKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMjI5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxNyx0aGlzLl9jdHgpO1xyXG4gICAgICAgIHN3aXRjaChsYV8pIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEJyYWNrZXRCb29sRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMTQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MUEFSRU4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjE1O1xyXG4gICAgICAgICAgICB0aGlzLmJvb2xFeHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjE2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQm9vbFVuYXJ5T3BlcmF0b3JDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMTg7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4Lm9wID0gdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLk5PVCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMTk7XHJcbiAgICAgICAgICAgIHRoaXMuYm9vbEV4cHJlc3Npb24oNik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEVCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjA7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LmxlZnRleHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjE7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4Lm9wID0gdGhpcy5faW5wdXQuTFQoMSk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKCgoKChfbGEgLSAzNikpICYgfjB4MWYpID09IDAgJiYgKCgxIDw8IChfbGEgLSAzNikpICYgKCgxIDw8IChvZGVHcmFtbWFyUGFyc2VyLkwgLSAzNikpIHwgKDEgPDwgKG9kZUdyYW1tYXJQYXJzZXIuRyAtIDM2KSkgfCAoMSA8PCAob2RlR3JhbW1hclBhcnNlci5MRSAtIDM2KSkgfCAoMSA8PCAob2RlR3JhbW1hclBhcnNlci5HRSAtIDM2KSkpKSAhPT0gMCkpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIyMjtcclxuICAgICAgICAgICAgbG9jYWxjdHgucmlnaHRleHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEVCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjQ7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LmxlZnRleHAgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjU7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4Lm9wID0gdGhpcy5faW5wdXQuTFQoMSk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuTkUgfHwgX2xhPT09b2RlR3JhbW1hclBhcnNlci5FKSkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHgub3AgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjY7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LnJpZ2h0ZXhwID0gdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBCb29sQ29uc3RhbnRDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMjg7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LnZhbHVlID0gdGhpcy5faW5wdXQuTFQoMSk7XHJcbiAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICBpZighKF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuVFJVRSB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkZBTFNFKSkge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxjdHgudmFsdWUgPSB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXJJbmxpbmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFx0dGhpcy5fZXJySGFuZGxlci5yZXBvcnRNYXRjaCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3R4LnN0b3AgPSB0aGlzLl9pbnB1dC5MVCgtMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDIzOTtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE5LHRoaXMuX2N0eClcclxuICAgICAgICB3aGlsZShfYWx0IT0yICYmIF9hbHQhPWFudGxyNC5hdG4uQVROLklOVkFMSURfQUxUX05VTUJFUikge1xyXG4gICAgICAgICAgICBpZihfYWx0PT09MSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyc2VMaXN0ZW5lcnMhPT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXhpdFJ1bGVFdmVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFfID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwxOCx0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKGxhXykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEJCb29sQmluYXJ5T3BlcmF0b3JDb250ZXh0KHRoaXMsIG5ldyBCb29sRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHgubGVmdCA9IF9wcmV2Y3R4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfYm9vbEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoIHRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5GYWlsZWRQcmVkaWNhdGVFeGNlcHRpb24odGhpcywgXCJ0aGlzLnByZWNwcmVkKHRoaXMuX2N0eCwgMylcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyMzI7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHgub3AgPSB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQU5EKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjMzO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4LnJpZ2h0ID0gdGhpcy5ib29sRXhwcmVzc2lvbig0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQkJvb2xCaW5hcnlPcGVyYXRvckNvbnRleHQodGhpcywgbmV3IEJvb2xFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBfcGFyZW50Y3R4LCBfcGFyZW50U3RhdGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5sZWZ0ID0gX3ByZXZjdHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTmV3UmVjdXJzaW9uQ29udGV4dChsb2NhbGN0eCwgX3N0YXJ0U3RhdGUsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9ib29sRXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIzNDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCAyKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIzNTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5PUik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDIzNjtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5yaWdodCA9IHRoaXMuYm9vbEV4cHJlc3Npb24oMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQxO1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIF9hbHQgPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDE5LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0gY2F0Y2goIGVycm9yKSB7XHJcbiAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBhbnRscjQuZXJyb3IuUmVjb2duaXRpb25FeGNlcHRpb24pIHtcclxuXHQgICAgICAgIGxvY2FsY3R4LmV4Y2VwdGlvbiA9IGVycm9yO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZXBvcnRFcnJvcih0aGlzLCBlcnJvcik7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlY292ZXIodGhpcywgZXJyb3IpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICBcdHRocm93IGVycm9yO1xyXG5cdCAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIHRoaXMudW5yb2xsUmVjdXJzaW9uQ29udGV4dHMoX3BhcmVudGN0eClcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbGN0eDtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSkge1xyXG5cdGlmKHBhcmVudD09PXVuZGVmaW5lZCkge1xyXG5cdCAgICBwYXJlbnQgPSBudWxsO1xyXG5cdH1cclxuXHRpZihpbnZva2luZ1N0YXRlPT09dW5kZWZpbmVkIHx8IGludm9raW5nU3RhdGU9PT1udWxsKSB7XHJcblx0XHRpbnZva2luZ1N0YXRlID0gLTE7XHJcblx0fVxyXG5cdGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5jYWxsKHRoaXMsIHBhcmVudCwgaW52b2tpbmdTdGF0ZSk7XHJcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcclxuICAgIHRoaXMucnVsZUluZGV4ID0gb2RlR3JhbW1hclBhcnNlci5SVUxFX2V4cHJlc3Npb247XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQuUGFyc2VyUnVsZUNvbnRleHQucHJvdG90eXBlKTtcclxuRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5cclxuIFxyXG5FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20gPSBmdW5jdGlvbihjdHgpIHtcclxuICAgIGFudGxyNC5QYXJzZXJSdWxlQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gQnJhY2tldEV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0RXhwcmVzc2lvbkNvbnRleHQuY2FsbCh0aGlzLCBwYXJzZXIpO1xyXG4gICAgRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tLmNhbGwodGhpcywgY3R4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5CcmFja2V0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5CcmFja2V0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQnJhY2tldEV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5CcmFja2V0RXhwcmVzc2lvbkNvbnRleHQgPSBCcmFja2V0RXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5CcmFja2V0RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkxQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MUEFSRU4sIDApO1xyXG59O1xyXG5cclxuQnJhY2tldEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuQnJhY2tldEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5SUEFSRU4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOLCAwKTtcclxufTtcclxuQnJhY2tldEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJyYWNrZXRFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIE1hY3JvRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRFeHByZXNzaW9uQ29udGV4dC5jYWxsKHRoaXMsIHBhcnNlcik7XHJcbiAgICB0aGlzLmlkID0gbnVsbDsgLy8gVmFySWRlbnRpZmllckNvbnRleHQ7XHJcbiAgICBFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbk1hY3JvRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5NYWNyb0V4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hY3JvRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLk1hY3JvRXhwcmVzc2lvbkNvbnRleHQgPSBNYWNyb0V4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuTWFjcm9FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcbk1hY3JvRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkxQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MUEFSRU4sIDApO1xyXG59O1xyXG5cclxuTWFjcm9FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuUlBBUkVOID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTiwgMCk7XHJcbn07XHJcblxyXG5NYWNyb0V4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcbk1hY3JvRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWFjcm9FeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIEJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRFeHByZXNzaW9uQ29udGV4dC5jYWxsKHRoaXMsIHBhcnNlcik7XHJcbiAgICB0aGlzLmxlZnQgPSBudWxsOyAvLyBFeHByZXNzaW9uQ29udGV4dDtcclxuICAgIHRoaXMub3AgPSBudWxsOyAvLyBUb2tlbjtcclxuICAgIHRoaXMucmlnaHQgPSBudWxsOyAvLyBFeHByZXNzaW9uQ29udGV4dDtcclxuICAgIEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbS5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSk7XHJcbkJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dCA9IEJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oaSkge1xyXG4gICAgaWYoaT09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgIGkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0cyhFeHByZXNzaW9uQ29udGV4dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsaSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5DQVJFVCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5DQVJFVCwgMCk7XHJcbn07XHJcblxyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5ESVZJU0lPTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5ESVZJU0lPTiwgMCk7XHJcbn07XHJcblxyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5BU1RFUklTSyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5BU1RFUklTSywgMCk7XHJcbn07XHJcblxyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5QTFVTID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlBMVVMsIDApO1xyXG59O1xyXG5cclxuQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuTUlOVVMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTUlOVVMsIDApO1xyXG59O1xyXG5CaW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeU9wZXJhdG9yRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0RXhwcmVzc2lvbkNvbnRleHQuY2FsbCh0aGlzLCBwYXJzZXIpO1xyXG4gICAgdGhpcy5mdW5jID0gbnVsbDsgLy8gVG9rZW47XHJcbiAgICBFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkZ1bmN0aW9uRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5GdW5jdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkZ1bmN0aW9uRXhwcmVzc2lvbkNvbnRleHQgPSBGdW5jdGlvbkV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuRnVuY3Rpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuTFBBUkVOID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkxQQVJFTiwgMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5mdW5jdGlvbkFyZ3VtZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChGdW5jdGlvbkFyZ3VtZW50c0NvbnRleHQsMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5SUEFSRU4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOLCAwKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLklEID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLklELCAwKTtcclxufTtcclxuRnVuY3Rpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gVW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0RXhwcmVzc2lvbkNvbnRleHQuY2FsbCh0aGlzLCBwYXJzZXIpO1xyXG4gICAgdGhpcy5vcCA9IG51bGw7IC8vIFRva2VuO1xyXG4gICAgRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tLmNhbGwodGhpcywgY3R4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQgPSBVbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoRXhwcmVzc2lvbkNvbnRleHQsMCk7XHJcbn07XHJcblxyXG5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLlBMVVMgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUExVUywgMCk7XHJcbn07XHJcblxyXG5VbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLk1JTlVTID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLk1JTlVTLCAwKTtcclxufTtcclxuVW5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih2aXNpdG9yKSB7XHJcbiAgICBpZiAoIHZpc2l0b3IgaW5zdGFuY2VvZiBvZGVHcmFtbWFyVmlzaXRvciApIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRFeHByZXNzaW9uQ29udGV4dC5jYWxsKHRoaXMsIHBhcnNlcik7XHJcbiAgICB0aGlzLnZhbHVlID0gbnVsbDsgLy8gTnVtYmVyQ29udGV4dDtcclxuICAgIEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbS5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSk7XHJcbkNvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dCA9IENvbnN0YW50RXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5Db25zdGFudEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5udW1iZXIgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoTnVtYmVyQ29udGV4dCwwKTtcclxufTtcclxuQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25zdGFudEV4cHJlc3Npb24odGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRFeHByZXNzaW9uQ29udGV4dC5jYWxsKHRoaXMsIHBhcnNlcik7XHJcbiAgICB0aGlzLml0ZXJhdG9yID0gbnVsbDsgLy8gVG9rZW47XHJcbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7IC8vIExvb3BCb3VuZHNDb250ZXh0O1xyXG4gICAgdGhpcy5zdW1tYXRpb25FeHAgPSBudWxsOyAvLyBFeHByZXNzaW9uQ29udGV4dDtcclxuICAgIEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb3B5RnJvbS5jYWxsKHRoaXMsIGN0eCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5TdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dDtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQgPSBTdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dDtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5TVU0gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuU1VNLCAwKTtcclxufTtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5MUEFSRU4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOLCAwKTtcclxufTtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5JTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5JTiwgMCk7XHJcbn07XHJcblxyXG5TdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuTFNRUiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5MU1FSLCAwKTtcclxufTtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5SU1FSID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlJTUVIsIDApO1xyXG59O1xyXG5cclxuU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLlJQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5SUEFSRU4sIDApO1xyXG59O1xyXG5cclxuU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkxDUkwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTENSTCwgMCk7XHJcbn07XHJcblxyXG5TdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuUkNSTCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5SQ1JMLCAwKTtcclxufTtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5JRCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5JRCwgMCk7XHJcbn07XHJcblxyXG5TdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUubG9vcEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChMb29wQm91bmRzQ29udGV4dCwwKTtcclxufTtcclxuXHJcblN1bW1hdGlvbkV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5leHByZXNzaW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlZFJ1bGVDb250ZXh0KEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5TdW1tYXRpb25FeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdW1tYXRpb25FeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uRGVyaXZhdGl2ZUNvbnRleHQocGFyc2VyLCBjdHgpIHtcclxuXHRFeHByZXNzaW9uQ29udGV4dC5jYWxsKHRoaXMsIHBhcnNlcik7XHJcbiAgICB0aGlzLmlkID0gbnVsbDsgLy8gVmFySWRlbnRpZmllckNvbnRleHQ7XHJcbiAgICBFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcbkZ1bmN0aW9uRGVyaXZhdGl2ZUNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5GdW5jdGlvbkRlcml2YXRpdmVDb250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZ1bmN0aW9uRGVyaXZhdGl2ZUNvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLkZ1bmN0aW9uRGVyaXZhdGl2ZUNvbnRleHQgPSBGdW5jdGlvbkRlcml2YXRpdmVDb250ZXh0O1xyXG5cclxuRnVuY3Rpb25EZXJpdmF0aXZlQ29udGV4dC5wcm90b3R5cGUuREVSID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLkRFUiwgMCk7XHJcbn07XHJcblxyXG5GdW5jdGlvbkRlcml2YXRpdmVDb250ZXh0LnByb3RvdHlwZS5MUEFSRU4gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOLCAwKTtcclxufTtcclxuXHJcbkZ1bmN0aW9uRGVyaXZhdGl2ZUNvbnRleHQucHJvdG90eXBlLlJQQVJFTiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW4ob2RlR3JhbW1hclBhcnNlci5SUEFSRU4sIDApO1xyXG59O1xyXG5cclxuRnVuY3Rpb25EZXJpdmF0aXZlQ29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuRnVuY3Rpb25EZXJpdmF0aXZlQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkRlcml2YXRpdmUodGhpcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hpbGRyZW4odGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gVmFyaWFibGVFeHByZXNzaW9uQ29udGV4dChwYXJzZXIsIGN0eCkge1xyXG5cdEV4cHJlc3Npb25Db250ZXh0LmNhbGwodGhpcywgcGFyc2VyKTtcclxuICAgIHRoaXMuaWQgPSBudWxsOyAvLyBWYXJJZGVudGlmaWVyQ29udGV4dDtcclxuICAgIHRoaXMuZGVyID0gbnVsbDsgLy8gVG9rZW47XHJcbiAgICBFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuY29weUZyb20uY2FsbCh0aGlzLCBjdHgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuXHJcblZhcmlhYmxlRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUpO1xyXG5WYXJpYWJsZUV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZhcmlhYmxlRXhwcmVzc2lvbkNvbnRleHQ7XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLlZhcmlhYmxlRXhwcmVzc2lvbkNvbnRleHQgPSBWYXJpYWJsZUV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuVmFyaWFibGVFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUudmFySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChWYXJJZGVudGlmaWVyQ29udGV4dCwwKTtcclxufTtcclxuXHJcblZhcmlhYmxlRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkFQT1NUUk9QSEUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuQVBPU1RST1BIRSwgMCk7XHJcbn07XHJcblZhcmlhYmxlRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGVFeHByZXNzaW9uKHRoaXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoaWxkcmVuKHRoaXMpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIFRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0KHBhcnNlciwgY3R4KSB7XHJcblx0RXhwcmVzc2lvbkNvbnRleHQuY2FsbCh0aGlzLCBwYXJzZXIpO1xyXG4gICAgdGhpcy5jb25kaXRpb24gPSBudWxsOyAvLyBCb29sRXhwcmVzc2lvbkNvbnRleHQ7XHJcbiAgICB0aGlzLmZpcnN0ID0gbnVsbDsgLy8gRXhwcmVzc2lvbkNvbnRleHQ7XHJcbiAgICB0aGlzLnNlY29uZCA9IG51bGw7IC8vIEV4cHJlc3Npb25Db250ZXh0O1xyXG4gICAgRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmNvcHlGcm9tLmNhbGwodGhpcywgY3R4KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5UZXJuYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZSk7XHJcblRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5UZXJuYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dCA9IFRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0O1xyXG5cclxuVGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLkxDUkwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuTENSTCwgMCk7XHJcbn07XHJcblxyXG5UZXJuYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuUVVFU1RJT05NQVJLID0gZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUb2tlbihvZGVHcmFtbWFyUGFyc2VyLlFVRVNUSU9OTUFSSywgMCk7XHJcbn07XHJcblxyXG5UZXJuYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuQ09MT04gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuQ09MT04sIDApO1xyXG59O1xyXG5cclxuVGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLlJDUkwgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuUkNSTCwgMCk7XHJcbn07XHJcblxyXG5UZXJuYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dC5wcm90b3R5cGUuYm9vbEV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHQoQm9vbEV4cHJlc3Npb25Db250ZXh0LDApO1xyXG59O1xyXG5cclxuVGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuVGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHZpc2l0b3IpIHtcclxuICAgIGlmICggdmlzaXRvciBpbnN0YW5jZW9mIG9kZUdyYW1tYXJWaXNpdG9yICkge1xyXG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbih0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKF9wKSB7XHJcblx0aWYoX3A9PT11bmRlZmluZWQpIHtcclxuXHQgICAgX3AgPSAwO1xyXG5cdH1cclxuICAgIHZhciBfcGFyZW50Y3R4ID0gdGhpcy5fY3R4O1xyXG4gICAgdmFyIF9wYXJlbnRTdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgdGhpcy5fY3R4LCBfcGFyZW50U3RhdGUpO1xyXG4gICAgdmFyIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICB2YXIgX3N0YXJ0U3RhdGUgPSA0MjtcclxuICAgIHRoaXMuZW50ZXJSZWN1cnNpb25SdWxlKGxvY2FsY3R4LCA0Miwgb2RlR3JhbW1hclBhcnNlci5SVUxFX2V4cHJlc3Npb24sIF9wKTtcclxuICAgIHZhciBfbGEgPSAwOyAvLyBUb2tlbiB0eXBlXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHRoaXMuZW50ZXJPdXRlckFsdChsb2NhbGN0eCwgMSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IDI5NjtcclxuICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjMsdGhpcy5fY3R4KTtcclxuICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBCcmFja2V0RXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MUEFSRU4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQ0O1xyXG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5SUEFSRU4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBGdW5jdGlvbkRlcml2YXRpdmVDb250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNDc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5ERVIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjQ4O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI0OTtcclxuICAgICAgICAgICAgbG9jYWxjdHguaWQgPSB0aGlzLnZhcklkZW50aWZpZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1MDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IEZ1bmN0aW9uRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1MjtcclxuICAgICAgICAgICAgbG9jYWxjdHguZnVuYyA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JRCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTM7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MUEFSRU4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjU0O1xyXG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uQXJndW1lbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTU7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5SUEFSRU4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBVbmFyeU9wZXJhdG9yRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1NztcclxuICAgICAgICAgICAgbG9jYWxjdHgub3AgPSB0aGlzLl9pbnB1dC5MVCgxKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIGlmKCEoX2xhPT09b2RlR3JhbW1hclBhcnNlci5QTFVTIHx8IF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuTUlOVVMpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI1ODtcclxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uKDgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICBsb2NhbGN0eCA9IG5ldyBWYXJpYWJsZUV4cHJlc3Npb25Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNTk7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LmlkID0gdGhpcy52YXJJZGVudGlmaWVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNjE7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGxhXyA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjAsdGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgaWYobGFfPT09MSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2MDtcclxuICAgICAgICAgICAgICAgIGxvY2FsY3R4LmRlciA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5BUE9TVFJPUEhFKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQ29uc3RhbnRFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBsb2NhbGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjYzO1xyXG4gICAgICAgICAgICBsb2NhbGN0eC52YWx1ZSA9IHRoaXMubnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IE1hY3JvRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI2NDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlRfXzApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY1O1xyXG4gICAgICAgICAgICBsb2NhbGN0eC5pZCA9IHRoaXMudmFySWRlbnRpZmllcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjc0O1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDIyLHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIGlmKGxhXz09PTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNjY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlKCgoKF9sYSkgJiB+MHgxZikgPT0gMCAmJiAoKDEgPDwgX2xhKSAmICgoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLlRfXzApIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5ERVIpIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5TVU0pIHwgKDEgPDwgb2RlR3JhbW1hclBhcnNlci5GTE9BVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklOVCkgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLklEKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuUExVUykgfCAoMSA8PCBvZGVHcmFtbWFyUGFyc2VyLk1JTlVTKSB8ICgxIDw8IG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOKSkpICE9PSAwKSB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkxDUkwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjY3O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMjcyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgU3VtbWF0aW9uRXhwcmVzc2lvbkNvbnRleHQodGhpcywgbG9jYWxjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgX3ByZXZjdHggPSBsb2NhbGN0eDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI3NjtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlNVTSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzc7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MUEFSRU4pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjc4O1xyXG4gICAgICAgICAgICBsb2NhbGN0eC5pdGVyYXRvciA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JRCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyNzk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5JTik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODA7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MU1FSKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4MTtcclxuICAgICAgICAgICAgbG9jYWxjdHguYm91bmRzID0gdGhpcy5sb29wQm91bmRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODI7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5SU1FSKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4MztcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlJQQVJFTik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MQ1JMKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4NTtcclxuICAgICAgICAgICAgbG9jYWxjdHguc3VtbWF0aW9uRXhwID0gdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjg2O1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuUkNSTCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgIGxvY2FsY3R4ID0gbmV3IFRlcm5hcnlPcGVyYXRvckV4cHJlc3Npb25Db250ZXh0KHRoaXMsIGxvY2FsY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIF9wcmV2Y3R4ID0gbG9jYWxjdHg7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyODg7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5MQ1JMKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI4OTtcclxuICAgICAgICAgICAgbG9jYWxjdHguY29uZGl0aW9uID0gdGhpcy5ib29sRXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5MDtcclxuICAgICAgICAgICAgdGhpcy5tYXRjaChvZGVHcmFtbWFyUGFyc2VyLlFVRVNUSU9OTUFSSyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyOTE7XHJcbiAgICAgICAgICAgIGxvY2FsY3R4LmZpcnN0ID0gdGhpcy5leHByZXNzaW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjkyO1xyXG4gICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQ09MT04pO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMjkzO1xyXG4gICAgICAgICAgICBsb2NhbGN0eC5zZWNvbmQgPSB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAyOTQ7XHJcbiAgICAgICAgICAgIHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5SQ1JMKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdHguc3RvcCA9IHRoaXMuX2lucHV0LkxUKC0xKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzA5O1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICB2YXIgX2FsdCA9IHRoaXMuX2ludGVycC5hZGFwdGl2ZVByZWRpY3QodGhpcy5faW5wdXQsMjUsdGhpcy5fY3R4KVxyXG4gICAgICAgIHdoaWxlKF9hbHQhPTIgJiYgX2FsdCE9YW50bHI0LmF0bi5BVE4uSU5WQUxJRF9BTFRfTlVNQkVSKSB7XHJcbiAgICAgICAgICAgIGlmKF9hbHQ9PT0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9wYXJzZUxpc3RlbmVycyE9PW51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFeGl0UnVsZUV2ZW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfcHJldmN0eCA9IGxvY2FsY3R4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwNztcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHZhciBsYV8gPSB0aGlzLl9pbnRlcnAuYWRhcHRpdmVQcmVkaWN0KHRoaXMuX2lucHV0LDI0LHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2gobGFfKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHgubGVmdCA9IF9wcmV2Y3R4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5ODtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA5KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDI5OTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMubWF0Y2gob2RlR3JhbW1hclBhcnNlci5DQVJFVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwMDtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5yaWdodCA9IHRoaXMuZXhwcmVzc2lvbig5KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHgubGVmdCA9IF9wcmV2Y3R4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA3KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwMjtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMuX2lucHV0LkxUKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCEoX2xhPT09b2RlR3JhbW1hclBhcnNlci5BU1RFUklTSyB8fCBfbGE9PT1vZGVHcmFtbWFyUGFyc2VyLkRJVklTSU9OKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMuX2VyckhhbmRsZXIucmVjb3ZlcklubGluZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHR0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydE1hdGNoKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwMztcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5yaWdodCA9IHRoaXMuZXhwcmVzc2lvbig4KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHggPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uQ29udGV4dCh0aGlzLCBuZXcgRXhwcmVzc2lvbkNvbnRleHQodGhpcywgX3BhcmVudGN0eCwgX3BhcmVudFN0YXRlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxjdHgubGVmdCA9IF9wcmV2Y3R4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaE5ld1JlY3Vyc2lvbkNvbnRleHQobG9jYWxjdHgsIF9zdGFydFN0YXRlLCBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwNDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISggdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDYpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYW50bHI0LmVycm9yLkZhaWxlZFByZWRpY2F0ZUV4Y2VwdGlvbih0aGlzLCBcInRoaXMucHJlY3ByZWQodGhpcy5fY3R4LCA2KVwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMwNTtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbGN0eC5vcCA9IHRoaXMuX2lucHV0LkxUKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9sYSA9IHRoaXMuX2lucHV0LkxBKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCEoX2xhPT09b2RlR3JhbW1hclBhcnNlci5QTFVTIHx8IF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuTUlOVVMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4Lm9wID0gdGhpcy5fZXJySGFuZGxlci5yZWNvdmVySW5saW5lKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBcdHRoaXMuX2VyckhhbmRsZXIucmVwb3J0TWF0Y2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gMzA2O1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsY3R4LnJpZ2h0ID0gdGhpcy5leHByZXNzaW9uKDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMxMTtcclxuICAgICAgICAgICAgdGhpcy5fZXJySGFuZGxlci5zeW5jKHRoaXMpO1xyXG4gICAgICAgICAgICBfYWx0ID0gdGhpcy5faW50ZXJwLmFkYXB0aXZlUHJlZGljdCh0aGlzLl9pbnB1dCwyNSx0aGlzLl9jdHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoKCBlcnJvcikge1xyXG4gICAgICAgIGlmKGVycm9yIGluc3RhbmNlb2YgYW50bHI0LmVycm9yLlJlY29nbml0aW9uRXhjZXB0aW9uKSB7XHJcblx0ICAgICAgICBsb2NhbGN0eC5leGNlcHRpb24gPSBlcnJvcjtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVwb3J0RXJyb3IodGhpcywgZXJyb3IpO1xyXG5cdCAgICAgICAgdGhpcy5fZXJySGFuZGxlci5yZWNvdmVyKHRoaXMsIGVycm9yKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgXHR0aHJvdyBlcnJvcjtcclxuXHQgICAgfVxyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgICB0aGlzLnVucm9sbFJlY3Vyc2lvbkNvbnRleHRzKF9wYXJlbnRjdHgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG9jYWxjdHg7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gRnVuY3Rpb25Bcmd1bWVudHNDb250ZXh0KHBhcnNlciwgcGFyZW50LCBpbnZva2luZ1N0YXRlKSB7XHJcblx0aWYocGFyZW50PT09dW5kZWZpbmVkKSB7XHJcblx0ICAgIHBhcmVudCA9IG51bGw7XHJcblx0fVxyXG5cdGlmKGludm9raW5nU3RhdGU9PT11bmRlZmluZWQgfHwgaW52b2tpbmdTdGF0ZT09PW51bGwpIHtcclxuXHRcdGludm9raW5nU3RhdGUgPSAtMTtcclxuXHR9XHJcblx0YW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LmNhbGwodGhpcywgcGFyZW50LCBpbnZva2luZ1N0YXRlKTtcclxuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG4gICAgdGhpcy5ydWxlSW5kZXggPSBvZGVHcmFtbWFyUGFyc2VyLlJVTEVfZnVuY3Rpb25Bcmd1bWVudHM7XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuRnVuY3Rpb25Bcmd1bWVudHNDb250ZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYW50bHI0LlBhcnNlclJ1bGVDb250ZXh0LnByb3RvdHlwZSk7XHJcbkZ1bmN0aW9uQXJndW1lbnRzQ29udGV4dC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGdW5jdGlvbkFyZ3VtZW50c0NvbnRleHQ7XHJcblxyXG5GdW5jdGlvbkFyZ3VtZW50c0NvbnRleHQucHJvdG90eXBlLmV4cHJlc3Npb24gPSBmdW5jdGlvbihpKSB7XHJcbiAgICBpZihpPT09dW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBpZihpPT09bnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUnVsZUNvbnRleHRzKEV4cHJlc3Npb25Db250ZXh0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRSdWxlQ29udGV4dChFeHByZXNzaW9uQ29udGV4dCxpKTtcclxuICAgIH1cclxufTtcclxuXHJcbkZ1bmN0aW9uQXJndW1lbnRzQ29udGV4dC5wcm90b3R5cGUuQ09NTUEgPSBmdW5jdGlvbihpKSB7XHJcblx0aWYoaT09PXVuZGVmaW5lZCkge1xyXG5cdFx0aSA9IG51bGw7XHJcblx0fVxyXG4gICAgaWYoaT09PW51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRUb2tlbnMob2RlR3JhbW1hclBhcnNlci5DT01NQSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEsIGkpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbkZ1bmN0aW9uQXJndW1lbnRzQ29udGV4dC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24odmlzaXRvcikge1xyXG4gICAgaWYgKCB2aXNpdG9yIGluc3RhbmNlb2Ygb2RlR3JhbW1hclZpc2l0b3IgKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRGdW5jdGlvbkFyZ3VtZW50cyh0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGlsZHJlbih0aGlzKTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIuRnVuY3Rpb25Bcmd1bWVudHNDb250ZXh0ID0gRnVuY3Rpb25Bcmd1bWVudHNDb250ZXh0O1xyXG5cclxub2RlR3JhbW1hclBhcnNlci5wcm90b3R5cGUuZnVuY3Rpb25Bcmd1bWVudHMgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgbG9jYWxjdHggPSBuZXcgRnVuY3Rpb25Bcmd1bWVudHNDb250ZXh0KHRoaXMsIHRoaXMuX2N0eCwgdGhpcy5zdGF0ZSk7XHJcbiAgICB0aGlzLmVudGVyUnVsZShsb2NhbGN0eCwgNDQsIG9kZUdyYW1tYXJQYXJzZXIuUlVMRV9mdW5jdGlvbkFyZ3VtZW50cyk7XHJcbiAgICB2YXIgX2xhID0gMDsgLy8gVG9rZW4gdHlwZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gMzIxO1xyXG4gICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICBzd2l0Y2godGhpcy5faW5wdXQuTEEoMSkpIHtcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuVF9fMDpcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuREVSOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5TVU06XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLkZMT0FUOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5JTlQ6XHJcbiAgICAgICAgY2FzZSBvZGVHcmFtbWFyUGFyc2VyLklEOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5QTFVTOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5NSU5VUzpcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuTFBBUkVOOlxyXG4gICAgICAgIGNhc2Ugb2RlR3JhbW1hclBhcnNlci5MQ1JMOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gMzEyO1xyXG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24oMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTc7XHJcbiAgICAgICAgICAgIHRoaXMuX2VyckhhbmRsZXIuc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgX2xhID0gdGhpcy5faW5wdXQuTEEoMSk7XHJcbiAgICAgICAgICAgIHdoaWxlKF9sYT09PW9kZUdyYW1tYXJQYXJzZXIuQ09NTUEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoKG9kZUdyYW1tYXJQYXJzZXIuQ09NTUEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDMxNDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbigwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAzMTk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnN5bmModGhpcyk7XHJcbiAgICAgICAgICAgICAgICBfbGEgPSB0aGlzLl9pbnB1dC5MQSgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIG9kZUdyYW1tYXJQYXJzZXIuUlBBUkVOOlxyXG4gICAgICAgICAgICB0aGlzLmVudGVyT3V0ZXJBbHQobG9jYWxjdHgsIDIpO1xyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGFudGxyNC5lcnJvci5Ob1ZpYWJsZUFsdEV4Y2VwdGlvbih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChyZSkge1xyXG4gICAgXHRpZihyZSBpbnN0YW5jZW9mIGFudGxyNC5lcnJvci5SZWNvZ25pdGlvbkV4Y2VwdGlvbikge1xyXG5cdCAgICAgICAgbG9jYWxjdHguZXhjZXB0aW9uID0gcmU7XHJcblx0ICAgICAgICB0aGlzLl9lcnJIYW5kbGVyLnJlcG9ydEVycm9yKHRoaXMsIHJlKTtcclxuXHQgICAgICAgIHRoaXMuX2VyckhhbmRsZXIucmVjb3Zlcih0aGlzLCByZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgIFx0dGhyb3cgcmU7XHJcblx0ICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgdGhpcy5leGl0UnVsZSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvY2FsY3R4O1xyXG59O1xyXG5cclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLnNlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcnVsZUluZGV4LCBwcmVkSW5kZXgpIHtcclxuXHRzd2l0Y2gocnVsZUluZGV4KSB7XHJcblx0Y2FzZSAyMDpcclxuXHRcdFx0cmV0dXJuIHRoaXMuYm9vbEV4cHJlc3Npb25fc2VtcHJlZChsb2NhbGN0eCwgcHJlZEluZGV4KTtcclxuXHRjYXNlIDIxOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5leHByZXNzaW9uX3NlbXByZWQobG9jYWxjdHgsIHByZWRJbmRleCk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IFwiTm8gcHJlZGljYXRlIHdpdGggaW5kZXg6XCIgKyBydWxlSW5kZXg7XHJcbiAgIH1cclxufTtcclxuXHJcbm9kZUdyYW1tYXJQYXJzZXIucHJvdG90eXBlLmJvb2xFeHByZXNzaW9uX3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAwOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDMpO1xyXG5cdFx0Y2FzZSAxOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDIpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5vZGVHcmFtbWFyUGFyc2VyLnByb3RvdHlwZS5leHByZXNzaW9uX3NlbXByZWQgPSBmdW5jdGlvbihsb2NhbGN0eCwgcHJlZEluZGV4KSB7XHJcblx0c3dpdGNoKHByZWRJbmRleCkge1xyXG5cdFx0Y2FzZSAyOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDkpO1xyXG5cdFx0Y2FzZSAzOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDcpO1xyXG5cdFx0Y2FzZSA0OlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5wcmVjcHJlZCh0aGlzLl9jdHgsIDYpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgXCJObyBwcmVkaWNhdGUgd2l0aCBpbmRleDpcIiArIHByZWRJbmRleDtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuZXhwb3J0cy5vZGVHcmFtbWFyUGFyc2VyID0gb2RlR3JhbW1hclBhcnNlcjtcclxuIiwiLy8gR2VuZXJhdGVkIGZyb20gZTpcXHByb2plY3RzXFxTb2x2ZXJzSlNcXHNyY1xcZ3JhbW1hclxcb2RlR3JhbW1hci5nNCBieSBBTlRMUiA0LjhcclxuLy8ganNoaW50IGlnbm9yZTogc3RhcnRcclxudmFyIGFudGxyNCA9IHJlcXVpcmUoJ2FudGxyNC9pbmRleCcpO1xyXG5cclxuLy8gVGhpcyBjbGFzcyBkZWZpbmVzIGEgY29tcGxldGUgZ2VuZXJpYyB2aXNpdG9yIGZvciBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlci5cclxuXHJcbmZ1bmN0aW9uIG9kZUdyYW1tYXJWaXNpdG9yKCkge1xyXG5cdGFudGxyNC50cmVlLlBhcnNlVHJlZVZpc2l0b3IuY2FsbCh0aGlzKTtcclxuXHRyZXR1cm4gdGhpcztcclxufVxyXG5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShhbnRscjQudHJlZS5QYXJzZVRyZWVWaXNpdG9yLnByb3RvdHlwZSk7XHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG9kZUdyYW1tYXJWaXNpdG9yO1xyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjZGFlLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXREYWUgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjZGFlU3RhdGVtZW50LlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXREYWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjaHlicmlkLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRIeWJyaWQgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjbnVtYmVyLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXROdW1iZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjaHlicmlkU3RhdGVtZW50LlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRIeWJyaWRTdGF0ZW1lbnQgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjaW5kZXguXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluZGV4ID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI3ZhcklkZW50aWZpZXIuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFZhcklkZW50aWZpZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjbG9vcFN0YXRlbWVudC5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TG9vcFN0YXRlbWVudCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlciNsb29wQm9keS5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TG9vcEJvZHkgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjbWFjcm9TdGF0ZW1lbnQuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hY3JvU3RhdGVtZW50ID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI21hY3JvQXJndW1lbnRzLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNYWNyb0FyZ3VtZW50cyA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlciNsb29wQm91bmRzLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMb29wQm91bmRzID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI2xvb3AuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExvb3AgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjZXF1YXRpb24uXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVxdWF0aW9uID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI3NldHRlci5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2V0dGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI2luaXRpYWxDb25kaXRpb24uXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluaXRpYWxDb25kaXRpb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjY29uc3RhbnRTdGF0ZW1lbnQuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnN0YW50U3RhdGVtZW50ID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI3N0YXRlU3RhdGVtZW50LlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlciNzdGF0ZURlZi5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U3RhdGVEZWYgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjc3RhdGVUcmFuc2l0aW9uLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjQm9vbENvbnN0YW50LlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCb29sQ29uc3RhbnQgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjQm9vbFVuYXJ5T3BlcmF0b3IuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJvb2xVbmFyeU9wZXJhdG9yID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI0JyYWNrZXRCb29sRXhwcmVzc2lvbi5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QnJhY2tldEJvb2xFeHByZXNzaW9uID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI0JCb29sQmluYXJ5T3BlcmF0b3IuXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJCb29sQmluYXJ5T3BlcmF0b3IgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjRUJvb2xCaW5hcnlPcGVyYXRvci5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RUJvb2xCaW5hcnlPcGVyYXRvciA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlciNCcmFja2V0RXhwcmVzc2lvbi5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QnJhY2tldEV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjTWFjcm9FeHByZXNzaW9uLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRNYWNyb0V4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjQmluYXJ5T3BlcmF0b3JFeHByZXNzaW9uLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjRnVuY3Rpb25FeHByZXNzaW9uLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjVW5hcnlPcGVyYXRvckV4cHJlc3Npb24uXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFVuYXJ5T3BlcmF0b3JFeHByZXNzaW9uID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI0NvbnN0YW50RXhwcmVzc2lvbi5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29uc3RhbnRFeHByZXNzaW9uID0gZnVuY3Rpb24oY3R4KSB7XHJcbiAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjdHgpO1xyXG59O1xyXG5cclxuXHJcbi8vIFZpc2l0IGEgcGFyc2UgdHJlZSBwcm9kdWNlZCBieSBvZGVHcmFtbWFyUGFyc2VyI1N1bW1hdGlvbkV4cHJlc3Npb24uXHJcbm9kZUdyYW1tYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFN1bW1hdGlvbkV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjRnVuY3Rpb25EZXJpdmF0aXZlLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkRlcml2YXRpdmUgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjVmFyaWFibGVFeHByZXNzaW9uLlxyXG5vZGVHcmFtbWFyVmlzaXRvci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZUV4cHJlc3Npb24gPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuLy8gVmlzaXQgYSBwYXJzZSB0cmVlIHByb2R1Y2VkIGJ5IG9kZUdyYW1tYXJQYXJzZXIjVGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbi5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVybmFyeU9wZXJhdG9yRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG4gIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY3R4KTtcclxufTtcclxuXHJcblxyXG4vLyBWaXNpdCBhIHBhcnNlIHRyZWUgcHJvZHVjZWQgYnkgb2RlR3JhbW1hclBhcnNlciNmdW5jdGlvbkFyZ3VtZW50cy5cclxub2RlR3JhbW1hclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25Bcmd1bWVudHMgPSBmdW5jdGlvbihjdHgpIHtcclxuICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGN0eCk7XHJcbn07XHJcblxyXG5cclxuXHJcbmV4cG9ydHMub2RlR3JhbW1hclZpc2l0b3IgPSBvZGVHcmFtbWFyVmlzaXRvcjsiLCJpbXBvcnQge3VpfSBmcm9tIFwiLi91aVwiO1xyXG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XHJcblxyXG51aS5pbml0KCk7XHJcblxyXG4oZnVuY3Rpb24oKXtcclxuICAgIHZhciBkYXRhOmFueSA9IFtdO1xyXG4gICAgICB2YXIgbGF5b3V0ID0ge1xyXG4gICAgICAgIHRpdGxlOidSZXN1bHQnLFxyXG4gICAgICAgIHdpZHRoOiQoXCIjcGxvdC1hcmVhXCIpLndpZHRoKCksXHJcbiAgICAgICAgaGVpZ2h0OiQoXCIjcGxvdC1hcmVhXCIpLmhlaWdodCgpLFxyXG4gICAgICAgIHBhcGVyX2JnY29sb3I6ICdyZ2JhKDI0NSwyNDUsMjQ1LDEpJyxcclxuICAgICAgICBwbG90X2JnY29sb3I6ICdyZ2JhKDI0NSwyNDUsMjQ1LDEpJ1xyXG4gICAgICB9O1xyXG4gICAgICAvL0B0cy1pZ25vcmVcclxuICAgIFBsb3RseS5uZXdQbG90KCdwbG90LWFyZWEnLGRhdGEsbGF5b3V0LHtyZXNwb25zaXZlOnRydWV9KTtcclxufSkoKTtcclxud2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24oKXtcclxuICBpZih1aS5pc1Jlc3VsdHNUYWIpe1xyXG4gICAgICAvL0B0cy1pZ25vcmVcclxuICAgIFBsb3RseS5yZWxheW91dCgncGxvdC1hcmVhJyx7XHJcbiAgICAgIHdpZHRoOiQoXCIjcGxvdC1hcmVhXCIpLndpZHRoKCksXHJcbiAgICAgIGhlaWdodDokKFwiI3Bsb3QtYXJlYVwiKS5oZWlnaHQoKVxyXG4gICAgfSlcclxuICAgIC8vY29uc29sZS5sb2coJChcIiNwbG90LWFyZWFcIikud2lkdGgoKSk7XHJcbiAgfVxyXG59XHJcblxyXG51aS5vcGVuVGFiKFwicnVuXCIpO1xyXG51aS5hZGRMb2dNZXNzYWdlKFwiU3RhcnRcIik7XHJcbnVpLmxvYWREYWVFeGFtcGxlKFwic3RpZmYtZXF1YXRpb25cIik7XHJcbnVpLnNob3dEZWJ1ZygpOyIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuL21hdHJpeFwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi92ZWN0b3JcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBnYXVzc3tcclxuICAgIC8qKlxyXG4gICAgICogZ2F1c3MgbWV0aG9kIGZvciBsaW5lYXIgZXF1YXRpb25zIHdpdGggcm93cyBzb3J0aW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzb2x2ZShBOm1hdHJpeCxiOnZlY3Rvcik6dmVjdG9ye1xyXG4gICAgICAgIHZhciByYW5nPWIubGVuZ3RoKCk7XHJcbiAgICAgICAgdmFyIHg6dmVjdG9yPXZlY3Rvci5lbXB0eShyYW5nKTtcclxuICAgICAgICBsZXQgZXBzaWxvbj0wLjAwMVxyXG4gICAgICAgIHZhciBpbmRleGVzID0gbmV3IEFycmF5KHJhbmcpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZzsgaSsrKXtcclxuICAgICAgICAgICAgaW5kZXhlc1tpXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgcmFuZzsgbCsrKXtcclxuICAgICAgICAgICAgdmFyIG1heCA9IGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsICsgMTsgaSA8IHJhbmc7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoQS5nZXQoaW5kZXhlc1tpXSxsKSk+TWF0aC5hYnMoQS5nZXQoaW5kZXhlc1ttYXhdLGwpKSlcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXggIT0gbCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGluZGV4ZXNbbF07XHJcbiAgICAgICAgICAgICAgICBpbmRleGVzW2xdID0gaW5kZXhlc1ttYXhdO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhlc1ttYXhdID0gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoQS5nZXQoaW5kZXhlc1tsXSxsKSkgPCBlcHNpbG9uKXtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wO2k8cmFuZztpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgeC5zZXQoMC4wLGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGwgKyAxOyBpIDwgcmFuZzsgaSsrKVxyXG4gICAgICAgICAgICAgICAgQS5zZXQoQS5nZXQoaW5kZXhlc1tsXSxpKSAvIEEuZ2V0KGluZGV4ZXNbbF0sbCksaW5kZXhlc1tsXSxpKTtcclxuICAgICAgICAgICAgYi5zZXQoYi5nZXQoaW5kZXhlc1tsXSkgLyBBLmdldChpbmRleGVzW2xdLGwpLCBpbmRleGVzW2xdKTtcclxuICAgICAgICAgICAgQS5zZXQoMSxpbmRleGVzW2xdLGwpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsICsgMTsgaSA8IHJhbmc7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gbCArIDE7IGsgPCByYW5nOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgQS5zZXQoQS5nZXQoaW5kZXhlc1tpXSxrKSAtIEEuZ2V0KGluZGV4ZXNbaV0sbCkgKiBBLmdldChpbmRleGVzW2xdLGspLGluZGV4ZXNbaV0sayk7XHJcbiAgICAgICAgICAgICAgICBiLnNldChiLmdldChpbmRleGVzW2ldKSAtIEEuZ2V0KGluZGV4ZXNbaV0sbCkgKiBiLmdldChpbmRleGVzW2xdKSwgaW5kZXhlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBBLnNldCgwLGluZGV4ZXNbaV0sbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgeC5zZXQoYi5nZXQoaW5kZXhlc1tyYW5nIC0gMV0pLHJhbmcgLSAxKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gcmFuZyAtIDI7IGkgPiAtMTsgaS0tKXtcclxuICAgICAgICAgICAgdmFyIGsgPSAwLjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgcmFuZzsgaisrKXtcclxuICAgICAgICAgICAgICAgIGsgPSBrICsgQS5nZXQoaW5kZXhlc1tpXSxqKSAqIHguZ2V0KGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHguc2V0KGIuZ2V0KGluZGV4ZXNbaV0pIC0gayxpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi92ZWN0b3JcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBtYXRyaXh7XHJcbiAgICBtdWx0VmVjKGR4OiB2ZWN0b3IpOnZlY3RvciB7XHJcbiAgICAgICAgbGV0IHJlc3VsdDp2ZWN0b3IgPSB2ZWN0b3IuZW1wdHkodGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5oZWlnaHQ7aSsrKXtcclxuICAgICAgICAgICAgbGV0IHYgPSAwO1xyXG4gICAgICAgICAgICBmb3IobGV0IGo9MDtqPHRoaXMud2lkdGg7aisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2Kz10aGlzLmdldChqLGkpICogZHguZ2V0KGopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXQodixpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHdpZHRoOm51bWJlcjtcclxuICAgIGhlaWdodDpudW1iZXI7XHJcbiAgICBkYXRhOm51bWJlcltdO1xyXG4gICAgY29uc3RydWN0b3IoZGF0YTpudW1iZXJbXSxjb2x1bW5zOm51bWJlcixyb3dzOm51bWJlcil7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLndpZHRoID0gY29sdW1ucztcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHJvd3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogY3JlYXRlcyBlbXB0eSBpZGVudGl0eSBtYXRyaXhcclxuICAgICovXHJcbiAgICBzdGF0aWMgaWRlbnRpdHkoc2l6ZTpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgZGF0YTpudW1iZXJbXTtcclxuICAgICAgICAoZGF0YSA9IFtdKS5sZW5ndGggPSBzaXplKnNpemU7IFxyXG4gICAgICAgIGRhdGEuZmlsbCgwKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHNpemU7aSsrKXtcclxuICAgICAgICAgICAgZGF0YVtpK2kqc2l6ZV0gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChkYXRhLHNpemUsc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogY3JlYXRlcyBlbXB0eSBzcXVhcmUgbWF0cml4XHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGVtcHR5U3F1YXJlKHNpemU6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IGRhdGE6bnVtYmVyW107XHJcbiAgICAgICAgKGRhdGEgPSBbXSkubGVuZ3RoID0gc2l6ZSpzaXplOyBcclxuICAgICAgICBkYXRhLmZpbGwoMCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoZGF0YSxzaXplLHNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIGNyZWF0ZXMgZW1wdHkgcmVjdGFuZ3VsYXIgbWF0cml4XHJcbiAgICAqL1xyXG4gICAgc3RhdGljIGVtcHR5KHJvd3M6bnVtYmVyLGNvbHVtbnM6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IGRhdGE6bnVtYmVyW107XHJcbiAgICAgICAgKGRhdGEgPSBbXSkubGVuZ3RoID0gcm93cypjb2x1bW5zOyBcclxuICAgICAgICBkYXRhLmZpbGwoMCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoZGF0YSxjb2x1bW5zLHJvd3MpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFkZChhOm1hdHJpeCxiOm1hdHJpeCk6bWF0cml4e1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGEuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhLmRhdGFbaV0gKyBiLmRhdGFbaV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgbWF0cml4KHJlc3VsdCxhLndpZHRoLGEuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzdWIoYTptYXRyaXgsYjptYXRyaXgpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxhLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYS5kYXRhW2ldIC0gYi5kYXRhW2ldKTtcclxuICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChyZXN1bHQsYS53aWR0aCxhLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2NhbGUoYTptYXRyaXgsYjpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxhLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYS5kYXRhW2ldICogYik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgocmVzdWx0LGEud2lkdGgsYS5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBtYXRyaXggbXVsdGlwbGljYXRpb24gXHJcbiAgICAgKiBAcGFyYW0gYSBtYXRyaXggd2l0aCAod2lkdGggPSB3X2EsIGhlaWdodCA9IGhfYSlcclxuICAgICAqIEBwYXJhbSBiIG1hdHJpeCB3aXRoICh3aWR0aCA9IHdfYiwgaGVpZ2h0ID0gd19hKVxyXG4gICAgICogQHJldHVybnMgbWF0cml4IHdpdGggKHdpZHRoID0gd19iLCBoZWlnaHQgPSBoX2EpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtdWx0KGE6bWF0cml4LGI6bWF0cml4KTptYXRyaXh7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1hdHJpeC5lbXB0eShhLmhlaWdodCxiLndpZHRoKTtcclxuICAgICAgICAvL2ZvciBlYWNoIGNlbGwgaW4gdGhlIHJlc3VsdFxyXG4gICAgICAgIGZvcihsZXQgaj0wO2o8YS5oZWlnaHQ7aisrKXtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxiLndpZHRoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBrID0gMDtrPGEud2lkdGg7aysrKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBhLmdldChqLGspICogYi5nZXQoayxpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQodmFsdWUsaixpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIGdldCB2YWx1ZVxyXG4gICAgKiBAcGFyYW0gcm93IHJvd1xyXG4gICAgKiBAcGFyYW0gY29sdW1uIGNvbHVtblxyXG4gICAgKi9cclxuICAgIGdldChyb3c6bnVtYmVyLGNvbHVtbjpudW1iZXIpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3Jvdyp0aGlzLndpZHRoK2NvbHVtbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogc2V0IHZhbHVlXHJcbiAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0gcm93IHJvd1xyXG4gICAgKiBAcGFyYW0gY29sdW1uIGNvbHVtblxyXG4gICAgKi9cclxuICAgIHNldCh2YWx1ZTpudW1iZXIscm93Om51bWJlcixjb2x1bW46bnVtYmVyKXtcclxuICAgICAgICB0aGlzLmRhdGFbcm93KnRoaXMud2lkdGgrY29sdW1uXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIG11bHRpcGx5IG1hdHJpeCBieSBzY2FsYXIgYW5kIHN0b3JlIHJlc3VsdCBpbiBkZXN0XHJcbiAgICAqIEBwYXJhbSBiIHNjYWxhclxyXG4gICAgKiBAcGFyYW0gZGVzdCBkZXN0aW5hdGlvbiBtYXRyaXhcclxuICAgICogQHJldHVybiByZXN1bHRcclxuICAgICovXHJcbiAgICBzY2FsZShiOm51bWJlciwgZGVzdD86bWF0cml4KTptYXRyaXh7XHJcbiAgICAgICAgaWYoZGVzdD09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgZGVzdCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIGRlc3QuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXSAqIGI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGQoYjptYXRyaXgsIGRlc3Q/Om1hdHJpeCk6bWF0cml4e1xyXG4gICAgICAgIGlmKGRlc3Q9PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGRlc3QgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICBkZXN0LmRhdGFbaV0gPSB0aGlzLmRhdGFbaV0gKyBiLmRhdGFbaV07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzdWIoYjptYXRyaXgsIGRlc3Q/Om1hdHJpeCk6bWF0cml4e1xyXG4gICAgICAgIGlmKGRlc3Q9PXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGRlc3QgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICBkZXN0LmRhdGFbaV0gPSB0aGlzLmRhdGFbaV0gLSBiLmRhdGFbaV07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzY2FsZVNlbGYoYjpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0qPWI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRTZWxmKGI6bWF0cml4KTptYXRyaXh7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldKz1iLmRhdGFbaV07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzdWJTZWxmKGI6bWF0cml4KTptYXRyaXh7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldLT1iLmRhdGFbaV07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRTdWJNYXRyaXgoYjptYXRyaXgscm93T2Zmc2V0Om51bWJlcixjb2x1bW5PZmZzZXQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBqPTA7ajxiLmhlaWdodDtqKyspXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPGIud2lkdGg7aSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldChqK3Jvd09mZnNldCxpICsgY29sdW1uT2Zmc2V0KStiLmdldChqLGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodmFsdWUsaityb3dPZmZzZXQsaStjb2x1bW5PZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3ViU3ViTWF0cml4KGI6bWF0cml4LHJvd09mZnNldDpudW1iZXIsY29sdW1uT2Zmc2V0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcihsZXQgaj0wO2o8Yi5oZWlnaHQ7aisrKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTxiLndpZHRoO2krKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXQoaityb3dPZmZzZXQsaSArIGNvbHVtbk9mZnNldCktYi5nZXQoaixpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHZhbHVlLGorcm93T2Zmc2V0LGkrY29sdW1uT2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufSIsImltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyB2ZWN0b3IgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgZ2F1c3MgfSBmcm9tIFwiLi4vbWF0aC9nYXVzc1wiO1xyXG5cclxuXHJcbmludGVyZmFjZSBBbGdlYnJhaWNTeXN0ZW17XHJcbiAgICBsZW5ndGgoKTpudW1iZXI7XHJcbiAgICBGKHg6dmVjdG9yKTp2ZWN0b3I7XHJcbiAgICBKKHg6dmVjdG9yKTptYXRyaXg7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBOZXd0b25Tb2x2ZXJ7XHJcbiAgICBwcm90ZWN0ZWQgaXRlcmF0aW9uczpudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgZkFic1RvbDpudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgZlJlbFRvbDpudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgYWxwaGE6bnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIG1pbkl0ZXJhdGlvbnM6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBnZXRNaW5JdGVyYXRpb25zKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbkl0ZXJhdGlvbnM7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0SXRlcmF0aW9ucygpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldEFic1RvbCgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5mQWJzVG9sO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldFJlbFRvbCgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gdGhpcy5mUmVsVG9sO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldEFscGhhKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFscGhhO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldE1pbkl0ZXJhdGlvbnModmFsdWU6bnVtYmVyKTp2b2lke1xyXG4gICAgICAgIHRoaXMubWluSXRlcmF0aW9ucyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldEl0ZXJhdGlvbnModmFsdWU6bnVtYmVyKTp2b2lke1xyXG4gICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldEFic1RvbCh2YWx1ZTpudW1iZXIpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5mQWJzVG9sID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0UmVsVG9sKHZhbHVlOm51bWJlcik6dm9pZHtcclxuICAgICAgICB0aGlzLmZSZWxUb2wgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXRBbHBoYSh2YWx1ZTpudW1iZXIpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGl0ZXJhdGlvbnM6bnVtYmVyLGZBYnNUb2w6bnVtYmVyLGZSZWxUb2w6bnVtYmVyLGFscGhhOm51bWJlcixtaW5JdGVyYXRpb25zOm51bWJlciA9IDApe1xyXG4gICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnM7XHJcbiAgICAgICAgdGhpcy5mQWJzVG9sID0gZkFic1RvbDtcclxuICAgICAgICB0aGlzLmZSZWxUb2wgPSBmUmVsVG9sO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcclxuICAgICAgICB0aGlzLm1pbkl0ZXJhdGlvbnMgPSBtaW5JdGVyYXRpb25zO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNvbHZlKEY6KHg6dmVjdG9yKT0+dmVjdG9yLCBKOih4OnZlY3Rvcik9Pm1hdHJpeCxsZW5ndGg6bnVtYmVyLHgwPzp2ZWN0b3IpOnZlY3RvcntcclxuICAgICAgICBsZXQgeDp2ZWN0b3I7XHJcbiAgICAgICAgaWYoeDA9PXVuZGVmaW5lZClcclxuICAgICAgICAgICAgeCA9IHZlY3Rvci5lbXB0eShsZW5ndGgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgeCA9IHgwLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IGY6dmVjdG9yICA9IEYoeCk7XHJcbiAgICAgICAgbGV0IGYwTm9ybSA9IGYubm9ybTIoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuaXRlcmF0aW9ucztpKyspe1xyXG4gICAgICAgICAgICBsZXQgajptYXRyaXggPSBKKHgpO1xyXG4gICAgICAgICAgICBsZXQgZHg6dmVjdG9yID0gZ2F1c3Muc29sdmUoaixmLnNjYWxlU2VsZigtdGhpcy5hbHBoYSkpO1xyXG4gICAgICAgICAgICB4LmFkZFNlbGYoZHgpO1xyXG4gICAgICAgICAgICBmID0gRih4KTtcclxuICAgICAgICAgICAgaWYoaT49dGhpcy5taW5JdGVyYXRpb25zJiZmLm5vcm0yKCk8dGhpcy5mQWJzVG9sK3RoaXMuZlJlbFRvbCpmME5vcm0pe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGl2ZXJnZW5jZSBvZiBuZXd0b24gbWV0aG9kXCIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNvbHZlU3lzdGVtKHN5c3RlbTpBbGdlYnJhaWNTeXN0ZW0seDA/OnZlY3Rvcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCB4OnZlY3RvcjtcclxuICAgICAgICBpZih4MD09dW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB4ID0gdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGgoKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB4ID0geDAuY2xvbmUoKTtcclxuICAgICAgICBsZXQgRjp2ZWN0b3IgID0gc3lzdGVtLkYoeCk7XHJcbiAgICAgICAgbGV0IGYwTm9ybSA9IEYubm9ybTIoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuaXRlcmF0aW9ucztpKyspe1xyXG4gICAgICAgICAgICBsZXQgSjptYXRyaXggPSBzeXN0ZW0uSih4KTtcclxuICAgICAgICAgICAgbGV0IGR4OnZlY3RvciA9IGdhdXNzLnNvbHZlKEosRi5zY2FsZVNlbGYoLXRoaXMuYWxwaGEpKTtcclxuICAgICAgICAgICAgeC5hZGRTZWxmKGR4KTtcclxuICAgICAgICAgICAgRiA9IHN5c3RlbS5GKHgpO1xyXG4gICAgICAgICAgICBpZihpPj10aGlzLm1pbkl0ZXJhdGlvbnMmJkYubm9ybTIoKTx0aGlzLmZBYnNUb2wrdGhpcy5mUmVsVG9sKmYwTm9ybSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZlcmdlbmNlIG9mIG5ld3RvbiBtZXRob2RcIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBtYXRyaXggfSBmcm9tIFwiLi9tYXRyaXhcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBsZXJwKGE6bnVtYmVyLGI6bnVtYmVyLHQ6bnVtYmVyKTpudW1iZXJ7XHJcbiAgICByZXR1cm4gYSooMS10KSArIGIqdDtcclxufVxyXG5leHBvcnQgY2xhc3MgdmVjdG9ye1xyXG4gICAgc3RhdGljIG91dGVyKGE6dmVjdG9yLGI6dmVjdG9yKTptYXRyaXh7XHJcbiAgICAgICAgbGV0IHJlc3VsdDptYXRyaXggPSBtYXRyaXguZW1wdHkoYS5sZW5ndGgoKSxiLmxlbmd0aCgpKTtcclxuICAgICAgICBmb3IobGV0IGogPSAwO2o8YS5sZW5ndGgoKTtqKyspe1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPGIubGVuZ3RoKCk7aSsrKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoYS5nZXQoaikqYi5nZXQoaSksaixpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbmNhdCh2ZWN0b3JzOiB2ZWN0b3JbXSkge1xyXG4gICAgICAgIGxldCBkYXRhOm51bWJlcltdID0gW107XHJcbiAgICAgICAgdmVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoaXRlbS5kYXRhKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRvdChhOiB2ZWN0b3IsIGI6IHZlY3Rvcik6bnVtYmVyIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgICAgICBmb3IobGV0IGkgPSAwO2k8YS5sZW5ndGgoKTtpKyspe1xyXG4gICAgICAgICAgICByZXN1bHQrPWEuZGF0YVtpXSpiLmRhdGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHZlY3RvciBpbnRlcnBvbGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtaXgoYTp2ZWN0b3IsIGI6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGEuY2xvbmUoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGEubGVuZ3RoKCk7aSsrKXtcclxuICAgICAgICAgICAgcmVzdWx0LmRhdGFbaV0gPSBsZXJwKHJlc3VsdC5kYXRhW2ldLGIuZGF0YVtpXSx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGRhdGE6bnVtYmVyW107XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhOm51bWJlcltdKXtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVtcHR5KGxlbmd0aDpudW1iZXIpe1xyXG4gICAgICAgIGxldCBkYXRhOm51bWJlcltdO1xyXG4gICAgICAgIChkYXRhID0gW10pLmxlbmd0aCA9IGxlbmd0aDsgXHJcbiAgICAgICAgZGF0YS5maWxsKDApO1xyXG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFkZChhOnZlY3RvcixiOnZlY3Rvcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGEuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhLmRhdGFbaV0gKyBiLmRhdGFbaV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgdmVjdG9yKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc3ViKGE6dmVjdG9yLGI6dmVjdG9yKTp2ZWN0b3J7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8YS5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGEuZGF0YVtpXSAtIGIuZGF0YVtpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzY2FsZShhOnZlY3RvcixiOm51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGEuZGF0YS5sZW5ndGg7aSsrKVxyXG4gICAgICAgICAgICByZXN1bHQucHVzaChhLmRhdGFbaV0gKiBiKTtcclxuICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKTp2ZWN0b3J7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IodGhpcy5kYXRhLnNsaWNlKCkpO1xyXG4gICAgfVxyXG4gICAgYWRkU2VsZihiOnZlY3Rvcik6dmVjdG9ye1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSs9Yi5kYXRhW2ldO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3ViU2VsZihiOnZlY3Rvcik6dmVjdG9ye1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXS09Yi5kYXRhW2ldO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2NhbGVTZWxmKGI6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldKj1iO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0KGk6bnVtYmVyKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW2ldO1xyXG4gICAgfVxyXG4gICAgc2V0KHZhbHVlOm51bWJlciwgaTpudW1iZXIpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBsZW5ndGgoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldFN1YlZlY3RvcihvZmZzZXQ6bnVtYmVyLGxlbmd0aDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBsZXQgcmVzdWx0RGF0YSA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8bGVuZ3RoO2krKylcclxuICAgICAgICAgICAgcmVzdWx0RGF0YVtpXSA9IHRoaXMuZGF0YVtvZmZzZXQraV07XHJcbiAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IocmVzdWx0RGF0YSk7XHJcbiAgICB9XHJcbiAgICBhZGRTdWJWZWN0b3IoYjp2ZWN0b3IsIG9mZnNldDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGIubGVuZ3RoKCk7aSsrKVxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaStvZmZzZXRdICs9IGIuZ2V0KGkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3ViU3ViVmVjdG9yKGI6dmVjdG9yLCBvZmZzZXQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxiLmxlbmd0aCgpO2krKylcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2krb2Zmc2V0XSAtPSBiLmdldChpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGFkZChiOnZlY3RvciwgZGVzdD86dmVjdG9yKTp2ZWN0b3J7XHJcbiAgICAgICAgaWYoZGVzdD09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgZGVzdCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIGRlc3QuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXSArIGIuZGF0YVtpXTtcclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIHN1YihiOnZlY3RvciwgZGVzdD86dmVjdG9yKTp2ZWN0b3J7XHJcbiAgICAgICAgaWYoZGVzdD09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgZGVzdCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIGRlc3QuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXSAtIGIuZGF0YVtpXTtcclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIHNjYWxlKGI6bnVtYmVyLCBkZXN0Pzp2ZWN0b3IpOnZlY3RvcntcclxuICAgICAgICBpZihkZXN0PT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBkZXN0ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx0aGlzLmRhdGEubGVuZ3RoO2krKylcclxuICAgICAgICAgICAgZGVzdC5kYXRhW2ldID0gdGhpcy5kYXRhW2ldICogYjtcclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIG5vcm0yKCk6bnVtYmVye1xyXG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8dGhpcy5kYXRhLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmRhdGFbaV0qdGhpcy5kYXRhW2ldO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQocmVzdWx0KTtcclxuICAgIH1cclxuICAgIG5vcm0yU3FyKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuZG90KHRoaXMsdGhpcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IFxyXG4gICAgRURBRV9FRXVsZXIsIFxyXG4gICAgRURBRV9JRXVsZXJcclxufSBmcm9tIFwiLi9kYWUvc29sdmVycy9lZGFlL2V1bGVyXCI7XHJcbmltcG9ydCB7IFxyXG4gICAgSURBRV9FRXVsZXIsXHJcbiAgICBJREFFX0lFdWxlciBcclxufSBmcm9tIFwiLi9kYWUvc29sdmVycy9pZGFlL2V1bGVyXCI7XHJcbmltcG9ydCB7ICAgICBFREFFX1JLNCwgXHJcbiAgICBFREFFX1JLNF8yLFxyXG4gICAgRURBRV9SSzRfUkFMU1RPTixcclxuICAgIEVEQUVfRE9QUkk1LCBcclxuICAgIEVEQUVfUkFEQVVJQTUsIFxyXG4gICAgRURBRV9CUzIzLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUEyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUE0LCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUIyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUI0LCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUMyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUM0LCBcclxuICAgIEVEQUVfUkFEQVVJSUEzLCBcclxuICAgIEVEQUVfUkFEQVVJSUE1LCBcclxuICAgIEVEQUVfR0FVU1NMRUdFTkRSRTQsIFxyXG4gICAgRURBRV9HQVVTU0xFR0VORFJFNixcclxuICAgIEVEQUVfSGV1bkV1bGVyLCBcclxuICAgIEVEQUVfTWlkcG9pbnRFdWxlciwgXHJcbiAgICBFREFFX1JLNiwgXHJcbiAgICBFREFFX1JLNl8yLCBcclxuICAgIEVEQUVfUks4IH0gZnJvbSBcIi4vZGFlL3NvbHZlcnMvZWRhZS9ya1wiO1xyXG5pbXBvcnQgeyBcclxuICAgIElEQUVfUks0LFxyXG4gICAgSURBRV9SSzRfMixcclxuICAgIElEQUVfUks0X1JBTFNUT04sXHJcbiAgICBJREFFX0RPUFJJNSwgXHJcbiAgICBJREFFX1JBREFVSUE1LCBcclxuICAgIElEQUVfQlMyMywgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlBMiwgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlBNCwgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlCMiwgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlCNCwgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlDMiwgXHJcbiAgICBJREFFX0xPQkFUVE9JSUlDNCwgXHJcbiAgICBJREFFX1JBREFVSUlBMywgXHJcbiAgICBJREFFX1JBREFVSUlBNSwgXHJcbiAgICBJREFFX0dBVVNTTEVHRU5EUkU0LCBcclxuICAgIElEQUVfR0FVU1NMRUdFTkRSRTYsXHJcbiAgICBJREFFX0hldW5FdWxlciwgXHJcbiAgICBJREFFX01pZHBvaW50RXVsZXIsIFxyXG4gICAgSURBRV9SSzYsIFxyXG4gICAgSURBRV9SSzZfMiwgXHJcbiAgICBJREFFX1JLOCB9IGZyb20gXCIuL2RhZS9zb2x2ZXJzL2lkYWUvcmtcIjtcclxuaW1wb3J0IHsgSURBRV9FTWlkcG9pbnQsIElEQUVfSU1pZHBvaW50IH0gZnJvbSBcIi4vZGFlL3NvbHZlcnMvaWRhZS9taWRwb2ludFwiO1xyXG5pbXBvcnQgeyBJREFFX0VUcmFwZXpvaWRhbCwgSURBRV9JVHJhcGV6b2lkYWwgfSBmcm9tIFwiLi9kYWUvc29sdmVycy9pZGFlL3RyYXBlem9pZGFsXCI7XHJcbmltcG9ydCB7IEVEQUVfSU1pZHBvaW50LCBFREFFX0VNaWRwb2ludCB9IGZyb20gXCIuL2RhZS9zb2x2ZXJzL2VkYWUvbWlkcG9pbnRcIjtcclxuaW1wb3J0IHsgRURBRV9FVHJhcGV6b2lkYWwsIEVEQUVfSVRyYXBlem9pZGFsIH0gZnJvbSBcIi4vZGFlL3NvbHZlcnMvZWRhZS90cmFwZXpvaWRhbFwiO1xyXG5pbXBvcnQgeyBFREFFX0FsZ2VicmFpY1NvbHZlciB9IGZyb20gXCIuL2RhZS9zb2x2ZXJzL2VkYWUvYWxnZWJyYWljU29sdmVyXCI7XHJcbmltcG9ydCB7IElEQUVfQWxnZWJyYWljU29sdmVyIH0gZnJvbSBcIi4vZGFlL3NvbHZlcnMvaWRhZS9hbGdlYnJhaWNTb2x2ZXJcIjtcclxuaW1wb3J0IHsgRURBRVNvbHZlciB9IGZyb20gXCIuL2RhZS9lZGFlU29sdmVyXCI7XHJcbmltcG9ydCB7IElEQUVTb2x2ZXIgfSBmcm9tIFwiLi9kYWUvaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBOZXd0b25Tb2x2ZXIgfSBmcm9tIFwiLi9tYXRoL25ld3RvblwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSVBhcmFtZXRlcnN7XHJcbiAgICBzb2x2ZXI6e1xyXG4gICAgICAgIGRhZUZvcm06c3RyaW5nLFxyXG4gICAgICAgIG1ldGhvZDpzdHJpbmcsXHJcbiAgICAgICAgc3RlcDpudW1iZXIsXHJcbiAgICAgICAgdDA6bnVtYmVyLFxyXG4gICAgICAgIHRpbWU6bnVtYmVyLFxyXG4gICAgICAgIHN0ZXBDb250cm9sOntcclxuICAgICAgICAgICAgbWluU3RlcDpudW1iZXIsXHJcbiAgICAgICAgICAgIGVyclRvbDpudW1iZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgaW1wbGljaXRTdGVwU29sdmVyOntcclxuICAgICAgICAgICAgaXRlcnM6bnVtYmVyLFxyXG4gICAgICAgICAgICBtaW5JdGVyczpudW1iZXIsXHJcbiAgICAgICAgICAgIGFic1RvbDpudW1iZXIsXHJcbiAgICAgICAgICAgIHJlbFRvbDpudW1iZXIsXHJcbiAgICAgICAgICAgIGFscGhhOm51bWJlclxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW1wbGljaXRTeXN0ZW1Tb2x2ZXI6e1xyXG4gICAgICAgICAgICBpdGVyczpudW1iZXIsXHJcbiAgICAgICAgICAgIG1pbkl0ZXJzOm51bWJlcixcclxuICAgICAgICAgICAgYWJzVG9sOm51bWJlcixcclxuICAgICAgICAgICAgcmVsVG9sOm51bWJlcixcclxuICAgICAgICAgICAgYWxwaGE6bnVtYmVyXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGV2ZW50RGV0ZWN0aW9uOntcclxuICAgICAgICBib3JkZXJUb2w6bnVtYmVyLFxyXG4gICAgICAgIGFkYXB0aXZlU3RlcDp7XHJcbiAgICAgICAgICAgIGVuYWJsZWQ6Ym9vbGVhbixcclxuICAgICAgICAgICAgZ2FtbWE6bnVtYmVyLFxyXG4gICAgICAgICAgICBtaW5TdGVwOm51bWJlclxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgemVyb0Nyb3NzaW5nOntcclxuICAgICAgICAgICAgZW5hYmxlZDpib29sZWFuLFxyXG4gICAgICAgICAgICBuZXd0b25JdGVyczpudW1iZXIsXHJcbiAgICAgICAgICAgIG5ld3RvbkFscGhhOm51bWJlcixcclxuICAgICAgICAgICAgYWJzVG9sOm51bWJlcixcclxuICAgICAgICAgICAgcmVsVG9sOm51bWJlcixcclxuICAgICAgICAgICAgYmlzZWN0SXRlcnM6bnVtYmVyLFxyXG4gICAgICAgICAgICB0aW1lQWJzVG9sOm51bWJlcixcclxuICAgICAgICAgICAgdGltZVJlbFRvbDpudW1iZXJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgc2ltcGxpZmljYXRpb246e1xyXG4gICAgICAgIGVuYWJsZWQ6Ym9vbGVhbixcclxuICAgICAgICBtZXRob2Q6c3RyaW5nLFxyXG4gICAgICAgIG1heFBvaW50czpudW1iZXIsXHJcbiAgICAgICAgdG9sZXJhbmNlOm51bWJlclxyXG4gICAgfTtcclxufVxyXG5cclxuY2xhc3MgTWV0aG9ke1xyXG4gICAgbmFtZTpzdHJpbmc7XHJcbiAgICBhdXRvc3RlcDpib29sZWFuO1xyXG4gICAgaW1wbGljaXQ6Ym9vbGVhbjtcclxuICAgIGVkYWVJbml0OihwYXJhbXM6VUlQYXJhbWV0ZXJzKT0+RURBRVNvbHZlcjtcclxuICAgIGlkYWVJbml0OihwYXJhbXM6VUlQYXJhbWV0ZXJzKT0+SURBRVNvbHZlcjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG1ldGhvZHM6UmVjb3JkPHN0cmluZyxNZXRob2Q+ID0ge1xyXG4gICAgZWRvcHJpNTp7XHJcbiAgICAgICAgbmFtZTpcIkRPUFJJNVwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6ZmFsc2UsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfRE9QUkk1KHMubWluU3RlcCxwLnNvbHZlci5zdGVwLHMuZXJyVG9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0RPUFJJNShcclxuICAgICAgICAgICAgICAgIHAuc29sdmVyLnN0ZXBDb250cm9sLm1pblN0ZXAsXHJcbiAgICAgICAgICAgICAgICBwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycyksXHJcbiAgICAgICAgICAgICAgICBwLnNvbHZlci5zdGVwQ29udHJvbC5lcnJUb2xcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVldWxlcjp7XHJcbiAgICAgICAgbmFtZTpcIkV1bGVyXCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6ZmFsc2UsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfRUV1bGVyKHAuc29sdmVyLnN0ZXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfRUV1bGVyKHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGVtaWRwb2ludDp7XHJcbiAgICAgICAgbmFtZTpcIk1pZHBvaW50XCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6ZmFsc2UsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfRU1pZHBvaW50KHAuc29sdmVyLnN0ZXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfRU1pZHBvaW50KHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGV0cmFwZXpvaWRhbDp7XHJcbiAgICAgICAgbmFtZTpcIlRyYXBlem9pZGFsXCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6ZmFsc2UsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfRVRyYXBlem9pZGFsKHAuc29sdmVyLnN0ZXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfRVRyYXBlem9pZGFsKHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZXJrNDp7XHJcbiAgICAgICAgbmFtZTpcIlN0YW5kYXJ0IFJLNFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OmZhbHNlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JLNChwLnNvbHZlci5zdGVwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX1JLNChwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycylcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwiZXJrNC0yXCI6e1xyXG4gICAgICAgIG5hbWU6XCJBbHQuIFJLNFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OmZhbHNlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JLNF8yKHAuc29sdmVyLnN0ZXApO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfUks0XzIocC5zb2x2ZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcImVyazQtcmFsc3RvblwiOntcclxuICAgICAgICBuYW1lOlwiUks0IGJ5IFJhbHN0b25cIixcclxuICAgICAgICBhdXRvc3RlcDpmYWxzZSxcclxuICAgICAgICBpbXBsaWNpdDpmYWxzZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9SSzRfUkFMU1RPTihwLnNvbHZlci5zdGVwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX1JLNF9SQUxTVE9OKHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKSlcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCJlYnMyM1wiOntcclxuICAgICAgICBuYW1lOlwiQm9nYWNraSBTaGFtcGluZSAyMyBlbWIuXCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6dHJ1ZSxcclxuICAgICAgICBpbXBsaWNpdDpmYWxzZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9CUzIzKHAuc29sdmVyLnN0ZXBDb250cm9sLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxwLnNvbHZlci5zdGVwQ29udHJvbC5lcnJUb2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfQlMyMyhjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZXJrNjp7XHJcbiAgICAgICAgbmFtZTpcIlJLNlwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OmZhbHNlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JLNihwLnNvbHZlci5zdGVwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX1JLNihwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgXCJlcms2LTJcIjp7XHJcbiAgICAgICAgbmFtZTpcIkFsdC4gUks2XCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6ZmFsc2UsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfUks2XzIocC5zb2x2ZXIuc3RlcCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBzID0gcC5zb2x2ZXIuaW1wbGljaXRTeXN0ZW1Tb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSURBRV9SSzZfMihwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgZXJrODp7XHJcbiAgICAgICAgbmFtZTpcIlJLOFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OmZhbHNlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JLOChwLnNvbHZlci5zdGVwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX1JLOChwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgZWFsZ2VicmFpYzp7XHJcbiAgICAgICAgbmFtZTpcIkFsZ2VicmFpYyBzb2x2ZXJcIixcclxuICAgICAgICBhdXRvc3RlcDpmYWxzZSxcclxuICAgICAgICBpbXBsaWNpdDpmYWxzZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9BbGdlYnJhaWNTb2x2ZXIocC5zb2x2ZXIuc3RlcCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBzID0gcC5zb2x2ZXIuaW1wbGljaXRTeXN0ZW1Tb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSURBRV9BbGdlYnJhaWNTb2x2ZXIocC5zb2x2ZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIGlldWxlcjp7XHJcbiAgICAgICAgbmFtZTpcIkV1bGVyXCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfSUV1bGVyKHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKGkuaXRlcnMsaS5hYnNUb2wsaS5yZWxUb2wsaS5hbHBoYSxpLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBzID0gcC5zb2x2ZXIuaW1wbGljaXRTeXN0ZW1Tb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSURBRV9JRXVsZXIocC5zb2x2ZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaW1pZHBvaW50OntcclxuICAgICAgICBuYW1lOlwiTWlkcG9pbnRcIixcclxuICAgICAgICBhdXRvc3RlcDpmYWxzZSxcclxuICAgICAgICBpbXBsaWNpdDp0cnVlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGkgPSBwLnNvbHZlci5pbXBsaWNpdFN0ZXBTb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9JTWlkcG9pbnQocC5zb2x2ZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIoaS5pdGVycyxpLmFic1RvbCxpLnJlbFRvbCxpLmFscGhhLGkubWluSXRlcnMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0lNaWRwb2ludChwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpdHJhcGV6b2lkYWw6e1xyXG4gICAgICAgIG5hbWU6XCJUcmFwZXpvaWRhbFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OnRydWUsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX0lUcmFwZXpvaWRhbChwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0lUcmFwZXpvaWRhbChwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycyksXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKGkuaXRlcnMsaS5hYnNUb2wsaS5yZWxUb2wsaS5hbHBoYSxpLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlyYWRhdWlhNTp7XHJcbiAgICAgICAgbmFtZTpcIlJBREFVIElBNVwiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OnRydWUsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JBREFVSUE1KHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKGkuaXRlcnMsaS5hYnNUb2wsaS5yZWxUb2wsaS5hbHBoYSxpLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBzID0gcC5zb2x2ZXIuaW1wbGljaXRTeXN0ZW1Tb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSURBRV9SQURBVUlBNShwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpcmFkYXVpaWEzOntcclxuICAgICAgICBuYW1lOlwiUkFEQVUgSUlBM1wiLFxyXG4gICAgICAgIGF1dG9zdGVwOmZhbHNlLFxyXG4gICAgICAgIGltcGxpY2l0OnRydWUsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX1JBREFVSUlBMyhwLnNvbHZlci5zdGVwLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfUkFEQVVJSUEzKHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGlyYWRhdWlpYTU6e1xyXG4gICAgICAgIG5hbWU6XCJSQURBVSBJSUE1XCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6ZmFsc2UsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfUkFEQVVJSUE1KHAuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKGkuaXRlcnMsaS5hYnNUb2wsaS5yZWxUb2wsaS5hbHBoYSxpLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBzID0gcC5zb2x2ZXIuaW1wbGljaXRTeXN0ZW1Tb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSURBRV9SQURBVUlJQTUocC5zb2x2ZXIuc3RlcCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIGxvYmF0dG9paWlhMjp7XHJcbiAgICAgICAgbmFtZTpcIkxPQkFUVE8gSUlJQTJcIixcclxuICAgICAgICBhdXRvc3RlcDp0cnVlLFxyXG4gICAgICAgIGltcGxpY2l0OnRydWUsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX0xPQkFUVE9JSUlBMihjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIoaS5pdGVycyxpLmFic1RvbCxpLnJlbFRvbCxpLmFscGhhLGkubWluSXRlcnMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0xPQkFUVE9JSUlBMihjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIGxvYmF0dG9paWlhNDp7XHJcbiAgICAgICAgbmFtZTpcIkxPQkFUVE8gSUlJQTRcIixcclxuICAgICAgICBhdXRvc3RlcDp0cnVlLFxyXG4gICAgICAgIGltcGxpY2l0OnRydWUsXHJcbiAgICAgICAgZWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgaSA9IHAuc29sdmVyLmltcGxpY2l0U3RlcFNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX0xPQkFUVE9JSUlBNChjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIoaS5pdGVycyxpLmFic1RvbCxpLnJlbFRvbCxpLmFscGhhLGkubWluSXRlcnMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0xPQkFUVE9JSUlBNChjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSxcclxuICAgIGxvYmF0b2lpaWIyOntcclxuICAgICAgICBuYW1lOlwiTE9CQVRUTyBJSUlCMlwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBjID0gcC5zb2x2ZXIuc3RlcENvbnRyb2w7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfTE9CQVRUT0lJSUIyKGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfTE9CQVRUT0lJSUIyKGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgbG9iYXR0b2lpaWI0OntcclxuICAgICAgICBuYW1lOlwiTE9CQVRUTyBJSUlCNFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBjID0gcC5zb2x2ZXIuc3RlcENvbnRyb2w7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfTE9CQVRUT0lJSUI0KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfTE9CQVRUT0lJSUI0KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgbG9iYXR0b2lpaWMyOntcclxuICAgICAgICBuYW1lOlwiTE9CQVRUTyBJSUlDMlwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBjID0gcC5zb2x2ZXIuc3RlcENvbnRyb2w7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfTE9CQVRUT0lJSUMyKGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfTE9CQVRUT0lJSUMyKGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgbG9iYXR0b2lpaWM0OntcclxuICAgICAgICBuYW1lOlwiTE9CQVRUTyBJSUlDNFwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBjID0gcC5zb2x2ZXIuc3RlcENvbnRyb2w7XHJcbiAgICAgICAgICAgIGxldCBpID0gcC5zb2x2ZXIuaW1wbGljaXRTdGVwU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVEQUVfTE9CQVRUT0lJSUM0KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihpLml0ZXJzLGkuYWJzVG9sLGkucmVsVG9sLGkuYWxwaGEsaS5taW5JdGVycykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfTE9CQVRUT0lJSUM0KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgZ2F1c3NsZWdlbmRyZTQ6e1xyXG4gICAgICAgIG5hbWU6XCJHQVVTUyBMRUdFTkRSRSA0XCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6dHJ1ZSxcclxuICAgICAgICBpbXBsaWNpdDp0cnVlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IGkgPSBwLnNvbHZlci5pbXBsaWNpdFN0ZXBTb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9HQVVTU0xFR0VORFJFNChjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIoaS5pdGVycyxpLmFic1RvbCxpLnJlbFRvbCxpLmFscGhhLGkubWluSXRlcnMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0dBVVNTTEVHRU5EUkU0KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgZ2F1c3NsZWdlbmRyZTY6e1xyXG4gICAgICAgIG5hbWU6XCJHQVVTUyBMRUdFTkRSRSA2XCIsXHJcbiAgICAgICAgYXV0b3N0ZXA6dHJ1ZSxcclxuICAgICAgICBpbXBsaWNpdDp0cnVlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IGkgPSBwLnNvbHZlci5pbXBsaWNpdFN0ZXBTb2x2ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9HQVVTU0xFR0VORFJFNihjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIoaS5pdGVycyxpLmFic1RvbCxpLnJlbFRvbCxpLmFscGhhLGkubWluSXRlcnMpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgbGV0IHMgPSBwLnNvbHZlci5pbXBsaWNpdFN5c3RlbVNvbHZlcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJREFFX0dBVVNTTEVHRU5EUkU2KGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgaWhldW5FdWxlcjp7XHJcbiAgICAgICAgbmFtZTpcIkhldW4gRXVsZXIgZW1iLlwiLFxyXG4gICAgICAgIGF1dG9zdGVwOnRydWUsXHJcbiAgICAgICAgaW1wbGljaXQ6dHJ1ZSxcclxuICAgICAgICBlZGFlSW5pdDpmdW5jdGlvbihwOlVJUGFyYW1ldGVycyl7XHJcbiAgICAgICAgICAgIGxldCBjID0gcC5zb2x2ZXIuc3RlcENvbnRyb2w7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRURBRV9IZXVuRXVsZXIoYy5taW5TdGVwLHAuc29sdmVyLnN0ZXAsYy5lcnJUb2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfSGV1bkV1bGVyKGMubWluU3RlcCxwLnNvbHZlci5zdGVwLGMuZXJyVG9sLFxyXG4gICAgICAgICAgICAgICAgbmV3IE5ld3RvblNvbHZlcihzLml0ZXJzLHMuYWJzVG9sLHMucmVsVG9sLHMuYWxwaGEscy5taW5JdGVycykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBpbWlkcG9pbnRFdWxlcjp7XHJcbiAgICAgICAgbmFtZTpcIk1pZHBvaW50IEV1bGVyIGVtYi5cIixcclxuICAgICAgICBhdXRvc3RlcDp0cnVlLFxyXG4gICAgICAgIGltcGxpY2l0OmZhbHNlLFxyXG4gICAgICAgIGVkYWVJbml0OmZ1bmN0aW9uKHA6VUlQYXJhbWV0ZXJzKXtcclxuICAgICAgICAgICAgbGV0IGMgPSBwLnNvbHZlci5zdGVwQ29udHJvbDtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFREFFX01pZHBvaW50RXVsZXIoYy5taW5TdGVwLHAuc29sdmVyLnN0ZXAsYy5lcnJUb2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWRhZUluaXQ6ZnVuY3Rpb24ocDpVSVBhcmFtZXRlcnMpe1xyXG4gICAgICAgICAgICBsZXQgYyA9IHAuc29sdmVyLnN0ZXBDb250cm9sO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHAuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IElEQUVfTWlkcG9pbnRFdWxlcihjLm1pblN0ZXAscC5zb2x2ZXIuc3RlcCxjLmVyclRvbCxcclxuICAgICAgICAgICAgICAgIG5ldyBOZXd0b25Tb2x2ZXIocy5pdGVycyxzLmFic1RvbCxzLnJlbFRvbCxzLmFscGhhLHMubWluSXRlcnMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgSHlicmlkU3RhdGVMaW5rIH0gZnJvbSBcIi4uL2RhZS9oeWJyaWRTdGF0ZUxpbmtcIjtcclxuaW1wb3J0IHtBZGFwdGl2ZVN0ZXBOZXd0b24sIEFkYXB0aXZlU3RlcFN0cmF0ZWd5fSBmcm9tIFwiLi4vZGFlL2FkYXB0aXZlU3RlcFwiO1xyXG5pbXBvcnQge0V2ZW50RGV0ZWN0aW9uQ29tcGxleCwgRXZlbnREZXRlY3Rpb25TaW1wbGUsIEV2ZW50RGV0ZWN0aW9ufSBmcm9tIFwiLi4vZGFlL2V2ZW50RGV0ZWN0aW9uXCI7XHJcbmltcG9ydCB7REFFVmVjdG9yfSBmcm9tIFwiLi4vZGFlL2RhZVZlY3RvclwiO1xyXG5pbXBvcnQge0lEQUVIeWJyaWRTeXN0ZW0sIElEQUVIeWJyaWRTdGF0ZX0gZnJvbSBcIi4uL2RhZS9pZGFlSHlicmlkU3lzdGVtXCI7XHJcbmltcG9ydCB7RURBRUh5YnJpZFN5c3RlbSwgRURBRUh5YnJpZFN0YXRlfSBmcm9tIFwiLi4vZGFlL2VkYWVIeWJyaWRTeXN0ZW1cIjtcclxuaW1wb3J0IHsgRURBRUh5YnJpZFNvbHZlciB9IGZyb20gXCIuLi9kYWUvZWRhZUh5YnJpZFNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFSHlicmlkU29sdmVyIH0gZnJvbSBcIi4uL2RhZS9pZGFlSHlicmlkU29sdmVyXCI7XHJcbmltcG9ydCB7IEVEQUVTb2x2ZXIgfSBmcm9tIFwiLi4vZGFlL2VkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgSURBRVNvbHZlciB9IGZyb20gXCIuLi9kYWUvaWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBFREFFU3lzdGVtIH0gZnJvbSBcIi4uL2RhZS9lZGFlU3lzdGVtXCI7XHJcbmltcG9ydCB7IElEQUVTeXN0ZW0gfSBmcm9tIFwiLi4vZGFlL2lkYWVTeXN0ZW1cIjtcclxuaW1wb3J0IHsgdmVjdG9yIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IG1hdHJpeCB9IGZyb20gXCIuLi9tYXRoL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBcclxuICAgIEVEQUVfRUV1bGVyLCBcclxuICAgIEVEQUVfSUV1bGVyXHJcbn0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvZXVsZXJcIjtcclxuaW1wb3J0IHsgXHJcbiAgICBJREFFX0VFdWxlcixcclxuICAgIElEQUVfSUV1bGVyIFxyXG59IGZyb20gXCIuLi9kYWUvc29sdmVycy9pZGFlL2V1bGVyXCI7XHJcbmltcG9ydCAkIGZyb20gXCJqcXVlcnlcIjtcclxuaW1wb3J0IHsgRURBRV9JTWlkcG9pbnQsIEVEQUVfRU1pZHBvaW50IH0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvbWlkcG9pbnRcIjtcclxuaW1wb3J0IHsgRURBRV9FVHJhcGV6b2lkYWwsIEVEQUVfSVRyYXBlem9pZGFsIH0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvdHJhcGV6b2lkYWxcIjtcclxuaW1wb3J0IHsgXHJcbiAgICBFREFFX1JLNCwgXHJcbiAgICBFREFFX1JLNF8yLFxyXG4gICAgRURBRV9SSzRfUkFMU1RPTixcclxuICAgIEVEQUVfRE9QUkk1LCBcclxuICAgIEVEQUVfUkFEQVVJQTUsIFxyXG4gICAgRURBRV9CUzIzLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUEyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUE0LCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUIyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUI0LCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUMyLCBcclxuICAgIEVEQUVfTE9CQVRUT0lJSUM0LCBcclxuICAgIEVEQUVfUkFEQVVJSUEzLCBcclxuICAgIEVEQUVfUkFEQVVJSUE1LCBcclxuICAgIEVEQUVfR0FVU1NMRUdFTkRSRTQsIFxyXG4gICAgRURBRV9HQVVTU0xFR0VORFJFNixcclxuICAgIEVEQUVfSGV1bkV1bGVyLCBcclxuICAgIEVEQUVfTWlkcG9pbnRFdWxlciwgXHJcbiAgICBFREFFX1JLNiwgXHJcbiAgICBFREFFX1JLNl8yLCBcclxuICAgIEVEQUVfUks4IH0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvcmtcIjtcclxuaW1wb3J0e1xyXG4gICAgSURBRV9SSzQsXHJcbiAgICBJREFFX1JLNF8yLFxyXG4gICAgSURBRV9SSzRfUkFMU1RPTixcclxuICAgIElEQUVfRE9QUkk1LCBcclxuICAgIElEQUVfUkFEQVVJQTUsIFxyXG4gICAgSURBRV9CUzIzLCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUEyLCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUE0LCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUIyLCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUI0LCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUMyLCBcclxuICAgIElEQUVfTE9CQVRUT0lJSUM0LCBcclxuICAgIElEQUVfUkFEQVVJSUEzLCBcclxuICAgIElEQUVfUkFEQVVJSUE1LCBcclxuICAgIElEQUVfR0FVU1NMRUdFTkRSRTQsIFxyXG4gICAgSURBRV9HQVVTU0xFR0VORFJFNixcclxuICAgIElEQUVfSGV1bkV1bGVyLCBcclxuICAgIElEQUVfTWlkcG9pbnRFdWxlciwgXHJcbiAgICBJREFFX1JLNiwgXHJcbiAgICBJREFFX1JLNl8yLCBcclxuICAgIElEQUVfUks4XHJcbiAgICB9IGZyb20gXCIuLi9kYWUvc29sdmVycy9pZGFlL3JrXCI7XHJcbmltcG9ydCB7IElEQUVfRU1pZHBvaW50LCBJREFFX0lNaWRwb2ludCB9IGZyb20gXCIuLi9kYWUvc29sdmVycy9pZGFlL21pZHBvaW50XCI7XHJcbmltcG9ydCB7IElEQUVfRVRyYXBlem9pZGFsLCBJREFFX0lUcmFwZXpvaWRhbCB9IGZyb20gXCIuLi9kYWUvc29sdmVycy9pZGFlL3RyYXBlem9pZGFsXCI7XHJcbmltcG9ydCB7IFxyXG4gICAgRURBRV9CREYyLFxyXG4gICAgRURBRV9CREYzLFxyXG4gICAgRURBRV9CREY0LFxyXG4gICAgRURBRV9CREY1LFxyXG4gICAgRURBRV9CREY2IH0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvYmRmXCI7XHJcbmltcG9ydCB7IFxyXG4gICAgSURBRV9CREYyLFxyXG4gICAgSURBRV9CREYzLFxyXG4gICAgSURBRV9CREY0LFxyXG4gICAgSURBRV9CREY1LFxyXG4gICAgSURBRV9CREY2IH0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2lkYWUvYmRmXCI7XHJcbmltcG9ydCB7XHJcbiAgICBFREFFX0FNMixcclxuICAgIEVEQUVfQU0zLFxyXG4gICAgRURBRV9BTTQsXHJcbiAgICBFREFFX0FNNSxcclxuICAgIEVEQUVfQU02XHJcbn0gZnJvbSBcIi4uL2RhZS9zb2x2ZXJzL2VkYWUvYWRhbXMtbW91bHRvblwiO1xyXG5pbXBvcnQge1xyXG4gICAgSURBRV9BTTIsXHJcbiAgICBJREFFX0FNMyxcclxuICAgIElEQUVfQU00LFxyXG4gICAgSURBRV9BTTUsXHJcbiAgICBJREFFX0FNNlxyXG59IGZyb20gXCIuLi9kYWUvc29sdmVycy9pZGFlL2FkYW1zLW1vdWx0b25cIjtcclxuaW1wb3J0IHtcclxuICAgIEVEQUVfQUIyLFxyXG4gICAgRURBRV9BQjMsXHJcbiAgICBFREFFX0FCNCxcclxuICAgIEVEQUVfQUI1LFxyXG4gICAgRURBRV9BQjZcclxufSBmcm9tIFwiLi4vZGFlL3NvbHZlcnMvZWRhZS9hZGFtcy1iYXNoZm9ydGhcIjtcclxuaW1wb3J0IHtcclxuICAgIElEQUVfQUIyLFxyXG4gICAgSURBRV9BQjMsXHJcbiAgICBJREFFX0FCNCxcclxuICAgIElEQUVfQUI1LFxyXG4gICAgSURBRV9BQjZcclxufSBmcm9tIFwiLi4vZGFlL3NvbHZlcnMvaWRhZS9hZGFtcy1iYXNoZm9ydGhcIjtcclxuaW1wb3J0IHsgTmV3dG9uU29sdmVyIH0gZnJvbSBcIi4uL21hdGgvbmV3dG9uXCI7XHJcbmltcG9ydCAge3VpfSBmcm9tIFwiLi4vdWlcIjtcclxuaW1wb3J0IHsgREFFQ29tcGlsZXIgfSBmcm9tIFwiLi4vY29tcGlsZXIvY29tcGlsZXJcIjtcclxuaW1wb3J0IHsgQ29tcGlsZXJFcnJvciB9IGZyb20gXCIuLi9jb21waWxlci9jb21waWxlckVycm9yXCI7XHJcbmltcG9ydCB7IEh5YnJpZFN5c3RlbUNvbXBpbGVyIH0gZnJvbSBcIi4uL2NvbXBpbGVyL2h5YnJpZENvbXBpbGVyXCI7XHJcbmltcG9ydCB7IFRleHRQb3NpdGlvbiB9IGZyb20gXCIuLi9jb21waWxlci9hc3ROb2RlXCI7XHJcbmltcG9ydCB7IElTaW1wbGlmaWNhdGlvbkFsZ29yaXRobSB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL0lTaW1wbGlmaWNhdGlvbkFsZ29yaXRobVwiO1xyXG5pbXBvcnQgeyBEb3VnbGFzUGV1Y2tlclNpbXBsaWZpY2F0aW9uIH0gZnJvbSBcIi4uL2N1cnZlU2ltcGxpZmljYXRpb24vZG91Z2xhc1BldWNrZXJTaW1wbGlmaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBQZXJwZW5kaWN1bGFyRGlzdGFuY2VTaW1wbGlmaWNhdGlvbiB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL3BlcnBlbmRpY3VsYXJEaXN0YW5jZVNpbXBsaWZpY2F0aW9uXCI7XHJcbmltcG9ydCB7IE1heFBvaW50c1NpbXBsaWZpY2F0aW9uIH0gZnJvbSBcIi4uL2N1cnZlU2ltcGxpZmljYXRpb24vbWF4UG9pbnRzU2ltcGxpZmljYXRpb25cIjtcclxuaW1wb3J0IHsgUmFkaWFsRGlzdGFuY2VTaW1wbGlmaWNhdGlvbiB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL3JhZGlhbERpc3RhbmNlU2ltcGxpZmljYXRpb25cIjtcclxuaW1wb3J0IHsgTGFuZ1NpbXBsaWZpY2F0aW9uIH0gZnJvbSBcIi4uL2N1cnZlU2ltcGxpZmljYXRpb24vbGFuZ1NpbXBsaWZpY2F0aW9uXCI7XHJcbmltcG9ydCB7IFJldW1hbm5XaXRrYW1TaW1wbGlmaWNhdGlvbiB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL3JldW1hbm5XaXRrYW1TaW1wbGlmaWNhdGlvblwiO1xyXG5pbXBvcnQgeyBPcGhlaW1TaW1wbGlmaWNhdGlvbiB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL29waGVpbVNpbXBsaWZpY2F0aW9uXCI7XHJcbmltcG9ydCB7IEV4cHJlc3Npb24gfSBmcm9tIFwiLi4vY29tcGlsZXIvZXhwcmVzc2lvblwiO1xyXG5pbXBvcnQgeyBEb3VnbGFzUGV1Y2tlck5TaW1wbGlmaWNhdGlvbiB9IGZyb20gXCIuLi9jdXJ2ZVNpbXBsaWZpY2F0aW9uL2RvdWdsYXNQZXVja2VyTlNpbXBsaWZpY2F0aW9uXCI7XHJcbmltcG9ydCB7IE50aFBvaW50U2ltcGxpZmljYXRpb24gfSBmcm9tIFwiLi4vY3VydmVTaW1wbGlmaWNhdGlvbi9udGhQb2ludFNpbXBsaWZpY2F0aW9uXCI7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHNvbHZlRXhwbGljaXQoeDA6dmVjdG9yLHQwOm51bWJlcix0MTpudW1iZXIsc29sdmVyOkVEQUVTb2x2ZXIsc3lzdGVtOkVEQUVTeXN0ZW0pOkRBRVZlY3Rvcltde1xyXG4gICAgbGV0IHNvbHV0aW9uOkRBRVZlY3RvcltdID0gW107XHJcbiAgICBsZXQgejAgPSBzeXN0ZW0uZyh4MCx0MCk7XHJcbiAgICBsZXQgcG9pbnQ6REFFVmVjdG9yID0gbmV3IERBRVZlY3Rvcih4MCx6MCx0MCk7XHJcbiAgICBzb2x1dGlvbi5wdXNoKHBvaW50KTtcclxuICAgIGZvcihsZXQgdCA9IHQwO3Q8PXQxO3Q9cG9pbnQudCl7XHJcbiAgICAgICAgcG9pbnQgPSBzb2x2ZXIubWFrZVN0ZXAocG9pbnQueCxwb2ludC56LHBvaW50LnQsc3lzdGVtKTtcclxuICAgICAgICBzb2x1dGlvbi5wdXNoKHBvaW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzb2x1dGlvbjtcclxufVxyXG5mdW5jdGlvbiBzb2x2ZUltcGxpY2l0KHgwOnZlY3Rvcix6MDp2ZWN0b3IsdDA6bnVtYmVyLHQxOm51bWJlcixzb2x2ZXI6SURBRVNvbHZlcixzeXN0ZW06SURBRVN5c3RlbSk6REFFVmVjdG9yW117XHJcbiAgICBsZXQgc29sdXRpb246REFFVmVjdG9yW10gPSBbXTtcclxuICAgIHowID0gc29sdmVyLnNvbHZlX3ooeDAsejAsdDAsc3lzdGVtKTtcclxuICAgIGxldCBwb2ludDpEQUVWZWN0b3IgPSBuZXcgREFFVmVjdG9yKHgwLHowLHQwKTtcclxuICAgIHNvbHV0aW9uLnB1c2gocG9pbnQpO1xyXG4gICAgZm9yKGxldCB0ID0gdDA7dDw9dDE7dD1wb2ludC50KXtcclxuICAgICAgICBwb2ludCA9IHNvbHZlci5tYWtlU3RlcChwb2ludC54LHBvaW50LnoscG9pbnQudCxzeXN0ZW0pO1xyXG4gICAgICAgIHNvbHV0aW9uLnB1c2gocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNvbHV0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGxvdEV4cHJlc3Npb24odDA6bnVtYmVyLHQxOm51bWJlcixkdDpudW1iZXIsZXhwcmVzc2lvbjpFeHByZXNzaW9uLGxhYmVsOnN0cmluZyl7XHJcbiAgICBsZXQgdHJhY2U6YW55ID0ge1xyXG4gICAgICAgIHg6IFtdLFxyXG4gICAgICAgIHk6IFtdLFxyXG4gICAgICAgIHR5cGU6XCJzY2F0dGVyZ2xcIixcclxuICAgICAgICBtb2RlOiAnbWFya2VycytsaW5lcycsXHJcbiAgICAgICAgbmFtZTogbGFiZWxcclxuICAgIH07XHJcbiAgICBmb3IobGV0IHQgPSB0MDsgdCA8PXQxO3QrPWR0KXtcclxuICAgICAgICB0cmFjZS54LnB1c2godCk7XHJcbiAgICAgICAgdHJhY2UueS5wdXNoKGV4cHJlc3Npb24uZXhlY3V0ZShbdF0pKTtcclxuICAgIH1cclxuICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgUGxvdGx5LmFkZFRyYWNlcygncGxvdC1hcmVhJywgW3RyYWNlXSk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXJyb3JzKGU6YW55KXtcclxuICAgIGlmKGUgaW5zdGFuY2VvZiBDb21waWxlckVycm9yKXtcclxuICAgICAgICBlLm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoaXRlbS5wcmludCgpKTtcclxuICAgICAgICAgICAgdWkuYWRkRXJyb3JNZXNzYWdlKGl0ZW0ubWVzc2FnZSxpdGVtLnRleHRQb3MpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLnByaW50KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfWVsc2UgaWYoZSBpbnN0YW5jZW9mIEVycm9yKXtcclxuICAgICAgICB1aS5hZGRMb2dNZXNzYWdlKGUubWVzc2FnZSk7XHJcbiAgICAgICAgdWkuYWRkRXJyb3JNZXNzYWdlKGUubWVzc2FnZSxUZXh0UG9zaXRpb24uaW52YWxpZCgpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhlLm1lc3NhZ2UpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdWkuYWRkTG9nTWVzc2FnZShcIkV4Y2VwdGlvbjogXCIrZSk7XHJcbiAgICAgICAgdWkuYWRkRXJyb3JNZXNzYWdlKFwiRXhjZXB0aW9uOiBcIitlLFRleHRQb3NpdGlvbi5pbnZhbGlkKCkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVGVzdHtcclxuICAgIHN0YXRpYyB0ZXN0RURBRVNvbHZlcnModDA6bnVtYmVyLHQxOm51bWJlcix4MDp2ZWN0b3Isc29sdmVyczp7bWV0aG9kOkVEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdLHN5c3RlbTpFREFFU3lzdGVtLHhOYW1lczpzdHJpbmdbXSx6TmFtZXM6c3RyaW5nW10sbGFiZWw6c3RyaW5nKTp2b2lke1xyXG4gICAgICAgIHNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgdWkuYWRkTG9nTWVzc2FnZShsYWJlbCtcIjogXCIraXRlbS5sYWJlbCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxhYmVsK1wiOiBcIitpdGVtLmxhYmVsKTtcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlczpEQUVWZWN0b3JbXSA9IHNvbHZlRXhwbGljaXQoeDAsdDAsdDEsaXRlbS5tZXRob2Qsc3lzdGVtKTtcclxuICAgICAgICAgICAgICAgIFRlc3Quc2hvd091dHB1dCh2YWx1ZXMseE5hbWVzLHpOYW1lcyxsYWJlbCtcIiBcIitpdGVtLmxhYmVsKTtcclxuICAgICAgICAgICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZHVyaW5nIFwiK2xhYmVsK1wiOiBcIitlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB1aS5hZGRMb2dNZXNzYWdlKFwiRXJyb3IgZHVyaW5nIFwiK2xhYmVsK1wiOiBcIitlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0ZXN0SURBRVNvbHZlcnModDA6bnVtYmVyLHQxOm51bWJlcix4MDp2ZWN0b3Isc29sdmVyczp7bWV0aG9kOklEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdLHN5c3RlbTpJREFFU3lzdGVtLHhOYW1lczpzdHJpbmdbXSx6TmFtZXM6c3RyaW5nW10sbGFiZWw6c3RyaW5nKTp2b2lke1xyXG4gICAgICAgIHNvbHZlcnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgdWkuYWRkTG9nTWVzc2FnZShsYWJlbCtcIjogXCIraXRlbS5sYWJlbCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGxhYmVsK1wiOiBcIitpdGVtLmxhYmVsKTtcclxuICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlczpEQUVWZWN0b3JbXSA9IHNvbHZlSW1wbGljaXQoeDAsdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeigpKSx0MCx0MSxpdGVtLm1ldGhvZCxzeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgVGVzdC5zaG93T3V0cHV0KHZhbHVlcyx4TmFtZXMsek5hbWVzLGxhYmVsK1wiIFwiK2l0ZW0ubGFiZWwpO1xyXG4gICAgICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkdXJpbmcgXCIrbGFiZWwrXCI6IFwiK2Vycm9yKTtcclxuICAgICAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoXCJFcnJvciBkdXJpbmcgXCIrbGFiZWwrXCI6IFwiK2Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNob3dPdXRwdXQodmFsdWVzOkRBRVZlY3RvcltdLGRpZlZhcmlhYmxlczpzdHJpbmdbXSxhbGdWYXJpYWJsZXM6c3RyaW5nW10sbGFiZWw6c3RyaW5nKTp2b2lke1xyXG4gICAgICAgIGxldCBkYXRhOmFueSA9IFtdO1xyXG4gICAgICAgIGRpZlZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06c3RyaW5nfG51bGwsaW5kZXg6bnVtYmVyKXtcclxuICAgICAgICAgICAgaWYoaXRlbSA9PW51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47IFxyXG4gICAgICAgICAgICBsZXQgdHJhY2U6YW55ID0ge1xyXG4gICAgICAgICAgICAgICAgeDogW10sXHJcbiAgICAgICAgICAgICAgICB5OiBbXSxcclxuICAgICAgICAgICAgICAgIHR5cGU6XCJzY2F0dGVyZ2xcIixcclxuICAgICAgICAgICAgICAgIG1vZGU6ICdtYXJrZXJzK2xpbmVzJyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGxhYmVsK1wiOiBcIitpdGVtXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8dmFsdWVzLmxlbmd0aDtpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZVZlY3RvciA9IHZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgIHRyYWNlLnkucHVzaCh2YWx1ZVZlY3Rvci54LmdldChpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgdHJhY2UueC5wdXNoKHZhbHVlVmVjdG9yLnQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YS5wdXNoKHRyYWNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBhbGdWYXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtOnN0cmluZ3xudWxsLGluZGV4Om51bWJlcil7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjsgXHJcbiAgICAgICAgICAgIGxldCB0cmFjZTphbnkgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBbXSxcclxuICAgICAgICAgICAgICAgIHk6IFtdLFxyXG4gICAgICAgICAgICAgICAgdHlwZTpcInNjYXR0ZXJnbFwiLFxyXG4gICAgICAgICAgICAgICAgbW9kZTogJ21hcmtlcnMrbGluZXMnLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogbGFiZWwrXCI6IFwiK2l0ZW1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yKGxldCBpPTA7aTx2YWx1ZXMubGVuZ3RoO2krKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlVmVjdG9yID0gdmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdHJhY2UueS5wdXNoKHZhbHVlVmVjdG9yLnouZ2V0KGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICB0cmFjZS54LnB1c2godmFsdWVWZWN0b3IudClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhLnB1c2godHJhY2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vQHRzLWlnbm9yZVxyXG4gICAgICAgIFBsb3RseS5hZGRUcmFjZXMoJ3Bsb3QtYXJlYScsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLypzdGF0aWMgc2VyaWFsaXplT3V0cHV0KHZhbHVlczpEQUVWZWN0b3JbXSxzdGF0ZXM6bnVtYmVyW10sdmFyaWFibGVOYW1lc1g6c3RyaW5nW10sdmFyaWFibGVOYW1lc1o6c3RyaW5nW10pOnN0cmluZ3tcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICB2YXJpYWJsZU5hbWVzWC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUsIGluZGV4KXtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChuYW1lKTtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChcIixcIik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyaWFibGVOYW1lc1ouZm9yRWFjaChmdW5jdGlvbihuYW1lLCBpbmRleCl7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQobmFtZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIsXCIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc3VsdC5hcHBlbmQoXCJzdGF0ZVwiKTtcclxuICAgICAgICByZXN1bHQuYXBwZW5kKFwiLFwiKTtcclxuICAgICAgICByZXN1bHQuYXBwZW5kKFwidFwiKTtcclxuICAgICAgICB2YWx1ZXMudC5mb3JFYWNoKGZ1bmN0aW9uKGlkKXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHZhcmlhYmxlTmFtZXNYLmZvckVhY2goZnVuY3Rpb24obmFtZSxpbmRleCl7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHZhbHVlcy54W2lkXS5nZXQoaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIsXCIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyaWFibGVOYW1lc1ouZm9yRWFjaChmdW5jdGlvbihuYW1lLGluZGV4KXtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodmFsdWVzLnpbaWRdLmdldChpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChcIixcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHN0YXRlc1tpZF0pO1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKFwiLFwiKTtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh2YWx1ZXMudFtpZF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSovXHJcbiAgICBzdGF0aWMgaW5pdFBsb3QoKTp2b2lke1xyXG4gICAgICAgIHZhciBsYXlvdXQgPSB7XHJcbiAgICAgICAgICAgIHRpdGxlOidSZXN1bHQnLFxyXG4gICAgICAgICAgICB0eXBlOlwic2NhdHRlcmdsXCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiQoXCIjcGxvdC1hcmVhXCIpLndpZHRoKCksXHJcbiAgICAgICAgICAgIGhlaWdodDokKFwiI3Bsb3QtYXJlYVwiKS5oZWlnaHQoKSxcclxuICAgICAgICAgICAgcGFwZXJfYmdjb2xvcjogJ3JnYmEoMjQ1LDI0NSwyNDUsMSknLFxyXG4gICAgICAgICAgICBwbG90X2JnY29sb3I6ICdyZ2JhKDI0NSwyNDUsMjQ1LDEpJyxcclxuICAgICAgICAgICAgbnRpY2tzOjMwXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICBQbG90bHkubmV3UGxvdCgncGxvdC1hcmVhJyxbXSxsYXlvdXQse3Jlc3BvbnNpdmU6dHJ1ZX0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJ1blRlc3RzKCk6dm9pZHtcclxuICAgICAgICAkKFwibG9nXCIpLnZhbChcIlwiKTtcclxuICAgICAgICB1aS5hZGRMb2dNZXNzYWdlKFwiUnVuIHRlc3RzXCIpO1xyXG4gICAgICAgIC8vdWkuY2xlYXJMb2coKTtcclxuICAgICAgICBsZXQgRURBRVNvbHZlcnM6e21ldGhvZDpFREFFU29sdmVyLGxhYmVsOnN0cmluZ31bXSA9IFtcclxuICAgICAgICAgICAgLyp7bWV0aG9kOm5ldyBFREFFX0VFdWxlcigxZS0zKSxsYWJlbDpcIkVFdWxlclwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9JRXVsZXIoMWUtMyxuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTUsMWUtNSwwLjk1LDQpKSxsYWJlbDpcIklFdWxlclwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9FTWlkcG9pbnQoMWUtMiksbGFiZWw6XCJFTWlkcG9pbnRcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfSU1pZHBvaW50KDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSkpLGxhYmVsOlwiSU1pZHBvaW50XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0VUcmFwZXpvaWRhbCgxZS0yKSxsYWJlbDpcIkVUcmFwZXpvaWRhbFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9JVHJhcGV6b2lkYWwoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1KSksbGFiZWw6XCJJVHJhcGV6b2lkYWxcIn0sKi9cclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9SSzQoMWUtMiksbGFiZWw6XCJFUks0XCJ9LFxyXG4gICAgICAgICAgICAvKnttZXRob2Q6bmV3IEVEQUVfUks0XzIoMWUtMiksbGFiZWw6XCJFUks0XzJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfUks0X1JBTFNUT04oMWUtMiksbGFiZWw6XCJFUks0X1JhbHN0b25cIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfRE9QUkk1KDFlLTIsM2UtMiwxZS02KSxsYWJlbDpcIkVET1BSSTVcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfQlMyMygxZS0yLDNlLTIsMWUtNiksbGFiZWw6XCJFQlMyM1wifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9SSzYoMWUtMiksbGFiZWw6XCJFUks2XzFcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfUks2XzIoMWUtMiksbGFiZWw6XCJFUks2XzJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfUks4KDFlLTIpLGxhYmVsOlwiRVJLOFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9SQURBVUlBNSgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUpKSxsYWJlbDpcIklSYWRhdV9JQTVcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfUkFEQVVJSUEzKDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSkpLGxhYmVsOlwiSVJhZGF1X0lJQTNcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfUkFEQVVJSUE1KDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSkpLGxhYmVsOlwiSVJhZGF1X0lJQTVcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfTE9CQVRUT0lJSUEyKDFlLTIsM2UtMiwxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUpKSxsYWJlbDpcIklMTG9iYXR0b19JSUlBMlwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9MT0JBVFRPSUlJQTQoMWUtMiwzZS0yLDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSkpLGxhYmVsOlwiSUxMb2JhdHRvX0lJSUE0XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0xPQkFUVE9JSUlCMigxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1KSksbGFiZWw6XCJJTExvYmF0dG9fSUlJQjJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfTE9CQVRUT0lJSUI0KDFlLTIsM2UtMiwxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUpKSxsYWJlbDpcIklMTG9iYXR0b19JSUlCNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9MT0JBVFRPSUlJQzIoMWUtMiwzZS0yLDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSkpLGxhYmVsOlwiSUxMb2JhdHRvX0lJSUMyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0xPQkFUVE9JSUlDNCgxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1KSksbGFiZWw6XCJJTG9iYXR0b19JSUlDNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9HQVVTU0xFR0VORFJFNCgxZS0yLDNlLTIsMWUtMyxuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklHYXVzc0xlZ2VuZGVyNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9HQVVTU0xFR0VORFJFNigxZS0yLDNlLTIsMWUtMyxuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklHYXVzc0xlZ2VuZGVyNlwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9IZXVuRXVsZXIoMWUtMiwzZS0yLDFlLTQpLGxhYmVsOlwiSUhldW5FdWxlclwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9NaWRwb2ludEV1bGVyKDFlLTIsM2UtMiwxZS00KSxsYWJlbDpcIklNaWRwb2ludEV1bGVyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0JERjIoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREYyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0JERjMoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREYzXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0JERjQoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY0XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0JERjUoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY1XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0JERjYoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY2XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0FNMigxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNikpLGxhYmVsOlwiSUFNMlwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9BTTMoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDYpKSxsYWJlbDpcIklBTTNcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfQU00KDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw2KSksbGFiZWw6XCJJQU00XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0FNNSgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNikpLGxhYmVsOlwiSUFNNVwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9BTTYoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDYpKSxsYWJlbDpcIklBTTZcIn0sKi9cclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9BQjIoMWUtMiksbGFiZWw6XCJFQUIyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0FCMygxZS0yKSxsYWJlbDpcIkVBQjNcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IEVEQUVfQUI0KDFlLTIpLGxhYmVsOlwiRUFCNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgRURBRV9BQjUoMWUtMiksbGFiZWw6XCJFQUI1XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBFREFFX0FCNigxZS0yKSxsYWJlbDpcIkVBQjZcIn1cclxuICAgICAgICBdO1xyXG4gICAgICAgIGxldCBJREFFU29sdmVyczp7bWV0aG9kOklEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdID0gW1xyXG4gICAgICAgICAgICAvKnttZXRob2Q6bmV3IElEQUVfRUV1bGVyKDFlLTMsbmV3IE5ld3RvblNvbHZlcigyMCwxZS01LDFlLTUsMC45NSw0KSksbGFiZWw6XCJFRXVsZXJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfSUV1bGVyKDFlLTMsIG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCkpLGxhYmVsOlwiSUV1bGVyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0VNaWRwb2ludCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRU1pZHBvaW50XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0lNaWRwb2ludCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCkpLGxhYmVsOlwiSU1pZHBvaW50XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0VUcmFwZXpvaWRhbCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRVRyYXBlem9pZGFsXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0lUcmFwZXpvaWRhbCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCksIG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMiwxZS0zLDAuOTUpKSxsYWJlbDpcIklUcmFwZXpvaWRhbFwifSwqL1xyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX1JLNCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNCwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRVJLNFwifSxcclxuICAgICAgICAgICAgLyp7bWV0aG9kOm5ldyBJREFFX1JLNF8yKDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS00LDFlLTUsMC45NSw0KSksbGFiZWw6XCJFUks0XzJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfUks0X1JBTFNUT04oMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTQsMWUtNSwwLjk1LDQpKSxsYWJlbDpcIkVSSzRfUmFsc3RvblwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9ET1BSSTUoMWUtMiwzZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNCwxZS01LDAuOTUsNCksMWUtNiksbGFiZWw6XCJFRE9QUkk1XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JTMjMoMWUtMiwzZS0yLDFlLTYsbmV3IE5ld3RvblNvbHZlcigyMCwxZS00LDFlLTUsMC45NSw0KSksbGFiZWw6XCJFQlMyM1wifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9SSzYoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTQsMWUtNSwwLjk1LDQpKSxsYWJlbDpcIkVSSzZfMVwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9SSzZfMigxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNCwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRVJLNl8yXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX1JLOCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNCwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRVJLOFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9SQURBVUlBNSgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiSVJhZGF1X0lBNVwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9SQURBVUlJQTMoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklSYWRhdV9JSUEzXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX1JBREFVSUlBNSgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiSVJhZGF1X0lJQTVcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfTE9CQVRUT0lJSUEyKDFlLTIsM2UtMiwxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiSUxMb2JhdHRvX0lJSUEyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0xPQkFUVE9JSUlBNCgxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklMTG9iYXR0b19JSUlBNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9MT0JBVFRPSUlJQjIoMWUtMiwzZS0yLDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJTExvYmF0dG9fSUlJQjJcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfTE9CQVRUT0lJSUI0KDFlLTIsM2UtMiwxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiSUxMb2JhdHRvX0lJSUI0XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0xPQkFUVE9JSUlDMigxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklMTG9iYXR0b19JSUlDMlwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9MT0JBVFRPSUlJQzQoMWUtMiwzZS0yLDFlLTIsbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJTG9iYXR0b19JSUlDNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9HQVVTU0xFR0VORFJFNCgxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklHYXVzc0xlZ2VuZGVyNFwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9HQVVTU0xFR0VORFJFNigxZS0yLDNlLTIsMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklHYXVzc0xlZ2VuZGVyNlwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9IZXVuRXVsZXIoMWUtMiwzZS0yLDFlLTQsbmV3IE5ld3RvblNvbHZlcigyMCwxZS01LDFlLTUsMC45NSw0KSksbGFiZWw6XCJFX0hldW5FdWxlclwifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9NaWRwb2ludEV1bGVyKDFlLTIsM2UtMiwxZS00LG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtNSwxZS01LDAuOTUsNCkpLGxhYmVsOlwiRV9NaWRwb2ludEV1bGVyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JERjIoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREYyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JERjMoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREYzXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JERjQoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY0XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JERjUoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY1XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0JERjYoMWUtMixuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIklCREY2XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FNMigxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNiksbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJQU0yXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FNMygxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNiksbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJQU0zXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FNNCgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNiksbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJQU00XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FNNSgxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNiksbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJQU01XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FNNigxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjAsMWUtMywxZS00LDAuOTUsNiksbmV3IE5ld3RvblNvbHZlcigyMCwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJJQU02XCJ9LCovXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfQUIyKDFlLTIsbmV3IE5ld3RvblNvbHZlcigyNSwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJFQUIyXCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FCMygxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjUsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiRUFCM1wifSxcclxuICAgICAgICAgICAge21ldGhvZDpuZXcgSURBRV9BQjQoMWUtMixuZXcgTmV3dG9uU29sdmVyKDI1LDFlLTMsMWUtNCwwLjk1LDQpKSxsYWJlbDpcIkVBQjRcIn0sXHJcbiAgICAgICAgICAgIHttZXRob2Q6bmV3IElEQUVfQUI1KDFlLTIsbmV3IE5ld3RvblNvbHZlcigyNSwxZS0zLDFlLTQsMC45NSw0KSksbGFiZWw6XCJFQUI1XCJ9LFxyXG4gICAgICAgICAgICB7bWV0aG9kOm5ldyBJREFFX0FCNigxZS0yLG5ldyBOZXd0b25Tb2x2ZXIoMjUsMWUtMywxZS00LDAuOTUsNCkpLGxhYmVsOlwiRUFCNlwifVxyXG4gICAgICAgIF1cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFBsb3QoKTtcclxuICAgICAgICAgICAgdGhpcy50ZXN0RURBRUNvbXBpbGVyKCk7XHJcbiAgICAgICAgICAgIC8vdGhpcy50ZXN0RGFscXVpc3QoRURBRVNvbHZlcnMsSURBRVNvbHZlcnMpOy8vXHJcbiAgICAgICAgICAgIC8vdGhpcy50ZXN0VmFuRGVyUG9sKEVEQUVTb2x2ZXJzLElEQUVTb2x2ZXJzKTsvL1xyXG4gICAgICAgICAgICAvL3RoaXMudGVzdExvcmVueihFREFFU29sdmVycyxJREFFU29sdmVycyk7Ly9cclxuICAgICAgICAgICAgLy90aGlzLnRlc3RJREFFKEVEQUVTb2x2ZXJzLElEQUVTb2x2ZXJzKTsvL1xyXG5cclxuICAgICAgICAgICAgLy90aGlzLnRlc3RKdW1waW5nQmFsbCgpOy8vcGFzc2VkXHJcbiAgICAgICAgICAgIC8vdGhpcy50ZXN0SURBRUp1bXBpbmdCYWxsKCk7XHJcbiAgICAgICAgICAgIC8vdGhpcy50ZXN0QWxnZWJyYWljKCk7Ly9QYXNzZWRcclxuICAgICAgICB9Y2F0Y2goZXJyb3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcclxuICAgICAgICAgICAgJChcIiNsb2dcIikudmFsKEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3REYWxxdWlzdChlZGFlU29sdmVyczp7bWV0aG9kOkVEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdLGlkYWVTb2x2ZXJzOnttZXRob2Q6SURBRVNvbHZlcixsYWJlbDpzdHJpbmd9W10pOnZvaWR7XHJcbiAgICAgICAgZnVuY3Rpb24gZXhwb25lbnRBbmFseXRpY2FsKHgwOm51bWJlcixhOm51bWJlcix0MDpudW1iZXIsdDE6bnVtYmVyLHN0ZXA6bnVtYmVyKTpEQUVWZWN0b3JbXVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdDpEQUVWZWN0b3JbXSA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgYyA9IHgwL01hdGguZXhwKGEqdDApO1xyXG4gICAgICAgICAgICBmb3IobGV0IHQgPSB0MDt0PD10MSoxLjAwMTt0Kz1zdGVwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREFFVmVjdG9yKG5ldyB2ZWN0b3IoW01hdGguZXhwKGEqdCkqY10pLG5ldyB2ZWN0b3IoW10pLHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICBkeCA9IGF4XHJcbiAgICAgICAgKi9cclxuICAgICAgICBjbGFzcyBEYWxxdWlzdFByb2JsZW0gaW1wbGVtZW50cyBFREFFU3lzdGVte1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgYTpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGE6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYSAqIHguZ2V0KDApXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnKHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW3RoaXMuYV0sMSwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR6KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHgoeDp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDEsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3goKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeigpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MCA9IDA7XHJcbiAgICAgICAgbGV0IHQxID0gMTtcclxuICAgICAgICBsZXQgYSA9IC0yO1xyXG4gICAgICAgIGxldCB4MCA9IG5ldyB2ZWN0b3IoWzFdKTtcclxuICAgICAgICBsZXQgRVN5c3RlbSA9IG5ldyBEYWxxdWlzdFByb2JsZW0oYSk7XHJcbiAgICAgICAgLypsZXQgRURBRUVTb2x2ZXIgPSBuZXcgRURBRV9FRXVsZXIoMC4wMSk7XHJcbiAgICAgICAgbGV0IEVEQUVJU29sdmVyID0gbmV3IEVEQUVfSUV1bGVyKDAuMDEsMjAsMC4wMjUsMC45NSk7XHJcbiAgICAgICAgbGV0IEVEQUVFU29sdXRpb24gPSBzb2x2ZUV4cGxpY2l0KG5ldyB2ZWN0b3IoWzFdKSx0MCx0MSxFREFFRVNvbHZlcixFU3lzdGVtKTsgICAgIFxyXG4gICAgICAgIGxldCBFREFFSVNvbHV0aW9uID0gc29sdmVFeHBsaWNpdChuZXcgdmVjdG9yKFsxXSksdDAsdDEsRURBRUlTb2x2ZXIsRVN5c3RlbSk7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KEVEQUVFU29sdXRpb24sW1wieFwiXSxbXSxcIkV4cG9uZW50IEVEQUVFXCIpO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChFREFFSVNvbHV0aW9uLFtcInhcIl0sW10sXCJFeHBvbmVudCBFREFFSVwiKTsqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGR4IC0gYXggPSAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xhc3MgSW1wbGljaXREYWxxdWlzdFByb2JsZW0gaW1wbGVtZW50cyBJREFFU3lzdGVte1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgYTpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGE6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtcclxuICAgICAgICAgICAgICAgICAgICBkeC5nZXQoMCktdGhpcy5hICogeC5nZXQoMClcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoWy10aGlzLmFdLDEsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbMV0sMSwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR6KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwxLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDAsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3goKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF96KCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgSVN5c3RlbSA9IG5ldyBJbXBsaWNpdERhbHF1aXN0UHJvYmxlbShhKTtcclxuICAgICAgICAvKmxldCBJREFFRVNvbHZlciA9IG5ldyBJREFFX0VFdWxlcigwLjAxLDIwLDAuMDI1LDAuOTUpO1xyXG4gICAgICAgIGxldCBJREFFSVNvbHZlciA9IG5ldyBJREFFX0lFdWxlcigwLjAxLDIwLDAuMDI1LDAuOTUpO1xyXG4gICAgICAgIGxldCBJREFFRVNvbHV0aW9uID0gc29sdmVJbXBsaWNpdChuZXcgdmVjdG9yKFsxXSksdDAsdDEsSURBRUVTb2x2ZXIsSVN5c3RlbSk7XHJcbiAgICAgICAgbGV0IElEQUVJU29sdXRpb24gPSBzb2x2ZUltcGxpY2l0KG5ldyB2ZWN0b3IoWzFdKSx0MCx0MSxJREFFSVNvbHZlcixJU3lzdGVtKTtcclxuICAgICAgICBUZXN0LnNob3dPdXRwdXQoSURBRUVTb2x1dGlvbixbXCJ4XCJdLFtdLFwiRXhwb25lbnQgSURBRUVcIik7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KElEQUVJU29sdXRpb24sW1wieFwiXSxbXSxcIkV4cG9uZW50IElEQUVJXCIpOyovXHJcblxyXG4gICAgICAgIHRoaXMudGVzdEVEQUVTb2x2ZXJzKHQwLHQxLHgwLGVkYWVTb2x2ZXJzLEVTeXN0ZW0sW1wieFwiXSxbXSxcIkVEQUVcIik7XHJcbiAgICAgICAgdGhpcy50ZXN0SURBRVNvbHZlcnModDAsdDEseDAsaWRhZVNvbHZlcnMsSVN5c3RlbSxbXCJ4XCJdLFtdLFwiSURBRVwiKTtcclxuICAgICAgICBUZXN0LnNob3dPdXRwdXQoZXhwb25lbnRBbmFseXRpY2FsKHgwLmdldCgwKSxhLHQwLHQxLDAuMDEpLFtcInhcIl0sW10sXCJFeHBvbmVudCBhbmFseXRpY2FsXCIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RWYW5EZXJQb2woZWRhZVNvbHZlcnM6e21ldGhvZDpFREFFU29sdmVyLGxhYmVsOnN0cmluZ31bXSxpZGFlU29sdmVyczp7bWV0aG9kOklEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdKTp2b2lke1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIGR4ID0geTtcclxuICAgICAgICAgICAgZHkgPSBtdSgxLXheMil5IC0geDtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzIEVWYW5EZXJQb2wgaW1wbGVtZW50cyBFREFFU3lzdGVte1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1ldGVyOm51bWJlcjtcclxuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyYW1ldGVyOm51bWJlcil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfeSA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW1xyXG4gICAgICAgICAgICAgICAgICAgIF95LFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyKigxLV94Kl94KSpfeSAtIF94XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnKHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgbGV0IF94ID0geC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3kgPSB4LmdldCgxKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6bWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0cml4LmVtcHR5U3F1YXJlKDIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KDEsMCwxKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoLTIqdGhpcy5wYXJhbWV0ZXIqX3kqX3gtMSwxLDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCh0aGlzLnBhcmFtZXRlciooMS1feCpfeCksMSwxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R4KHg6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwyLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHooeDp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDAsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3goKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeigpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIGR4IC0geSA9IDA7XHJcbiAgICAgICAgICAgIGR5IC0gbXUoMS14XjIpeSArIHggPSAwO1xyXG4gICAgICAgICovXHJcbiAgICAgICAgY2xhc3MgSVZhbkRlclBvbCBpbXBsZW1lbnRzIElEQUVTeXN0ZW17XHJcbiAgICAgICAgICAgIHByb3RlY3RlZCBwYXJhbWV0ZXI6bnVtYmVyO1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXI6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfeSA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IF9keCA9IGR4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfZHkgPSBkeC5nZXQoMSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgX2R4IC0gX3ksXHJcbiAgICAgICAgICAgICAgICAgICAgX2R5IC0gdGhpcy5wYXJhbWV0ZXIqKDEtX3gqX3gpKl95ICsgX3hcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgbGV0IF94ID0geC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3kgPSB4LmdldCgxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtcclxuICAgICAgICAgICAgICAgICAgICAwLC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIDEgKyAyKnRoaXMucGFyYW1ldGVyKl95Kl94LCAtdGhpcy5wYXJhbWV0ZXIqKDEtX3gqX3gpXHJcbiAgICAgICAgICAgICAgICBdLDIsMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXHJcbiAgICAgICAgICAgICAgICAgICAgMSwwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsMVxyXG4gICAgICAgICAgICAgICAgXSwyLDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHooeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDIsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeCgpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF96KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHQwID0gMDtcclxuICAgICAgICBsZXQgdDEgPSA1O1xyXG4gICAgICAgIGxldCB4MCA9IG5ldyB2ZWN0b3IoWzEsMV0pO1xyXG4gICAgICAgIGxldCBFU3lzdGVtID0gbmV3IEVWYW5EZXJQb2woMjApO1xyXG4gICAgICAgIHRoaXMudGVzdEVEQUVTb2x2ZXJzKHQwLHQxLHgwLGVkYWVTb2x2ZXJzLEVTeXN0ZW0sW1wieFwiLFwieCdcIl0sW10sXCJFREFFXCIpO1xyXG4gICAgICAgIGxldCBJU3lzdGVtID0gbmV3IElWYW5EZXJQb2woMjApO1xyXG4gICAgICAgIHRoaXMudGVzdElEQUVTb2x2ZXJzKHQwLHQxLHgwLGlkYWVTb2x2ZXJzLElTeXN0ZW0sW1wieFwiLFwieCdcIl0sW10sXCJJREFFXCIpO1xyXG4gICAgICAgIC8qbGV0IEVEQUVFU29sdmVyID0gbmV3IEVEQUVfRUV1bGVyKDAuMDEpO1xyXG4gICAgICAgIGxldCBFREFFSVNvbHZlciA9IG5ldyBFREFFX0lFdWxlcigwLjAxLDIwLDAuMDUsMC45NSk7XHJcbiAgICAgICAgbGV0IEVEQUVFU29sdXRpb24gPSBzb2x2ZUV4cGxpY2l0KG5ldyB2ZWN0b3IoWzEsMV0pLHQwLHQxLEVEQUVFU29sdmVyLEVTeXN0ZW0pOyAgICAgXHJcbiAgICAgICAgbGV0IEVEQUVJU29sdXRpb24gPSBzb2x2ZUV4cGxpY2l0KG5ldyB2ZWN0b3IoWzEsMV0pLHQwLHQxLEVEQUVJU29sdmVyLEVTeXN0ZW0pO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChFREFFRVNvbHV0aW9uLFtcInhcIixcIngnXCJdLFtdLFwiVmFuIGRlciBwb2wgRURBRUVcIik7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KEVEQUVJU29sdXRpb24sW1wieFwiLFwieCdcIl0sW10sXCJWYW4gZGVyIHBvbCBFREFFSVwiKTsqL1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RXZWlzc2luZ2VyKCk6dm9pZHtcclxuICAgICAgICBjbGFzcyBJV2Vpc3NpbmdlciBpbXBsZW1lbnRzIElEQUVTeXN0ZW17XHJcbiAgICAgICAgICAgIGYoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfZHggPSBkeC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgdCpNYXRoLnBvdyhfeCpfZHgsMikqX2R4LU1hdGgucG93KF94Kl9keCwyKSpfeCt0Kih0KnQrMSkqX2R4LXQqdCpfeFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZyh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfZHggPSBkeC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXHJcbiAgICAgICAgICAgICAgICAgICAgMip0Kl94Kk1hdGgucG93KF9keCwzKSAtIDMqTWF0aC5wb3coX3gqX2R4LDIpIC10KnRcclxuICAgICAgICAgICAgICAgIF0sMSwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmRkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIGxldCBfeCA9IHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF9keCA9IGR4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtcclxuICAgICAgICAgICAgICAgICAgICAzKnQqTWF0aC5wb3coX3gqX2R4LDIpIC0gMipfZHgqTWF0aC5wb3coX3gsMykgLSB0Kih0KnQrMSlcclxuICAgICAgICAgICAgICAgIF0sMSwxKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHooeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDEsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeCgpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF96KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdGVzdExvcmVueihlZGFlU29sdmVyczp7bWV0aG9kOkVEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdLGlkYWVTb2x2ZXJzOnttZXRob2Q6SURBRVNvbHZlcixsYWJlbDpzdHJpbmd9W10pOnZvaWR7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgICAgZHggPSBzKHkteClcclxuICAgICAgICAgICAgZHkgPSB4KHAteikgLSB5XHJcbiAgICAgICAgICAgIGR6ID0geHkgLSBielxyXG4gICAgICAgICovXHJcbiAgICAgICAgY2xhc3MgRUxvcmVueiBpbXBsZW1lbnRzIEVEQUVTeXN0ZW17XHJcbiAgICAgICAgICAgIHNpZ21hOm51bWJlcjtcclxuICAgICAgICAgICAgcmhvOm51bWJlcjtcclxuICAgICAgICAgICAgYmV0YTpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHNpZ21hOm51bWJlcixyaG86bnVtYmVyLGJldGE6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2lnbWEgPSBzaWdtYTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmhvID0gcmhvO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iZXRhID0gYmV0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfeSA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IF96ID0geC5nZXQoMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWdtYSooX3ktX3gpLFxyXG4gICAgICAgICAgICAgICAgICAgIF94Kih0aGlzLnJoby1feiktX3ksXHJcbiAgICAgICAgICAgICAgICAgICAgX3gqX3kgLSB0aGlzLmJldGEqX3pcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfeSA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IF96ID0geC5nZXQoMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChcclxuICAgICAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC10aGlzLnNpZ21hLHRoaXMuc2lnbWEsMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yaG8gLSBfeiwtMSwtX3gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF95LF94LC10aGlzLmJldGFcclxuICAgICAgICAgICAgICAgICAgICBdLDMsMyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R4KHg6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwzLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF94KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3ooKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzcyBJTG9yZW56IGltcGxlbWVudHMgSURBRVN5c3RlbXtcclxuICAgICAgICAgICAgc2lnbWE6bnVtYmVyO1xyXG4gICAgICAgICAgICByaG86bnVtYmVyO1xyXG4gICAgICAgICAgICBiZXRhOm51bWJlcjtcclxuICAgICAgICAgICAgY29uc3RydWN0b3Ioc2lnbWE6bnVtYmVyLHJobzpudW1iZXIsYmV0YTpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaWdtYSA9IHNpZ21hO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaG8gPSByaG87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJldGEgPSBiZXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGYoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfeSA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IF96ID0geC5nZXQoMik7XHJcbiAgICAgICAgICAgICAgICBsZXQgX2R4ID0gZHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF9keSA9IGR4LmdldCgxKTtcclxuICAgICAgICAgICAgICAgIGxldCBfZHogPSBkeC5nZXQoMik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgX2R4LXRoaXMuc2lnbWEqKF95LV94KSxcclxuICAgICAgICAgICAgICAgICAgICBfZHkgLSBfeCoodGhpcy5yaG8tX3opK195LFxyXG4gICAgICAgICAgICAgICAgICAgIF9keiAtIF94Kl95ICsgdGhpcy5iZXRhKl96XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIGxldCBfeCA9IHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF95ID0geC5nZXQoMSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ogPSB4LmdldCgyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFxyXG4gICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWdtYSwtdGhpcy5zaWdtYSwwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtdGhpcy5yaG8gKyBfeiwxLF94LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtX3ksLV94LHRoaXMuYmV0YVxyXG4gICAgICAgICAgICAgICAgICAgIF0sMywzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmRkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtcclxuICAgICAgICAgICAgICAgICAgICAxLDAsMCxcclxuICAgICAgICAgICAgICAgICAgICAwLDEsMCxcclxuICAgICAgICAgICAgICAgICAgICAwLDAsMVxyXG4gICAgICAgICAgICAgICAgXSwzLDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHooeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDAsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMywwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeCgpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF96KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHQwID0gMDtcclxuICAgICAgICBsZXQgdDEgPSA1O1xyXG4gICAgICAgIGxldCB4MCA9IG5ldyB2ZWN0b3IoWzEsMSwxXSk7XHJcbiAgICAgICAgbGV0IEVTeXN0ZW0gPSBuZXcgRUxvcmVueigxMCwyOCw4LzMpO1xyXG4gICAgICAgIGxldCBJU3lzdGVtID0gbmV3IElMb3JlbnooMTAsMjgsOC8zKTtcclxuICAgICAgICB0aGlzLnRlc3RFREFFU29sdmVycyh0MCx0MSx4MCxlZGFlU29sdmVycyxFU3lzdGVtLFtcInhcIixcInlcIixcInpcIl0sW10sXCJFREFFXCIpO1xyXG4gICAgICAgIHRoaXMudGVzdElEQUVTb2x2ZXJzKHQwLHQxLHgwLGlkYWVTb2x2ZXJzLElTeXN0ZW0sW1wieFwiLFwieVwiLFwielwiXSxbXSxcIklEQUVcIik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLypsZXQgRURBRUVTb2x2ZXIgPSBuZXcgRURBRV9FRXVsZXIoMC4wMik7XHJcbiAgICAgICAgbGV0IEVEQUVJU29sdmVyID0gbmV3IEVEQUVfSUV1bGVyKDAuMDIsMjAsMC4wNSwwLjk1KTtcclxuICAgICAgICBsZXQgRURBRUVTb2x1dGlvbiA9IHNvbHZlRXhwbGljaXQobmV3IHZlY3RvcihbMSwxLDFdKSx0MCx0MSxFREFFRVNvbHZlcixFU3lzdGVtKTsgICAgIFxyXG4gICAgICAgIGxldCBFREFFSVNvbHV0aW9uID0gc29sdmVFeHBsaWNpdChuZXcgdmVjdG9yKFsxLDEsMV0pLHQwLHQxLEVEQUVJU29sdmVyLEVTeXN0ZW0pO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChFREFFRVNvbHV0aW9uLFtcInhcIixcInlcIixcInpcIl0sW10sXCJMb3JlbnogRURBRUVcIik7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KEVEQUVJU29sdXRpb24sW1wieFwiLFwieVwiLFwielwiXSxbXSxcIkxvcmVueiBFREFFSVwiKTsqL1xyXG5cclxuICAgIH1cclxuICAgIHN0YXRpYyB0ZXN0SURBRShlZGFlU29sdmVyczp7bWV0aG9kOkVEQUVTb2x2ZXIsbGFiZWw6c3RyaW5nfVtdLGlkYWVTb2x2ZXJzOnttZXRob2Q6SURBRVNvbHZlcixsYWJlbDpzdHJpbmd9W10pOnZvaWR7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgIGR4ID0geSArIHogKyB0XHJcbiAgICAgICAgICAgIGR5ID0geFxyXG4gICAgICAgICAgICB6ID0geCArIHlcclxuICAgICAgICAgICAgZHgteS16LXQ9MFxyXG4gICAgICAgICAgICBkeS14PTBcclxuICAgICAgICAgICAgei14LXk9MFxyXG4gICAgICAgICovXHJcbiAgICAgICAgY2xhc3MgRURBRVByb2JsZW0gaW1wbGVtZW50cyBFREFFU3lzdGVte1xyXG4gICAgICAgIGYoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoXHJcbiAgICAgICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAgICAgICAgeC5nZXQoMSkrei5nZXQoMCkrdCxcclxuICAgICAgICAgICAgICAgICAgICB4LmdldCgwKVxyXG4gICAgICAgICAgICAgICAgXSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZyh4OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbeC5nZXQoMCkreC5nZXQoMSldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGZkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbMCwxLDEsMF0sMiwyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGZkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbMSwwXSwxLDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZ2R4KHg6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFsxLDFdLDIsMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlbmd0aF94KCk6bnVtYmVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVuZ3RoX3ooKTpudW1iZXJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhc3MgSURBRVByb2JsZW0gaW1wbGVtZW50cyBJREFFU3lzdGVte1xyXG4gICAgICAgICAgICBmKHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoXHJcbiAgICAgICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeC5nZXQoMCkteC5nZXQoMSktei5nZXQoMCktdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHguZ2V0KDEpLXguZ2V0KDApXHJcbiAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZyh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW3ouZ2V0KDApLXguZ2V0KDApLXguZ2V0KDEpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6bWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0cml4LmVtcHR5U3F1YXJlKDIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgwLDAsMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KC0xLDAsMSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KC0xLDEsMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KDAsMSwxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6bWF0cml4O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0cml4LmVtcHR5KDIsMSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KC0xLDAsMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KDAsMSwwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0Om1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdHJpeC5lbXB0eVNxdWFyZSgyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoMSwwLDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgwLDAsMSk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KDAsMSwwKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoMSwxLDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0Om1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdHJpeC5lbXB0eSgxLDIpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgtMSwwLDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgtMSwwLDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R6KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0Om1hdHJpeDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdHJpeC5lbXB0eSgxLDEpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldCgxLDAsMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF94KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3ooKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDAgPSAwO1xyXG4gICAgICAgIGxldCB0MSA9IDE7XHJcbiAgICAgICAgbGV0IHgwID0gbmV3IHZlY3RvcihbMCwwXSk7XHJcbiAgICAgICAgbGV0IElTeXN0ZW0gPSBuZXcgSURBRVByb2JsZW0oKTtcclxuICAgICAgICBsZXQgRVN5c3RlbSA9IG5ldyBFREFFUHJvYmxlbSgpO1xyXG4gICAgICAgIC8qbGV0IElEQUVFU29sdmVyID0gbmV3IElEQUVfRUV1bGVyKDAuMDA1LDIwLDAuMDUsMC45NSk7XHJcbiAgICAgICAgbGV0IElEQUVJU29sdmVyID0gbmV3IElEQUVfSUV1bGVyKDAuMDEwLDIwLDAuMDEsMC45NSk7XHJcbiAgICAgICAgbGV0IElEQUVFU29sdXRpb24gPSBzb2x2ZUltcGxpY2l0KG5ldyB2ZWN0b3IoWzAsMF0pLHQwLHQxLElEQUVFU29sdmVyLElTeXN0ZW0pOyAgICAgXHJcbiAgICAgICAgbGV0IElEQUVJU29sdXRpb24gPSBzb2x2ZUltcGxpY2l0KG5ldyB2ZWN0b3IoWzAsMF0pLHQwLHQxLElEQUVJU29sdmVyLElTeXN0ZW0pOyovXHJcbiAgICAgICAgdGhpcy50ZXN0RURBRVNvbHZlcnModDAsdDEseDAsZWRhZVNvbHZlcnMsRVN5c3RlbSxbXCJ4XCIsXCJ5XCJdLFtcInpcIl0sXCJFREFFXCIpO1xyXG4gICAgICAgIHRoaXMudGVzdElEQUVTb2x2ZXJzKHQwLHQxLHgwLGlkYWVTb2x2ZXJzLElTeXN0ZW0sW1wieFwiLFwieVwiXSxbXCJ6XCJdLFwiSURBRVwiKTtcclxuICAgICAgICAvKlRlc3Quc2hvd091dHB1dChJREFFRVNvbHV0aW9uLFtcInhcIixcInlcIl0sW1wielwiXSxcIklEQUVFIHByb2JsZW1cIik7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KElEQUVJU29sdXRpb24sW1wieFwiLFwieVwiXSxbXCJ6XCJdLFwiSURBRUkgcHJvYmxlbVwiKTsqL1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RJREFFSnVtcGluZ0JhbGwoKTp2b2lke1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldEFuYWx0eXRpY0p1bXBpbmdCYWxsKHgwOm51bWJlcix2MDpudW1iZXIsdDE6bnVtYmVyLGR0Om51bWJlcixrOm51bWJlcik6REFFVmVjdG9yW117XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQ6REFFVmVjdG9yW10gPSBbXTtcclxuICAgICAgICAgICAgbGV0IHBvaW50ID0gbmV3IERBRVZlY3RvcihuZXcgdmVjdG9yKFt4MCx2MF0pLG5ldyB2ZWN0b3IoW10pLDApO1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCgpO1xyXG4gICAgICAgICAgICBsZXQgX3YwID0gdjA7XHJcbiAgICAgICAgICAgIGxldCBfeDAgPSB4MDtcclxuICAgICAgICAgICAgbGV0IGcgPSAxMDtcclxuICAgICAgICAgICAgbGV0IHQgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSh0PHQxKXtcclxuICAgICAgICAgICAgICAgIC8vZmluZCB0aW1lIG9mIG5leHQgaW50ZXJzZWN0aW9uIHdpdGggeCBheGlzXHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRTdGVwID0gKF92MCArIE1hdGguc3FydChfdjAqX3YwKzIqX3gwKmcpKS9nO1xyXG4gICAgICAgICAgICAgICAgbGV0IHROZXh0ID0gdCArIGV2ZW50U3RlcDtcclxuICAgICAgICAgICAgICAgIGxldCB2TmV4dCA9IE1hdGguYWJzKF92MCAtIGcqZXZlbnRTdGVwKTtcclxuICAgICAgICAgICAgICAgIGlmKGV2ZW50U3RlcDw9MC4wMDEpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IF9kdCA9IDA7dDx0TmV4dDt0Kz1kdCxfZHQrPWR0KXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0Pj10MSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBEQUVWZWN0b3IobmV3IHZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF94MCArIF92MCpfZHQgLSBnKl9kdCpfZHQvMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3YwIC0gZypfZHRcclxuICAgICAgICAgICAgICAgICAgICBdKSxuZXcgdmVjdG9yKFtdKSx0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ID0gdE5leHQ7XHJcbiAgICAgICAgICAgICAgICBfeDAgPSAwO1xyXG4gICAgICAgICAgICAgICAgX3YwID0gdk5leHQqaztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEQUVWZWN0b3IobmV3IHZlY3RvcihbX3gwLF92MF0pLG5ldyB2ZWN0b3IoW10pLHQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKlxyXG4gICAgICAgICAgICBjb25zdGFudCBtID0gMTtcclxuICAgICAgICAgICAgdih0MCkgPSAwO1xyXG4gICAgICAgICAgICB4KHQwKSA9IDE7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB4JyAtIHYgPSAwO1xyXG4gICAgICAgICAgICB2ZWxvY2l0eTogdicgKyBtZyA9IDA7XHJcbiAgICAgICAgICAgIHN0YXRlIGp1bXAgb24gKHY8PTAmJng8PTApe1xyXG4gICAgICAgICAgICAgICAgc2V0IHYgPSAtdjtcclxuICAgICAgICAgICAgfSBmcm9tIGluaXQsIGp1bXA7XHJcbiAgICAgICAgKi9cclxuICAgICAgICBjbGFzcyBKdW1wU3RhdGVMaW5rIGltcGxlbWVudHMgSHlicmlkU3RhdGVMaW5re1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgc3RhdGVOdW1iZXI6bnVtYmVyO1xyXG4gICAgICAgICAgICBwcm90ZWN0ZWQgazpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHN0YXRlTnVtYmVyOm51bWJlcixrOm51bWJlcil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlTnVtYmVyID0gc3RhdGVOdW1iZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmsgPSBrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldE5ld1N0YXRlKCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZU51bWJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5nZXQoMCk8PTAgJiYgeC5nZXQoMSk8PTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcil7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oLXguZ2V0KDApLC14LmdldCgxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHBkdCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZHBkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRwZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIGxldCBfeCA9IHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF92ID0geC5nZXQoMSk7XHJcbiAgICAgICAgICAgICAgICBpZigtX3g8LV92KXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbLTEsMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoWzAsLTFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRDb25kaXRpb25zKHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbeC5nZXQoMCksLXguZ2V0KDEpKnRoaXMua10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzIElEQUVKdW1wU3RhdGUgZXh0ZW5kcyBJREFFSHlicmlkU3RhdGV7XHJcbiAgICAgICAgICAgIHByb3RlY3RlZCBfZzpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG5hbWU6c3RyaW5nLGxpbmtzOkh5YnJpZFN0YXRlTGlua1tdLHRlcm1pbmFsOmZhbHNlLGc6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHN1cGVyKG5hbWUsbGlua3MsdGVybWluYWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZyA9IGc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtcclxuICAgICAgICAgICAgICAgICAgICBkeC5nZXQoMCkteC5nZXQoMSksXHJcbiAgICAgICAgICAgICAgICAgICAgZHguZ2V0KDEpK3RoaXMuX2dcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoWzAsLTEsMCwwXSwyLDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZGR4KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoWzEsMCwwLDFdLDIsMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDAsMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeCh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMiwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R6KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHQoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeCgpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF96KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhc3MgSURBRUp1bXBpbmdCYWxsIGV4dGVuZHMgSURBRUh5YnJpZFN5c3RlbXtcclxuICAgICAgICAgICAgY29uc3RydWN0b3IoZzpudW1iZXIsazpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmsgPSBuZXcgSnVtcFN0YXRlTGluaygxLGspO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluaXQgPSBuZXcgSURBRUp1bXBTdGF0ZShcImluaXRcIixbbGlua10sZmFsc2UsZyk7XHJcbiAgICAgICAgICAgICAgICBsZXQganVtcCA9IG5ldyBJREFFSnVtcFN0YXRlKFwianVtcFwiLFtsaW5rXSxmYWxzZSxnKTtcclxuICAgICAgICAgICAgICAgIHN1cGVyKFtpbml0LGp1bXBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDEgPSAyMztcclxuICAgICAgICBsZXQgayA9IDAuODtcclxuICAgICAgICBsZXQgZXZlbnREZXRlY3RvclNpbXBsZSA9IG5ldyBFdmVudERldGVjdGlvblNpbXBsZSgpO1xyXG4gICAgICAgIGxldCBldmVudERldGVjdG9yQ29tcGxleCA9IG5ldyBFdmVudERldGVjdGlvbkNvbXBsZXgoKTtcclxuICAgICAgICBsZXQgYWRhcHRpdmVTdGVwU3RyYXRlZ3kgPSBuZXcgQWRhcHRpdmVTdGVwTmV3dG9uKDAuOTUsMWUtNSk7XHJcbiAgICAgICAgbGV0IGlkYWVIeWJyaWRTb2x2ZXIgPSBuZXcgSURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdG9yQ29tcGxleCxhZGFwdGl2ZVN0ZXBTdHJhdGVneSk7XHJcbiAgICAgICAgbGV0IGlkYWVTeXN0ZW0gPSBuZXcgSURBRUp1bXBpbmdCYWxsKDEwLGspO1xyXG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSBuZXcgdmVjdG9yKFsxMCwgMTVdKTtcclxuICAgICAgICBsZXQgaWRhZVNvbHV0aW9uO1xyXG4gICAgICAgIC8vaWRhZVNvbHV0aW9uID0gaWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCwxLGlkYWVpRXVsZXJTb2x2ZXIsaWRhZVN5c3RlbSxbXSk7XHJcbiAgICAgICAgLy9UZXN0LnNob3dPdXRwdXQoaWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsXCJ2XCJdLFtdLFwiSnVtcGluZyBiYWxsIGlkYWUgY29tcGxleCB3aXRoIHN0ZXBcIik7XHJcbiAgICAgICAgaWRhZUh5YnJpZFNvbHZlciA9IG5ldyBJREFFSHlicmlkU29sdmVyKGV2ZW50RGV0ZWN0b3JTaW1wbGUsYWRhcHRpdmVTdGVwU3RyYXRlZ3kpO1xyXG4gICAgICAgIC8vaWRhZVNvbHV0aW9uID0gaWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCwxLGlkYWVpRXVsZXJTb2x2ZXIsaWRhZVN5c3RlbSxbXSk7XHJcbiAgICAgICAgLy9UZXN0LnNob3dPdXRwdXQoaWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsXCJ2XCJdLFtdLFwiSnVtcGluZyBiYWxsIGlkYWUgc2ltcGxlIHdpdGggc3RlcFwiKTtcclxuICAgICAgICBpZGFlSHlicmlkU29sdmVyID0gbmV3IElEQUVIeWJyaWRTb2x2ZXIoZXZlbnREZXRlY3RvckNvbXBsZXgsbnVsbCk7XHJcbiAgICAgICAgLy9pZGFlU29sdXRpb24gPSBpZGFlSHlicmlkU29sdmVyLnNvbHZlKGluaXRpYWxTdGF0ZSwwLDEsaWRhZWlFdWxlclNvbHZlcixpZGFlU3lzdGVtLFtdKTtcclxuICAgICAgICAvL1Rlc3Quc2hvd091dHB1dChpZGFlU29sdXRpb24udmFsdWVzLFtcInhcIixcInZcIl0sW10sXCJKdW1waW5nIGJhbGwgaWRhZSBjb21wbGV4XCIpO1xyXG4gICAgICAgIGlkYWVIeWJyaWRTb2x2ZXIgPSBuZXcgSURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdG9yU2ltcGxlLG51bGwpO1xyXG4gICAgICAgIC8vaWRhZVNvbHV0aW9uID0gaWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCwxLGlkYWVpRXVsZXJTb2x2ZXIsaWRhZVN5c3RlbSxbXSk7XHJcbiAgICAgICAgLy9UZXN0LnNob3dPdXRwdXQoaWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsXCJ2XCJdLFtdLFwiSnVtcGluZyBiYWxsIGlkYWUgc2ltcGxlXCIpO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChnZXRBbmFsdHl0aWNKdW1waW5nQmFsbChpbml0aWFsU3RhdGUuZ2V0KDApLGluaXRpYWxTdGF0ZS5nZXQoMSksdDEsMC4wNSxrKSxbXCJ4XCJdLFtdLFwiSnVtcGluZyBiYWxsIGFuYWx5dGljYWxcIik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdGVzdEp1bXBpbmdCYWxsKCk6dm9pZHtcclxuICAgICAgICBmdW5jdGlvbiBnZXRBbmFsdHl0aWNKdW1waW5nQmFsbCh4MDpudW1iZXIsdjA6bnVtYmVyLHQxOm51bWJlcixkdDpudW1iZXIsazpudW1iZXIpOkRBRVZlY3Rvcltde1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0OkRBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgICAgIGxldCBwb2ludCA9IG5ldyBEQUVWZWN0b3IobmV3IHZlY3RvcihbeDAsdjBdKSxuZXcgdmVjdG9yKFtdKSwwKTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKTtcclxuICAgICAgICAgICAgbGV0IF92MCA9IHYwO1xyXG4gICAgICAgICAgICBsZXQgX3gwID0geDA7XHJcbiAgICAgICAgICAgIGxldCBnID0gMTA7XHJcbiAgICAgICAgICAgIGxldCB0ID0gMDtcclxuICAgICAgICAgICAgd2hpbGUodDx0MSl7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbmQgdGltZSBvZiBuZXh0IGludGVyc2VjdGlvbiB3aXRoIHggYXhpc1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50U3RlcCA9IChfdjAgKyBNYXRoLnNxcnQoX3YwKl92MCsyKl94MCpnKSkvZztcclxuICAgICAgICAgICAgICAgIGxldCB0TmV4dCA9IHQgKyBldmVudFN0ZXA7XHJcbiAgICAgICAgICAgICAgICBsZXQgdk5leHQgPSBNYXRoLmFicyhfdjAgLSBnKmV2ZW50U3RlcCk7XHJcbiAgICAgICAgICAgICAgICBpZihldmVudFN0ZXA8PTAuMDAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBfZHQgPSAwO3Q8dE5leHQ7dCs9ZHQsX2R0Kz1kdCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodD49dDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBuZXcgREFFVmVjdG9yKG5ldyB2ZWN0b3IoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfeDAgKyBfdjAqX2R0IC0gZypfZHQqX2R0LzIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92MCAtIGcqX2R0XHJcbiAgICAgICAgICAgICAgICAgICAgXSksbmV3IHZlY3RvcihbXSksdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdCA9IHROZXh0O1xyXG4gICAgICAgICAgICAgICAgX3gwID0gMDtcclxuICAgICAgICAgICAgICAgIF92MCA9IHZOZXh0Kms7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgREFFVmVjdG9yKG5ldyB2ZWN0b3IoW194MCxfdjBdKSxuZXcgdmVjdG9yKFtdKSx0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xhc3MgSnVtcFN0YXRlTGluayBpbXBsZW1lbnRzIEh5YnJpZFN0YXRlTGlua3tcclxuICAgICAgICAgICAgcHJvdGVjdGVkIHN0YXRlTnVtYmVyOm51bWJlcjtcclxuICAgICAgICAgICAgcHJvdGVjdGVkIGs6bnVtYmVyO1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihzdGF0ZU51bWJlcjpudW1iZXIsazpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZU51bWJlciA9IHN0YXRlTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rID0gaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXROZXdTdGF0ZSgpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVOdW1iZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHIoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHguZ2V0KDApPD0wICYmIHguZ2V0KDEpPD0wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKC14LmdldCgwKSwteC5nZXQoMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRwZHQoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRwZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkcGR4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfdiA9IHguZ2V0KDEpO1xyXG4gICAgICAgICAgICAgICAgaWYoLV94PC1fdil7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoWy0xLDBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFswLC0xXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0Q29uZGl0aW9ucyh4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW3guZ2V0KDApLC14LmdldCgxKSp0aGlzLmtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjbGFzcyBFREFFSnVtcFN0YXRlIGV4dGVuZHMgRURBRUh5YnJpZFN0YXRle1xyXG4gICAgICAgICAgICBfZzpudW1iZXI7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKG5hbWU6c3RyaW5nLGxpbmtzOkh5YnJpZFN0YXRlTGlua1tdLHRlcm1pbmFsOmZhbHNlLGc6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIHN1cGVyKG5hbWUsbGlua3MsdGVybWluYWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZyA9IGc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgbGV0IF94ID0geC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3YgPSB4LmdldCgxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtfdiwtdGhpcy5fZ10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXHJcbiAgICAgICAgICAgICAgICAgICAgMCwxLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsMFxyXG4gICAgICAgICAgICAgICAgXSwyLDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHooeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDAsMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeCh4OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMiwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R0KHg6dmVjdG9yLHQ6bnVtYmVyKTp2ZWN0b3J7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3goKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeigpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICAgIGNvbnN0YW50IG0gPSAxO1xyXG4gICAgICAgICAgICB2KHQwKSA9IDA7XHJcbiAgICAgICAgICAgIHgodDApID0gMTtcclxuICAgICAgICAgICAgeCcgPSB2O1xyXG4gICAgICAgICAgICB2Jz0gLSBtZztcclxuICAgICAgICAgICAgc3RhdGUganVtcCBvbiAodjw9MCYmeDw9MCl7XHJcbiAgICAgICAgICAgICAgICBzZXQgdiA9IC12O1xyXG4gICAgICAgICAgICB9IGZyb20gaW5pdCwganVtcDtcclxuICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzIEVEQUVKdW1waW5nQmFsbCBleHRlbmRzIEVEQUVIeWJyaWRTeXN0ZW17XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKGc6bnVtYmVyLGs6bnVtYmVyKXtcclxuICAgICAgICAgICAgICAgIGxldCBsaW5rID0gbmV3IEp1bXBTdGF0ZUxpbmsoMSxrKTtcclxuICAgICAgICAgICAgICAgIGxldCBpbml0ID0gbmV3IEVEQUVKdW1wU3RhdGUoXCJpbml0XCIsW2xpbmtdLGZhbHNlLGcpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGp1bXAgPSBuZXcgRURBRUp1bXBTdGF0ZShcImp1bXBcIixbbGlua10sZmFsc2UsZyk7XHJcbiAgICAgICAgICAgICAgICBzdXBlcihbaW5pdCxqdW1wXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuc3RhdGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMuc3RhdGVzID0gW3tuYW1lOlwiaW5pdFwiLGxpbmtzOltsaW5rXSx0ZXJtaW5hbDpmYWxzZX0se25hbWU6XCJqdW1wXCIsbGlua3M6W2xpbmtdLHRlcm1pbmFsOmZhbHNlfV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHQxID0gMjM7XHJcbiAgICAgICAgbGV0IGsgPSAwLjg7XHJcbiAgICAgICAgbGV0IGFkYXB0aXZlU3RlcFN0cmF0ZWd5ID0gbmV3IEFkYXB0aXZlU3RlcE5ld3RvbigwLjk1LDFlLTUpO1xyXG4gICAgICAgIGxldCBldmVudERldGVjdG9yQ29tcGxleCA9IG5ldyBFdmVudERldGVjdGlvbkNvbXBsZXgoKTtcclxuICAgICAgICBsZXQgZXZlbnREZXRlY3RvclNpbXBsZSA9IG5ldyBFdmVudERldGVjdGlvblNpbXBsZSgpO1xyXG4gICAgICAgIGxldCBpbml0aWFsU3RhdGUgPSBuZXcgdmVjdG9yKFsxMCwgMTVdKTtcclxuICAgICAgICBsZXQgZWRhZWVSSzRTb2x2ZXIgPSBuZXcgRURBRV9SSzQoMWUtMik7XHJcbiAgICAgICAgbGV0IGVkYWVIeWJyaWRTb2x2ZXIgPSBuZXcgRURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdG9yQ29tcGxleCxhZGFwdGl2ZVN0ZXBTdHJhdGVneSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGVkYWVTeXN0ZW0gPSBuZXcgRURBRUp1bXBpbmdCYWxsKDEwLGspO1xyXG4gICAgICAgIGxldCBlZGFlU29sdXRpb247XHJcbiAgICAgICAgZWRhZVNvbHV0aW9uID0gZWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCx0MSxlZGFlZVJLNFNvbHZlcixlZGFlU3lzdGVtKTtcclxuICAgICAgICBUZXN0LnNob3dPdXRwdXQoZWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsbnVsbF0sW10sXCJKdW1waW5nIGJhbGwgZWRhZSBjb21wbGV4IHdpdGggc3RlcFwiKTtcclxuICAgICAgICBlZGFlSHlicmlkU29sdmVyID0gbmV3IEVEQUVIeWJyaWRTb2x2ZXIoZXZlbnREZXRlY3RvclNpbXBsZSxhZGFwdGl2ZVN0ZXBTdHJhdGVneSk7XHJcbiAgICAgICAgZWRhZVNvbHV0aW9uID0gZWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCx0MSxlZGFlZVJLNFNvbHZlcixlZGFlU3lzdGVtKTtcclxuICAgICAgICBUZXN0LnNob3dPdXRwdXQoZWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsbnVsbF0sW10sXCJKdW1waW5nIGJhbGwgZWRhZSBzaW1wbGUgd2l0aCBzdGVwXCIpO1xyXG4gICAgICAgIGVkYWVIeWJyaWRTb2x2ZXIgPSBuZXcgRURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdG9yQ29tcGxleCxudWxsKTtcclxuICAgICAgICBlZGFlU29sdXRpb24gPSBlZGFlSHlicmlkU29sdmVyLnNvbHZlKGluaXRpYWxTdGF0ZSwwLHQxLGVkYWVlUks0U29sdmVyLGVkYWVTeXN0ZW0pO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChlZGFlU29sdXRpb24udmFsdWVzLFtcInhcIixudWxsXSxbXSxcIkp1bXBpbmcgYmFsbCBlZGFlIGNvbXBsZXhcIik7XHJcbiAgICAgICAgZWRhZUh5YnJpZFNvbHZlciA9IG5ldyBFREFFSHlicmlkU29sdmVyKGV2ZW50RGV0ZWN0b3JTaW1wbGUsbnVsbCk7XHJcbiAgICAgICAgZWRhZVNvbHV0aW9uID0gZWRhZUh5YnJpZFNvbHZlci5zb2x2ZShpbml0aWFsU3RhdGUsMCx0MSxlZGFlZVJLNFNvbHZlcixlZGFlU3lzdGVtKTtcclxuICAgICAgICBUZXN0LnNob3dPdXRwdXQoZWRhZVNvbHV0aW9uLnZhbHVlcyxbXCJ4XCIsbnVsbF0sW10sXCJKdW1waW5nIGJhbGwgZWRhZSBzaW1wbGVcIik7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KGdldEFuYWx0eXRpY0p1bXBpbmdCYWxsKGluaXRpYWxTdGF0ZS5nZXQoMCksaW5pdGlhbFN0YXRlLmdldCgxKSx0MSwwLjEsayksW1wieFwiXSxbXSxcIkp1bXBpbmcgYmFsbCBhbmFseXRpY2FsXCIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RBbGdlYnJhaWMoKTp2b2lke1xyXG4gICAgICAgIGNsYXNzIEFsZ2VicmFpY1Byb2JsZW0gaW1wbGVtZW50cyBJREFFU3lzdGVtXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmKHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6dmVjdG9ye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtNYXRoLnNpbih0K3ouZ2V0KDApKS10KnouZ2V0KDApXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRmZHooKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwwLDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRnZHgoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFtdLDEsMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGdkeih4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW01hdGguY29zKHQrei5nZXQoMCkpLXRdLDEsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3goKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW5ndGhfeigpOm51bWJlcntcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0MCA9IDAuNTtcclxuICAgICAgICBsZXQgdDEgPSAwLjg7XHJcbiAgICAgICAgbGV0IGlkYWVlRXVsZXJTb2x2ZXIgPSBuZXcgSURBRV9FRXVsZXIoMC4xLG5ldyBOZXd0b25Tb2x2ZXIoMTYwLDAuMDUsMWUtNCwwLjUpKTtcclxuICAgICAgICBsZXQgaWRhZWlFdWxlclNvbHZlciA9IG5ldyBJREFFX0lFdWxlcigwLjA1LG5ldyBOZXd0b25Tb2x2ZXIoODAsMC4wNSwxZS00LDAuNzUpKTtcclxuICAgICAgICBsZXQgc3lzdGVtID0gbmV3IEFsZ2VicmFpY1Byb2JsZW0oKTtcclxuICAgICAgICBsZXQgSURBRUVTb2x1dGlvbiA9IHNvbHZlSW1wbGljaXQobmV3IHZlY3RvcihbXSksdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeigpKSx0MCx0MSxpZGFlZUV1bGVyU29sdmVyLHN5c3RlbSk7ICAgICBcclxuICAgICAgICBsZXQgSURBRUlTb2x1dGlvbiA9IHNvbHZlSW1wbGljaXQobmV3IHZlY3RvcihbXSksdmVjdG9yLmVtcHR5KHN5c3RlbS5sZW5ndGhfeigpKSx0MCx0MSxpZGFlaUV1bGVyU29sdmVyLHN5c3RlbSk7XHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KElEQUVFU29sdXRpb24sW10sW1wielwiXSxcIkFsZ2VicmFpYyBwcm9ibGVtIElEQUVFXCIpO1xyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChJREFFSVNvbHV0aW9uLFtdLFtcInpcIl0sXCJBbGdlYnJhaWMgcHJvYmxlbSBJREFFSVwiKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0ZXN0RURBRUNvbXBpbGVyKCk6dm9pZHtcclxuICAgICAgICB1aS5jbGVhckVycm9ycygpO1xyXG4gICAgICAgIFRlc3QuaW5pdFBsb3QoKTtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJzID0gdWkuZ2V0UGFyYW1ldGVycygpO1xyXG4gICAgICAgICAgICBsZXQgdGV4dDpzdHJpbmcgPSAkKFwiI3RleHQtaW5wdXRcIikudmFsKCkgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICBsZXQgY29tcGlsZXIgPSBuZXcgREFFQ29tcGlsZXIoKTtcclxuICAgICAgICAgICAgbGV0IHtzeXN0ZW0seDAseCx6fSA9IGNvbXBpbGVyLmNvbXBpbGVFeHBsaWNpdCh0ZXh0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBzb2x2ZXIgPSBuZXcgRURBRV9SSzQocGFyYW1ldGVycy5zb2x2ZXIuc3RlcCk7XHJcbiAgICAgICAgICAgIGxldCB0MCA9IHBhcmFtZXRlcnMuc29sdmVyLnQwO1xyXG4gICAgICAgICAgICBsZXQgdDEgPSBwYXJhbWV0ZXJzLnNvbHZlci50MCArIHBhcmFtZXRlcnMuc29sdmVyLnRpbWU7XHJcbiAgICAgICAgICAgIGxldCBzb2x1dGlvbiA9IHNvbHZlRXhwbGljaXQoeDAsdDAsdDEsc29sdmVyLHN5c3RlbSk7XHJcbiAgICAgICAgICAgIFRlc3Quc2hvd091dHB1dChzb2x1dGlvbix4LHosXCJUZXN0IGVkYWUgY29tcGlsZXJcIik7XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJyZXN1bHRzXCIpO1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3JzKGUpO1xyXG4gICAgICAgICAgICB1aS5vcGVuVGFiKFwibWFpblwiKTtcclxuICAgICAgICAgICAgdWkub3BlblRhYihcImVycm9ycy10YWJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RJREFFQ29tcGlsZXIoKTp2b2lke1xyXG4gICAgICAgIHVpLmNsZWFyRXJyb3JzKCk7XHJcbiAgICAgICAgVGVzdC5pbml0UGxvdCgpO1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHBhcmFtZXRlcnMgPSB1aS5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0OnN0cmluZyA9ICQoXCIjdGV4dC1pbnB1dFwiKS52YWwoKSBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIGxldCBjb21waWxlciA9IG5ldyBEQUVDb21waWxlcigpO1xyXG4gICAgICAgICAgICBsZXQge3N5c3RlbSx4MCx4LHosejB9ID0gY29tcGlsZXIuY29tcGlsZUltcGxpY2l0KHRleHQpO1xyXG4gICAgICAgICAgICBsZXQgcyA9IHBhcmFtZXRlcnMuc29sdmVyLmltcGxpY2l0U3lzdGVtU29sdmVyO1xyXG4gICAgICAgICAgICBsZXQgc29sdmVyID0gbmV3IElEQUVfUks0KHBhcmFtZXRlcnMuc29sdmVyLnN0ZXAsXHJcbiAgICAgICAgICAgICAgICBuZXcgTmV3dG9uU29sdmVyKHMuaXRlcnMscy5hYnNUb2wscy5yZWxUb2wscy5hbHBoYSxzLm1pbkl0ZXJzKSk7XHJcbiAgICAgICAgICAgIGxldCB0MCA9IHBhcmFtZXRlcnMuc29sdmVyLnQwO1xyXG4gICAgICAgICAgICBsZXQgdDEgPSBwYXJhbWV0ZXJzLnNvbHZlci50MCArIHBhcmFtZXRlcnMuc29sdmVyLnRpbWU7XHJcbiAgICAgICAgICAgIGxldCBzb2x1dGlvbiA9IHNvbHZlSW1wbGljaXQoeDAsejAsdDAsdDEsc29sdmVyLHN5c3RlbSk7XHJcbiAgICAgICAgICAgIFRlc3Quc2hvd091dHB1dChzb2x1dGlvbix4LHosXCJUZXN0IGlkYWUgY29tcGlsZXJcIik7XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJyZXN1bHRzXCIpO1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3JzKGUpO1xyXG4gICAgICAgICAgICB1aS5vcGVuVGFiKFwibWFpblwiKTtcclxuICAgICAgICAgICAgdWkub3BlblRhYihcImVycm9ycy10YWJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RFeHBsaWNpdEh5YnJpZENvbXBpbGVyKCk6dm9pZHtcclxuICAgICAgICB1aS5jbGVhckVycm9ycygpO1xyXG4gICAgICAgIFRlc3QuaW5pdFBsb3QoKTtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0OnN0cmluZyA9ICQoXCIjdGV4dC1pbnB1dFwiKS52YWwoKSBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIGxldCBjb21waWxlciA9IG5ldyBIeWJyaWRTeXN0ZW1Db21waWxlcigpO1xyXG4gICAgICAgICAgICBsZXQgc3lzRGVmID0gY29tcGlsZXIuY29tcGlsZUV4cGxpY2l0KHRleHQpO1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1ldGVycyA9IHVpLmdldFBhcmFtZXRlcnMoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBldmVudERldGVjdGlvbjpFdmVudERldGVjdGlvbjtcclxuICAgICAgICAgICAgaWYocGFyYW1ldGVycy5ldmVudERldGVjdGlvbi56ZXJvQ3Jvc3NpbmcuZW5hYmxlZCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gcGFyYW1ldGVycy5ldmVudERldGVjdGlvbi56ZXJvQ3Jvc3Npbmc7XHJcbiAgICAgICAgICAgICAgICBldmVudERldGVjdGlvbiA9IG5ldyBFdmVudERldGVjdGlvbkNvbXBsZXgoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5ld3Rvbkl0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5yZWxUb2wscGFyYW1zLmFic1RvbCxwYXJhbXMubmV3dG9uQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJpc2VjdEl0ZXJzLHBhcmFtcy50aW1lQWJzVG9sLHBhcmFtcy50aW1lUmVsVG9sKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBldmVudERldGVjdGlvbiA9IG5ldyBFdmVudERldGVjdGlvblNpbXBsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhZGFwdGl2ZVN0ZXBTdHJhdGVneTpBZGFwdGl2ZVN0ZXBTdHJhdGVneTtcclxuICAgICAgICAgICAgaWYocGFyYW1ldGVycy5ldmVudERldGVjdGlvbi5hZGFwdGl2ZVN0ZXAuZW5hYmxlZCl7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGFkYXB0aXZlU3RlcFN0cmF0ZWd5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdDAgPSBwYXJhbWV0ZXJzLnNvbHZlci50MDtcclxuICAgICAgICAgICAgbGV0IHQxID0gdDAgKyBwYXJhbWV0ZXJzLnNvbHZlci50aW1lO1xyXG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gdWkubWV0aG9kc1twYXJhbWV0ZXJzLnNvbHZlci5tZXRob2RdLmVkYWVJbml0KHBhcmFtZXRlcnMpO1xyXG4gICAgICAgICAgICBsZXQgc29sdmVyID0gbmV3IEVEQUVIeWJyaWRTb2x2ZXIoZXZlbnREZXRlY3Rpb24sYWRhcHRpdmVTdGVwU3RyYXRlZ3kpO1xyXG4gICAgICAgICAgICBsZXQgc29sdXRpb24gPSBzb2x2ZXIuc29sdmUoc3lzRGVmLngwLHQwLHQxLG1ldGhvZCxzeXNEZWYuc3lzdGVtKTtcclxuICAgICAgICAgICAgVGVzdC5zaG93T3V0cHV0KHNvbHV0aW9uLnZhbHVlcyxzeXNEZWYueCxzeXNEZWYueixcIlRlc3QgZXhwbGljaXQgaHlicmlkIGNvbXBpbGVyXCIpO1xyXG4gICAgICAgICAgICAvL3VpLnBsb3RTb2x1dGlvbihzb2x1dGlvbixzeXNEZWYueCxzeXNEZWYueik7XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJyZXN1bHRzXCIpO1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3JzKGUpO1xyXG4gICAgICAgICAgICB1aS5vcGVuVGFiKFwibWFpblwiKTtcclxuICAgICAgICAgICAgdWkub3BlblRhYihcImVycm9ycy10YWJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHRlc3RTaW1wbGlmaWNhdGlvbigpOnZvaWR7XHJcbiAgICAgICAgdWkuY2xlYXJFcnJvcnMoKTtcclxuICAgICAgICBUZXN0LmluaXRQbG90KCk7XHJcbiAgICAgICAgbGV0IG1ldGhvZHM6e2FsZzpJU2ltcGxpZmljYXRpb25BbGdvcml0aG0sbmFtZTpzdHJpbmd9W10gPSBbXHJcbiAgICAgICAgICAgIHthbGc6bmV3IERvdWdsYXNQZXVja2VyU2ltcGxpZmljYXRpb24oMC4wMDUpLG5hbWU6XCJkb3VnbGFzUGV1Y2tlclwifSxcclxuICAgICAgICAgICAge2FsZzpuZXcgUGVycGVuZGljdWxhckRpc3RhbmNlU2ltcGxpZmljYXRpb24oMC4wMSksbmFtZTpcInBlcnBEaXN0XCJ9LFxyXG4gICAgICAgICAgICAvL3thbGc6bmV3IE1heFBvaW50c1NpbXBsaWZpY2F0aW9uKDEwMCksbmFtZTpcIm1heFBvaW50c1wifSxcclxuICAgICAgICAgICAge2FsZzpuZXcgUmFkaWFsRGlzdGFuY2VTaW1wbGlmaWNhdGlvbigwLjEpLG5hbWU6XCJyYWREaXN0XCJ9LFxyXG4gICAgICAgICAgICB7YWxnOm5ldyBMYW5nU2ltcGxpZmljYXRpb24oMC4xLDQpLG5hbWU6XCJsYW5nXCJ9LFxyXG4gICAgICAgICAgICB7YWxnOm5ldyBSZXVtYW5uV2l0a2FtU2ltcGxpZmljYXRpb24oMC4xKSxuYW1lOlwicmV1bWFubldpdGthbVwifSxcclxuICAgICAgICAgICAge2FsZzpuZXcgT3BoZWltU2ltcGxpZmljYXRpb24oMC4wNSwwLjEpLG5hbWU6XCJvcGhlaW1cIn0sXHJcbiAgICAgICAgICAgIHthbGc6bmV3IERvdWdsYXNQZXVja2VyTlNpbXBsaWZpY2F0aW9uKDEwMCksbmFtZTpcImRvdWdsYXNQZXVja2VyTlwifSxcclxuICAgICAgICAgICAge2FsZzpuZXcgTnRoUG9pbnRTaW1wbGlmaWNhdGlvbigxMDApLG5hbWU6XCJOdGggcG9pbnQgc2ltcGxpZmljYXRpb25cIn1cclxuICAgICAgICBdO1xyXG4gICAgICAgIGxldCBkYXRhOkRBRVZlY3RvcltdID0gW107XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTwxMDAwO2krKyl7XHJcbiAgICAgICAgICAgIGxldCB0ID0gaSowLjAxO1xyXG4gICAgICAgICAgICBsZXQgeCA9IE1hdGguY29zKHQqNi4wKSpNYXRoLmV4cCgtMi4qdCk7XHJcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgREFFVmVjdG9yKG5ldyB2ZWN0b3IoW3hdKSxuZXcgdmVjdG9yKFtdKSx0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRlc3Quc2hvd091dHB1dChkYXRhLFtcInhcIl0sW10sXCJzaW4gb3V0cHV0XCIpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8bWV0aG9kcy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IHJlcyA9IG1ldGhvZHNbaV0uYWxnLnNpbXBsaWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICBUZXN0LnNob3dPdXRwdXQocmVzLFtcInhcIl0sW10sbWV0aG9kc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgdWkuYWRkTG9nTWVzc2FnZShgJHttZXRob2RzW2ldLm5hbWV9OiAke3Jlcy5sZW5ndGh9IHBvaW50c2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1aS5vcGVuVGFiKFwicmVzdWx0c1wiKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0ZXN0SW1wbGljaXRIeWJyaWRDb21waWxlcigpOnZvaWR7XHJcbiAgICAgICAgdWkuY2xlYXJFcnJvcnMoKTtcclxuICAgICAgICBUZXN0LmluaXRQbG90KCk7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGV4dDpzdHJpbmcgPSAkKFwiI3RleHQtaW5wdXRcIikudmFsKCkgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICBsZXQgY29tcGlsZXIgPSBuZXcgSHlicmlkU3lzdGVtQ29tcGlsZXIoKTtcclxuICAgICAgICAgICAgbGV0IHN5c0RlZiA9IGNvbXBpbGVyLmNvbXBpbGVJbXBsaWNpdCh0ZXh0KTtcclxuICAgICAgICAgICAgbGV0IHBhcmFtZXRlcnMgPSB1aS5nZXRQYXJhbWV0ZXJzKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgZXZlbnREZXRlY3Rpb246RXZlbnREZXRlY3Rpb247XHJcbiAgICAgICAgICAgIGlmKHBhcmFtZXRlcnMuZXZlbnREZXRlY3Rpb24uemVyb0Nyb3NzaW5nLmVuYWJsZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHBhcmFtZXRlcnMuZXZlbnREZXRlY3Rpb24uemVyb0Nyb3NzaW5nO1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZXRlY3Rpb24gPSBuZXcgRXZlbnREZXRlY3Rpb25Db21wbGV4KFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5uZXd0b25JdGVycyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucmVsVG9sLHBhcmFtcy5hYnNUb2wscGFyYW1zLm5ld3RvbkFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5iaXNlY3RJdGVycyxwYXJhbXMudGltZUFic1RvbCxwYXJhbXMudGltZVJlbFRvbCk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZXRlY3Rpb24gPSBuZXcgRXZlbnREZXRlY3Rpb25TaW1wbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYWRhcHRpdmVTdGVwU3RyYXRlZ3k6QWRhcHRpdmVTdGVwU3RyYXRlZ3k7XHJcbiAgICAgICAgICAgIGlmKHBhcmFtZXRlcnMuZXZlbnREZXRlY3Rpb24uYWRhcHRpdmVTdGVwLmVuYWJsZWQpe1xyXG5cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBhZGFwdGl2ZVN0ZXBTdHJhdGVneSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHQwID0gcGFyYW1ldGVycy5zb2x2ZXIudDA7XHJcbiAgICAgICAgICAgIGxldCB0MSA9IHQwICsgcGFyYW1ldGVycy5zb2x2ZXIudGltZTtcclxuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IHVpLm1ldGhvZHNbcGFyYW1ldGVycy5zb2x2ZXIubWV0aG9kXS5pZGFlSW5pdChwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgbGV0IHNvbHZlciA9IG5ldyBJREFFSHlicmlkU29sdmVyKGV2ZW50RGV0ZWN0aW9uLGFkYXB0aXZlU3RlcFN0cmF0ZWd5KTtcclxuICAgICAgICAgICAgbGV0IHNvbHV0aW9uID0gc29sdmVyLnNvbHZlKHN5c0RlZi54MCxzeXNEZWYuejAsdDAsdDEsbWV0aG9kLHN5c0RlZi5zeXN0ZW0pO1xyXG4gICAgICAgICAgICBUZXN0LnNob3dPdXRwdXQoc29sdXRpb24udmFsdWVzLHN5c0RlZi54LHN5c0RlZi56LFwiVGVzdCBleHBsaWNpdCBoeWJyaWQgY29tcGlsZXJcIik7XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJyZXN1bHRzXCIpO1xyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgaWYoZSBpbnN0YW5jZW9mIENvbXBpbGVyRXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoaXRlbS5wcmludCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLnByaW50KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKGUgaW5zdGFuY2VvZiBFcnJvcil7XHJcbiAgICAgICAgICAgICAgICB1aS5hZGRMb2dNZXNzYWdlKGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoXCJFeGNlcHRpb246IFwiK2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJtYWluXCIpO1xyXG4gICAgICAgICAgICB1aS5vcGVuVGFiKFwiZXJyb3JzLXRhYlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdGVzdFdlaXNzaW5nZXJJbXBsaWNpdCgpe1xyXG4gICAgICAgIGNsYXNzIElXZWlzc2luZ2VyIGltcGxlbWVudHMgSURBRVN5c3RlbXtcclxuICAgICAgICAgICAgZih4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIGxldCBfeCA9IHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF9keCA9IGR4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdmVjdG9yKFtcclxuICAgICAgICAgICAgICAgICAgICB0Kk1hdGgucG93KF94LDIpKk1hdGgucG93KF9keCwzKS1cclxuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhfeCwzKSpNYXRoLnBvdyhfZHgsMikrXHJcbiAgICAgICAgICAgICAgICAgICAgdCoodCp0KzEpKl9keC10KnQqX3hcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGcoeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOnZlY3RvcntcclxuICAgICAgICAgICAgICAgIGxldCBfeiA9IHouZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB2ZWN0b3IoW196IC0gTWF0aC5zcXJ0KHQqdCswLjUpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkeCh4OnZlY3RvcixkeDp2ZWN0b3Isejp2ZWN0b3IsdDpudW1iZXIpOm1hdHJpeHtcclxuICAgICAgICAgICAgICAgIGxldCBfeCA9IHguZ2V0KDApO1xyXG4gICAgICAgICAgICAgICAgbGV0IF9keCA9IGR4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0cml4KFxyXG4gICAgICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICAgICAyKnQqX3gqTWF0aC5wb3coX2R4LDMpLTMqTWF0aC5wb3coX3gqX2R4LDIpLXQqdCBcclxuICAgICAgICAgICAgICAgICAgICBdLDEsMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGZkZHgoeDp2ZWN0b3IsZHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICBsZXQgX3ggPSB4LmdldCgwKTtcclxuICAgICAgICAgICAgICAgIGxldCBfZHggPSBkeC5nZXQoMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXHJcbiAgICAgICAgICAgICAgICAgICAgMyp0Kk1hdGgucG93KF94Kl9keCwyKS0yKk1hdGgucG93KF94LDMpKl9keCt0Kih0KnQrMSlcclxuICAgICAgICAgICAgICAgIF0sMSwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZmR6KHg6dmVjdG9yLGR4OnZlY3Rvcix6OnZlY3Rvcix0Om51bWJlcik6bWF0cml4e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBtYXRyaXgoW10sMCwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R6KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbMV0sMSwxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZ2R4KHg6dmVjdG9yLHo6dmVjdG9yLHQ6bnVtYmVyKTptYXRyaXh7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IG1hdHJpeChbXSwxLDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbmd0aF94KCk6bnVtYmVye1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoX3ooKTpudW1iZXJ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdDAgPSAwO1xyXG4gICAgICAgIGxldCB0MSA9IDE7XHJcbiAgICAgICAgbGV0IHN5c3RlbSA9IG5ldyBJV2Vpc3NpbmdlcigpO1xyXG4gICAgICAgIGxldCBzb2x2ZXIgPSBuZXcgSURBRV9SSzQoMC4wMSxuZXcgTmV3dG9uU29sdmVyKDIwLDFlLTMsMWUtNSwwLjk1LDMpKTtcclxuICAgICAgICBsZXQgc29sdXRpb24gPSBzb2x2ZUltcGxpY2l0KG5ldyB2ZWN0b3IoW01hdGguc3FydCgzLzIpXSksbmV3IHZlY3RvcihbMF0pLHQwLHQxLHNvbHZlcixzeXN0ZW0pOyAgXHJcbiAgICAgICAgVGVzdC5zaG93T3V0cHV0KHNvbHV0aW9uLFtcInhcIl0sW1wielwiXSxcIkltcGxpY2l0IHdlaXNzaW5nZXJcIik7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQge2V4YW1wbGVzfSBmcm9tIFwiLi9leGFtcGxlc1wiO1xyXG5pbXBvcnQgJCBmcm9tIFwianF1ZXJ5XCI7XHJcbmltcG9ydCB7IERBRVZlY3RvciB9IGZyb20gXCIuL2RhZS9kYWVWZWN0b3JcIjtcclxuaW1wb3J0IEVycm9yTWVzc2FnZSBmcm9tIFwiLi9jb21waWxlci9lcnJvclwiO1xyXG5pbXBvcnQgeyBUZXN0IH0gZnJvbSBcIi4vdGVzdC90ZXN0XCI7XHJcbmltcG9ydCB7IEVEQUVIeWJyaWRTb2x2ZXJ9IGZyb20gXCIuL2RhZS9lZGFlSHlicmlkU29sdmVyXCI7XHJcbmltcG9ydCB7IElEQUVIeWJyaWRTb2x2ZXIgfSBmcm9tIFwiLi9kYWUvaWRhZUh5YnJpZFNvbHZlclwiO1xyXG5pbXBvcnQgeyBIeWJyaWRTeXN0ZW1Db21waWxlciB9IGZyb20gXCIuL2NvbXBpbGVyL2h5YnJpZENvbXBpbGVyXCI7XHJcbmltcG9ydCB7IENvbXBpbGVyRXJyb3IgfSBmcm9tIFwiLi9jb21waWxlci9jb21waWxlckVycm9yXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0ZWN0aW9uU2ltcGxlLEV2ZW50RGV0ZWN0aW9uQ29tcGxleCwgRXZlbnREZXRlY3Rpb24gfSBmcm9tIFwiLi9kYWUvZXZlbnREZXRlY3Rpb25cIjtcclxuaW1wb3J0IHsgQWRhcHRpdmVTdGVwU3RyYXRlZ3kgfSBmcm9tIFwiLi9kYWUvYWRhcHRpdmVTdGVwXCI7XHJcbmltcG9ydCB7IEVEQUVTb2x2ZXIgfSBmcm9tIFwiLi9kYWUvZWRhZVNvbHZlclwiO1xyXG5pbXBvcnQgeyBJREFFU29sdmVyIH0gZnJvbSBcIi4vZGFlL2lkYWVTb2x2ZXJcIjtcclxuaW1wb3J0IHsgSHlicmlkU29sdXRpb24gfSBmcm9tIFwiLi9kYWUvaHlicmlkU29sdXRpb25cIjtcclxuaW1wb3J0IHsgVGV4dFBvc2l0aW9uIH0gZnJvbSBcIi4vY29tcGlsZXIvYXN0Tm9kZVwiO1xyXG5pbXBvcnQgeyBtZXRob2RzLCBVSVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9tZXRob2RzXCI7XHJcblxyXG5cclxuXHJcbi8vdGFicyBpbml0XHJcbmV4cG9ydCBjb25zdCB1aSA9IHtcclxuICAgIGlzUmVzdWx0c1RhYjpmYWxzZSxcclxuICAgIG1ldGhvZHM6bWV0aG9kcyxcclxuICAgIHNob3dEZWJ1ZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICQoXCIjZGVidWdcIikuY3NzKFwiZGlzcGxheVwiLFwiYmxvY2tcIik7XHJcbiAgICB9LFxyXG4gICAgaGlkZURlYnVnOmZ1bmN0aW9uKCl7XHJcbiAgICAgICAgJChcIiNkZWJ1Z1wiKS5jc3MoXCJkaXNwbGF5XCIsXCJub25lXCIpO1xyXG4gICAgfSxcclxuICAgIGluaXQ6ZnVuY3Rpb24oKXtcclxuICAgICAgICAvL2luaXQgZGVidWdcclxuICAgICAgICAkKFwiI2RlYnVnXCIpLmFwcGVuZCgnPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiIGlkPVwiZGVidWctaGlkZVwiPkhpZGU8L2J1dHRvbj4nKTtcclxuICAgICAgICAkKFwiI2RlYnVnLWhpZGVcIikuY2xpY2sodWkuaGlkZURlYnVnKTtcclxuICAgICAgICAkKFwiI2RlYnVnXCIpLmFwcGVuZCgnPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiIGlkPVwiZWRhZS10ZXN0XCI+VGVzdCBFREFFPC9idXR0b24+Jyk7XHJcbiAgICAgICAgJChcIiNkZWJ1Z1wiKS5hcHBlbmQoJzxidXR0b24gY2xhc3M9XCJidXR0b25cIiBpZD1cImlkYWUtdGVzdFwiPlRlc3QgSURBRTwvYnV0dG9uPicpO1xyXG4gICAgICAgICQoXCIjZGVidWdcIikuYXBwZW5kKCc8YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCIgaWQ9XCJlLWh5YnJpZC10ZXN0XCI+VGVzdCBFeHBsaWNpdCBIeWJyaWQ8L2J1dHRvbj4nKTtcclxuICAgICAgICAkKFwiI2RlYnVnXCIpLmFwcGVuZCgnPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiIGlkPVwiaS1oeWJyaWQtdGVzdFwiPlRlc3QgSW1wbGljaXQgSHlicmlkPC9idXR0b24+Jyk7XHJcbiAgICAgICAgJCgnI2VkYWUtdGVzdCcpLmNsaWNrKFRlc3QudGVzdEVEQUVDb21waWxlcik7XHJcbiAgICAgICAgJCgnI2lkYWUtdGVzdCcpLmNsaWNrKFRlc3QudGVzdElEQUVDb21waWxlcik7XHJcbiAgICAgICAgJCgnI2UtaHlicmlkLXRlc3QnKS5jbGljayhUZXN0LnRlc3RFeHBsaWNpdEh5YnJpZENvbXBpbGVyKTtcclxuICAgICAgICAkKCcjaS1oeWJyaWQtdGVzdCcpLmNsaWNrKFRlc3QudGVzdEltcGxpY2l0SHlicmlkQ29tcGlsZXIpO1xyXG5cclxuICAgICAgICAkKFwiI3J1bi1idXR0b25cIikuY2xpY2sodWkucnVuKTtcclxuICAgICAgICAkKFwiI2V4cG9ydC1idXR0b25cIikuY2xpY2sodWkucnVuKTtcclxuICAgICAgICAkKCcqW2RhdGEtcm9sZT1cInRhYlwiXScpLmNsaWNrKFxyXG4gICAgICAgIGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgICAgICB1aS5vcGVuVGFiKCQoZS50YXJnZXQpLmRhdGEoXCJ0YWJcIikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBleGFtcGxlc0NvbnRhaW5lciA9ICQoJyNleGFtcGxlcy1kYWUnKTtcclxuICAgICAgICBPYmplY3QuZW50cmllcyhleGFtcGxlcy5kYWUpLmZvckVhY2goZnVuY3Rpb24oW2tleSx2YWx1ZV0pe1xyXG4gICAgICAgICAgICBleGFtcGxlc0NvbnRhaW5lci5hcHBlbmQoYDxidXR0b24gaWQ9XCIke2tleX1cIiBjbGFzcz1cImV4YW1wbGUtYnV0dG9uIGRhZSBidXR0b25cIj4ke3ZhbHVlLm5hbWV9PC9idXR0b25gKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgZXhhbXBsZXNDb250YWluZXIgPSAkKCcjZXhhbXBsZXMtaHlicmlkJyk7XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZXhhbXBsZXMuaHlicmlkKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksdmFsdWVdKXtcclxuICAgICAgICAgICAgZXhhbXBsZXNDb250YWluZXIuYXBwZW5kKGA8YnV0dG9uIGlkPVwiJHtrZXl9XCIgY2xhc3M9XCJleGFtcGxlLWJ1dHRvbiBoeWJyaWQgYnV0dG9uXCI+JHt2YWx1ZS5uYW1lfTwvYnV0dG9uYClcclxuICAgICAgICB9KVxyXG4gICAgICAgICQoJy5leGFtcGxlLWJ1dHRvbi5kYWUnKS5jbGljayhmdW5jdGlvbih0aGlzLGUpe1xyXG4gICAgICAgICAgICB1aS5sb2FkRGFlRXhhbXBsZSh0aGlzLmlkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcuZXhhbXBsZS1idXR0b24uaHlicmlkJykuY2xpY2soZnVuY3Rpb24odGhpcyxlKXtcclxuICAgICAgICAgICAgdWkubG9hZEh5YnJpZEV4YW1wbGUodGhpcy5pZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHN0ZXBDb250cm9sID0gJCgnI3N0ZXAtY29udHJvbCcpO1xyXG4gICAgICAgIGxldCBzdGVwU29sdmVyID0gJCgnI3N0ZXAtc29sdmVyJyk7XHJcbiAgICAgICAgbGV0IHN5c3RlbVNvbHZlciA9ICQoJyNzeXN0ZW0tc29sdmVyJyk7XHJcbiAgICAgICAgbGV0IGFkYXB0aXZlID0gJCgnI2FkYXB0aXZlJyk7XHJcbiAgICAgICAgbGV0IHplcm9Dcm9zc2luZyA9ICQoJyN6ZXJvLWNyb3NzaW5nJyk7XHJcbiAgICAgICAgbGV0IHNpbXBsaWZpY2F0aW9uID0gJCgnI3NpbXBsaWZpY2F0aW9uJyk7XHJcbiAgICAgICAgbGV0IGFkYXB0aXZlR2FtbWEgPSAkKCcjYWRhcHRpdmUtZ2FtbWEnKTtcclxuICAgICAgICBsZXQgYWRhcHRpdmVNaW5TdGVwID0gJCgnI2FkYXB0aXZlLW1pbi1zdGVwJyk7XHJcbiAgICAgICAgbGV0IHplcm9Dcm9zc2luZ05ld3Rvbkl0ZXJhdGlvbnMgPSAkKCcjbmV3dG9uLWl0ZXJhdGlvbnMtemVyby1jcm9zc2luZycpO1xyXG4gICAgICAgIGxldCB6ZXJvQ3Jvc3NpbmdOZXd0b25BbHBoaGEgPSAkKCcjYWxwaGEtemVyby1jcm9zc2luZycpO1xyXG4gICAgICAgIGxldCB6ZXJvQ3Jvc3NpbmdBYnNUb2wgPSAkKCcjYWJzLXRvbC16ZXJvLWNyb3NzaW5nJyk7XHJcbiAgICAgICAgbGV0IHplcm9Dcm9zc2luZ1JlbFRvbCA9ICQoJyNyZWwtdG9sLXplcm8tY3Jvc3NpbmcnKTtcclxuICAgICAgICBsZXQgemVyb0Nyb3NzaW5nQmlzZWN0aW9uSXRlcmF0aW9ucyA9ICQoJyNiaXNlY3Rpb24taXRlcmF0aW9ucy16ZXJvLWNyb3NzaW5nJyk7XHJcbiAgICAgICAgbGV0IHplcm9Dcm9zc2luZ1RpbWVSZXNBYnNUb2wgPSAkKCcjdGltZS1hYnMtdG9sLXplcm8tY3Jvc3NpbmcnKTtcclxuICAgICAgICBsZXQgemVyb0Nyb3NzaW5nVGltZVJlc1JlbFRvbCA9ICQoJyN0aW1lLXJlbC10b2wtemVyby1jcm9zc2luZycpO1xyXG4gICAgICAgIGxldCBzaW1wbGlmaWNhdGlvbk1ldGhvZCA9ICQoJyNzaW1wbGlmaWNhdGlvbi1tZXRob2QnKTtcclxuICAgICAgICBsZXQgc2ltcGxpZmljYXRpb25Qb2ludHNMaW1pdCA9ICQoJyNzaW1wbGlmaWNhdGlvbi1saW1pdCcpO1xyXG4gICAgICAgICQoJyNkYWUtZm9ybScpLmNoYW5nZShmdW5jdGlvbih0aGlzKXtcclxuICAgICAgICAgICAgaWYoJCh0aGlzKS52YWwoKT09XCJleHBsaWNpdFwiKVxyXG4gICAgICAgICAgICAgICAgc3lzdGVtU29sdmVyLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN5c3RlbVNvbHZlci5hdHRyKFwiZGlzYWJsZWRcIixudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjZGFlLWZvcm0nKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xyXG4gICAgICAgIGxldCBleHBsaWNpdE1ldGhvZHMgPSAkKFwiI2V4cGxpY2l0TWV0aG9kc1wiKTtcclxuICAgICAgICBsZXQgaW1wbGljaXRNZXRob2RzID0gJChcIiNpbXBsaWNpdE1ldGhvZHNcIik7XHJcbiAgICAgICAgLy9pbml0IG1ldGhvZHMgc2VsZWN0IGVsZW1lbnRcclxuICAgICAgICBPYmplY3QuZW50cmllcyhtZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uKFtrZXksaXRlbV0pe1xyXG4gICAgICAgICAgICBsZXQgZWwgPSBgPG9wdGlvbiB2YWx1ZT1cIiR7a2V5fVwiPiR7aXRlbS5uYW1lfTwvb3B0aW9uPmA7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0uaW1wbGljaXQpe1xyXG4gICAgICAgICAgICAgICAgaW1wbGljaXRNZXRob2RzLmFwcGVuZChlbCk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgZXhwbGljaXRNZXRob2RzLmFwcGVuZChlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjbWV0aG9kJykuY2hhbmdlKGZ1bmN0aW9uKHRoaXMpe1xyXG4gICAgICAgICAgICBpZihtZXRob2RzWyQodGhpcykudmFsKCkgYXMgc3RyaW5nXS5hdXRvc3RlcD09dHJ1ZSlcclxuICAgICAgICAgICAgICAgIHN0ZXBDb250cm9sLmF0dHIoXCJkaXNhYmxlZFwiLG51bGwpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzdGVwQ29udHJvbC5hdHRyKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICBpZihtZXRob2RzWyQodGhpcykudmFsKCkgYXMgc3RyaW5nXS5pbXBsaWNpdD09dHJ1ZSlcclxuICAgICAgICAgICAgICAgIHN0ZXBTb2x2ZXIuYXR0cihcImRpc2FibGVkXCIsbnVsbCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN0ZXBTb2x2ZXIuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjbWV0aG9kJykudHJpZ2dlcihcImNoYW5nZVwiKTtcclxuICAgICAgICAkKCcjYWRhcHRpdmUtc3RlcCcpLmNoYW5nZShmdW5jdGlvbih0aGlzKXtcclxuICAgICAgICAgICAgaWYoJCh0aGlzKS5wcm9wKFwiY2hlY2tlZFwiKSl7XHJcbiAgICAgICAgICAgICAgICBhZGFwdGl2ZS5hdHRyKFwiZGlzYWJsZWRcIixudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgYWRhcHRpdmUuYXR0cihcImRpc2FibGVkXCIsXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjYWRhcHRpdmUtc3RlcCcpLnRyaWdnZXIoXCJjaGFuZ2VcIik7XHJcbiAgICAgICAgJCgnI3plcm8tY3Jvc3NpbmctZGV0ZWN0aW9uJykuY2hhbmdlKGZ1bmN0aW9uKHRoaXMpe1xyXG4gICAgICAgICAgICBpZigkKHRoaXMpLnByb3AoXCJjaGVja2VkXCIpKXtcclxuICAgICAgICAgICAgICAgIHplcm9Dcm9zc2luZy5hdHRyKFwiZGlzYWJsZWRcIixudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgemVyb0Nyb3NzaW5nLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjemVyby1jcm9zc2luZy1kZXRlY3Rpb24nKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xyXG4gICAgICAgICQoJyN1c2Utc2ltcGxpZmljYXRpb24nKS5jaGFuZ2UoZnVuY3Rpb24odGhpcyl7XHJcbiAgICAgICAgICAgIGlmKCQodGhpcykucHJvcChcImNoZWNrZWRcIikpe1xyXG4gICAgICAgICAgICAgICAgc2ltcGxpZmljYXRpb24uYXR0cihcImRpc2FibGVkXCIsbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHNpbXBsaWZpY2F0aW9uLmF0dHIoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAkKCcjdXNlLXNpbXBsaWZpY2F0aW9uJykudHJpZ2dlcihcImNoYW5nZVwiKTtcclxuICAgIH0sXHJcbiAgICBnZXRQYXJhbWV0ZXJzOmZ1bmN0aW9uKCk6VUlQYXJhbWV0ZXJze1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNvbHZlcjp7XHJcbiAgICAgICAgICAgICAgICBkYWVGb3JtOiQoXCIjZGFlLWZvcm1cIikudmFsKCkgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiQoXCIjbWV0aG9kXCIpLnZhbCgpIGFzIHN0cmluZyxcclxuICAgICAgICAgICAgICAgIHN0ZXA6cGFyc2VGbG9hdCgkKFwiI3N0ZXBcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgdDA6cGFyc2VGbG9hdCgkKFwiI3QwXCIpLnZhbCgpIGFzIHN0cmluZyksXHJcbiAgICAgICAgICAgICAgICB0aW1lOnBhcnNlRmxvYXQoJChcIiN0aW1lXCIpLnZhbCgpIGFzIHN0cmluZyksXHJcbiAgICAgICAgICAgICAgICBzdGVwQ29udHJvbDp7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluU3RlcDpwYXJzZUZsb2F0KCQoXCIjbWluLXN0ZXBcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgICAgIGVyclRvbDpwYXJzZUZsb2F0KCQoXCIjZXJyb3ItdG9sZXJhbmNlXCIpLnZhbCgpIGFzIHN0cmluZykqMWUtM1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGltcGxpY2l0U3RlcFNvbHZlcjp7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcnM6cGFyc2VGbG9hdCgkKFwiI2ltcGxpY2l0LWl0ZXJhdGlvbnNcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5JdGVyczpwYXJzZUZsb2F0KCQoXCIjaW1wbGljaXQtbWluLWl0ZXJhdGlvbnNcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICBhYnNUb2w6cGFyc2VGbG9hdCgkKFwiI2ltcGxpY2l0LWYtYWJzLXRvbFwiKS52YWwoKSBhcyBzdHJpbmcpKjFlLTMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVsVG9sOnBhcnNlRmxvYXQoJChcIiNpbXBsaWNpdC1mLXJlbC10b2xcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgICAgIGFscGhhOnBhcnNlRmxvYXQoJChcIiNpbXBsaWNpdC1hbHBoYVwiKS52YWwoKSBhcyBzdHJpbmcpXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaW1wbGljaXRTeXN0ZW1Tb2x2ZXI6e1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJzOnBhcnNlRmxvYXQoJChcIiNpZGFlLWl0ZXJhdGlvbnNcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5JdGVyczpwYXJzZUZsb2F0KCQoXCIjaWRhZS1taW4taXRlcmF0aW9uc1wiKS52YWwoKSBhcyBzdHJpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFic1RvbDpwYXJzZUZsb2F0KCQoXCIjaWRhZS1mLWFicy10b2xcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbFRvbDpwYXJzZUZsb2F0KCQoXCIjaWRhZS1mLXJlbC10b2xcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgICAgIGFscGhhOnBhcnNlRmxvYXQoJChcIiNpZGFlLWFscGhhXCIpLnZhbCgpIGFzIHN0cmluZylcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV2ZW50RGV0ZWN0aW9uOntcclxuICAgICAgICAgICAgICAgIGJvcmRlclRvbDpwYXJzZUZsb2F0KCQoXCIjemVyby1jcm9zc2luZy1ib3JkZXItdG9sXCIpLnZhbCgpIGFzIHN0cmluZykqMWUtMyxcclxuICAgICAgICAgICAgICAgIGFkYXB0aXZlU3RlcDp7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDokKFwiI2FkYXB0aXZlLXN0ZXBcIikudmFsKCk9PVwib25cIixcclxuICAgICAgICAgICAgICAgICAgICBnYW1tYTpwYXJzZUZsb2F0KCQoXCIjYWRhcHRpdmUtZ2FtbWFcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICBtaW5TdGVwOnBhcnNlRmxvYXQoJChcIiNhZGFwdGl2ZS1taW4tc3RlcFwiKS52YWwoKSBhcyBzdHJpbmcpKjFlLTMsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgemVyb0Nyb3NzaW5nOntcclxuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiQoXCIjemVyby1jcm9zc2luZy1kZXRlY3Rpb25cIikudmFsKCk9PVwib25cIixcclxuICAgICAgICAgICAgICAgICAgICBuZXd0b25JdGVyczpwYXJzZUludCgkKFwiI25ld3Rvbi1pdGVyYXRpb25zLXplcm8tY3Jvc3NpbmdcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXd0b25BbHBoYTpwYXJzZUZsb2F0KCQoXCIjYWxwaGEtemVyby1jcm9zc2luZ1wiKS52YWwoKSBhcyBzdHJpbmcpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFic1RvbDpwYXJzZUZsb2F0KCQoXCIjYWJzLXRvbC16ZXJvLWNyb3NzaW5nXCIpLnZhbCgpIGFzIHN0cmluZykqMWUtMyxcclxuICAgICAgICAgICAgICAgICAgICByZWxUb2w6cGFyc2VGbG9hdCgkKFwiI3JlbC10b2wtemVyby1jcm9zc2luZ1wiKS52YWwoKSBhcyBzdHJpbmcpKjFlLTMsXHJcbiAgICAgICAgICAgICAgICAgICAgYmlzZWN0SXRlcnM6cGFyc2VJbnQoJChcIiNiaXNlY3Rpb24taXRlcmF0aW9ucy16ZXJvLWNyb3NzaW5nXCIpLnZhbCgpIGFzIHN0cmluZyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZUFic1RvbDpwYXJzZUZsb2F0KCQoXCIjdGltZS1hYnMtdG9sLXplcm8tY3Jvc3NpbmdcIikudmFsKCkgYXMgc3RyaW5nKSoxZS0zLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVSZWxUb2w6cGFyc2VGbG9hdCgkKFwiI3RpbWUtcmVsLXRvbC16ZXJvLWNyb3NzaW5nXCIpLnZhbCgpIGFzIHN0cmluZykqMWUtM1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW1wbGlmaWNhdGlvbjp7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiQoXCIjdXNlLXNpbXBsaWZpY2F0aW9uXCIpLnZhbCgpPT1cIm9uXCIsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6JChcIiNzaW1wbGlmaWNhdGlvbi1tZXRob2RcIikudmFsKCkgYXMgc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgbWF4UG9pbnRzOnBhcnNlSW50KCQoXCIjc2ltcGxpZmljYXRpb24tbGltaXRcIikudmFsKCkgYXMgc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgIHRvbGVyYW5jZTpwYXJzZUZsb2F0KCQoXCIjc2ltcGxpZmljYXRpb24tdG9sZXJhbmNlXCIpLnZhbCgpIGFzIHN0cmluZylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgb3BlblRhYjpmdW5jdGlvbih0YWJJZDpzdHJpbmcpe1xyXG4gICAgICAgIGxldCB0YXJnZXQgPSAkKCdbZGF0YS1yb2xlPVwidGFiXCJdW2RhdGEtdGFiPVwiJyt0YWJJZCsnXCJdJyk7XHJcbiAgICAgICAgbGV0IHBhcmVudElkID0gdGFyZ2V0LmRhdGEoXCJwYXJlbnRcIik7XHJcbiAgICAgICAgbGV0IHBhcmVudD0kKCcjJytwYXJlbnRJZCk7XHJcbiAgICAgICAgJCgnW2RhdGEtcm9sZT1cInRhYi1pdGVtXCJdW2RhdGEtcGFyZW50PVwiJytwYXJlbnRJZCsnXCInKS5yZW1vdmVDbGFzcyhcInNob3dcIik7XHJcbiAgICAgICAgJCgnW2RhdGEtcm9sZT1cInRhYlwiXVtkYXRhLXBhcmVudD1cIicrcGFyZW50SWQrJ1wiJykucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XHJcbiAgICAgICAgdGFyZ2V0LmFkZENsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICAgICQoJyMnK3RhYklkKS5hZGRDbGFzcyhcInNob3dcIik7XHJcbiAgICAgICAgaWYodGFiSWQ9PVwicmVzdWx0c1wiKXtcclxuICAgICAgICAgICAgdWkuaXNSZXN1bHRzVGFiID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICBQbG90bHkucmVsYXlvdXQoJ3Bsb3QtYXJlYScse1xyXG4gICAgICAgICAgICB3aWR0aDokKFwiI3Bsb3QtYXJlYVwiKS53aWR0aCgpLFxyXG4gICAgICAgICAgICBoZWlnaHQ6JChcIiNwbG90LWFyZWFcIikuaGVpZ2h0KClcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHVpLmlzUmVzdWx0c1RhYiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsb2FkRGFlRXhhbXBsZTpmdW5jdGlvbihleGFtcGxlSWQ6c3RyaW5nKXtcclxuICAgICAgICAkKCcjdGV4dC1pbnB1dCcpLnZhbChleGFtcGxlcy5kYWVbZXhhbXBsZUlkXS50ZXh0KTtcclxuICAgIH0sXHJcbiAgICBsb2FkSHlicmlkRXhhbXBsZTpmdW5jdGlvbihleGFtcGxlSWQ6c3RyaW5nKXtcclxuICAgICAgICAkKCcjdGV4dC1pbnB1dCcpLnZhbChleGFtcGxlcy5oeWJyaWRbZXhhbXBsZUlkXS50ZXh0KTtcclxuICAgIH0sXHJcbiAgICBjbGVhckxvZzpmdW5jdGlvbigpe1xyXG4gICAgICAgICQoJyNsb2ctYXJlYScpLmVtcHR5KCk7XHJcbiAgICB9LFxyXG4gICAgY2xlYXJFcnJvcnM6ZnVuY3Rpb24oKXtcclxuICAgICAgICAkKCcjZXJyb3ItbGlzdCcpLmVtcHR5KCk7XHJcbiAgICB9LFxyXG4gICAgYWRkRXJyb3JNZXNzYWdlOmZ1bmN0aW9uKG1lc3NhZ2U6c3RyaW5nLHRleHRQb3M6VGV4dFBvc2l0aW9uKXtcclxuICAgICAgICAkKCcjZXJyb3ItbGlzdCcpLmFwcGVuZChgPGRpdiBjbGFzcz1cImVycm9ycy1yb3cke3RleHRQb3MubGluZT09LTE/XCJcIjpcIiBjbGlja2FibGVcIn1cIiBkYXRhLWxpbmU9XCIke3RleHRQb3MubGluZX1cIiBkYXRhLWNvbHVtbj1cIiR7dGV4dFBvcy5jb2x1bW59XCIgZGF0YS1zdGFydD1cIiR7dGV4dFBvcy5zdGFydH1cIiBkYXRhLXN0b3A9XCIke3RleHRQb3Muc3RvcH1cIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3JzLWNlbGxcIj4ke3RleHRQb3MubGluZT09LTE/XCJcIjp0ZXh0UG9zLmxpbmV9PC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVycm9ycy1jZWxsXCI+JHt0ZXh0UG9zLmxpbmU9PS0xP1wiXCI6dGV4dFBvcy5jb2x1bW59PC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImVycm9ycy1jZWxsXCI+JHttZXNzYWdlfTwvZGl2PlxyXG4gICAgICAgIDwvZGl2PmApO1xyXG4gICAgICAgIGlmKHRleHRQb3MubGluZSE9LTEpXHJcbiAgICAgICAgICAgICQoJyNlcnJvci1saXN0JykuY2hpbGRyZW4oKS5sYXN0KCkuY2xpY2sodWkub25DbGlja0Vycm9yTWVzc2FnZSk7XHJcbiAgICB9LFxyXG4gICAgc2V0Q3Vyc29yKGxpbmU6bnVtYmVyLHBvc2l0aW9uOm51bWJlcil7XHJcbiAgICAgICAgbGV0IGVsZW0gPSAkKFwiI3RleHQtaW5wdXRcIilbMF0gYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcclxuICAgICAgICBsZXQgcm93ID0gMTtcclxuICAgICAgICBsZXQgcG9zID0gMDtcclxuICAgICAgICB3aGlsZShyb3c8bGluZSl7XHJcbiAgICAgICAgICAgIGxldCBsaW5lRW5kID0gZWxlbS52YWx1ZS5pbmRleE9mKFwiXFxuXCIscG9zKTtcclxuICAgICAgICAgICAgaWYobGluZUVuZCA9PSAtMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93Kys7XHJcbiAgICAgICAgICAgIHBvcyA9IGxpbmVFbmQrMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxpbmVFbmQgPSBlbGVtLnZhbHVlLmluZGV4T2YoXCJcXG5cIixwb3MpO1xyXG4gICAgICAgIGxpbmVFbmQ9KGxpbmVFbmQ9PS0xP2VsZW0udmFsdWUubGVuZ3RoOmxpbmVFbmQpO1xyXG4gICAgICAgIHBvcyA9IE1hdGgubWluKGxpbmVFbmQscG9zICsgcG9zaXRpb24pO1xyXG4gICAgICAgIGVsZW0uZm9jdXMoKTtcclxuICAgICAgICBlbGVtLnNldFNlbGVjdGlvblJhbmdlKHBvcyxwb3MrMSk7XHJcbiAgICB9LFxyXG4gICAgb25DbGlja0Vycm9yTWVzc2FnZTpmdW5jdGlvbih0aGlzOkhUTUxFbGVtZW50KXtcclxuICAgICAgICBsZXQgbGluZSA9IHBhcnNlSW50KCQodGhpcykuZGF0YShcImxpbmVcIikpO1xyXG4gICAgICAgIGxldCBjb2x1bW4gPSBwYXJzZUludCgkKHRoaXMpLmRhdGEoXCJjb2x1bW5cIikpO1xyXG4gICAgICAgIGxldCBzdGFydCA9IHBhcnNlSW50KCQodGhpcykuZGF0YShcInN0YXJ0XCIpKTtcclxuICAgICAgICBsZXQgc3RvcCA9IHBhcnNlSW50KCQodGhpcykuZGF0YShcInN0b3BcIikpO1xyXG4gICAgICAgIGlmKHN0YXJ0ID09IC0xKVxyXG4gICAgICAgICAgICB1aS5zZXRDdXJzb3IobGluZSxjb2x1bW4pO1xyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCBlbGVtID0gJChcIiN0ZXh0LWlucHV0XCIpWzBdIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGVsZW0uZm9jdXMoKTtcclxuICAgICAgICAgICAgZWxlbS5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCxzdG9wKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgYWRkTG9nTWVzc2FnZTpmdW5jdGlvbihtZXNzYWdlOnN0cmluZyl7XHJcbiAgICAgICAgbGV0IGxvZ0FyZWEgPSAgJCgnI2xvZy1hcmVhJyk7XHJcbiAgICAgICAgbGV0IGNoaWxkcyA9IGxvZ0FyZWEuY2hpbGRyZW4oKTtcclxuICAgICAgICBsZXQgaT0wO1xyXG4gICAgICAgIHdoaWxlKGNoaWxkcy5sZW5ndGg+MTUraSl7XHJcbiAgICAgICAgICAgIGNoaWxkc1tpXS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3Qgc3MgPSBTdHJpbmcoZGF0ZS5nZXRTZWNvbmRzKCkrMSkucGFkU3RhcnQoMiwnMCcpO1xyXG4gICAgICAgIGNvbnN0IGhoID0gU3RyaW5nKGRhdGUuZ2V0SG91cnMoKSkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICBjb25zdCBtbSA9IFN0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSkucGFkU3RhcnQoMiwgJzAnKTtcclxuICAgICAgICBsb2dBcmVhLmFwcGVuZChgPGRpdiBjbGFzcz1cImxvZy1tZXNzYWdlXCI+WyR7aGh9OiR7bW19OiR7c3N9XTogJHttZXNzYWdlfTwvZGl2PmApO3ZhciBteWRpdiA9ICQoXCIjc2Nyb2xsXCIpO1xyXG4gICAgICAgIGxvZ0FyZWEuc2Nyb2xsVG9wKGxvZ0FyZWEucHJvcChcInNjcm9sbEhlaWdodFwiKSk7XHJcbiAgICB9LFxyXG4gICAgcmVnaXN0ZXJNZXRob2RzOmZ1bmN0aW9uKG1ldGhvZHM6e2V4cGxpY2l0OntpZDpzdHJpbmcsbmFtZTpzdHJpbmd9W10saW1wbGljaXQ6e2lkOnN0cmluZyxuYW1lOnN0cmluZ31bXX0pe1xyXG5cclxuICAgICAgICBsZXQgZXhwbGljaXQgPSAkKFwiI21ldGhvZHNcIikuYXBwZW5kKCc8b3B0Z3JvdXAgbGFiZWw9XCJFeHBsaWNpdCBtZXRob2RzXCI+PC9vcHRncm91cD4nKTtcclxuICAgICAgICBtZXRob2RzLmV4cGxpY2l0LmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIGV4cGxpY2l0LmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cIiR7aXRlbS5pZH1cIj4ke2l0ZW0ubmFtZX08L29wdGlvbj5gKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaW1wbGljaXQgPSAkKFwiI21ldGhvZHNcIikuYXBwZW5kKCc8b3B0Z3JvdXAgbGFiZWw9XCJJbXBsaWNpdCBtZXRob2RzXCI+PC9vcHRncm91cD4nKTtcclxuICAgICAgICBtZXRob2RzLmltcGxpY2l0LmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIGltcGxpY2l0LmFwcGVuZChgPG9wdGlvbiB2YWx1ZT1cIiR7aXRlbS5pZH1cIj4ke2l0ZW0ubmFtZX08L29wdGlvbj5gKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICBwbG90U29sdXRpb246ZnVuY3Rpb24oc29sdXRpb246SHlicmlkU29sdXRpb24seDpzdHJpbmdbXSx6OnN0cmluZ1tdKTp2b2lke1xyXG4gICAgICAgIGxldCBkYXRhOmFueSA9IFtdO1xyXG4gICAgICAgIGxldCB0Om51bWJlcltdID0gW107XHJcbiAgICAgICAgbGV0IHhUcmFjZXM6YW55W10gPSBbXTtcclxuICAgICAgICBsZXQgelRyYWNlczphbnlbXSA9IFtdO1xyXG4gICAgICAgIGRhdGEucHVzaCh7eDp0LHk6W10sdHlwZTpcInNjYXR0ZXJnbFwiLG1vZGU6J21hcmtlcnMrbGluZXMnLG5hbWU6XCJTdGF0ZVwiLFxyXG4gICAgICAgIGxpbmU6IHtzaGFwZTogJ2h2J30sfSk7XHJcbiAgICAgICAgeC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICAgICAgICB4VHJhY2VzLnB1c2goe3g6dCx5OltdLHR5cGU6XCJzY2F0dGVyZ2xcIixtb2RlOidtYXJrZXJzK2xpbmVzJyxuYW1lOml0ZW19KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB6LmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgIHpUcmFjZXMucHVzaCh7eDp0LHk6W10sdHlwZTpcInNjYXR0ZXJnbFwiLG1vZGU6J21hcmtlcnMrbGluZXMnLG5hbWU6aXRlbX0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgc29sdXRpb24udmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsaW5kZXgpe1xyXG4gICAgICAgICAgICB0LnB1c2godmFsdWUudCk7XHJcbiAgICAgICAgICAgIGRhdGFbMF0ueS5wdXNoKHNvbHV0aW9uLnN0YXRlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICB4VHJhY2VzLmZvckVhY2goZnVuY3Rpb24oaXRlbSxpZDpudW1iZXIpe1xyXG4gICAgICAgICAgICAgICAgaXRlbS55LnB1c2godmFsdWUueC5nZXQoaWQpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHpUcmFjZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLGlkKXtcclxuICAgICAgICAgICAgICAgIGl0ZW0ueS5wdXNoKHZhbHVlLnouZ2V0KGlkKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHhUcmFjZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKHhUcmFjZXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHpUcmFjZXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcclxuICAgICAgICAgICAgZGF0YS5wdXNoKHpUcmFjZXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgUGxvdGx5LmFkZFRyYWNlcygncGxvdC1hcmVhJywgZGF0YSk7XHJcbiAgICB9LFxyXG4gICAgcGxvdDpmdW5jdGlvbih4Om51bWJlcltdLHQ6bnVtYmVyW10sbGFiZWw6c3RyaW5nKTp2b2lke1xyXG4gICAgICAgIGxldCBkYXRhOmFueSA9IFtdO1xyXG4gICAgICAgIGxldCB0cmFjZTphbnkgPSB7XHJcbiAgICAgICAgICAgIHg6IHQsXHJcbiAgICAgICAgICAgIHk6IHgsXHJcbiAgICAgICAgICAgIHR5cGU6XCJzY2F0dGVyZ2xcIixcclxuICAgICAgICAgICAgbW9kZTogJ21hcmtlcnMrbGluZXMnLFxyXG4gICAgICAgICAgICBuYW1lOiBsYWJlbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGF0YS5wdXNoKHRyYWNlKTtcclxuICAgICAgICAvL0B0cy1pZ25vcmVcclxuICAgICAgICBQbG90bHkuYWRkVHJhY2VzKCdwbG90LWFyZWEnLCBkYXRhKTtcclxuICAgIH0sXHJcbiAgICBleHBvcnQ6ZnVuY3Rpb24oKTp2b2lke1xyXG5cclxuICAgIH0sXHJcbiAgICBydW46ZnVuY3Rpb24oKTp2b2lke1xyXG4gICAgICAgIFRlc3QudGVzdFNpbXBsaWZpY2F0aW9uKCk7XHJcbiAgICAgICAgLy9UZXN0LnJ1blRlc3RzKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcclxuICAgICAgICB1aS5jbGVhckVycm9ycygpO1xyXG4gICAgICAgIGxldCBwYXJhbWV0ZXJzID0gdWkuZ2V0UGFyYW1ldGVycygpO1xyXG4gICAgICAgIGxldCB0ZXh0ID0gJChcIiN0ZXh0LWlucHV0XCIpLnZhbCgpIGFzIHN0cmluZztcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBldmVudERldGVjdGlvbjpFdmVudERldGVjdGlvbjtcclxuICAgICAgICAgICAgaWYocGFyYW1ldGVycy5ldmVudERldGVjdGlvbi56ZXJvQ3Jvc3NpbmcuZW5hYmxlZCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1zID0gcGFyYW1ldGVycy5ldmVudERldGVjdGlvbi56ZXJvQ3Jvc3Npbmc7XHJcbiAgICAgICAgICAgICAgICBldmVudERldGVjdGlvbiA9IG5ldyBFdmVudERldGVjdGlvbkNvbXBsZXgoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm5ld3Rvbkl0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5yZWxUb2wscGFyYW1zLmFic1RvbCxwYXJhbXMubmV3dG9uQWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJpc2VjdEl0ZXJzLHBhcmFtcy50aW1lQWJzVG9sLHBhcmFtcy50aW1lUmVsVG9sKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBldmVudERldGVjdGlvbiA9IG5ldyBFdmVudERldGVjdGlvblNpbXBsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBhZGFwdGl2ZVN0ZXBTdHJhdGVneTpBZGFwdGl2ZVN0ZXBTdHJhdGVneTtcclxuICAgICAgICAgICAgaWYocGFyYW1ldGVycy5ldmVudERldGVjdGlvbi5hZGFwdGl2ZVN0ZXAuZW5hYmxlZCl7XHJcblxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGFkYXB0aXZlU3RlcFN0cmF0ZWd5ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY29tcGlsZXIgPSBuZXcgSHlicmlkU3lzdGVtQ29tcGlsZXIoKTtcclxuICAgICAgICAgICAgaWYocGFyYW1ldGVycy5zb2x2ZXIuZGFlRm9ybSA9PSBcImV4cGxpY2l0XCIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHN5c0RlZiA9IGNvbXBpbGVyLmNvbXBpbGVFeHBsaWNpdCh0ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCBkYWVTb2x2ZXI6RURBRVNvbHZlciA9IG1ldGhvZHNbcGFyYW1ldGVycy5zb2x2ZXIubWV0aG9kXS5lZGFlSW5pdChwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb2x2ZXIgPSBuZXcgRURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdGlvbixhZGFwdGl2ZVN0ZXBTdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc29sdXRpb24gPSBzb2x2ZXIuc29sdmUoc3lzRGVmLngwLHBhcmFtZXRlcnMuc29sdmVyLnQwLHBhcmFtZXRlcnMuc29sdmVyLnQwK3BhcmFtZXRlcnMuc29sdmVyLnRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGFlU29sdmVyLHN5c0RlZi5zeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdWkucGxvdFNvbHV0aW9uKHNvbHV0aW9uLHN5c0RlZi54LHN5c0RlZi56KTsgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbGV0IHN5c0RlZiA9IGNvbXBpbGVyLmNvbXBpbGVJbXBsaWNpdCh0ZXh0KTtcclxuICAgICAgICAgICAgICAgIGxldCBkYWVTb2x2ZXI6SURBRVNvbHZlciA9IG1ldGhvZHNbcGFyYW1ldGVycy5zb2x2ZXIubWV0aG9kXS5pZGFlSW5pdChwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb2x2ZXIgPSBuZXcgSURBRUh5YnJpZFNvbHZlcihldmVudERldGVjdGlvbixhZGFwdGl2ZVN0ZXBTdHJhdGVneSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc29sdXRpb24gPSBzb2x2ZXIuc29sdmUoc3lzRGVmLngwLHN5c0RlZi56MCxwYXJhbWV0ZXJzLnNvbHZlci50MCxwYXJhbWV0ZXJzLnNvbHZlci50MCArIHBhcmFtZXRlcnMuc29sdmVyLnRpbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGFlU29sdmVyLHN5c0RlZi5zeXN0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdWkucGxvdFNvbHV0aW9uKHNvbHV0aW9uLHN5c0RlZi54LHN5c0RlZi56KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgaWYoZSBpbnN0YW5jZW9mIENvbXBpbGVyRXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06RXJyb3JNZXNzYWdlKXtcclxuICAgICAgICAgICAgICAgICAgICB1aS5hZGRFcnJvck1lc3NhZ2UoaXRlbS5tZXNzYWdlLGl0ZW0udGV4dFBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbS5wcmludCgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihlIGluc3RhbmNlb2YgRXJyb3Ipe1xyXG4gICAgICAgICAgICAgICAgdWkuYWRkRXJyb3JNZXNzYWdlKGUubWVzc2FnZSxUZXh0UG9zaXRpb24uaW52YWxpZCgpKTtcclxuICAgICAgICAgICAgICAgIHVpLmFkZExvZ01lc3NhZ2UoZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdWkuYWRkRXJyb3JNZXNzYWdlKFwiRXhjZXB0aW9uOiBcIitlLFRleHRQb3NpdGlvbi5pbnZhbGlkKCkpO1xyXG4gICAgICAgICAgICAgICAgdWkuYWRkTG9nTWVzc2FnZShcIkV4Y2VwdGlvbjogXCIrZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWkub3BlblRhYihcIm1haW5cIik7XHJcbiAgICAgICAgICAgIHVpLm9wZW5UYWIoXCJlcnJvcnMtdGFiXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSJdLCJzb3VyY2VSb290IjoiIn0=